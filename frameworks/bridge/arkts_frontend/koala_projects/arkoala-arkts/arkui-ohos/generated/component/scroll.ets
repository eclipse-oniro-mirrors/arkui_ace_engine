/*
 * Copyright (c) 2024-2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


// WARNING! THIS FILE IS AUTO-GENERATED, DO NOT MAKE CHANGES, THEY WILL BE LOST ON NEXT GENERATION!

import { SerializerBase, DeserializerBase, Finalizable, runtimeType, RuntimeType, toPeerPtr, KPointer, MaterializedBase, NativeBuffer, nullptr, KInt, KBoolean, KStringPtr, CallbackResource, InteropNativeModule, Tags, KSerializerBuffer, KUint8ArrayPtr } from "@koalaui/interop"
import { Resource_serializer } from "./../framework/resource"
import { RectResult_serializer, RectResult, NestedScrollOptions_serializer, EdgeEffectOptions_serializer, ArkScrollableCommonMethodPeer, ScrollableCommonMethod, NestedScrollOptions, CommonMethod, EdgeEffectOptions, ArkScrollableCommonMethodComponent, ArkScrollableCommonMethodStyle, ArkCommonMethodComponent, ArkCommonMethodStyle } from "./common"
import { Edge, ScrollSource, BarState, Color, EdgeEffect } from "./enums"
import { Length, VoidCallback, Dimension } from "./units"
import { Resource } from "global.resource"
import { TypeChecker, ArkUIGeneratedNativeModule } from "#components"
import { unsafeCast, int32, int64, float32 } from "@koalaui/common"
import { CallbackTransformer } from "./../CallbackTransformer"
import { ComponentBase } from "./../ComponentBase"
import { PeerNode } from "./../PeerNode"
import { ScrollState, ScrollSnapAlign } from "./list"
import { AttributeModifier, extractors, hookScrollAttributeModifier, AttributeUpdater } from "#handwritten"
import { CallbackKind } from "./../framework/peers/CallbackKind"
import { memo, memo_stable } from "@koalaui/runtime/annotations"
import { ComponentBuilder, Builder } from "@koalaui/builderLambda"
import { LengthMetrics } from "arkui.Graphics"
import { default as curves } from "@ohos.curves"
import { ScrollModifier } from "./../ScrollModifier"
import { NodeAttach, remember } from "@koalaui/runtime"
import { curves_ICurve_serializer } from "./../framework/ohos.curves"
import { LengthMetrics_serializer } from "./../Graphics"
export class ScrollerInternal {
    public static fromPtr(ptr: KPointer): Scroller {
        return new Scroller(ptr)
    }
}
export class Scroller implements MaterializedBase {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, Scroller.getFinalizer())
    }
    constructor() {
        this(Scroller.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._Scroller_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._Scroller_getFinalizer()
    }
    public scrollTo(options: ScrollOptions): void {
        const options_casted = options as (ScrollOptions)
        this.scrollTo_serialize(options_casted)
        return
    }
    public scrollEdge(value: Edge, options?: ScrollEdgeOptions): void {
        const value_casted = value as (Edge)
        const options_casted = options as (ScrollEdgeOptions | undefined)
        this.scrollEdge_serialize(value_casted, options_casted)
        return
    }
    public fling(velocity: number): void {
        const velocity_casted = velocity as (number)
        this.fling_serialize(velocity_casted)
        return
    }
    public scrollPage(value: ScrollPageOptions): void {
        const value_casted = value as (ScrollPageOptions)
        this.scrollPage_serialize(value_casted)
        return
    }
    public currentOffset(): OffsetResult {
        return this.currentOffset_serialize()
    }
    public scrollToIndex(value: number, smooth?: boolean, align?: ScrollAlign, options?: ScrollToIndexOptions): void {
        const value_casted = value as (number)
        const smooth_casted = smooth as (boolean | undefined)
        const align_casted = align as (ScrollAlign | undefined)
        const options_casted = options as (ScrollToIndexOptions | undefined)
        this.scrollToIndex_serialize(value_casted, smooth_casted, align_casted, options_casted)
        return
    }
    public scrollBy(dx: Length, dy: Length): void {
        const dx_casted = dx as (Length)
        const dy_casted = dy as (Length)
        this.scrollBy_serialize(dx_casted, dy_casted)
        return
    }
    public isAtEnd(): boolean {
        return this.isAtEnd_serialize()
    }
    public getItemRect(index: number): RectResult {
        const index_casted = index as (number)
        return this.getItemRect_serialize(index_casted)
    }
    public getItemIndex(x: number, y: number): number {
        const x_casted = x as (number)
        const y_casted = y as (number)
        return this.getItemIndex_serialize(x_casted, y_casted)
    }
    scrollTo_serialize(options: ScrollOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        ScrollOptions_serializer.write(thisSerializer, options)
        ArkUIGeneratedNativeModule._Scroller_scrollTo(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    scrollEdge_serialize(value: Edge, options?: ScrollEdgeOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            ScrollEdgeOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._Scroller_scrollEdge(this.peer!.ptr, value.valueOf(), thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    fling_serialize(velocity: number): void {
        ArkUIGeneratedNativeModule._Scroller_fling(this.peer!.ptr, velocity)
    }
    scrollPage_serialize(value: ScrollPageOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        ScrollPageOptions_serializer.write(thisSerializer, value)
        ArkUIGeneratedNativeModule._Scroller_scrollPage(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    currentOffset_serialize(): OffsetResult {
        const retval  = ArkUIGeneratedNativeModule._Scroller_currentOffset(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : OffsetResult = OffsetResult_serializer.read(retvalDeserializer)
        return returnResult
    }
    scrollToIndex_serialize(value: number, smooth?: boolean, align?: ScrollAlign, options?: ScrollToIndexOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (smooth !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const smoothTmpValue  = smooth!
            thisSerializer.writeBoolean(smoothTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (align !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const alignTmpValue  = (align as ScrollAlign)
            thisSerializer.writeInt32(alignTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            ScrollToIndexOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._Scroller_scrollToIndex(this.peer!.ptr, value, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    scrollBy_serialize(dx: Length, dy: Length): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (dx instanceof string) {
            thisSerializer.writeInt8((0).toChar())
            const dxForIdx0  = dx as string
            thisSerializer.writeString(dxForIdx0)
        } else if (dx instanceof number) {
            thisSerializer.writeInt8((1).toChar())
            const dxForIdx1  = dx as number
            thisSerializer.writeNumber(dxForIdx1)
        } else if (dx instanceof Resource) {
            thisSerializer.writeInt8((2).toChar())
            const dxForIdx2  = dx as Resource
            Resource_serializer.write(thisSerializer, dxForIdx2)
        }
        if (dy instanceof string) {
            thisSerializer.writeInt8((0).toChar())
            const dyForIdx0  = dy as string
            thisSerializer.writeString(dyForIdx0)
        } else if (dy instanceof number) {
            thisSerializer.writeInt8((1).toChar())
            const dyForIdx1  = dy as number
            thisSerializer.writeNumber(dyForIdx1)
        } else if (dy instanceof Resource) {
            thisSerializer.writeInt8((2).toChar())
            const dyForIdx2  = dy as Resource
            Resource_serializer.write(thisSerializer, dyForIdx2)
        }
        ArkUIGeneratedNativeModule._Scroller_scrollBy(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    isAtEnd_serialize(): boolean {
        const retval  = ArkUIGeneratedNativeModule._Scroller_isAtEnd(this.peer!.ptr)
        return retval
    }
    getItemRect_serialize(index: number): RectResult {
        const retval  = ArkUIGeneratedNativeModule._Scroller_getItemRect(this.peer!.ptr, index)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : RectResult = RectResult_serializer.read(retvalDeserializer)
        return returnResult
    }
    getItemIndex_serialize(x: number, y: number): number {
        const retval  = ArkUIGeneratedNativeModule._Scroller_getItemIndex(this.peer!.ptr, x, y)
        return retval
    }
}
export class ArkScrollPeer extends ArkScrollableCommonMethodPeer {
    attributeSet?: ScrollModifier;
    public constructor(peerPtr: KPointer, id: int32, name: string = "", flags: int32 = 0) {
        super(peerPtr, id, name, flags)
    }
    public static create(component?: ComponentBase, flags: int32 = 0): ArkScrollPeer {
        const peerId  = PeerNode.nextId()
        const _peerPtr  = ArkUIGeneratedNativeModule._Scroll_construct(peerId, flags)
        const _peer  = new ArkScrollPeer(_peerPtr, peerId, 'Scroll', flags)
        component?.setPeer(_peer)
        return _peer
    }
    setScrollOptionsAttribute(scroller?: Scroller): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (scroller !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const scrollerTmpValue  = scroller!
            Scroller_serializer.write(thisSerializer, scrollerTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollInterface_setScrollOptions(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setScrollableAttribute(value: ScrollDirection | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as ScrollDirection)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollAttribute_setScrollable(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnWillScrollAttribute(value: ScrollOnWillScrollCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollAttribute_setOnWillScroll(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDidScrollAttribute(value: ScrollOnScrollCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollAttribute_setOnDidScroll(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnScrollEdgeAttribute(value: OnScrollEdgeCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollAttribute_setOnScrollEdge(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnScrollStartAttribute(value: VoidCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollAttribute_setOnScrollStart(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnScrollStopAttribute(value: VoidCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollAttribute_setOnScrollStop(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setScrollBarAttribute(value: BarState | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as BarState)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollAttribute_setScrollBar(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setScrollBarColorAttribute(value: Color | number | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Color) {
                thisSerializer.writeInt8((0).toChar())
                const valueTmpValueForIdx0  = valueTmpValue as Color
                thisSerializer.writeInt32(valueTmpValueForIdx0.valueOf())
            } else if (valueTmpValue instanceof number) {
                thisSerializer.writeInt8((1).toChar())
                const valueTmpValueForIdx1  = valueTmpValue as number
                thisSerializer.writeNumber(valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((2).toChar())
                const valueTmpValueForIdx2  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollAttribute_setScrollBarColor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setScrollBarWidthAttribute(value: number | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof number) {
                thisSerializer.writeInt8((0).toChar())
                const valueTmpValueForIdx0  = valueTmpValue as number
                thisSerializer.writeNumber(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toChar())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollAttribute_setScrollBarWidth(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnScrollFrameBeginAttribute(value: OnScrollFrameBeginCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollAttribute_setOnScrollFrameBegin(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setNestedScrollAttribute(value: NestedScrollOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            NestedScrollOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollAttribute_setNestedScroll(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setEnableScrollInteractionAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollAttribute_setEnableScrollInteraction(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFrictionAttribute(value: number | Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof number) {
                thisSerializer.writeInt8((0).toChar())
                const valueTmpValueForIdx0  = valueTmpValue as number
                thisSerializer.writeNumber(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof Resource) {
                thisSerializer.writeInt8((1).toChar())
                const valueTmpValueForIdx1  = valueTmpValue as Resource
                Resource_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollAttribute_setFriction(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setScrollSnapAttribute(value: ScrollSnapOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            ScrollSnapOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollAttribute_setScrollSnap(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setEnablePagingAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollAttribute_setEnablePaging(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setInitialOffsetAttribute(value: OffsetOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            OffsetOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollAttribute_setInitialOffset(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setEdgeEffectAttribute(edgeEffect: EdgeEffect | undefined, options?: EdgeEffectOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (edgeEffect !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const edgeEffectTmpValue  = (edgeEffect as EdgeEffect)
            thisSerializer.writeInt32(edgeEffectTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            EdgeEffectOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollAttribute_setEdgeEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export enum ScrollDirection {
    VERTICAL = 0,
    Vertical = 0,
    HORIZONTAL = 1,
    Horizontal = 1,
    NONE = 2,
    None = 2
}
export enum ScrollAlign {
    START = 0,
    CENTER = 1,
    END = 2,
    AUTO = 3
}
export interface OffsetResult {
    xOffset: number;
    yOffset: number;
}
export interface ScrollEdgeOptions {
    velocity?: number;
}
export interface ScrollToIndexOptions {
    extraOffset?: LengthMetrics;
}
export interface ScrollAnimationOptions {
    duration?: number;
    curve?: curves.Curve | curves.ICurve;
    canOverScroll?: boolean;
}
export interface OffsetOptions {
    xOffset?: Dimension;
    yOffset?: Dimension;
}
export interface ScrollOptions {
    xOffset: number | string;
    yOffset: number | string;
    animation?: ScrollAnimationOptions | boolean;
}
export interface ScrollPageOptions {
    next: boolean;
    animation?: boolean;
}
export interface ScrollSnapOptions {
    snapAlign: ScrollSnapAlign;
    snapPagination?: Dimension | Array<Dimension>;
    enableSnapToStart?: boolean;
    enableSnapToEnd?: boolean;
}
export type OnScrollEdgeCallback = (side: Edge) => void;
export interface OnScrollFrameBeginHandlerResult {
    offsetRemain: number;
}
export type OnScrollFrameBeginCallback = (offset: number, state: ScrollState) => OnScrollFrameBeginHandlerResult;
export interface ScrollAttribute extends ScrollableCommonMethod {
    setScrollOptions(scroller?: Scroller): this {
        throw new Error("Unimplemented method setScrollOptions")
    }
    scrollable(value: ScrollDirection | undefined): this {
        throw new Error("Unimplemented method scrollable")
    }
    onWillScroll(value: ScrollOnWillScrollCallback | undefined): this {
        throw new Error("Unimplemented method onWillScroll")
    }
    onDidScroll(value: ScrollOnScrollCallback | undefined): this {
        throw new Error("Unimplemented method onDidScroll")
    }
    onScrollEdge(value: OnScrollEdgeCallback | undefined): this {
        throw new Error("Unimplemented method onScrollEdge")
    }
    onScrollStart(value: VoidCallback | undefined): this
    onScrollStop(value: VoidCallback | undefined): this
    scrollBar(value: BarState | undefined): this
    scrollBarColor(value: Color | number | string | undefined): this
    scrollBarWidth(value: number | string | undefined): this
    onScrollFrameBegin(value: OnScrollFrameBeginCallback | undefined): this {
        throw new Error("Unimplemented method onScrollFrameBegin")
    }
    nestedScroll(value: NestedScrollOptions | undefined): this
    enableScrollInteraction(value: boolean | undefined): this
    friction(value: number | Resource | undefined): this
    scrollSnap(value: ScrollSnapOptions | undefined): this {
        throw new Error("Unimplemented method scrollSnap")
    }
    enablePaging(value: boolean | undefined): this {
        throw new Error("Unimplemented method enablePaging")
    }
    initialOffset(value: OffsetOptions | undefined): this {
        throw new Error("Unimplemented method initialOffset")
    }
    edgeEffect(edgeEffect: EdgeEffect | undefined, options?: EdgeEffectOptions): this {
        throw new Error("Unimplemented method edgeEffect")
    }
    attributeModifier(value: AttributeModifier<ScrollAttribute> | AttributeModifier<ScrollableCommonMethod> | AttributeModifier<CommonMethod> | undefined): this {
        throw new Error("Unimplemented method attributeModifier")
    }
}
export class ArkScrollStyle extends ArkScrollableCommonMethodStyle implements ScrollAttribute {
    scrollable_value?: ScrollDirection | undefined
    onWillScroll_value?: ScrollOnWillScrollCallback | undefined
    onDidScroll_value?: ScrollOnScrollCallback | undefined
    onScrollEdge_value?: OnScrollEdgeCallback | undefined
    onScrollStart_value?: VoidCallback | undefined
    onScrollStop_value?: VoidCallback | undefined
    scrollBar_value?: BarState | undefined
    scrollBarColor_value?: Color | number | string | undefined
    scrollBarWidth_value?: number | string | undefined
    onScrollFrameBegin_value?: OnScrollFrameBeginCallback | undefined
    nestedScroll_value?: NestedScrollOptions | undefined
    enableScrollInteraction_value?: boolean | undefined
    friction_value?: number | Resource | undefined
    scrollSnap_value?: ScrollSnapOptions | undefined
    enablePaging_value?: boolean | undefined
    initialOffset_value?: OffsetOptions | undefined
    attributeModifier_value?: AttributeModifier<ScrollAttribute> | AttributeModifier<CommonMethod> | undefined
    setScrollOptions(scroller?: Scroller): this {
        return this
    }
    scrollable(value: ScrollDirection | undefined): this {
        return this
    }
    onWillScroll(value: ScrollOnWillScrollCallback | undefined): this {
        return this
    }
    onDidScroll(value: ScrollOnScrollCallback | undefined): this {
        return this
    }
    onScrollEdge(value: OnScrollEdgeCallback | undefined): this {
        return this
    }
    onScrollStart(value: VoidCallback | undefined): this {
        return this
    }
    onScrollStop(value: VoidCallback | undefined): this {
        return this
    }
    scrollBar(value: BarState | undefined): this {
        return this
    }
    scrollBarColor(value: Color | number | string | undefined): this {
        return this
    }
    scrollBarWidth(value: number | string | undefined): this {
        return this
    }
    onScrollFrameBegin(value: OnScrollFrameBeginCallback | undefined): this {
        return this
    }
    nestedScroll(value: NestedScrollOptions | undefined): this {
        return this
    }
    enableScrollInteraction(value: boolean | undefined): this {
        return this
    }
    friction(value: number | Resource | undefined): this {
        return this
    }
    scrollSnap(value: ScrollSnapOptions | undefined): this {
        return this
    }
    enablePaging(value: boolean | undefined): this {
        return this
    }
    initialOffset(value: OffsetOptions | undefined): this {
        return this
    }
    edgeEffect(edgeEffect: EdgeEffect | undefined, options?: EdgeEffectOptions): this {
        return this
    }
    public attributeModifier(value: AttributeModifier<ScrollAttribute> | AttributeModifier<ScrollableCommonMethod> | AttributeModifier<CommonMethod> | undefined): this {
        throw new Error("Not implemented")
    }
}
export type ScrollOnScrollCallback = (xOffset: number, yOffset: number, scrollState: ScrollState) => void;
export type ScrollOnWillScrollCallback = (xOffset: number, yOffset: number, scrollState: ScrollState, scrollSource: ScrollSource) => OffsetResult | undefined;

export class ArkScrollComponent extends ArkScrollableCommonMethodComponent implements ScrollAttribute {
    getPeer(): ArkScrollPeer {
        return (this.peer as ArkScrollPeer)
    }
    public setScrollOptions(scroller?: Scroller): this {
        if (this.checkPriority("setScrollOptions")) {
            const scroller_casted = scroller as (Scroller | undefined)
            this.getPeer()?.setScrollOptionsAttribute(scroller_casted)
            return this
        }
        return this
    }
    public scrollable(value: ScrollDirection | undefined): this {
        if (this.checkPriority("scrollable")) {
            const value_casted = value as (ScrollDirection | undefined)
            this.getPeer()?.setScrollableAttribute(value_casted)
            return this
        }
        return this
    }
    public onWillScroll(value: ScrollOnWillScrollCallback | undefined): this {
        if (this.checkPriority("onWillScroll")) {
            const value_casted = value as (ScrollOnWillScrollCallback | undefined)
            this.getPeer()?.setOnWillScrollAttribute(value_casted)
            return this
        }
        return this
    }
    public onDidScroll(value: ScrollOnScrollCallback | undefined): this {
        if (this.checkPriority("onDidScroll")) {
            const value_casted = value as (ScrollOnScrollCallback | undefined)
            this.getPeer()?.setOnDidScrollAttribute(value_casted)
            return this
        }
        return this
    }
    public onScrollEdge(value: OnScrollEdgeCallback | undefined): this {
        if (this.checkPriority("onScrollEdge")) {
            const value_casted = value as (OnScrollEdgeCallback | undefined)
            this.getPeer()?.setOnScrollEdgeAttribute(value_casted)
            return this
        }
        return this
    }
    public onScrollStart(value: VoidCallback | undefined): this {
        if (this.checkPriority("onScrollStart")) {
            const value_casted = value as (VoidCallback | undefined)
            this.getPeer()?.setOnScrollStartAttribute(value_casted)
            return this
        }
        return this
    }
    public onScrollStop(value: VoidCallback | undefined): this {
        if (this.checkPriority("onScrollStop")) {
            const value_casted = value as (VoidCallback | undefined)
            this.getPeer()?.setOnScrollStopAttribute(value_casted)
            return this
        }
        return this
    }
    public scrollBar(value: BarState | undefined): this {
        if (this.checkPriority("scrollBar")) {
            const value_casted = value as (BarState | undefined)
            this.getPeer()?.setScrollBarAttribute(value_casted)
            return this
        }
        return this
    }
    public scrollBarColor(value: Color | number | string | undefined): this {
        if (this.checkPriority("scrollBarColor")) {
            const value_casted = value as (Color | number | string | undefined)
            this.getPeer()?.setScrollBarColorAttribute(value_casted)
            return this
        }
        return this
    }
    public scrollBarWidth(value: number | string | undefined): this {
        if (this.checkPriority("scrollBarWidth")) {
            const value_casted = value as (number | string | undefined)
            this.getPeer()?.setScrollBarWidthAttribute(value_casted)
            return this
        }
        return this
    }
    public onScrollFrameBegin(value: OnScrollFrameBeginCallback | undefined): this {
        if (this.checkPriority("onScrollFrameBegin")) {
            const value_casted = value as (OnScrollFrameBeginCallback | undefined)
            this.getPeer()?.setOnScrollFrameBeginAttribute(value_casted)
            return this
        }
        return this
    }
    public nestedScroll(value: NestedScrollOptions | undefined): this {
        if (this.checkPriority("nestedScroll")) {
            const value_casted = value as (NestedScrollOptions | undefined)
            this.getPeer()?.setNestedScrollAttribute(value_casted)
            return this
        }
        return this
    }
    public enableScrollInteraction(value: boolean | undefined): this {
        if (this.checkPriority("enableScrollInteraction")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setEnableScrollInteractionAttribute(value_casted)
            return this
        }
        return this
    }
    public friction(value: number | Resource | undefined): this {
        if (this.checkPriority("friction")) {
            const value_casted = value as (number | Resource | undefined)
            this.getPeer()?.setFrictionAttribute(value_casted)
            return this
        }
        return this
    }
    public scrollSnap(value: ScrollSnapOptions | undefined): this {
        if (this.checkPriority("scrollSnap")) {
            const value_casted = value as (ScrollSnapOptions | undefined)
            this.getPeer()?.setScrollSnapAttribute(value_casted)
            return this
        }
        return this
    }
    public enablePaging(value: boolean | undefined): this {
        if (this.checkPriority("enablePaging")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setEnablePagingAttribute(value_casted)
            return this
        }
        return this
    }
    public initialOffset(value: OffsetOptions | undefined): this {
        if (this.checkPriority("initialOffset")) {
            const value_casted = value as (OffsetOptions | undefined)
            this.getPeer()?.setInitialOffsetAttribute(value_casted)
            return this
        }
        return this
    }
    public edgeEffect(edgeEffect: EdgeEffect | undefined, options?: EdgeEffectOptions): this {
        if (this.checkPriority("edgeEffect")) {
            const edgeEffect_casted = edgeEffect as (EdgeEffect | undefined)
            const options_casted = options as (EdgeEffectOptions | undefined)
            this.getPeer()?.setEdgeEffectAttribute(edgeEffect_casted, options_casted)
            return this
        }
        return this
    }
    public attributeModifier(value: AttributeModifier<ScrollAttribute> | AttributeModifier<ScrollableCommonMethod> | AttributeModifier<CommonMethod> | undefined): this {
        hookScrollAttributeModifier(this, value);
        return this
    }
    public applyAttributesFinish(): void {
        // we call this function outside of class, so need to make it public
        super.applyAttributesFinish()
    }
}

@memo
export function ScrollImpl(
    @memo
    style: ((attributes: ScrollAttribute) => void) | undefined,
    @memo
    content_?: () => void,
): void {
    const receiver = remember<ArkScrollComponent>((): ArkScrollComponent => {
        return new ArkScrollComponent()
    })
    NodeAttach<ArkScrollPeer>((): ArkScrollPeer => ArkScrollPeer.create(receiver), (_: ArkScrollPeer): void => {
        style?.(receiver)
        content_?.()
    })
}

export class OffsetResult_serializer {
    public static write(buffer: SerializerBase, value: OffsetResult): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForXOffset  = value.xOffset
        valueSerializer.writeNumber(valueHolderForXOffset)
        const valueHolderForYOffset  = value.yOffset
        valueSerializer.writeNumber(valueHolderForYOffset)
    }
    public static read(buffer: DeserializerBase): OffsetResult {
        let valueDeserializer : DeserializerBase = buffer
        const xOffsetTmpResult : number = (valueDeserializer.readNumber() as number)
        const yOffsetTmpResult : number = (valueDeserializer.readNumber() as number)
        let value : OffsetResult = ({xOffset: xOffsetTmpResult, yOffset: yOffsetTmpResult} as OffsetResult)
        return value
    }
}
export class OnScrollFrameBeginHandlerResult_serializer {
    public static write(buffer: SerializerBase, value: OnScrollFrameBeginHandlerResult): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForOffsetRemain  = value.offsetRemain
        valueSerializer.writeNumber(valueHolderForOffsetRemain)
    }
    public static read(buffer: DeserializerBase): OnScrollFrameBeginHandlerResult {
        let valueDeserializer : DeserializerBase = buffer
        const offsetRemainTmpResult : number = (valueDeserializer.readNumber() as number)
        let value : OnScrollFrameBeginHandlerResult = ({offsetRemain: offsetRemainTmpResult} as OnScrollFrameBeginHandlerResult)
        return value
    }
}
export class Scroller_serializer {
    public static write(buffer: SerializerBase, value: Scroller): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): Scroller {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return ScrollerInternal.fromPtr(ptr)
    }
}
export class ScrollAnimationOptions_serializer {
    public static write(buffer: SerializerBase, value: ScrollAnimationOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDuration  = value.duration
        if (valueHolderForDuration !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDurationTmpValue  = valueHolderForDuration!
            valueSerializer.writeNumber(valueHolderForDurationTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCurve  = value.curve
        if (valueHolderForCurve !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCurveTmpValue  = valueHolderForCurve!
            if (valueHolderForCurveTmpValue instanceof curves.Curve) {
                valueSerializer.writeInt8((0).toChar())
                const valueHolderForCurveTmpValueForIdx0  = valueHolderForCurveTmpValue as curves.Curve
                valueSerializer.writeInt32(valueHolderForCurveTmpValueForIdx0.valueOf())
            } else if (valueHolderForCurveTmpValue instanceof curves.ICurve) {
                valueSerializer.writeInt8((1).toChar())
                const valueHolderForCurveTmpValueForIdx1  = valueHolderForCurveTmpValue as curves.ICurve
                curves_ICurve_serializer.write(valueSerializer, valueHolderForCurveTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCanOverScroll  = value.canOverScroll
        if (valueHolderForCanOverScroll !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCanOverScrollTmpValue  = valueHolderForCanOverScroll!
            valueSerializer.writeBoolean(valueHolderForCanOverScrollTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ScrollAnimationOptions {
        let valueDeserializer : DeserializerBase = buffer
        const durationTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let durationTmpBuf : number | undefined = undefined
        if ((durationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            durationTmpBuf = (valueDeserializer.readNumber() as number)
        }
        const durationTmpResult : number | undefined = durationTmpBuf
        const curveTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let curveTmpBuf : curves.Curve | curves.ICurve | undefined = undefined
        if ((curveTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const curveTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let curveTmpBuf_ : curves.Curve | curves.ICurve | undefined
            if (curveTmpBuf_UnionSelector == (0).toChar()) {
                curveTmpBuf_ = curves.Curve.fromValue(valueDeserializer.readInt32())
            } else if (curveTmpBuf_UnionSelector == (1).toChar()) {
                curveTmpBuf_ = (curves_ICurve_serializer.read(valueDeserializer) as curves.ICurve)
            } else {
                throw new Error("One of the branches for curveTmpBuf_ has to be chosen through deserialisation.")
            }
            curveTmpBuf = (curveTmpBuf_ as curves.Curve | curves.ICurve)
        }
        const curveTmpResult : curves.Curve | curves.ICurve | undefined = curveTmpBuf
        const canOverScrollTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let canOverScrollTmpBuf : boolean | undefined = undefined
        if ((canOverScrollTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            canOverScrollTmpBuf = valueDeserializer.readBoolean()
        }
        const canOverScrollTmpResult : boolean | undefined = canOverScrollTmpBuf
        let value : ScrollAnimationOptions = ({duration: durationTmpResult, curve: curveTmpResult, canOverScroll: canOverScrollTmpResult} as ScrollAnimationOptions)
        return value
    }
}
export class ScrollEdgeOptions_serializer {
    public static write(buffer: SerializerBase, value: ScrollEdgeOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForVelocity  = value.velocity
        if (valueHolderForVelocity !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForVelocityTmpValue  = valueHolderForVelocity!
            valueSerializer.writeNumber(valueHolderForVelocityTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ScrollEdgeOptions {
        let valueDeserializer : DeserializerBase = buffer
        const velocityTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let velocityTmpBuf : number | undefined = undefined
        if ((velocityTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            velocityTmpBuf = (valueDeserializer.readNumber() as number)
        }
        const velocityTmpResult : number | undefined = velocityTmpBuf
        let value : ScrollEdgeOptions = ({velocity: velocityTmpResult} as ScrollEdgeOptions)
        return value
    }
}
export class ScrollPageOptions_serializer {
    public static write(buffer: SerializerBase, value: ScrollPageOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForNext  = value.next
        valueSerializer.writeBoolean(valueHolderForNext)
        const valueHolderForAnimation  = value.animation
        if (valueHolderForAnimation !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAnimationTmpValue  = valueHolderForAnimation!
            valueSerializer.writeBoolean(valueHolderForAnimationTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ScrollPageOptions {
        let valueDeserializer : DeserializerBase = buffer
        const nextTmpResult : boolean = valueDeserializer.readBoolean()
        const animationTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let animationTmpBuf : boolean | undefined = undefined
        if ((animationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            animationTmpBuf = valueDeserializer.readBoolean()
        }
        const animationTmpResult : boolean | undefined = animationTmpBuf
        let value : ScrollPageOptions = ({next: nextTmpResult, animation: animationTmpResult} as ScrollPageOptions)
        return value
    }
}
export class ScrollOptions_serializer {
    public static write(buffer: SerializerBase, value: ScrollOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForXOffset  = value.xOffset
        if (valueHolderForXOffset instanceof number) {
            valueSerializer.writeInt8((0).toChar())
            const valueHolderForXOffsetForIdx0  = valueHolderForXOffset as number
            valueSerializer.writeNumber(valueHolderForXOffsetForIdx0)
        } else if (valueHolderForXOffset instanceof string) {
            valueSerializer.writeInt8((1).toChar())
            const valueHolderForXOffsetForIdx1  = valueHolderForXOffset as string
            valueSerializer.writeString(valueHolderForXOffsetForIdx1)
        }
        const valueHolderForYOffset  = value.yOffset
        if (valueHolderForYOffset instanceof number) {
            valueSerializer.writeInt8((0).toChar())
            const valueHolderForYOffsetForIdx0  = valueHolderForYOffset as number
            valueSerializer.writeNumber(valueHolderForYOffsetForIdx0)
        } else if (valueHolderForYOffset instanceof string) {
            valueSerializer.writeInt8((1).toChar())
            const valueHolderForYOffsetForIdx1  = valueHolderForYOffset as string
            valueSerializer.writeString(valueHolderForYOffsetForIdx1)
        }
        const valueHolderForAnimation  = value.animation
        if (valueHolderForAnimation !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAnimationTmpValue  = valueHolderForAnimation!
            if (valueHolderForAnimationTmpValue instanceof ScrollAnimationOptions) {
                valueSerializer.writeInt8((0).toChar())
                const valueHolderForAnimationTmpValueForIdx0  = valueHolderForAnimationTmpValue as ScrollAnimationOptions
                ScrollAnimationOptions_serializer.write(valueSerializer, valueHolderForAnimationTmpValueForIdx0)
            } else if (valueHolderForAnimationTmpValue instanceof boolean) {
                valueSerializer.writeInt8((1).toChar())
                const valueHolderForAnimationTmpValueForIdx1  = valueHolderForAnimationTmpValue as boolean
                valueSerializer.writeBoolean(valueHolderForAnimationTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ScrollOptions {
        let valueDeserializer : DeserializerBase = buffer
        const xOffsetTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let xOffsetTmpBuf : number | string | undefined
        if (xOffsetTmpBufUnionSelector == (0).toChar()) {
            xOffsetTmpBuf = (valueDeserializer.readNumber() as number)
        } else if (xOffsetTmpBufUnionSelector == (1).toChar()) {
            xOffsetTmpBuf = (valueDeserializer.readString() as string)
        } else {
            throw new Error("One of the branches for xOffsetTmpBuf has to be chosen through deserialisation.")
        }
        const xOffsetTmpResult : number | string = (xOffsetTmpBuf as number | string)
        const yOffsetTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let yOffsetTmpBuf : number | string | undefined
        if (yOffsetTmpBufUnionSelector == (0).toChar()) {
            yOffsetTmpBuf = (valueDeserializer.readNumber() as number)
        } else if (yOffsetTmpBufUnionSelector == (1).toChar()) {
            yOffsetTmpBuf = (valueDeserializer.readString() as string)
        } else {
            throw new Error("One of the branches for yOffsetTmpBuf has to be chosen through deserialisation.")
        }
        const yOffsetTmpResult : number | string = (yOffsetTmpBuf as number | string)
        const animationTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let animationTmpBuf : ScrollAnimationOptions | boolean | undefined = undefined
        if ((animationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const animationTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let animationTmpBuf_ : ScrollAnimationOptions | boolean | undefined
            if (animationTmpBuf_UnionSelector == (0).toChar()) {
                animationTmpBuf_ = ScrollAnimationOptions_serializer.read(valueDeserializer)
            } else if (animationTmpBuf_UnionSelector == (1).toChar()) {
                animationTmpBuf_ = valueDeserializer.readBoolean()
            } else {
                throw new Error("One of the branches for animationTmpBuf_ has to be chosen through deserialisation.")
            }
            animationTmpBuf = (animationTmpBuf_ as ScrollAnimationOptions | boolean)
        }
        const animationTmpResult : ScrollAnimationOptions | boolean | undefined = animationTmpBuf
        let value : ScrollOptions = ({xOffset: xOffsetTmpResult, yOffset: yOffsetTmpResult, animation: animationTmpResult} as ScrollOptions)
        return value
    }
}
export class ScrollToIndexOptions_serializer {
    public static write(buffer: SerializerBase, value: ScrollToIndexOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForExtraOffset  = value.extraOffset
        if (valueHolderForExtraOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForExtraOffsetTmpValue  = valueHolderForExtraOffset!
            LengthMetrics_serializer.write(valueSerializer, valueHolderForExtraOffsetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ScrollToIndexOptions {
        let valueDeserializer : DeserializerBase = buffer
        const extraOffsetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let extraOffsetTmpBuf : LengthMetrics | undefined = undefined
        if ((extraOffsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            extraOffsetTmpBuf = (LengthMetrics_serializer.read(valueDeserializer) as LengthMetrics)
        }
        const extraOffsetTmpResult : LengthMetrics | undefined = extraOffsetTmpBuf
        let value : ScrollToIndexOptions = ({extraOffset: extraOffsetTmpResult} as ScrollToIndexOptions)
        return value
    }
}
export class OffsetOptions_serializer {
    public static write(buffer: SerializerBase, value: OffsetOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForXOffset  = value.xOffset
        if (valueHolderForXOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForXOffsetTmpValue  = valueHolderForXOffset!
            if (valueHolderForXOffsetTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toChar())
                const valueHolderForXOffsetTmpValueForIdx0  = valueHolderForXOffsetTmpValue as string
                valueSerializer.writeString(valueHolderForXOffsetTmpValueForIdx0)
            } else if (valueHolderForXOffsetTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toChar())
                const valueHolderForXOffsetTmpValueForIdx1  = valueHolderForXOffsetTmpValue as number
                valueSerializer.writeNumber(valueHolderForXOffsetTmpValueForIdx1)
            } else if (valueHolderForXOffsetTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toChar())
                const valueHolderForXOffsetTmpValueForIdx2  = valueHolderForXOffsetTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForXOffsetTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForYOffset  = value.yOffset
        if (valueHolderForYOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForYOffsetTmpValue  = valueHolderForYOffset!
            if (valueHolderForYOffsetTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toChar())
                const valueHolderForYOffsetTmpValueForIdx0  = valueHolderForYOffsetTmpValue as string
                valueSerializer.writeString(valueHolderForYOffsetTmpValueForIdx0)
            } else if (valueHolderForYOffsetTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toChar())
                const valueHolderForYOffsetTmpValueForIdx1  = valueHolderForYOffsetTmpValue as number
                valueSerializer.writeNumber(valueHolderForYOffsetTmpValueForIdx1)
            } else if (valueHolderForYOffsetTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toChar())
                const valueHolderForYOffsetTmpValueForIdx2  = valueHolderForYOffsetTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForYOffsetTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): OffsetOptions {
        let valueDeserializer : DeserializerBase = buffer
        const xOffsetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let xOffsetTmpBuf : Dimension | undefined = undefined
        if ((xOffsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const xOffsetTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let xOffsetTmpBuf_ : string | number | Resource | undefined
            if (xOffsetTmpBuf_UnionSelector == (0).toChar()) {
                xOffsetTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (xOffsetTmpBuf_UnionSelector == (1).toChar()) {
                xOffsetTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (xOffsetTmpBuf_UnionSelector == (2).toChar()) {
                xOffsetTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for xOffsetTmpBuf_ has to be chosen through deserialisation.")
            }
            xOffsetTmpBuf = (xOffsetTmpBuf_ as string | number | Resource)
        }
        const xOffsetTmpResult : Dimension | undefined = xOffsetTmpBuf
        const yOffsetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let yOffsetTmpBuf : Dimension | undefined = undefined
        if ((yOffsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const yOffsetTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let yOffsetTmpBuf_ : string | number | Resource | undefined
            if (yOffsetTmpBuf_UnionSelector == (0).toChar()) {
                yOffsetTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (yOffsetTmpBuf_UnionSelector == (1).toChar()) {
                yOffsetTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (yOffsetTmpBuf_UnionSelector == (2).toChar()) {
                yOffsetTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for yOffsetTmpBuf_ has to be chosen through deserialisation.")
            }
            yOffsetTmpBuf = (yOffsetTmpBuf_ as string | number | Resource)
        }
        const yOffsetTmpResult : Dimension | undefined = yOffsetTmpBuf
        let value : OffsetOptions = ({xOffset: xOffsetTmpResult, yOffset: yOffsetTmpResult} as OffsetOptions)
        return value
    }
}
export class ScrollSnapOptions_serializer {
    public static write(buffer: SerializerBase, value: ScrollSnapOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForSnapAlign  = value.snapAlign
        valueSerializer.writeInt32(valueHolderForSnapAlign.valueOf())
        const valueHolderForSnapPagination  = value.snapPagination
        if (valueHolderForSnapPagination !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForSnapPaginationTmpValue  = valueHolderForSnapPagination!
            if (valueHolderForSnapPaginationTmpValue instanceof Dimension) {
                valueSerializer.writeInt8((0).toChar())
                const valueHolderForSnapPaginationTmpValueForIdx0  = valueHolderForSnapPaginationTmpValue as Dimension
                if (valueHolderForSnapPaginationTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toChar())
                    const valueHolderForSnapPaginationTmpValueForIdx0ForIdx0  = valueHolderForSnapPaginationTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForSnapPaginationTmpValueForIdx0ForIdx0)
                } else if (valueHolderForSnapPaginationTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toChar())
                    const valueHolderForSnapPaginationTmpValueForIdx0ForIdx1  = valueHolderForSnapPaginationTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForSnapPaginationTmpValueForIdx0ForIdx1)
                } else if (valueHolderForSnapPaginationTmpValueForIdx0 instanceof Resource) {
                    valueSerializer.writeInt8((2).toChar())
                    const valueHolderForSnapPaginationTmpValueForIdx0ForIdx2  = valueHolderForSnapPaginationTmpValueForIdx0 as Resource
                    Resource_serializer.write(valueSerializer, valueHolderForSnapPaginationTmpValueForIdx0ForIdx2)
                }
            } else if (TypeChecker.isArray_Dimension(valueHolderForSnapPaginationTmpValue)) {
                valueSerializer.writeInt8((1).toChar())
                const valueHolderForSnapPaginationTmpValueForIdx1  = valueHolderForSnapPaginationTmpValue as Array<Dimension>
                valueSerializer.writeInt32((valueHolderForSnapPaginationTmpValueForIdx1.length).toInt())
                for (let valueHolderForSnapPaginationTmpValueForIdx1CounterI = 0; valueHolderForSnapPaginationTmpValueForIdx1CounterI < valueHolderForSnapPaginationTmpValueForIdx1.length; valueHolderForSnapPaginationTmpValueForIdx1CounterI++) {
                    const valueHolderForSnapPaginationTmpValueForIdx1TmpElement : Dimension = valueHolderForSnapPaginationTmpValueForIdx1[valueHolderForSnapPaginationTmpValueForIdx1CounterI]
                    if (valueHolderForSnapPaginationTmpValueForIdx1TmpElement instanceof string) {
                        valueSerializer.writeInt8((0).toChar())
                        const valueHolderForSnapPaginationTmpValueForIdx1TmpElementForIdx0  = valueHolderForSnapPaginationTmpValueForIdx1TmpElement as string
                        valueSerializer.writeString(valueHolderForSnapPaginationTmpValueForIdx1TmpElementForIdx0)
                    } else if (valueHolderForSnapPaginationTmpValueForIdx1TmpElement instanceof number) {
                        valueSerializer.writeInt8((1).toChar())
                        const valueHolderForSnapPaginationTmpValueForIdx1TmpElementForIdx1  = valueHolderForSnapPaginationTmpValueForIdx1TmpElement as number
                        valueSerializer.writeNumber(valueHolderForSnapPaginationTmpValueForIdx1TmpElementForIdx1)
                    } else if (valueHolderForSnapPaginationTmpValueForIdx1TmpElement instanceof Resource) {
                        valueSerializer.writeInt8((2).toChar())
                        const valueHolderForSnapPaginationTmpValueForIdx1TmpElementForIdx2  = valueHolderForSnapPaginationTmpValueForIdx1TmpElement as Resource
                        Resource_serializer.write(valueSerializer, valueHolderForSnapPaginationTmpValueForIdx1TmpElementForIdx2)
                    }
                }
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableSnapToStart  = value.enableSnapToStart
        if (valueHolderForEnableSnapToStart !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableSnapToStartTmpValue  = valueHolderForEnableSnapToStart!
            valueSerializer.writeBoolean(valueHolderForEnableSnapToStartTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableSnapToEnd  = value.enableSnapToEnd
        if (valueHolderForEnableSnapToEnd !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableSnapToEndTmpValue  = valueHolderForEnableSnapToEnd!
            valueSerializer.writeBoolean(valueHolderForEnableSnapToEndTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ScrollSnapOptions {
        let valueDeserializer : DeserializerBase = buffer
        const snapAlignTmpResult : ScrollSnapAlign = ScrollSnapAlign.fromValue(valueDeserializer.readInt32())
        const snapPaginationTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let snapPaginationTmpBuf : Dimension | Array<Dimension> | undefined = undefined
        if ((snapPaginationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const snapPaginationTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let snapPaginationTmpBuf_ : Dimension | Array<Dimension> | undefined
            if (snapPaginationTmpBuf_UnionSelector == (0).toChar()) {
                const snapPaginationTmpBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                let snapPaginationTmpBuf_BufU : string | number | Resource | undefined
                if (snapPaginationTmpBuf_BufUUnionSelector == (0).toChar()) {
                    snapPaginationTmpBuf_BufU = (valueDeserializer.readString() as string)
                } else if (snapPaginationTmpBuf_BufUUnionSelector == (1).toChar()) {
                    snapPaginationTmpBuf_BufU = (valueDeserializer.readNumber() as number)
                } else if (snapPaginationTmpBuf_BufUUnionSelector == (2).toChar()) {
                    snapPaginationTmpBuf_BufU = Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error("One of the branches for snapPaginationTmpBuf_BufU has to be chosen through deserialisation.")
                }
                snapPaginationTmpBuf_ = (snapPaginationTmpBuf_BufU as string | number | Resource)
            } else if (snapPaginationTmpBuf_UnionSelector == (1).toChar()) {
                const snapPaginationTmpBuf_BufULength : int32 = valueDeserializer.readInt32()
                let snapPaginationTmpBuf_BufU : Array<Dimension> = new Array<Dimension>(snapPaginationTmpBuf_BufULength)
                for (let snapPaginationTmpBuf_BufUBufCounterI = 0; snapPaginationTmpBuf_BufUBufCounterI < snapPaginationTmpBuf_BufULength; snapPaginationTmpBuf_BufUBufCounterI++) {
                    const snapPaginationTmpBuf_BufUTempBufUnionSelector : int32 = valueDeserializer.readInt8()
                    let snapPaginationTmpBuf_BufUTempBuf : string | number | Resource | undefined
                    if (snapPaginationTmpBuf_BufUTempBufUnionSelector == (0).toChar()) {
                        snapPaginationTmpBuf_BufUTempBuf = (valueDeserializer.readString() as string)
                    } else if (snapPaginationTmpBuf_BufUTempBufUnionSelector == (1).toChar()) {
                        snapPaginationTmpBuf_BufUTempBuf = (valueDeserializer.readNumber() as number)
                    } else if (snapPaginationTmpBuf_BufUTempBufUnionSelector == (2).toChar()) {
                        snapPaginationTmpBuf_BufUTempBuf = Resource_serializer.read(valueDeserializer)
                    } else {
                        throw new Error("One of the branches for snapPaginationTmpBuf_BufUTempBuf has to be chosen through deserialisation.")
                    }
                    snapPaginationTmpBuf_BufU[snapPaginationTmpBuf_BufUBufCounterI] = (snapPaginationTmpBuf_BufUTempBuf as string | number | Resource)
                }
                snapPaginationTmpBuf_ = snapPaginationTmpBuf_BufU
            } else {
                throw new Error("One of the branches for snapPaginationTmpBuf_ has to be chosen through deserialisation.")
            }
            snapPaginationTmpBuf = (snapPaginationTmpBuf_ as Dimension | Array<Dimension>)
        }
        const snapPaginationTmpResult : Dimension | Array<Dimension> | undefined = snapPaginationTmpBuf
        const enableSnapToStartTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableSnapToStartTmpBuf : boolean | undefined = undefined
        if ((enableSnapToStartTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableSnapToStartTmpBuf = valueDeserializer.readBoolean()
        }
        const enableSnapToStartTmpResult : boolean | undefined = enableSnapToStartTmpBuf
        const enableSnapToEndTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableSnapToEndTmpBuf : boolean | undefined = undefined
        if ((enableSnapToEndTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableSnapToEndTmpBuf = valueDeserializer.readBoolean()
        }
        const enableSnapToEndTmpResult : boolean | undefined = enableSnapToEndTmpBuf
        let value : ScrollSnapOptions = ({snapAlign: snapAlignTmpResult, snapPagination: snapPaginationTmpResult, enableSnapToStart: enableSnapToStartTmpResult, enableSnapToEnd: enableSnapToEndTmpResult} as ScrollSnapOptions)
        return value
    }
}
