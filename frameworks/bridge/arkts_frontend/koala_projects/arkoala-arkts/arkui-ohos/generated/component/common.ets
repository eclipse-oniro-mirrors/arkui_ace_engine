/*
 * Copyright (c) 2024-2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


// WARNING! THIS FILE IS AUTO-GENERATED, DO NOT MAKE CHANGES, THEY WILL BE LOST ON NEXT GENERATION!

import { SerializerBase, DeserializerBase, resourceFinalizerRegister, Finalizable, RuntimeType, toPeerPtr, KPointer, MaterializedBase, MaterializedBaseTag, NativeBuffer, nullptr, KInt, KBoolean, KStringPtr, CallbackResource, InteropNativeModule, Tags, KSerializerBuffer, KUint8ArrayPtr } from '@koalaui/interop'
import { unsafeCast, int32, int64, float32 } from '@koalaui/common'
import { ArkUIGeneratedNativeModule } from '#components'
import { CallbackTransformer } from './../CallbackTransformer'
import { CrownAction, KeyType, KeySource, Color as arkui_component_enums_Color, HitTestMode, ImageSize, Alignment, BorderStyle, ColoringStrategy, HoverEffect, Visibility, ItemAlign, Direction, ObscuredReasons, RenderFit, FocusDrawLevel, ImageRepeat, Axis, ResponseType, FunctionKey, ModifierKey, InteractionHand, GradientDirection, Curve, SharedTransitionEffectType, ArrowPointPosition, Placement, LineCapStyle, LineJoinStyle, BarState, CrownSensitivity, EdgeEffect, TextDecorationType, TextDecorationStyle, PlayMode, VerticalAlign, HorizontalAlign, FontWeight, FontStyle, TouchType, ClickEffectLevel, NestedScrollMode, PixelRoundCalcPolicy, ScrollSource, IlluminatedType, AccessibilityHoverType, AxisAction, AxisModel, MouseButton, MouseAction } from './enums'
import { unifiedDataChannel_UnifiedData_serializer, unifiedDataChannel_Summary_serializer, unifiedDataChannel_GetDataParams_serializer } from './../framework/ohos.data.unifiedDataChannel'
import { extractors, DrawModifier, GestureModifier, GestureType, Gesture, GestureGroup, WrappedBuilder, GestureControl, hookId, hookStateStyleImpl, hookGesture, hookPriorityGesture, hookParallelGesture, hookGestureModifier, hookCustomPropertyImpl, hookDrawModifier, hookAllowDrop, hookDragPreviewOptions, CustomStyles, initializers, ContentModifier, hookCommonMethodAttributeModifier, AttributeModifier, AttributeUpdater, hookCommonShapeMethodAttributeModifier, hookScrollableCommonMethodAttributeModifier } from '#handwritten'
import { default as unifiedDataChannel } from '@ohos.data.unifiedDataChannel'
import { VoidCallback, Position_serializer, DirectionalEdgesT_F64_serializer, Position, DirectionalEdgesT, ConstraintSizeOptions_serializer, ConstraintSizeOptions, ResourceColor, Resource as arkui_component_units_Resource, SizeOptions, SizeOptions_serializer, ChainWeightOptions_serializer, Padding_serializer, LocalizedPadding_serializer, BorderOptions_serializer, EdgeStyles_serializer, EdgeWidths_serializer, LocalizedEdgeWidths_serializer, EdgeColors_serializer, LocalizedEdgeColors_serializer, BorderRadiuses_serializer, LocalizedBorderRadiuses_serializer, OutlineOptions_serializer, EdgeOutlineStyles_serializer, EdgeOutlineWidths_serializer, OutlineRadiuses_serializer, Edges_serializer, LocalizedEdges_serializer, LocalizedPosition_serializer, AccessibilityOptions_serializer, Length, ChainWeightOptions, Padding, LocalizedPadding, Margin, LocalizedMargin, ColorMetrics as arkui_component_units_ColorMetrics, ResourceStr as arkui_component_units_ResourceStr, BorderOptions, EdgeStyles, EdgeWidths, LocalizedEdgeWidths, EdgeColors, LocalizedEdgeColors, BorderRadiuses, LocalizedBorderRadiuses, OutlineOptions, EdgeOutlineStyles, Dimension, EdgeOutlineWidths, OutlineRadiuses, Area, Edges, LocalizedEdges, LocalizedPosition, AccessibilityOptions, Bias, Font as arkui_component_units_Font, EdgeWidth, Bias_serializer, Area_serializer, arkui_component_units_Font_serializer } from './units'
import { IntentionCode } from '@ohos.multimodalInput.intentionCode'
import { global_resource_Resource_serializer } from './../framework/resource'
import { Resource as global_resource_Resource } from 'global.resource'
import { TextRange_serializer, TextRange } from './textCommon'
import { arkui_Graphics_LengthMetrics_serializer, arkui_Graphics_ColorMetrics_serializer } from './../framework/Graphics'
import { image_PixelMap_serializer } from './../framework/ohos.multimedia.image'
import { ResizableOptions_serializer, ResizableOptions } from './image'
import { uiEffect_VisualEffect_serializer, uiEffect_Filter_serializer, uiEffect_BrightnessBlender_serializer } from './../framework/ohos.graphics.uiEffect'
import { FocusBoxStyle_serializer, FocusBoxStyle, FocusPriority } from './focus'
import { matrix4_Matrix4Transit_serializer } from './../framework/ohos.matrix4'
import { CircleShape_serializer, EllipseShape_serializer, PathShape_serializer, RectShape_serializer } from './../framework/ohos.arkui.shape'
import { ComponentContent_serializer } from './../framework/ComponentContent'
import { StyledString_serializer, StyledString, ImageAttachment, CustomSpan, StyleOptions, StyledStringKey, SpanStyle, StyledStringMarshallCallback, StyledStringMarshallingValue, UserDataSpan, StyledStringUnmarshallCallback } from './styledString'
import { ComponentBase } from './../ComponentBase'
import { PeerNode } from './../PeerNode'
import { LengthMetrics as arkui_Graphics_LengthMetrics, ColorMetrics as arkui_Graphics_ColorMetrics, DrawContext as arkui_Graphics_DrawContext } from '@arkui.Graphics'
import { default as image } from '@ohos.multimedia.image'
import { default as uiEffect } from '@ohos.graphics.uiEffect'
import { default as matrix4 } from '@ohos.matrix4'
import { CustomBuilder, CustomBuilderT } from './builder'
import { default as uniformTypeDescriptor } from '@ohos.data.uniformTypeDescriptor'
import { CircleShape, EllipseShape, PathShape, RectShape } from '@ohos.arkui.shape'
import { GestureInfo, BaseGestureEvent, GestureJudgeResult, GestureRecognizer, TouchRecognizer, GestureMask, GestureMode, FingerInfo, GestureRecognizerState, EventTargetInfo } from './gesture'
import { ComponentContent, ComponentContentBase } from '@arkui.ComponentContent'
import { AsyncCallback, BusinessError, RecordData } from '@ohos.base'
import { default as colorSpaceManager } from '@ohos.graphics.colorSpaceManager'
import { default as rpc } from '@ohos.rpc'
import { default as curves } from '@ohos.curves'
import { ImageModifier } from 'arkui.ImageModifier'
import { UIContext as ohos_arkui_UIContext_UIContext } from '@ohos.arkui.UIContext'
import { BuildOptions } from 'arkui.BuilderNode'
import { SymbolGlyphModifier } from '@arkui.SymbolGlyphModifier'
import { CallbackKind } from './../framework/peers/CallbackKind'
import { memo, memo_stable, memo_skip } from 'arkui.stateManagement.runtime'
import { ComponentBuilder, Builder } from '@koalaui/builderLambda'
import { default as application_Context_Context } from 'application.Context'
import { default as pointer } from '@ohos.multimodalInput.pointer'
import { ButtonType, ButtonStyleMode, ButtonRole } from './button'
import { default as uiObserver } from '@ohos.arkui.observer'
import { default as promptAction } from '@ohos.promptAction'
import { ScrollState } from './list'
import { default as Want } from '@ohos.app.ability.Want'
import { default as intl } from '@ohos.intl'
import { CommonMethodModifier } from './../CommonMethodModifier'
import { NodeAttach, remember } from '@koalaui/runtime'
import { ModifierStateManager } from './../CommonModifier'
import { CommonShapeMethodModifier } from './../CommonShapeMethodModifier'
import { ScrollableCommonMethodModifier } from './../ScrollableCommonMethodModifier'
import { GlobalScope } from './../framework/GlobalScope'
import { curves_ICurve_serializer } from './../framework/ohos.curves'
import { Want_serializer } from './../framework/ohos.app.ability.Want'
import { ImageModifier_serializer } from './../framework/ImageModifier'
import { SymbolGlyphModifier_serializer } from './../framework/SymbolGlyphModifier'
import { ohos_arkui_UIContext_UIContext_serializer } from './../framework/ohos.arkui.UIContext'
// instructive change start
import { _animateTo, _animationStart, _animationStop } from "arkui/base/ArkAnimation"
import { AnimationExtender } from '#generated';
import { ModifierStateManager } from '../CommonModifier';
// instructive change end

export interface BaseEvent {
    target: EventTarget
    timestamp: int64
    source: SourceType
    axisHorizontal?: double | undefined
    axisVertical?: double | undefined
    pressure: double
    tiltX: double
    tiltY: double
    rollAngle?: double | undefined
    sourceTool: SourceTool
    getModifierKeyState?: ModifierKeyStateGetter | undefined
    deviceId?: int32 | undefined
    targetDisplayId?: int32 | undefined
    axisPinch?: double | undefined
}
export class BaseEventInternal implements MaterializedBase,BaseEvent {
    public peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    public target: EventTarget
    public timestamp: int64
    public source: SourceType
    public axisHorizontal?: double | undefined
    public axisVertical?: double | undefined
    public pressure: double
    public tiltX: double
    public tiltY: double
    public rollAngle?: double | undefined
    public sourceTool: SourceTool
    public getModifierKeyState?: ModifierKeyStateGetter | undefined
    public deviceId?: int32 | undefined
    public targetDisplayId?: int32 | undefined
    public axisPinch?: double | undefined
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, BaseEventInternal.getFinalizer())
        this.target = this.getTarget()
        this.timestamp = this.getTimestamp()
        this.source = this.getSource()
        this.axisHorizontal = this.getAxisHorizontal()
        this.axisVertical = this.getAxisVertical()
        this.pressure = this.getPressure()
        this.tiltX = this.getTiltX()
        this.tiltY = this.getTiltY()
        this.rollAngle = this.getRollAngle()
        this.sourceTool = this.getSourceTool()
        this.getModifierKeyState = this.getGetModifierKeyState()
        this.deviceId = this.getDeviceId()
        this.targetDisplayId = this.getTargetDisplayId()
        this.axisPinch = this.getAxisPinch()
    }
    constructor() {
        this(MaterializedBaseTag.NOP, BaseEventInternal.construct())
        this.target = this.getTarget()
        this.timestamp = this.getTimestamp()
        this.source = this.getSource()
        this.axisHorizontal = this.getAxisHorizontal()
        this.axisVertical = this.getAxisVertical()
        this.pressure = this.getPressure()
        this.tiltX = this.getTiltX()
        this.tiltY = this.getTiltY()
        this.rollAngle = this.getRollAngle()
        this.sourceTool = this.getSourceTool()
        this.getModifierKeyState = this.getGetModifierKeyState()
        this.deviceId = this.getDeviceId()
        this.targetDisplayId = this.getTargetDisplayId()
        this.axisPinch = this.getAxisPinch()
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._BaseEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): BaseEventInternal {
        return new BaseEventInternal(MaterializedBaseTag.NOP, ptr)
    }
    private getTarget(): EventTarget {
        return this.getTarget_serialize()
    }
    private setTarget(target: EventTarget): void {
        const target_casted = target as (EventTarget)
        this.setTarget_serialize(target_casted)
        return
    }
    private getTimestamp(): int64 {
        return this.getTimestamp_serialize()
    }
    private setTimestamp(timestamp: int64): void {
        const timestamp_casted = timestamp as (int64)
        this.setTimestamp_serialize(timestamp_casted)
        return
    }
    private getSource(): SourceType {
        return this.getSource_serialize()
    }
    private setSource(source: SourceType): void {
        const source_casted = source as (SourceType)
        this.setSource_serialize(source_casted)
        return
    }
    private getAxisHorizontal(): double | undefined {
        return this.getAxisHorizontal_serialize()
    }
    private setAxisHorizontal(axisHorizontal: double | undefined): void {
        const axisHorizontal_casted = axisHorizontal as (double | undefined)
        this.setAxisHorizontal_serialize(axisHorizontal_casted)
        return
    }
    private getAxisVertical(): double | undefined {
        return this.getAxisVertical_serialize()
    }
    private setAxisVertical(axisVertical: double | undefined): void {
        const axisVertical_casted = axisVertical as (double | undefined)
        this.setAxisVertical_serialize(axisVertical_casted)
        return
    }
    private getPressure(): double {
        return this.getPressure_serialize()
    }
    private setPressure(pressure: double): void {
        const pressure_casted = pressure as (double)
        this.setPressure_serialize(pressure_casted)
        return
    }
    private getTiltX(): double {
        return this.getTiltX_serialize()
    }
    private setTiltX(tiltX: double): void {
        const tiltX_casted = tiltX as (double)
        this.setTiltX_serialize(tiltX_casted)
        return
    }
    private getTiltY(): double {
        return this.getTiltY_serialize()
    }
    private setTiltY(tiltY: double): void {
        const tiltY_casted = tiltY as (double)
        this.setTiltY_serialize(tiltY_casted)
        return
    }
    private getRollAngle(): double | undefined {
        return this.getRollAngle_serialize()
    }
    private setRollAngle(rollAngle: double | undefined): void {
        const rollAngle_casted = rollAngle as (double | undefined)
        this.setRollAngle_serialize(rollAngle_casted)
        return
    }
    private getSourceTool(): SourceTool {
        return this.getSourceTool_serialize()
    }
    private setSourceTool(sourceTool: SourceTool): void {
        const sourceTool_casted = sourceTool as (SourceTool)
        this.setSourceTool_serialize(sourceTool_casted)
        return
    }
    private getGetModifierKeyState(): ModifierKeyStateGetter | undefined {
        // instructive change start
        let returnResult: ModifierKeyStateGetter = (keys: Array<string>) => {
            return ArkUIAniModule._BaseEvent_getModifierKeyState(this!.peer!.ptr, keys);
        }
        return returnResult
        // instructive change end
    }
    private setGetModifierKeyState(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const getModifierKeyState_casted = getModifierKeyState as (ModifierKeyStateGetter | undefined)
        this.setGetModifierKeyState_serialize(getModifierKeyState_casted)
        return
    }
    private getDeviceId(): int32 | undefined {
        return this.getDeviceId_serialize()
    }
    private setDeviceId(deviceId: int32 | undefined): void {
        const deviceId_casted = deviceId as (int32 | undefined)
        this.setDeviceId_serialize(deviceId_casted)
        return
    }
    private getTargetDisplayId(): int32 | undefined {
        return this.getTargetDisplayId_serialize()
    }
    private setTargetDisplayId(targetDisplayId: int32 | undefined): void {
        const targetDisplayId_casted = targetDisplayId as (int32 | undefined)
        this.setTargetDisplayId_serialize(targetDisplayId_casted)
        return
    }
    private getAxisPinch(): double | undefined {
        return this.getAxisPinch_serialize()
    }
    private setAxisPinch(axisPinch: double | undefined): void {
        const axisPinch_casted = axisPinch as (double | undefined)
        this.setAxisPinch_serialize(axisPinch_casted)
        return
    }
    private getTarget_serialize(): EventTarget {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getTarget(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : EventTarget = EventTarget_serializer.read(retvalDeserializer)
        return returnResult
    }
    private setTarget_serialize(target: EventTarget): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        EventTarget_serializer.write(thisSerializer, target)
        ArkUIGeneratedNativeModule._BaseEvent_setTarget(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getTimestamp_serialize(): int64 {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getTimestamp(this.peer!.ptr)
        return retval
    }
    private setTimestamp_serialize(timestamp: int64): void {
        ArkUIGeneratedNativeModule._BaseEvent_setTimestamp(this.peer!.ptr, timestamp)
    }
    private getSource_serialize(): SourceType {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getSource(this.peer!.ptr)
        return SourceType.fromValue(retval)
    }
    private setSource_serialize(source: SourceType): void {
        ArkUIGeneratedNativeModule._BaseEvent_setSource(this.peer!.ptr, source.valueOf())
    }
    private getAxisHorizontal_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getAxisHorizontal(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setAxisHorizontal_serialize(axisHorizontal: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (axisHorizontal !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const axisHorizontalTmpValue  = axisHorizontal!
            thisSerializer.writeFloat64(axisHorizontalTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setAxisHorizontal(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getAxisVertical_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getAxisVertical(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setAxisVertical_serialize(axisVertical: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (axisVertical !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const axisVerticalTmpValue  = axisVertical!
            thisSerializer.writeFloat64(axisVerticalTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setAxisVertical(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getPressure_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getPressure(this.peer!.ptr)
        return retval
    }
    private setPressure_serialize(pressure: double): void {
        ArkUIGeneratedNativeModule._BaseEvent_setPressure(this.peer!.ptr, pressure)
    }
    private getTiltX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getTiltX(this.peer!.ptr)
        return retval
    }
    private setTiltX_serialize(tiltX: double): void {
        ArkUIGeneratedNativeModule._BaseEvent_setTiltX(this.peer!.ptr, tiltX)
    }
    private getTiltY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getTiltY(this.peer!.ptr)
        return retval
    }
    private setTiltY_serialize(tiltY: double): void {
        ArkUIGeneratedNativeModule._BaseEvent_setTiltY(this.peer!.ptr, tiltY)
    }
    private getRollAngle_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getRollAngle(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setRollAngle_serialize(rollAngle: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (rollAngle !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const rollAngleTmpValue  = rollAngle!
            thisSerializer.writeFloat64(rollAngleTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setRollAngle(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getSourceTool_serialize(): SourceTool {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getSourceTool(this.peer!.ptr)
        return SourceTool.fromValue(retval)
    }
    private setSourceTool_serialize(sourceTool: SourceTool): void {
        ArkUIGeneratedNativeModule._BaseEvent_setSourceTool(this.peer!.ptr, sourceTool.valueOf())
    }
    private getGetModifierKeyState_serialize(): ModifierKeyStateGetter | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getGetModifierKeyState(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : ModifierKeyStateGetter | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            const bufferOptBufResource : CallbackResource = retvalDeserializer.readCallbackResource()
            const bufferOptBufCall : KPointer = retvalDeserializer.readPointer()
            const bufferOptBufCallSync : KPointer = retvalDeserializer.readPointer()
            const bufferOptClosure  = (keys: Array<string>):boolean => {
                const bufferOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                bufferOptBufArgsSerializer.writeInt32(bufferOptBufResource.resourceId);
                bufferOptBufArgsSerializer.writePointer(bufferOptBufCall);
                bufferOptBufArgsSerializer.writePointer(bufferOptBufCallSync);
                bufferOptBufArgsSerializer.writeInt32((keys.length).toInt());
                for (let keysCounterI = 0; keysCounterI < keys.length; keysCounterI++) {
                    const keysTmpElement : string = keys[keysCounterI];
                    bufferOptBufArgsSerializer.writeString(keysTmpElement);
                }
                let bufferOptBufContinuationValue : boolean | undefined;
                const bufferOptBufContinuationCallback : ((isSelected: boolean) => void) = (value: boolean):void => {
                bufferOptBufContinuationValue = value;
            }
                bufferOptBufArgsSerializer.holdAndWriteCallback(bufferOptBufContinuationCallback);
                InteropNativeModule._CallCallbackSync(10, -1142029296, bufferOptBufArgsSerializer.asBuffer(), bufferOptBufArgsSerializer.length());
                bufferOptBufArgsSerializer.release();
                return (bufferOptBufContinuationValue as boolean);
            }
            resourceFinalizerRegister(bufferOptClosure, bufferOptBufResource)
            buffer = bufferOptClosure
        }
        const returnResult : ModifierKeyStateGetter | undefined = buffer
        return returnResult
    }
    private setGetModifierKeyState_serialize(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (getModifierKeyState !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const getModifierKeyStateTmpValue  = getModifierKeyState!
            thisSerializer.holdAndWriteCallback(getModifierKeyStateTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setGetModifierKeyState(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getDeviceId_serialize(): int32 | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getDeviceId(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : int32 | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readInt32()
        }
        const returnResult : int32 | undefined = buffer
        return returnResult
    }
    private setDeviceId_serialize(deviceId: int32 | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (deviceId !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const deviceIdTmpValue  = deviceId!
            thisSerializer.writeInt32(deviceIdTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setDeviceId(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getTargetDisplayId_serialize(): int32 | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getTargetDisplayId(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : int32 | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readInt32()
        }
        const returnResult : int32 | undefined = buffer
        return returnResult
    }
    private setTargetDisplayId_serialize(targetDisplayId: int32 | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (targetDisplayId !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const targetDisplayIdTmpValue  = targetDisplayId!
            thisSerializer.writeInt32(targetDisplayIdTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setTargetDisplayId(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getAxisPinch_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getAxisPinch(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setAxisPinch_serialize(axisPinch: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (axisPinch !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const axisPinchTmpValue  = axisPinch!
            thisSerializer.writeFloat64(axisPinchTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setAxisPinch(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface CrownEvent {
    timestamp: int64
    angularVelocity: double
    degree: double
    action: CrownAction
    stopPropagation(): void
}
export class CrownEventInternal implements MaterializedBase,CrownEvent {
    public peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    public timestamp: int64
    public angularVelocity: double
    public degree: double
    public action: CrownAction
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, CrownEventInternal.getFinalizer())
        this.timestamp = this.getTimestamp()
        this.angularVelocity = this.getAngularVelocity()
        this.degree = this.getDegree()
        this.action = this.getAction()
    }
    constructor() {
        this(MaterializedBaseTag.NOP, CrownEventInternal.construct())
        this.timestamp = this.getTimestamp()
        this.angularVelocity = this.getAngularVelocity()
        this.degree = this.getDegree()
        this.action = this.getAction()
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._CrownEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._CrownEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): CrownEventInternal {
        return new CrownEventInternal(MaterializedBaseTag.NOP, ptr)
    }
    public stopPropagation(): void {
        this.stopPropagation_serialize()
        return
    }
    private getTimestamp(): int64 {
        return this.getTimestamp_serialize()
    }
    private setTimestamp(timestamp: int64): void {
        const timestamp_casted = timestamp as (int64)
        this.setTimestamp_serialize(timestamp_casted)
        return
    }
    private getAngularVelocity(): double {
        return this.getAngularVelocity_serialize()
    }
    private setAngularVelocity(angularVelocity: double): void {
        const angularVelocity_casted = angularVelocity as (double)
        this.setAngularVelocity_serialize(angularVelocity_casted)
        return
    }
    private getDegree(): double {
        return this.getDegree_serialize()
    }
    private setDegree(degree: double): void {
        const degree_casted = degree as (double)
        this.setDegree_serialize(degree_casted)
        return
    }
    private getAction(): CrownAction {
        return this.getAction_serialize()
    }
    private setAction(action: CrownAction): void {
        const action_casted = action as (CrownAction)
        this.setAction_serialize(action_casted)
        return
    }
    private stopPropagation_serialize(): void {
        ArkUIGeneratedNativeModule._CrownEvent_stopPropagation(this.peer!.ptr)
    }
    private getTimestamp_serialize(): int64 {
        const retval  = ArkUIGeneratedNativeModule._CrownEvent_getTimestamp(this.peer!.ptr)
        return retval
    }
    private setTimestamp_serialize(timestamp: int64): void {
        ArkUIGeneratedNativeModule._CrownEvent_setTimestamp(this.peer!.ptr, timestamp)
    }
    private getAngularVelocity_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._CrownEvent_getAngularVelocity(this.peer!.ptr)
        return retval
    }
    private setAngularVelocity_serialize(angularVelocity: double): void {
        ArkUIGeneratedNativeModule._CrownEvent_setAngularVelocity(this.peer!.ptr, angularVelocity)
    }
    private getDegree_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._CrownEvent_getDegree(this.peer!.ptr)
        return retval
    }
    private setDegree_serialize(degree: double): void {
        ArkUIGeneratedNativeModule._CrownEvent_setDegree(this.peer!.ptr, degree)
    }
    private getAction_serialize(): CrownAction {
        const retval  = ArkUIGeneratedNativeModule._CrownEvent_getAction(this.peer!.ptr)
        return CrownAction.fromValue(retval)
    }
    private setAction_serialize(action: CrownAction): void {
        ArkUIGeneratedNativeModule._CrownEvent_setAction(this.peer!.ptr, action.valueOf())
    }
}
export interface DismissPopupAction {
    reason: DismissReason
    dismiss(): void
}
export class DismissPopupActionInternal implements MaterializedBase,DismissPopupAction {
    public peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    public reason: DismissReason
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, DismissPopupActionInternal.getFinalizer())
        this.reason = this.getReason()
    }
    constructor() {
        this(MaterializedBaseTag.NOP, DismissPopupActionInternal.construct())
        this.reason = this.getReason()
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._DismissPopupAction_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._DismissPopupAction_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): DismissPopupActionInternal {
        return new DismissPopupActionInternal(MaterializedBaseTag.NOP, ptr)
    }
    public dismiss(): void {
        this.dismiss_serialize()
        return
    }
    private getReason(): DismissReason {
        return this.getReason_serialize()
    }
    private setReason(reason: DismissReason): void {
        const reason_casted = reason as (DismissReason)
        this.setReason_serialize(reason_casted)
        return
    }
    private dismiss_serialize(): void {
        ArkUIGeneratedNativeModule._DismissPopupAction_dismiss(this.peer!.ptr)
    }
    private getReason_serialize(): DismissReason {
        const retval  = ArkUIGeneratedNativeModule._DismissPopupAction_getReason(this.peer!.ptr)
        return DismissReason.fromValue(retval)
    }
    private setReason_serialize(reason: DismissReason): void {
        ArkUIGeneratedNativeModule._DismissPopupAction_setReason(this.peer!.ptr, reason.valueOf())
    }
}
export interface DragEvent {
    dragBehavior: DragBehavior
    useCustomDropAnimation: boolean
    getModifierKeyState?: ModifierKeyStateGetter | undefined
    getDisplayX(): double
    getDisplayY(): double
    getWindowX(): double
    getWindowY(): double
    setData(unifiedData: UnifiedData): void
    getData(): UnifiedData | undefined
    getSummary(): Summary | undefined
    setResult(dragResult: DragResult): void
    getResult(): DragResult
    getPreviewRect(): Rectangle
    getVelocityX(): double
    getVelocityY(): double
    getVelocity(): double
    startDataLoading(options: DataSyncOptions): string | undefined
    executeDropAnimation(customDropAnimation: VoidCallback): void
    enableInternalDropAnimation(configuration: string): void
}
export class DragEventInternal implements MaterializedBase,DragEvent {
    public peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    public dragBehavior: DragBehavior
    public useCustomDropAnimation: boolean
    public getModifierKeyState?: ModifierKeyStateGetter | undefined
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, DragEventInternal.getFinalizer())
        this.dragBehavior = this.getDragBehavior()
        this.useCustomDropAnimation = this.getUseCustomDropAnimation()
        this.getModifierKeyState = this.getGetModifierKeyState()
    }
    constructor() {
        this(MaterializedBaseTag.NOP, DragEventInternal.construct())
        this.dragBehavior = this.getDragBehavior()
        this.useCustomDropAnimation = this.getUseCustomDropAnimation()
        this.getModifierKeyState = this.getGetModifierKeyState()
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._DragEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): DragEventInternal {
        return new DragEventInternal(MaterializedBaseTag.NOP, ptr)
    }
    public getDisplayX(): double {
        return this.getDisplayX_serialize()
    }
    public getDisplayY(): double {
        return this.getDisplayY_serialize()
    }
    public getWindowX(): double {
        return this.getWindowX_serialize()
    }
    public getWindowY(): double {
        return this.getWindowY_serialize()
    }
    public setData(unifiedData: UnifiedData): void {
        const unifiedData_casted = unifiedData as (UnifiedData)
        this.setData_serialize(unifiedData_casted)
        return
    }
    public getData(): UnifiedData | undefined {
        return this.getData_serialize()
    }
    public getSummary(): Summary | undefined {
        return this.getSummary_serialize()
    }
    public setResult(dragResult: DragResult): void {
        const dragResult_casted = dragResult as (DragResult)
        this.setResult_serialize(dragResult_casted)
        return
    }
    public getResult(): DragResult {
        return this.getResult_serialize()
    }
    public getPreviewRect(): Rectangle {
        return this.getPreviewRect_serialize()
    }
    public getVelocityX(): double {
        return this.getVelocityX_serialize()
    }
    public getVelocityY(): double {
        return this.getVelocityY_serialize()
    }
    public getVelocity(): double {
        return this.getVelocity_serialize()
    }
    public startDataLoading(options: DataSyncOptions): string | undefined {
        const options_casted = options as (DataSyncOptions)
        return this.startDataLoading_serialize(options_casted)
    }
    public executeDropAnimation(customDropAnimation: VoidCallback): void {
        const customDropAnimation_casted = customDropAnimation as (VoidCallback)
        this.executeDropAnimation_serialize(customDropAnimation_casted)
        return
    }
    public enableInternalDropAnimation(configuration: string): void {
        const configuration_casted = configuration as (string)
        this.enableInternalDropAnimation_serialize(configuration_casted)
        return
    }
    private getDragBehavior(): DragBehavior {
        return this.getDragBehavior_serialize()
    }
    private setDragBehavior(dragBehavior: DragBehavior): void {
        const dragBehavior_casted = dragBehavior as (DragBehavior)
        this.setDragBehavior_serialize(dragBehavior_casted)
        return
    }
    private getUseCustomDropAnimation(): boolean {
        return this.getUseCustomDropAnimation_serialize()
    }
    private setUseCustomDropAnimation(useCustomDropAnimation: boolean): void {
        const useCustomDropAnimation_casted = useCustomDropAnimation as (boolean)
        this.setUseCustomDropAnimation_serialize(useCustomDropAnimation_casted)
        return
    }
    private getGetModifierKeyState(): ModifierKeyStateGetter | undefined {
        // instructive change start
        let returnResult: ModifierKeyStateGetter = (keys: Array<string>) => {
            return ArkUIAniModule._DragEvent_getModifierKeyState(this!.peer!.ptr, keys);
        }
        return returnResult
        // instructive change end
    }
    private setGetModifierKeyState(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const getModifierKeyState_casted = getModifierKeyState as (ModifierKeyStateGetter | undefined)
        this.setGetModifierKeyState_serialize(getModifierKeyState_casted)
        return
    }
    private getDisplayX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getDisplayX(this.peer!.ptr)
        return retval
    }
    private getDisplayY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getDisplayY(this.peer!.ptr)
        return retval
    }
    private getWindowX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getWindowX(this.peer!.ptr)
        return retval
    }
    private getWindowY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getWindowY(this.peer!.ptr)
        return retval
    }
    private setData_serialize(unifiedData: UnifiedData): void {
        ArkUIGeneratedNativeModule._DragEvent_setData(this.peer!.ptr, extractors.toUnifiedDataChannelUnifiedDataPtr(unifiedData))
    }
    private getData_serialize(): UnifiedData | undefined {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getData(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : UnifiedData | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = (unifiedDataChannel_UnifiedData_serializer.read(retvalDeserializer) as unifiedDataChannel.UnifiedData)
        }
        const returnResult : UnifiedData | undefined = buffer
        return returnResult
    }
    private getSummary_serialize(): Summary | undefined {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getSummary(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : Summary | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = (unifiedDataChannel_Summary_serializer.read(retvalDeserializer) as unifiedDataChannel.Summary)
        }
        const returnResult : Summary | undefined = buffer
        return returnResult
    }
    private setResult_serialize(dragResult: DragResult): void {
        ArkUIGeneratedNativeModule._DragEvent_setResult(this.peer!.ptr, dragResult.valueOf())
    }
    private getResult_serialize(): DragResult {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getResult(this.peer!.ptr)
        return DragResult.fromValue(retval)
    }
    private getPreviewRect_serialize(): Rectangle {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getPreviewRect(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : Rectangle = Rectangle_serializer.read(retvalDeserializer)
        return returnResult
    }
    private getVelocityX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getVelocityX(this.peer!.ptr)
        return retval
    }
    private getVelocityY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getVelocityY(this.peer!.ptr)
        return retval
    }
    private getVelocity_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getVelocity(this.peer!.ptr)
        return retval
    }
    private startDataLoading_serialize(options: DataSyncOptions): string | undefined {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        unifiedDataChannel_GetDataParams_serializer.write(thisSerializer, options)
        const retval  = ArkUIGeneratedNativeModule._DragEvent_startDataLoading(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : string | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = (retvalDeserializer.readString() as string)
        }
        const returnResult : string | undefined = buffer
        return returnResult
    }
    private executeDropAnimation_serialize(customDropAnimation: VoidCallback): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.holdAndWriteCallback(customDropAnimation)
        ArkUIGeneratedNativeModule._DragEvent_executeDropAnimation(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private enableInternalDropAnimation_serialize(configuration: string): void {
        ArkUIGeneratedNativeModule._DragEvent_enableInternalDropAnimation(this.peer!.ptr, configuration)
    }
    private getDragBehavior_serialize(): DragBehavior {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getDragBehavior(this.peer!.ptr)
        return DragBehavior.fromValue(retval)
    }
    private setDragBehavior_serialize(dragBehavior: DragBehavior): void {
        ArkUIGeneratedNativeModule._DragEvent_setDragBehavior(this.peer!.ptr, dragBehavior.valueOf())
    }
    private getUseCustomDropAnimation_serialize(): boolean {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getUseCustomDropAnimation(this.peer!.ptr)
        return retval
    }
    private setUseCustomDropAnimation_serialize(useCustomDropAnimation: boolean): void {
        ArkUIGeneratedNativeModule._DragEvent_setUseCustomDropAnimation(this.peer!.ptr, useCustomDropAnimation ? true : false)
    }
    private getGetModifierKeyState_serialize(): ModifierKeyStateGetter | undefined {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getGetModifierKeyState(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : ModifierKeyStateGetter | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            const bufferOptBufResource : CallbackResource = retvalDeserializer.readCallbackResource()
            const bufferOptBufCall : KPointer = retvalDeserializer.readPointer()
            const bufferOptBufCallSync : KPointer = retvalDeserializer.readPointer()
            const bufferOptClosure  = (keys: Array<string>):boolean => {
                const bufferOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                bufferOptBufArgsSerializer.writeInt32(bufferOptBufResource.resourceId);
                bufferOptBufArgsSerializer.writePointer(bufferOptBufCall);
                bufferOptBufArgsSerializer.writePointer(bufferOptBufCallSync);
                bufferOptBufArgsSerializer.writeInt32((keys.length).toInt());
                for (let keysCounterI = 0; keysCounterI < keys.length; keysCounterI++) {
                    const keysTmpElement : string = keys[keysCounterI];
                    bufferOptBufArgsSerializer.writeString(keysTmpElement);
                }
                let bufferOptBufContinuationValue : boolean | undefined;
                const bufferOptBufContinuationCallback : ((isSelected: boolean) => void) = (value: boolean):void => {
                bufferOptBufContinuationValue = value;
            }
                bufferOptBufArgsSerializer.holdAndWriteCallback(bufferOptBufContinuationCallback);
                InteropNativeModule._CallCallbackSync(10, -1142029296, bufferOptBufArgsSerializer.asBuffer(), bufferOptBufArgsSerializer.length());
                bufferOptBufArgsSerializer.release();
                return (bufferOptBufContinuationValue as boolean);
            }
            resourceFinalizerRegister(bufferOptClosure, bufferOptBufResource)
            buffer = bufferOptClosure
        }
        const returnResult : ModifierKeyStateGetter | undefined = buffer
        return returnResult
    }
    private setGetModifierKeyState_serialize(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (getModifierKeyState !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const getModifierKeyStateTmpValue  = getModifierKeyState!
            thisSerializer.holdAndWriteCallback(getModifierKeyStateTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._DragEvent_setGetModifierKeyState(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface KeyEvent {
    type: KeyType
    keyCode: int32
    keyText: string
    keySource: KeySource
    deviceId: int32
    metaKey: int32
    timestamp: int64
    stopPropagation: (() => void)
    intentionCode: IntentionCode
    getModifierKeyState?: ModifierKeyStateGetter | undefined
    unicode?: int64 | undefined
}
export class KeyEventInternal implements MaterializedBase,KeyEvent {
    public peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    public type: KeyType
    public keyCode: int32
    public keyText: string
    public keySource: KeySource
    public deviceId: int32
    public metaKey: int32
    public timestamp: int64
    public stopPropagation: (() => void)
    public intentionCode: IntentionCode
    public getModifierKeyState?: ModifierKeyStateGetter | undefined
    public unicode?: int64 | undefined
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, KeyEventInternal.getFinalizer())
        this.type = this.getType()
        this.keyCode = this.getKeyCode()
        this.keyText = this.getKeyText()
        this.keySource = this.getKeySource()
        this.deviceId = this.getDeviceId()
        this.metaKey = this.getMetaKey()
        this.timestamp = this.getTimestamp()
        this.stopPropagation = this.getStopPropagation()
        this.intentionCode = this.getIntentionCode()
        this.getModifierKeyState = this.getGetModifierKeyState()
        this.unicode = this.getUnicode()
    }
    constructor() {
        this(MaterializedBaseTag.NOP, KeyEventInternal.construct())
        this.type = this.getType()
        this.keyCode = this.getKeyCode()
        this.keyText = this.getKeyText()
        this.keySource = this.getKeySource()
        this.deviceId = this.getDeviceId()
        this.metaKey = this.getMetaKey()
        this.timestamp = this.getTimestamp()
        this.stopPropagation = this.getStopPropagation()
        this.intentionCode = this.getIntentionCode()
        this.getModifierKeyState = this.getGetModifierKeyState()
        this.unicode = this.getUnicode()
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._KeyEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): KeyEventInternal {
        return new KeyEventInternal(MaterializedBaseTag.NOP, ptr)
    }
    private getType(): KeyType {
        return this.getType_serialize()
    }
    private setType(type: KeyType): void {
        const type_casted = type as (KeyType)
        this.setType_serialize(type_casted)
        return
    }
    private getKeyCode(): int32 {
        return this.getKeyCode_serialize()
    }
    private setKeyCode(keyCode: int32): void {
        const keyCode_casted = keyCode as (int32)
        this.setKeyCode_serialize(keyCode_casted)
        return
    }
    private getKeyText(): string {
        return this.getKeyText_serialize()
    }
    private setKeyText(keyText: string): void {
        const keyText_casted = keyText as (string)
        this.setKeyText_serialize(keyText_casted)
        return
    }
    private getKeySource(): KeySource {
        return this.getKeySource_serialize()
    }
    private setKeySource(keySource: KeySource): void {
        const keySource_casted = keySource as (KeySource)
        this.setKeySource_serialize(keySource_casted)
        return
    }
    private getDeviceId(): int32 {
        return this.getDeviceId_serialize()
    }
    private setDeviceId(deviceId: int32): void {
        const deviceId_casted = deviceId as (int32)
        this.setDeviceId_serialize(deviceId_casted)
        return
    }
    private getMetaKey(): int32 {
        return this.getMetaKey_serialize()
    }
    private setMetaKey(metaKey: int32): void {
        const metaKey_casted = metaKey as (int32)
        this.setMetaKey_serialize(metaKey_casted)
        return
    }
    private getTimestamp(): int64 {
        return this.getTimestamp_serialize()
    }
    private setTimestamp(timestamp: int64): void {
        const timestamp_casted = timestamp as (int64)
        this.setTimestamp_serialize(timestamp_casted)
        return
    }
    private getStopPropagation(): (() => void) {
        return this.getStopPropagation_serialize()
    }
    private setStopPropagation(stopPropagation: (() => void)): void {
        const stopPropagation_casted = stopPropagation as ((() => void))
        this.setStopPropagation_serialize(stopPropagation_casted)
        return
    }
    private getIntentionCode(): IntentionCode {
        return this.getIntentionCode_serialize()
    }
    private setIntentionCode(intentionCode: IntentionCode): void {
        const intentionCode_casted = intentionCode as (IntentionCode)
        this.setIntentionCode_serialize(intentionCode_casted)
        return
    }
    private getGetModifierKeyState(): ModifierKeyStateGetter | undefined {
        // instructive change start
        let returnResult: ModifierKeyStateGetter = (keys: Array<string>) => {
            return ArkUIAniModule._KeyEvent_getModifierKeyState(this!.peer!.ptr, keys);
        }
        return returnResult
        // instructive change end
    }
    private setGetModifierKeyState(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const getModifierKeyState_casted = getModifierKeyState as (ModifierKeyStateGetter | undefined)
        this.setGetModifierKeyState_serialize(getModifierKeyState_casted)
        return
    }
    private getUnicode(): int64 | undefined {
        return this.getUnicode_serialize()
    }
    private setUnicode(unicode: int64 | undefined): void {
        const unicode_casted = unicode as (int64 | undefined)
        this.setUnicode_serialize(unicode_casted)
        return
    }
    private getType_serialize(): KeyType {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getType(this.peer!.ptr)
        return KeyType.fromValue(retval)
    }
    private setType_serialize(type: KeyType): void {
        ArkUIGeneratedNativeModule._KeyEvent_setType(this.peer!.ptr, type.valueOf())
    }
    private getKeyCode_serialize(): int32 {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getKeyCode(this.peer!.ptr)
        return retval
    }
    private setKeyCode_serialize(keyCode: int32): void {
        ArkUIGeneratedNativeModule._KeyEvent_setKeyCode(this.peer!.ptr, keyCode)
    }
    private getKeyText_serialize(): string {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getKeyText(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : string = (retvalDeserializer.readString() as string)
        return returnResult
    }
    private setKeyText_serialize(keyText: string): void {
        ArkUIGeneratedNativeModule._KeyEvent_setKeyText(this.peer!.ptr, keyText)
    }
    private getKeySource_serialize(): KeySource {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getKeySource(this.peer!.ptr)
        return KeySource.fromValue(retval)
    }
    private setKeySource_serialize(keySource: KeySource): void {
        ArkUIGeneratedNativeModule._KeyEvent_setKeySource(this.peer!.ptr, keySource.valueOf())
    }
    private getDeviceId_serialize(): int32 {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getDeviceId(this.peer!.ptr)
        return retval
    }
    private setDeviceId_serialize(deviceId: int32): void {
        ArkUIGeneratedNativeModule._KeyEvent_setDeviceId(this.peer!.ptr, deviceId)
    }
    private getMetaKey_serialize(): int32 {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getMetaKey(this.peer!.ptr)
        return retval
    }
    private setMetaKey_serialize(metaKey: int32): void {
        ArkUIGeneratedNativeModule._KeyEvent_setMetaKey(this.peer!.ptr, metaKey)
    }
    private getTimestamp_serialize(): int64 {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getTimestamp(this.peer!.ptr)
        return retval
    }
    private setTimestamp_serialize(timestamp: int64): void {
        ArkUIGeneratedNativeModule._KeyEvent_setTimestamp(this.peer!.ptr, timestamp)
    }
    private getStopPropagation_serialize(): (() => void) {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getStopPropagation(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const bufferBufResource : CallbackResource = retvalDeserializer.readCallbackResource()
        const bufferBufCall : KPointer = retvalDeserializer.readPointer()
        const bufferBufCallSync : KPointer = retvalDeserializer.readPointer()
        const bufferClosure  = ():void => {
            const bufferBufArgsSerializer : SerializerBase = SerializerBase.hold();
            bufferBufArgsSerializer.writeInt32(bufferBufResource.resourceId);
            bufferBufArgsSerializer.writePointer(bufferBufCall);
            bufferBufArgsSerializer.writePointer(bufferBufCallSync);
            InteropNativeModule._CallCallbackSync(10, -1225416436, bufferBufArgsSerializer.asBuffer(), bufferBufArgsSerializer.length());
            bufferBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(bufferClosure, bufferBufResource)
        const returnResult : (() => void) = bufferClosure
        return returnResult
    }
    private setStopPropagation_serialize(stopPropagation: (() => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.holdAndWriteCallback(stopPropagation)
        ArkUIGeneratedNativeModule._KeyEvent_setStopPropagation(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getIntentionCode_serialize(): IntentionCode {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getIntentionCode(this.peer!.ptr)
        return IntentionCode.fromValue(retval)
    }
    private setIntentionCode_serialize(intentionCode: IntentionCode): void {
        ArkUIGeneratedNativeModule._KeyEvent_setIntentionCode(this.peer!.ptr, intentionCode.valueOf())
    }
    private getGetModifierKeyState_serialize(): ModifierKeyStateGetter | undefined {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getGetModifierKeyState(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : ModifierKeyStateGetter | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            const bufferOptBufResource : CallbackResource = retvalDeserializer.readCallbackResource()
            const bufferOptBufCall : KPointer = retvalDeserializer.readPointer()
            const bufferOptBufCallSync : KPointer = retvalDeserializer.readPointer()
            const bufferOptClosure  = (keys: Array<string>):boolean => {
                const bufferOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                bufferOptBufArgsSerializer.writeInt32(bufferOptBufResource.resourceId);
                bufferOptBufArgsSerializer.writePointer(bufferOptBufCall);
                bufferOptBufArgsSerializer.writePointer(bufferOptBufCallSync);
                bufferOptBufArgsSerializer.writeInt32((keys.length).toInt());
                for (let keysCounterI = 0; keysCounterI < keys.length; keysCounterI++) {
                    const keysTmpElement : string = keys[keysCounterI];
                    bufferOptBufArgsSerializer.writeString(keysTmpElement);
                }
                let bufferOptBufContinuationValue : boolean | undefined;
                const bufferOptBufContinuationCallback : ((isSelected: boolean) => void) = (value: boolean):void => {
                bufferOptBufContinuationValue = value;
            }
                bufferOptBufArgsSerializer.holdAndWriteCallback(bufferOptBufContinuationCallback);
                InteropNativeModule._CallCallbackSync(10, -1142029296, bufferOptBufArgsSerializer.asBuffer(), bufferOptBufArgsSerializer.length());
                bufferOptBufArgsSerializer.release();
                return (bufferOptBufContinuationValue as boolean);
            }
            resourceFinalizerRegister(bufferOptClosure, bufferOptBufResource)
            buffer = bufferOptClosure
        }
        const returnResult : ModifierKeyStateGetter | undefined = buffer
        return returnResult
    }
    private setGetModifierKeyState_serialize(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (getModifierKeyState !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const getModifierKeyStateTmpValue  = getModifierKeyState!
            thisSerializer.holdAndWriteCallback(getModifierKeyStateTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._KeyEvent_setGetModifierKeyState(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getUnicode_serialize(): int64 | undefined {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getUnicode(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : int64 | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readInt64()
        }
        const returnResult : int64 | undefined = buffer
        return returnResult
    }
    private setUnicode_serialize(unicode: int64 | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (unicode !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const unicodeTmpValue  = unicode!
            thisSerializer.writeInt64(unicodeTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._KeyEvent_setUnicode(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface Layoutable {
    measureResult: MeasureResult
    uniqueId?: int64 | undefined
    layout(position: Position): void
    getMargin(): DirectionalEdgesT<double> | undefined
    getPadding(): DirectionalEdgesT<double> | undefined
    getBorderWidth(): DirectionalEdgesT<double> | undefined
}
export class LayoutableInternal implements MaterializedBase,Layoutable {
    public peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    public measureResult: MeasureResult
    public uniqueId?: int64 | undefined
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, LayoutableInternal.getFinalizer())
        this.measureResult = this.getMeasureResult()
        this.uniqueId = this.getUniqueId()
    }
    constructor() {
        this(MaterializedBaseTag.NOP, LayoutableInternal.construct())
        this.measureResult = this.getMeasureResult()
        this.uniqueId = this.getUniqueId()
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._Layoutable_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): LayoutableInternal {
        return new LayoutableInternal(MaterializedBaseTag.NOP, ptr)
    }
    public layout(position: Position): void {
        const position_casted = position as (Position)
        this.layout_serialize(position_casted)
        return
    }
    public getMargin(): DirectionalEdgesT<double> | undefined {
        return this.getMargin_serialize()
    }
    public getPadding(): DirectionalEdgesT<double> | undefined {
        return this.getPadding_serialize()
    }
    public getBorderWidth(): DirectionalEdgesT<double> | undefined {
        return this.getBorderWidth_serialize()
    }
    private getMeasureResult(): MeasureResult {
        return this.getMeasureResult_serialize()
    }
    private setMeasureResult(measureResult: MeasureResult): void {
        const measureResult_casted = measureResult as (MeasureResult)
        this.setMeasureResult_serialize(measureResult_casted)
        return
    }
    private getUniqueId(): int64 | undefined {
        return this.getUniqueId_serialize()
    }
    private setUniqueId(uniqueId: int64 | undefined): void {
        const uniqueId_casted = uniqueId as (int64 | undefined)
        this.setUniqueId_serialize(uniqueId_casted)
        return
    }
    private layout_serialize(position: Position): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        Position_serializer.write(thisSerializer, position)
        ArkUIGeneratedNativeModule._Layoutable_layout(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getMargin_serialize(): DirectionalEdgesT<double> | undefined {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_getMargin(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : DirectionalEdgesT<double> | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = DirectionalEdgesT_F64_serializer.read(retvalDeserializer)
        }
        const returnResult : DirectionalEdgesT<double> | undefined = buffer
        return returnResult
    }
    private getPadding_serialize(): DirectionalEdgesT<double> | undefined {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_getPadding(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : DirectionalEdgesT<double> | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = DirectionalEdgesT_F64_serializer.read(retvalDeserializer)
        }
        const returnResult : DirectionalEdgesT<double> | undefined = buffer
        return returnResult
    }
    private getBorderWidth_serialize(): DirectionalEdgesT<double> | undefined {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_getBorderWidth(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : DirectionalEdgesT<double> | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = DirectionalEdgesT_F64_serializer.read(retvalDeserializer)
        }
        const returnResult : DirectionalEdgesT<double> | undefined = buffer
        return returnResult
    }
    private getMeasureResult_serialize(): MeasureResult {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_getMeasureResult(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : MeasureResult = MeasureResult_serializer.read(retvalDeserializer)
        return returnResult
    }
    private setMeasureResult_serialize(measureResult: MeasureResult): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        MeasureResult_serializer.write(thisSerializer, measureResult)
        ArkUIGeneratedNativeModule._Layoutable_setMeasureResult(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getUniqueId_serialize(): int64 | undefined {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_getUniqueId(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : int64 | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readInt64()
        }
        const returnResult : int64 | undefined = buffer
        return returnResult
    }
    private setUniqueId_serialize(uniqueId: int64 | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (uniqueId !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const uniqueIdTmpValue  = uniqueId!
            thisSerializer.writeInt64(uniqueIdTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._Layoutable_setUniqueId(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export class LayoutPolicyInternal {
    public static fromPtr(ptr: KPointer): LayoutPolicy {
        return new LayoutPolicy(MaterializedBaseTag.NOP, ptr)
    }
}
export class LayoutPolicy implements MaterializedBase {
    public peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    public static readonly matchParent: LayoutPolicy = LayoutPolicy.getMatchParent()
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, LayoutPolicy.getFinalizer())
    }
    constructor() {
        this(MaterializedBaseTag.NOP, LayoutPolicy.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._LayoutPolicy_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._LayoutPolicy_getFinalizer()
    }
    private static getMatchParent(): LayoutPolicy {
        return LayoutPolicy.getMatchParent_serialize()
    }
    private static getMatchParent_serialize(): LayoutPolicy {
        const retval  = ArkUIGeneratedNativeModule._LayoutPolicy_getMatchParent()
        const obj : LayoutPolicy = LayoutPolicyInternal.fromPtr(retval)
        return obj
    }
}
export interface Measurable {
    uniqueId?: int64 | undefined
    measure(constraint: ConstraintSizeOptions): MeasureResult | undefined
    getMargin(): DirectionalEdgesT<double> | undefined
    getPadding(): DirectionalEdgesT<double> | undefined
    getBorderWidth(): DirectionalEdgesT<double> | undefined
}
export class MeasurableInternal implements MaterializedBase,Measurable {
    public peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    public uniqueId?: int64 | undefined
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, MeasurableInternal.getFinalizer())
        this.uniqueId = this.getUniqueId()
    }
    constructor() {
        this(MaterializedBaseTag.NOP, MeasurableInternal.construct())
        this.uniqueId = this.getUniqueId()
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._Measurable_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._Measurable_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): MeasurableInternal {
        return new MeasurableInternal(MaterializedBaseTag.NOP, ptr)
    }
    public measure(constraint: ConstraintSizeOptions): MeasureResult | undefined {
        const constraint_casted = constraint as (ConstraintSizeOptions)
        return this.measure_serialize(constraint_casted)
    }
    public getMargin(): DirectionalEdgesT<double> | undefined {
        return this.getMargin_serialize()
    }
    public getPadding(): DirectionalEdgesT<double> | undefined {
        return this.getPadding_serialize()
    }
    public getBorderWidth(): DirectionalEdgesT<double> | undefined {
        return this.getBorderWidth_serialize()
    }
    private getUniqueId(): int64 | undefined {
        return this.getUniqueId_serialize()
    }
    private setUniqueId(uniqueId: int64 | undefined): void {
        const uniqueId_casted = uniqueId as (int64 | undefined)
        this.setUniqueId_serialize(uniqueId_casted)
        return
    }
    private measure_serialize(constraint: ConstraintSizeOptions): MeasureResult | undefined {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        ConstraintSizeOptions_serializer.write(thisSerializer, constraint)
        const retval  = ArkUIGeneratedNativeModule._Measurable_measure(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : MeasureResult | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = MeasureResult_serializer.read(retvalDeserializer)
        }
        const returnResult : MeasureResult | undefined = buffer
        return returnResult
    }
    private getMargin_serialize(): DirectionalEdgesT<double> | undefined {
        const retval  = ArkUIGeneratedNativeModule._Measurable_getMargin(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : DirectionalEdgesT<double> | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = DirectionalEdgesT_F64_serializer.read(retvalDeserializer)
        }
        const returnResult : DirectionalEdgesT<double> | undefined = buffer
        return returnResult
    }
    private getPadding_serialize(): DirectionalEdgesT<double> | undefined {
        const retval  = ArkUIGeneratedNativeModule._Measurable_getPadding(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : DirectionalEdgesT<double> | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = DirectionalEdgesT_F64_serializer.read(retvalDeserializer)
        }
        const returnResult : DirectionalEdgesT<double> | undefined = buffer
        return returnResult
    }
    private getBorderWidth_serialize(): DirectionalEdgesT<double> | undefined {
        const retval  = ArkUIGeneratedNativeModule._Measurable_getBorderWidth(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : DirectionalEdgesT<double> | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = DirectionalEdgesT_F64_serializer.read(retvalDeserializer)
        }
        const returnResult : DirectionalEdgesT<double> | undefined = buffer
        return returnResult
    }
    private getUniqueId_serialize(): int64 | undefined {
        const retval  = ArkUIGeneratedNativeModule._Measurable_getUniqueId(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : int64 | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readInt64()
        }
        const returnResult : int64 | undefined = buffer
        return returnResult
    }
    private setUniqueId_serialize(uniqueId: int64 | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (uniqueId !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const uniqueIdTmpValue  = uniqueId!
            thisSerializer.writeInt64(uniqueIdTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._Measurable_setUniqueId(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface PixelMapMock {
    release(): void
}
export class PixelMapMockInternal implements MaterializedBase,PixelMapMock {
    public peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, PixelMapMockInternal.getFinalizer())
    }
    constructor() {
        this(MaterializedBaseTag.NOP, PixelMapMockInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._PixelMapMock_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._PixelMapMock_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): PixelMapMockInternal {
        return new PixelMapMockInternal(MaterializedBaseTag.NOP, ptr)
    }
    public release(): void {
        this.release_serialize()
        return
    }
    private release_serialize(): void {
        ArkUIGeneratedNativeModule._PixelMapMock_release(this.peer!.ptr)
    }
}
export class ProgressMaskInternal {
    public static fromPtr(ptr: KPointer): ProgressMask {
        return new ProgressMask(MaterializedBaseTag.NOP, ptr)
    }
}
export class ProgressMask implements MaterializedBase {
    public peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, ProgressMask.getFinalizer())
    }
    constructor(value: double, total: double, color: ResourceColor) {
        this(MaterializedBaseTag.NOP, ProgressMask.construct(value, total, color))
    }
    static construct(value: double, total: double, color: ResourceColor): KPointer {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (color instanceof arkui_component_enums_Color) {
            thisSerializer.writeInt8((0).toByte())
            const colorForIdx0  = color as arkui_component_enums_Color
            thisSerializer.writeInt32((colorForIdx0.getOrdinal()) % (12))
        } else if (color instanceof int32) {
            thisSerializer.writeInt8((1).toByte())
            const colorForIdx1  = color as int32
            thisSerializer.writeInt32(colorForIdx1)
        } else if (color instanceof string) {
            thisSerializer.writeInt8((2).toByte())
            const colorForIdx2  = color as string
            thisSerializer.writeString(colorForIdx2)
        } else if (color instanceof arkui_component_units_Resource) {
            thisSerializer.writeInt8((3).toByte())
            const colorForIdx3  = color as arkui_component_units_Resource
            global_resource_Resource_serializer.write(thisSerializer, colorForIdx3)
        }
        const retval  = ArkUIGeneratedNativeModule._ProgressMask_construct(value, total, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._ProgressMask_getFinalizer()
    }
    public updateProgress(value: double): void {
        const value_casted = value as (double)
        this.updateProgress_serialize(value_casted)
        return
    }
    public updateColor(value: ResourceColor): void {
        const value_casted = value as (ResourceColor)
        this.updateColor_serialize(value_casted)
        return
    }
    public enableBreathingAnimation(value: boolean): void {
        const value_casted = value as (boolean)
        this.enableBreathingAnimation_serialize(value_casted)
        return
    }
    private updateProgress_serialize(value: double): void {
        ArkUIGeneratedNativeModule._ProgressMask_updateProgress(this.peer!.ptr, value)
    }
    private updateColor_serialize(value: ResourceColor): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value instanceof arkui_component_enums_Color) {
            thisSerializer.writeInt8((0).toByte())
            const valueForIdx0  = value as arkui_component_enums_Color
            thisSerializer.writeInt32((valueForIdx0.getOrdinal()) % (12))
        } else if (value instanceof int32) {
            thisSerializer.writeInt8((1).toByte())
            const valueForIdx1  = value as int32
            thisSerializer.writeInt32(valueForIdx1)
        } else if (value instanceof string) {
            thisSerializer.writeInt8((2).toByte())
            const valueForIdx2  = value as string
            thisSerializer.writeString(valueForIdx2)
        } else if (value instanceof arkui_component_units_Resource) {
            thisSerializer.writeInt8((3).toByte())
            const valueForIdx3  = value as arkui_component_units_Resource
            global_resource_Resource_serializer.write(thisSerializer, valueForIdx3)
        }
        ArkUIGeneratedNativeModule._ProgressMask_updateColor(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private enableBreathingAnimation_serialize(value: boolean): void {
        ArkUIGeneratedNativeModule._ProgressMask_enableBreathingAnimation(this.peer!.ptr, value ? true : false)
    }
}
export class ScrollResultInternal {
    public static fromPtr(ptr: KPointer): ScrollResult {
        return new ScrollResult(MaterializedBaseTag.NOP, ptr)
    }
}
export class ScrollResult implements MaterializedBase {
    public peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get offsetRemain(): double {
        return this.getOffsetRemain()
    }
    set offsetRemain(offsetRemain: double) {
        this.setOffsetRemain(offsetRemain)
    }
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, ScrollResult.getFinalizer())
    }
    constructor() {
        this(MaterializedBaseTag.NOP, ScrollResult.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._ScrollResult_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._ScrollResult_getFinalizer()
    }
    private getOffsetRemain(): double {
        return this.getOffsetRemain_serialize()
    }
    private setOffsetRemain(offsetRemain: double): void {
        const offsetRemain_casted = offsetRemain as (double)
        this.setOffsetRemain_serialize(offsetRemain_casted)
        return
    }
    private getOffsetRemain_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._ScrollResult_getOffsetRemain(this.peer!.ptr)
        return retval
    }
    private setOffsetRemain_serialize(offsetRemain: double): void {
        ArkUIGeneratedNativeModule._ScrollResult_setOffsetRemain(this.peer!.ptr, offsetRemain)
    }
}
export interface SpringBackAction {
    springBack(): void
}
export class SpringBackActionInternal implements MaterializedBase,SpringBackAction {
    public peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, SpringBackActionInternal.getFinalizer())
    }
    constructor() {
        this(MaterializedBaseTag.NOP, SpringBackActionInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._SpringBackAction_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._SpringBackAction_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): SpringBackActionInternal {
        return new SpringBackActionInternal(MaterializedBaseTag.NOP, ptr)
    }
    public springBack(): void {
        this.springBack_serialize()
        return
    }
    private springBack_serialize(): void {
        ArkUIGeneratedNativeModule._SpringBackAction_springBack(this.peer!.ptr)
    }
}
export class TextContentControllerBaseInternal {
    public static fromPtr(ptr: KPointer): TextContentControllerBase {
        return new TextContentControllerBase(MaterializedBaseTag.NOP, ptr)
    }
}
export class TextContentControllerBase implements MaterializedBase {
    public peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, TextContentControllerBase.getFinalizer())
    }
    constructor() {
        this(MaterializedBaseTag.NOP, TextContentControllerBase.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._TextContentControllerBase_getFinalizer()
    }
    public getCaretOffset(): CaretOffset | undefined {
        return this.getCaretOffset_serialize()
    }
    public getTextContentRect(): RectResult | undefined {
        return this.getTextContentRect_serialize()
    }
    public getTextContentLineCount(): int32 | undefined {
        return this.getTextContentLineCount_serialize()
    }
    public addText(text: string, textOperationOptions?: TextContentControllerOptions): int32 | undefined {
        const text_casted = text as (string)
        const textOperationOptions_casted = textOperationOptions as (TextContentControllerOptions | undefined)
        return this.addText_serialize(text_casted, textOperationOptions_casted)
    }
    public deleteText(range?: TextRange): void {
        const range_casted = range as (TextRange | undefined)
        this.deleteText_serialize(range_casted)
        return
    }
    public getSelection(): TextRange | undefined {
        return this.getSelection_serialize()
    }
    public clearPreviewText(): void {
        this.clearPreviewText_serialize()
        return
    }
    public getText(range?: TextRange): string | undefined {
        const range_casted = range as (TextRange | undefined)
        return this.getText_serialize(range_casted)
    }
    private getCaretOffset_serialize(): CaretOffset | undefined {
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_getCaretOffset(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : CaretOffset | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = CaretOffset_serializer.read(retvalDeserializer)
        }
        const returnResult : CaretOffset | undefined = buffer
        return returnResult
    }
    private getTextContentRect_serialize(): RectResult | undefined {
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_getTextContentRect(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : RectResult | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = RectResult_serializer.read(retvalDeserializer)
        }
        const returnResult : RectResult | undefined = buffer
        return returnResult
    }
    private getTextContentLineCount_serialize(): int32 | undefined {
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_getTextContentLineCount(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : int32 | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readInt32()
        }
        const returnResult : int32 | undefined = buffer
        return returnResult
    }
    private addText_serialize(text: string, textOperationOptions?: TextContentControllerOptions): int32 | undefined {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (textOperationOptions !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const textOperationOptionsTmpValue  = textOperationOptions!
            TextContentControllerOptions_serializer.write(thisSerializer, textOperationOptionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_addText(this.peer!.ptr, text, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : int32 | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readInt32()
        }
        const returnResult : int32 | undefined = buffer
        return returnResult
    }
    private deleteText_serialize(range?: TextRange): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (range !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const rangeTmpValue  = range!
            TextRange_serializer.write(thisSerializer, rangeTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._TextContentControllerBase_deleteText(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getSelection_serialize(): TextRange | undefined {
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_getSelection(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : TextRange | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = TextRange_serializer.read(retvalDeserializer)
        }
        const returnResult : TextRange | undefined = buffer
        return returnResult
    }
    private clearPreviewText_serialize(): void {
        ArkUIGeneratedNativeModule._TextContentControllerBase_clearPreviewText(this.peer!.ptr)
    }
    private getText_serialize(range?: TextRange): string | undefined {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (range !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const rangeTmpValue  = range!
            TextRange_serializer.write(thisSerializer, rangeTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_getText(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : string | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = (retvalDeserializer.readString() as string)
        }
        const returnResult : string | undefined = buffer
        return returnResult
    }
}
export class TransitionEffectInternal {
    public static fromPtr(ptr: KPointer): TransitionEffect {
        return new TransitionEffect(MaterializedBaseTag.NOP, ptr)
    }
}
export class TransitionEffect implements MaterializedBase {
    public peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    static get IDENTITY(): TransitionEffect {
        return TransitionEffect.getIDENTITY()
    }
    static get OPACITY(): TransitionEffect {
        return TransitionEffect.getOPACITY()
    }
    static get SLIDE(): TransitionEffect {
        return TransitionEffect.getSLIDE()
    }
    static get SLIDE_SWITCH(): TransitionEffect {
        return TransitionEffect.getSLIDE_SWITCH()
    }
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, TransitionEffect.getFinalizer())
    }
    constructor(type: string) {
        this(MaterializedBaseTag.NOP, TransitionEffect.construct0(type))
    }
    constructor(effect: double) {
        this(MaterializedBaseTag.NOP, TransitionEffect.construct1(effect))
    }
    constructor(effect: TransitionEdge) {
        this(MaterializedBaseTag.NOP, TransitionEffect.construct2(effect))
    }
    constructor(effect: TranslateOptions) {
        this(MaterializedBaseTag.NOP, TransitionEffect.construct3(effect))
    }
    constructor(effect: RotateOptions) {
        this(MaterializedBaseTag.NOP, TransitionEffect.construct4(effect))
    }
    constructor(effect: ScaleOptions) {
        this(MaterializedBaseTag.NOP, TransitionEffect.construct5(effect))
    }
    constructor(effect: AsymmetricTransitionOption) {
        this(MaterializedBaseTag.NOP, TransitionEffect.construct6(effect))
    }
    static construct0(type: string): KPointer {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct0(type)
        return retval
    }
    static construct1(effect: double): KPointer {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct1(effect)
        return retval
    }
    static construct2(effect: TransitionEdge): KPointer {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct2(effect.valueOf())
        return retval
    }
    static construct3(effect: TranslateOptions): KPointer {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        TranslateOptions_serializer.write(thisSerializer, effect)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct3(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    static construct4(effect: RotateOptions): KPointer {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        RotateOptions_serializer.write(thisSerializer, effect)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct4(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    static construct5(effect: ScaleOptions): KPointer {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        ScaleOptions_serializer.write(thisSerializer, effect)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct5(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    static construct6(effect: AsymmetricTransitionOption): KPointer {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        AsymmetricTransitionOption_serializer.write(thisSerializer, effect)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct6(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._TransitionEffect_getFinalizer()
    }
    public static translate(options: TranslateOptions): TransitionEffect {
        const options_casted = options as (TranslateOptions)
        return TransitionEffect.translate_serialize(options_casted)
    }
    public static rotate(options: RotateOptions): TransitionEffect {
        const options_casted = options as (RotateOptions)
        return TransitionEffect.rotate_serialize(options_casted)
    }
    public static scale(options: ScaleOptions): TransitionEffect {
        const options_casted = options as (ScaleOptions)
        return TransitionEffect.scale_serialize(options_casted)
    }
    public static opacity(alpha: double): TransitionEffect {
        const alpha_casted = alpha as (double)
        return TransitionEffect.opacity_serialize(alpha_casted)
    }
    public static move(edge: TransitionEdge): TransitionEffect {
        const edge_casted = edge as (TransitionEdge)
        return TransitionEffect.move_serialize(edge_casted)
    }
    public static asymmetric(appear: TransitionEffect, disappear: TransitionEffect): TransitionEffect {
        const appear_casted = appear as (TransitionEffect)
        const disappear_casted = disappear as (TransitionEffect)
        return TransitionEffect.asymmetric_serialize(appear_casted, disappear_casted)
    }
    private static getIDENTITY(): TransitionEffect {
        return TransitionEffect.getIDENTITY_serialize()
    }
    private static getOPACITY(): TransitionEffect {
        return TransitionEffect.getOPACITY_serialize()
    }
    private static getSLIDE(): TransitionEffect {
        return TransitionEffect.getSLIDE_serialize()
    }
    private static getSLIDE_SWITCH(): TransitionEffect {
        return TransitionEffect.getSLIDE_SWITCH_serialize()
    }
    private static translate_serialize(options: TranslateOptions): TransitionEffect {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        TranslateOptions_serializer.write(thisSerializer, options)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_translate(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static rotate_serialize(options: RotateOptions): TransitionEffect {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        RotateOptions_serializer.write(thisSerializer, options)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_rotate(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static scale_serialize(options: ScaleOptions): TransitionEffect {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        ScaleOptions_serializer.write(thisSerializer, options)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_scale(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static opacity_serialize(alpha: double): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_opacity(alpha)
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static move_serialize(edge: TransitionEdge): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_move(edge.valueOf())
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static asymmetric_serialize(appear: TransitionEffect, disappear: TransitionEffect): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_asymmetric(toPeerPtr(appear), toPeerPtr(disappear))
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static getIDENTITY_serialize(): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_getIDENTITY()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static getOPACITY_serialize(): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_getOPACITY()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static getSLIDE_serialize(): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_getSLIDE()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static getSLIDE_SWITCH_serialize(): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_getSLIDE_SWITCH()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    public animation(value: AnimateParam): TransitionEffect {
        const value_casted = value as (AnimateParam)
        return this.animation_serialize(value_casted)
    }
    public combine(transitionEffect: TransitionEffect): TransitionEffect {
        const transitionEffect_casted = transitionEffect as (TransitionEffect)
        return this.combine_serialize(transitionEffect_casted)
    }
    private animation_serialize(value: AnimateParam): TransitionEffect {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        AnimateParam_serializer.write(thisSerializer, value)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_animation(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private combine_serialize(transitionEffect: TransitionEffect): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_combine(this.peer!.ptr, toPeerPtr(transitionEffect))
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
}
export interface UICommonEvent {
    setOnClick(callback_: ((event: ClickEvent) => void) | undefined): void
    setOnTouch(callback_: ((event: TouchEvent) => void) | undefined): void
    setOnAppear(callback_: VoidCallback | undefined): void
    setOnDisappear(callback_: VoidCallback | undefined): void
    setOnKeyEvent(callback_: Callback<KeyEvent, void> | undefined): void
    setOnFocus(callback_: VoidCallback | undefined): void
    setOnBlur(callback_: VoidCallback | undefined): void
    setOnHover(callback_: HoverCallback | undefined): void
    setOnMouse(callback_: ((event: MouseEvent) => void) | undefined): void
    setOnSizeChange(callback_: SizeChangeCallback | undefined): void
    setOnVisibleAreaApproximateChange(options: VisibleAreaEventOptions, event: VisibleAreaChangeCallback | undefined): void
}
export class UICommonEventInternal implements MaterializedBase,UICommonEvent {
    public peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, UICommonEventInternal.getFinalizer())
    }
    constructor() {
        this(MaterializedBaseTag.NOP, UICommonEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._UICommonEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._UICommonEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): UICommonEventInternal {
        return new UICommonEventInternal(MaterializedBaseTag.NOP, ptr)
    }
    public setOnClick(callback_: ((event: ClickEvent) => void) | undefined): void {
        const callback__casted = callback_ as (((event: ClickEvent) => void) | undefined)
        this.setOnClick_serialize(callback__casted)
        return
    }
    public setOnTouch(callback_: ((event: TouchEvent) => void) | undefined): void {
        const callback__casted = callback_ as (((event: TouchEvent) => void) | undefined)
        this.setOnTouch_serialize(callback__casted)
        return
    }
    public setOnAppear(callback_: VoidCallback | undefined): void {
        const callback__casted = callback_ as (VoidCallback | undefined)
        this.setOnAppear_serialize(callback__casted)
        return
    }
    public setOnDisappear(callback_: VoidCallback | undefined): void {
        const callback__casted = callback_ as (VoidCallback | undefined)
        this.setOnDisappear_serialize(callback__casted)
        return
    }
    public setOnKeyEvent(callback_: Callback<KeyEvent, void> | undefined): void {
        const callback__casted = callback_ as (Callback<KeyEvent, void> | undefined)
        this.setOnKeyEvent_serialize(callback__casted)
        return
    }
    public setOnFocus(callback_: VoidCallback | undefined): void {
        const callback__casted = callback_ as (VoidCallback | undefined)
        this.setOnFocus_serialize(callback__casted)
        return
    }
    public setOnBlur(callback_: VoidCallback | undefined): void {
        const callback__casted = callback_ as (VoidCallback | undefined)
        this.setOnBlur_serialize(callback__casted)
        return
    }
    public setOnHover(callback_: HoverCallback | undefined): void {
        const callback__casted = callback_ as (HoverCallback | undefined)
        this.setOnHover_serialize(callback__casted)
        return
    }
    public setOnMouse(callback_: ((event: MouseEvent) => void) | undefined): void {
        const callback__casted = callback_ as (((event: MouseEvent) => void) | undefined)
        this.setOnMouse_serialize(callback__casted)
        return
    }
    public setOnSizeChange(callback_: SizeChangeCallback | undefined): void {
        const callback__casted = callback_ as (SizeChangeCallback | undefined)
        this.setOnSizeChange_serialize(callback__casted)
        return
    }
    public setOnVisibleAreaApproximateChange(options: VisibleAreaEventOptions, event: VisibleAreaChangeCallback | undefined): void {
        const options_casted = options as (VisibleAreaEventOptions)
        const event_casted = event as (VisibleAreaChangeCallback | undefined)
        this.setOnVisibleAreaApproximateChange_serialize(options_casted, event_casted)
        return
    }
    private setOnClick_serialize(callback_: ((event: ClickEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnClick(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnTouch_serialize(callback_: ((event: TouchEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnTouch(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnAppear_serialize(callback_: VoidCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnAppear(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnDisappear_serialize(callback_: VoidCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnDisappear(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnKeyEvent_serialize(callback_: Callback<KeyEvent, void> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnKeyEvent(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnFocus_serialize(callback_: VoidCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnFocus(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnBlur_serialize(callback_: VoidCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnBlur(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnHover_serialize(callback_: HoverCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnHover(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnMouse_serialize(callback_: ((event: MouseEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnMouse(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnSizeChange_serialize(callback_: SizeChangeCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnSizeChange(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private setOnVisibleAreaApproximateChange_serialize(options: VisibleAreaEventOptions, event: VisibleAreaChangeCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        VisibleAreaEventOptions_serializer.write(thisSerializer, options)
        if (event !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const eventTmpValue  = event!
            thisSerializer.holdAndWriteCallback(eventTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnVisibleAreaApproximateChange(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export class ArkCommonMethodPeer extends PeerNode {
    attributeSet?: CommonMethodModifier;
    public constructor(peerPtr: KPointer, id: int32, name: string = '', flags: int32 = 0) {
        super(peerPtr, id, name, flags)
    }
    public static create(component?: ComponentBase, flags: int32 = 0): ArkCommonMethodPeer {
        const peerId  = PeerNode.nextId()
        const _peerPtr  = ArkUIGeneratedNativeModule._CommonMethod_construct(peerId, flags)
        const _peer  = new ArkCommonMethodPeer(_peerPtr, peerId, 'CommonMethod', flags)
        component?.setPeer(_peer)
        return _peer
    }
    setWidthAttribute(value: Length | LayoutPolicy | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Length) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Length
                if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx0)
                } else if (valueTmpValueForIdx0 instanceof double) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as double
                    thisSerializer.writeFloat64(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx2)
                }
            } else if (valueTmpValue instanceof LayoutPolicy) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as LayoutPolicy
                LayoutPolicy_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setWidth(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setHeightAttribute(value: Length | LayoutPolicy | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Length) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Length
                if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx0)
                } else if (valueTmpValueForIdx0 instanceof double) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as double
                    thisSerializer.writeFloat64(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx2)
                }
            } else if (valueTmpValue instanceof LayoutPolicy) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as LayoutPolicy
                LayoutPolicy_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setHeight(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setResponseRegionAttribute(value: Array<Rectangle> | Rectangle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Rectangle) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as Rectangle
                Rectangle_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof Array) {
                if (valueTmpValue.length == 0) {
                    thisSerializer.writeInt8((0).toByte())
                    thisSerializer.writeInt32(0)
                } else {
                    const valueTmpValueElem  = valueTmpValue[0]
                    if (valueTmpValueElem instanceof Rectangle) {
                        thisSerializer.writeInt8((0).toByte())
                        const valueTmpValueForIdx0  = valueTmpValue as Array<Rectangle>
                        thisSerializer.writeInt32((valueTmpValueForIdx0.length).toInt())
                        for (let valueTmpValueForIdx0CounterI = 0; valueTmpValueForIdx0CounterI < valueTmpValueForIdx0.length; valueTmpValueForIdx0CounterI++) {
                            const valueTmpValueForIdx0TmpElement : Rectangle = valueTmpValueForIdx0[valueTmpValueForIdx0CounterI]
                            Rectangle_serializer.write(thisSerializer, valueTmpValueForIdx0TmpElement)
                        }
                    }
                }
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setResponseRegion(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMouseResponseRegionAttribute(value: Array<Rectangle> | Rectangle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Rectangle) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as Rectangle
                Rectangle_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof Array) {
                if (valueTmpValue.length == 0) {
                    thisSerializer.writeInt8((0).toByte())
                    thisSerializer.writeInt32(0)
                } else {
                    const valueTmpValueElem  = valueTmpValue[0]
                    if (valueTmpValueElem instanceof Rectangle) {
                        thisSerializer.writeInt8((0).toByte())
                        const valueTmpValueForIdx0  = valueTmpValue as Array<Rectangle>
                        thisSerializer.writeInt32((valueTmpValueForIdx0.length).toInt())
                        for (let valueTmpValueForIdx0CounterI = 0; valueTmpValueForIdx0CounterI < valueTmpValueForIdx0.length; valueTmpValueForIdx0CounterI++) {
                            const valueTmpValueForIdx0TmpElement : Rectangle = valueTmpValueForIdx0[valueTmpValueForIdx0CounterI]
                            Rectangle_serializer.write(thisSerializer, valueTmpValueForIdx0TmpElement)
                        }
                    }
                }
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMouseResponseRegion(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSizeAttribute(value: SizeOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            SizeOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSize(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setConstraintSizeAttribute(value: ConstraintSizeOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            ConstraintSizeOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setConstraintSize(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setHitTestBehaviorAttribute(value: HitTestMode | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as HitTestMode)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setHitTestBehavior(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnChildTouchTestAttribute(value: ((value: Array<TouchTestInfo>) => TouchResult) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnChildTouchTest(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setLayoutWeightAttribute(value: double | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof double) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as double
                thisSerializer.writeFloat64(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setLayoutWeight(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setChainWeightAttribute(value: ChainWeightOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            ChainWeightOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setChainWeight(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setPaddingAttribute(value: Padding | Length | LocalizedPadding | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Padding) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Padding
                Padding_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof Length) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as Length
                if (valueTmpValueForIdx1 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx1ForIdx0  = valueTmpValueForIdx1 as string
                    thisSerializer.writeString(valueTmpValueForIdx1ForIdx0)
                } else if (valueTmpValueForIdx1 instanceof double) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx1ForIdx1  = valueTmpValueForIdx1 as double
                    thisSerializer.writeFloat64(valueTmpValueForIdx1ForIdx1)
                } else if (valueTmpValueForIdx1 instanceof arkui_component_units_Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx1ForIdx2  = valueTmpValueForIdx1 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx1ForIdx2)
                }
            } else if (valueTmpValue instanceof LocalizedPadding) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedPadding
                LocalizedPadding_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setPadding(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSafeAreaPaddingAttribute(value: Padding | arkui_Graphics_LengthMetrics | LocalizedPadding | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Padding) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Padding
                Padding_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof arkui_Graphics_LengthMetrics) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as arkui_Graphics_LengthMetrics
                arkui_Graphics_LengthMetrics_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof LocalizedPadding) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedPadding
                LocalizedPadding_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSafeAreaPadding(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMarginAttribute(value: Margin | Length | LocalizedMargin | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Margin) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Margin
                Padding_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof Length) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as Length
                if (valueTmpValueForIdx1 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx1ForIdx0  = valueTmpValueForIdx1 as string
                    thisSerializer.writeString(valueTmpValueForIdx1ForIdx0)
                } else if (valueTmpValueForIdx1 instanceof double) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx1ForIdx1  = valueTmpValueForIdx1 as double
                    thisSerializer.writeFloat64(valueTmpValueForIdx1ForIdx1)
                } else if (valueTmpValueForIdx1 instanceof arkui_component_units_Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx1ForIdx2  = valueTmpValueForIdx1 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx1ForIdx2)
                }
            } else if (valueTmpValue instanceof LocalizedMargin) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedMargin
                LocalizedPadding_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMargin(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundColorAttribute(value: ResourceColor | arkui_component_units_ColorMetrics | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof ResourceColor) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as ResourceColor
                if (valueTmpValueForIdx0 instanceof arkui_component_enums_Color) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as arkui_component_enums_Color
                    thisSerializer.writeInt32((valueTmpValueForIdx0ForIdx0.getOrdinal()) % (12))
                } else if (valueTmpValueForIdx0 instanceof int32) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as int32
                    thisSerializer.writeInt32(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx2)
                } else if (valueTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    thisSerializer.writeInt8((3).toByte())
                    const valueTmpValueForIdx0ForIdx3  = valueTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx3)
                }
            } else if (valueTmpValue instanceof arkui_component_units_ColorMetrics) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as arkui_component_units_ColorMetrics
                arkui_Graphics_ColorMetrics_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundColor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setPixelRoundAttribute(value: PixelRoundPolicy | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            PixelRoundPolicy_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setPixelRound(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundImage0Attribute(value: arkui_component_units_ResourceStr | PixelMap | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof arkui_component_units_ResourceStr) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as arkui_component_units_ResourceStr
                if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx0)
                } else if (valueTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx1)
                }
            } else if (valueTmpValue instanceof PixelMap) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as PixelMap
                image_PixelMap_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundImage0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundImageSizeAttribute(value: SizeOptions | ImageSize | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof SizeOptions) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as SizeOptions
                SizeOptions_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof ImageSize) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as ImageSize
                thisSerializer.writeInt32(valueTmpValueForIdx1.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundImageSize(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundImagePositionAttribute(value: Position | Alignment | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Position) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Position
                Position_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof Alignment) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as Alignment
                thisSerializer.writeInt32(valueTmpValueForIdx1.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundImagePosition(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundImageResizableAttribute(value: ResizableOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            ResizableOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundImageResizable(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setForegroundEffectAttribute(value: ForegroundEffectOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            ForegroundEffectOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setForegroundEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setVisualEffectAttribute(value: VisualEffect | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            uiEffect_VisualEffect_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setVisualEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundFilterAttribute(value: Filter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            uiEffect_Filter_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundFilter(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setForegroundFilterAttribute(value: Filter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            uiEffect_Filter_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setForegroundFilter(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setCompositingFilterAttribute(value: Filter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            uiEffect_Filter_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setCompositingFilter(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOpacityAttribute(value: double | global_resource_Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof double) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as double
                thisSerializer.writeFloat64(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof global_resource_Resource) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOpacity(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderAttribute(value: BorderOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            BorderOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorder(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderStyleAttribute(value: BorderStyle | EdgeStyles | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof BorderStyle) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as BorderStyle
                thisSerializer.writeInt32(valueTmpValueForIdx0.valueOf())
            } else if (valueTmpValue instanceof EdgeStyles) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as EdgeStyles
                EdgeStyles_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorderStyle(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderWidthAttribute(value: Length | EdgeWidths | LocalizedEdgeWidths | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Length) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Length
                if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx0)
                } else if (valueTmpValueForIdx0 instanceof double) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as double
                    thisSerializer.writeFloat64(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx2)
                }
            } else if (valueTmpValue instanceof EdgeWidths) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as EdgeWidths
                EdgeWidths_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof LocalizedEdgeWidths) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedEdgeWidths
                LocalizedEdgeWidths_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorderWidth(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderColorAttribute(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof ResourceColor) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as ResourceColor
                if (valueTmpValueForIdx0 instanceof arkui_component_enums_Color) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as arkui_component_enums_Color
                    thisSerializer.writeInt32((valueTmpValueForIdx0ForIdx0.getOrdinal()) % (12))
                } else if (valueTmpValueForIdx0 instanceof int32) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as int32
                    thisSerializer.writeInt32(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx2)
                } else if (valueTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    thisSerializer.writeInt8((3).toByte())
                    const valueTmpValueForIdx0ForIdx3  = valueTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx3)
                }
            } else if (valueTmpValue instanceof EdgeColors) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as EdgeColors
                EdgeColors_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof LocalizedEdgeColors) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedEdgeColors
                LocalizedEdgeColors_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorderColor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderRadiusAttribute(value: Length | BorderRadiuses | LocalizedBorderRadiuses | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Length) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Length
                if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx0)
                } else if (valueTmpValueForIdx0 instanceof double) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as double
                    thisSerializer.writeFloat64(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx2)
                }
            } else if (valueTmpValue instanceof BorderRadiuses) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as BorderRadiuses
                BorderRadiuses_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof LocalizedBorderRadiuses) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorderRadius(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderImageAttribute(value: BorderImageOption | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            BorderImageOption_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorderImage(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOutlineAttribute(value: OutlineOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            OutlineOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOutline(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOutlineStyleAttribute(value: OutlineStyle | EdgeOutlineStyles | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof OutlineStyle) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as OutlineStyle
                thisSerializer.writeInt32(valueTmpValueForIdx0.valueOf())
            } else if (valueTmpValue instanceof EdgeOutlineStyles) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as EdgeOutlineStyles
                EdgeOutlineStyles_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOutlineStyle(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOutlineWidthAttribute(value: Dimension | EdgeOutlineWidths | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Dimension) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Dimension
                if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx0)
                } else if (valueTmpValueForIdx0 instanceof number) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as number
                    thisSerializer.writeNumber(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof global_resource_Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as global_resource_Resource
                    global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx2)
                }
            } else if (valueTmpValue instanceof EdgeOutlineWidths) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as EdgeOutlineWidths
                EdgeOutlineWidths_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOutlineWidth(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOutlineColorAttribute(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof ResourceColor) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as ResourceColor
                if (valueTmpValueForIdx0 instanceof arkui_component_enums_Color) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as arkui_component_enums_Color
                    thisSerializer.writeInt32((valueTmpValueForIdx0ForIdx0.getOrdinal()) % (12))
                } else if (valueTmpValueForIdx0 instanceof int32) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as int32
                    thisSerializer.writeInt32(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx2)
                } else if (valueTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    thisSerializer.writeInt8((3).toByte())
                    const valueTmpValueForIdx0ForIdx3  = valueTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx3)
                }
            } else if (valueTmpValue instanceof EdgeColors) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as EdgeColors
                EdgeColors_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof LocalizedEdgeColors) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedEdgeColors
                LocalizedEdgeColors_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOutlineColor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOutlineRadiusAttribute(value: Dimension | OutlineRadiuses | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Dimension) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Dimension
                if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx0)
                } else if (valueTmpValueForIdx0 instanceof number) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as number
                    thisSerializer.writeNumber(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof global_resource_Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as global_resource_Resource
                    global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx2)
                }
            } else if (valueTmpValue instanceof OutlineRadiuses) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as OutlineRadiuses
                OutlineRadiuses_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOutlineRadius(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setForegroundColorAttribute(value: ResourceColor | ColoringStrategy | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof ResourceColor) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as ResourceColor
                if (valueTmpValueForIdx0 instanceof arkui_component_enums_Color) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as arkui_component_enums_Color
                    thisSerializer.writeInt32((valueTmpValueForIdx0ForIdx0.getOrdinal()) % (12))
                } else if (valueTmpValueForIdx0 instanceof int32) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as int32
                    thisSerializer.writeInt32(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx2)
                } else if (valueTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    thisSerializer.writeInt8((3).toByte())
                    const valueTmpValueForIdx0ForIdx3  = valueTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx3)
                }
            } else if (valueTmpValue instanceof ColoringStrategy) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as ColoringStrategy
                thisSerializer.writeInt32(valueTmpValueForIdx1.getOrdinal())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setForegroundColor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnClick0Attribute(value: ((event: ClickEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnClick0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnHoverAttribute(value: ((isHover: boolean,event: HoverEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnHover(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnHoverMoveAttribute(value: Callback<HoverEvent, void> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnHoverMove(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAccessibilityHoverAttribute(value: AccessibilityCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAccessibilityHover(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAccessibilityHoverTransparentAttribute(value: AccessibilityTransparentCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAccessibilityHoverTransparent(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setHoverEffectAttribute(value: HoverEffect | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as HoverEffect)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setHoverEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnMouseAttribute(value: ((event: MouseEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnMouse(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnTouchAttribute(value: ((event: TouchEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnTouch(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnKeyEventAttribute(value: Callback<KeyEvent, boolean> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnKeyEvent(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDigitalCrownAttribute(value: Callback<CrownEvent, void> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDigitalCrown(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnKeyPreImeAttribute(value: Callback<KeyEvent, boolean> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnKeyPreIme(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnKeyEventDispatchAttribute(value: Callback<KeyEvent, boolean> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnKeyEventDispatch(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnFocusAxisEventAttribute(value: Callback<FocusAxisEvent, void> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnFocusAxisEvent(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAxisEventAttribute(value: Callback<AxisEvent, void> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAxisEvent(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFocusableAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFocusable(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setNextFocusAttribute(value: FocusMovement | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            FocusMovement_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setNextFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTabStopAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTabStop(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnFocusAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnBlurAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnBlur(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTabIndexAttribute(value: int32 | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeInt32(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTabIndex(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDefaultFocusAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDefaultFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setGroupDefaultFocusAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setGroupDefaultFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFocusOnTouchAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFocusOnTouch(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFocusBoxAttribute(value: FocusBoxStyle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            FocusBoxStyle_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFocusBox(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAnimationAttribute(value: AnimateParam | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            AnimateParam_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAnimation(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTransition0Attribute(value: TransitionEffect | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            TransitionEffect_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTransition0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMotionBlurAttribute(value: MotionBlurOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            MotionBlurOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMotionBlur(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBrightnessAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBrightness(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setContrastAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setContrast(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setGrayscaleAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setGrayscale(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setColorBlendAttribute(value: arkui_component_enums_Color | string | global_resource_Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof arkui_component_enums_Color) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as arkui_component_enums_Color
                thisSerializer.writeInt32((valueTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof global_resource_Resource) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setColorBlend(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSaturateAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSaturate(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSepiaAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSepia(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setInvertAttribute(value: double | InvertOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof double) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as double
                thisSerializer.writeFloat64(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof InvertOptions) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as InvertOptions
                InvertOptions_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setInvert(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setHueRotateAttribute(value: double | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof double) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as double
                thisSerializer.writeFloat64(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setHueRotate(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setUseShadowBatchingAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setUseShadowBatching(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setUseEffect0Attribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setUseEffect0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setRenderGroupAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setRenderGroup(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFreezeAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFreeze(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTranslateAttribute(value: TranslateOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            TranslateOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTranslate(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setScaleAttribute(value: ScaleOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            ScaleOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setScale(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setRotateAttribute(value: RotateOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            RotateOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setRotate(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTransformAttribute(value: Matrix4Transit | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            matrix4_Matrix4Transit_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTransform(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAppearAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAppear(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDisAppearAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDisAppear(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAttachAttribute(value: VoidCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAttach(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDetachAttribute(value: VoidCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDetach(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAreaChangeAttribute(value: ((oldValue: Area,newValue: Area) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAreaChange(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setVisibilityAttribute(value: Visibility | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as Visibility)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setVisibility(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFlexGrowAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFlexGrow(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFlexShrinkAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFlexShrink(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFlexBasisAttribute(value: double | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof double) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as double
                thisSerializer.writeFloat64(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFlexBasis(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAlignSelfAttribute(value: ItemAlign | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as ItemAlign)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAlignSelf(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDisplayPriorityAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDisplayPriority(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setZIndexAttribute(value: int32 | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeInt32(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setZIndex(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDirectionAttribute(value: Direction | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as Direction)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDirection(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAlignAttribute(value: Alignment | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as Alignment)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAlign(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setPositionAttribute(value: Position | Edges | LocalizedEdges | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Position) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Position
                Position_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof Edges) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as Edges
                Edges_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof LocalizedEdges) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedEdges
                LocalizedEdges_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setPosition(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMarkAnchorAttribute(value: Position | LocalizedPosition | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Position) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Position
                Position_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof LocalizedPosition) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as LocalizedPosition
                LocalizedPosition_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMarkAnchor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOffsetAttribute(value: Position | Edges | LocalizedEdges | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Position) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Position
                Position_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof Edges) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as Edges
                Edges_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof LocalizedEdges) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedEdges
                LocalizedEdges_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOffset(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setEnabledAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setEnabled(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAlignRulesAttribute(value: AlignRuleOption | LocalizedAlignRuleOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof AlignRuleOption) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as AlignRuleOption
                AlignRuleOption_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof LocalizedAlignRuleOptions) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as LocalizedAlignRuleOptions
                LocalizedAlignRuleOptions_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAlignRules(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAspectRatioAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAspectRatio(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setClickEffectAttribute(value: ClickEffect | null | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined && value !== null) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            ClickEffect_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setClickEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDragStartAttribute(value: ((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDragStart(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDragEnterAttribute(value: ((event: DragEvent,extraParams?: string) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDragEnter(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDragMoveAttribute(value: ((event: DragEvent,extraParams?: string) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDragMove(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDragLeaveAttribute(value: ((event: DragEvent,extraParams?: string) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDragLeave(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDrop0Attribute(value: ((event: DragEvent,extraParams?: string) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDrop0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDragEndAttribute(value: ((event: DragEvent,extraParams?: string) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDragEnd(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDraggableAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDraggable(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnPreDragAttribute(value: Callback<PreDragStatus, void> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnPreDrag(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setLinearGradientAttribute(value: LinearGradientOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            LinearGradientOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setLinearGradient(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSweepGradientAttribute(value: SweepGradientOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            SweepGradientOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSweepGradient(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setRadialGradientAttribute(value: RadialGradientOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            RadialGradientOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setRadialGradient(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMotionPathAttribute(value: MotionPathOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            MotionPathOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMotionPath(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setShadowAttribute(value: ShadowOptions | ShadowStyle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof ShadowOptions) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as ShadowOptions
                ShadowOptions_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof ShadowStyle) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as ShadowStyle
                thisSerializer.writeInt32(valueTmpValueForIdx1.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setShadow(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setClipAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setClip(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setClipShapeAttribute(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof CircleShape) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as CircleShape
                CircleShape_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof EllipseShape) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as EllipseShape
                EllipseShape_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof PathShape) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as PathShape
                PathShape_serializer.write(thisSerializer, valueTmpValueForIdx2)
            } else if (valueTmpValue instanceof RectShape) {
                thisSerializer.writeInt8((3).toByte())
                const valueTmpValueForIdx3  = valueTmpValue as RectShape
                RectShape_serializer.write(thisSerializer, valueTmpValueForIdx3)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setClipShape(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMaskAttribute(value: ProgressMask | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            ProgressMask_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMask(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMaskShapeAttribute(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof CircleShape) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as CircleShape
                CircleShape_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof EllipseShape) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as EllipseShape
                EllipseShape_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof PathShape) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as PathShape
                PathShape_serializer.write(thisSerializer, valueTmpValueForIdx2)
            } else if (valueTmpValue instanceof RectShape) {
                thisSerializer.writeInt8((3).toByte())
                const valueTmpValueForIdx3  = valueTmpValue as RectShape
                RectShape_serializer.write(thisSerializer, valueTmpValueForIdx3)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMaskShape(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setKeyAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeString(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setKey(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setIdAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeString(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setId(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setRestoreIdAttribute(value: int32 | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeInt32(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setRestoreId(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSphericalEffectAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSphericalEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setLightUpEffectAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setLightUpEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setPixelStretchEffectAttribute(value: PixelStretchEffectOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            PixelStretchEffectOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setPixelStretchEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityNextFocusIdAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeString(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityNextFocusId(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityDefaultFocusAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityDefaultFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityUseSamePageAttribute(value: AccessibilitySamePageMode | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as AccessibilitySamePageMode)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityUseSamePage(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityScrollTriggerableAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityScrollTriggerable(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityTextAttribute(value: global_resource_Resource | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof global_resource_Resource) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityText(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityRoleAttribute(value: AccessibilityRoleType | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as AccessibilityRoleType)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityRole(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAccessibilityFocusAttribute(value: AccessibilityFocusCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAccessibilityFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAccessibilityActionInterceptAttribute(value: AccessibilityActionInterceptCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAccessibilityActionIntercept(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityTextHintAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeString(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityTextHint(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityDescriptionAttribute(value: global_resource_Resource | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof global_resource_Resource) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityDescription(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityLevelAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeString(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityLevel(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityVirtualNodeAttribute(value: CustomBuilder | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(valueTmpValue))
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityVirtualNode(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityCheckedAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityChecked(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilitySelectedAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilitySelected(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setObscuredAttribute(value: Array<ObscuredReasons> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeInt32((valueTmpValue.length).toInt())
            for (let valueTmpValueCounterI = 0; valueTmpValueCounterI < valueTmpValue.length; valueTmpValueCounterI++) {
                const valueTmpValueTmpElement : ObscuredReasons = valueTmpValue[valueTmpValueCounterI]
                thisSerializer.writeInt32(valueTmpValueTmpElement.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setObscured(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setReuseIdAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeString(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setReuseId(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setReuseAttribute(value: ReuseOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            ReuseOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setReuse(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setRenderFitAttribute(value: RenderFit | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as RenderFit)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setRenderFit(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundBrightnessAttribute(value: BackgroundBrightnessOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            BackgroundBrightnessOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundBrightness(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnGestureJudgeBeginAttribute(value: ((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnGestureJudgeBegin(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnGestureRecognizerJudgeBegin0Attribute(value: GestureRecognizerJudgeBeginCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnGestureRecognizerJudgeBegin0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setShouldBuiltInRecognizerParallelWithAttribute(value: ShouldBuiltInRecognizerParallelWithCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setShouldBuiltInRecognizerParallelWith(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMonopolizeEventsAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMonopolizeEvents(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnTouchInterceptAttribute(value: Callback<TouchEvent, HitTestMode> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnTouchIntercept(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnSizeChangeAttribute(value: SizeChangeCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnSizeChange(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityFocusDrawLevelAttribute(value: FocusDrawLevel | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as FocusDrawLevel)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityFocusDrawLevel(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnTouchTestDoneAttribute(value: TouchTestDoneCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnTouchTestDone(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setExpandSafeAreaAttribute(types?: Array<SafeAreaType>, edges?: Array<SafeAreaEdge>): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (types !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const typesTmpValue  = types!
            thisSerializer.writeInt32((typesTmpValue.length).toInt())
            for (let typesTmpValueCounterI = 0; typesTmpValueCounterI < typesTmpValue.length; typesTmpValueCounterI++) {
                const typesTmpValueTmpElement : SafeAreaType = typesTmpValue[typesTmpValueCounterI]
                thisSerializer.writeInt32(typesTmpValueTmpElement.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (edges !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const edgesTmpValue  = edges!
            thisSerializer.writeInt32((edgesTmpValue.length).toInt())
            for (let edgesTmpValueCounterI = 0; edgesTmpValueCounterI < edgesTmpValue.length; edgesTmpValueCounterI++) {
                const edgesTmpValueTmpElement : SafeAreaEdge = edgesTmpValue[edgesTmpValueCounterI]
                thisSerializer.writeInt32(edgesTmpValueTmpElement.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setExpandSafeArea(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundAttribute(builder: CustomBuilder | undefined, options?: BackgroundOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (builder !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const builderTmpValue  = builder!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(builderTmpValue))
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            BackgroundOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackground(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundImage1Attribute(src: arkui_component_units_ResourceStr | PixelMap | undefined, options: BackgroundImageOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (src !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const srcTmpValue  = src!
            if (srcTmpValue instanceof arkui_component_units_ResourceStr) {
                thisSerializer.writeInt8((0).toByte())
                const srcTmpValueForIdx0  = srcTmpValue as arkui_component_units_ResourceStr
                if (srcTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const srcTmpValueForIdx0ForIdx0  = srcTmpValueForIdx0 as string
                    thisSerializer.writeString(srcTmpValueForIdx0ForIdx0)
                } else if (srcTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    thisSerializer.writeInt8((1).toByte())
                    const srcTmpValueForIdx0ForIdx1  = srcTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(thisSerializer, srcTmpValueForIdx0ForIdx1)
                }
            } else if (srcTmpValue instanceof PixelMap) {
                thisSerializer.writeInt8((1).toByte())
                const srcTmpValueForIdx1  = srcTmpValue as PixelMap
                image_PixelMap_serializer.write(thisSerializer, srcTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        BackgroundImageOptions_serializer.write(thisSerializer, options)
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundImage1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundImage2Attribute(src: arkui_component_units_ResourceStr | PixelMap | undefined, repeat: ImageRepeat): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (src !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const srcTmpValue  = src!
            if (srcTmpValue instanceof arkui_component_units_ResourceStr) {
                thisSerializer.writeInt8((0).toByte())
                const srcTmpValueForIdx0  = srcTmpValue as arkui_component_units_ResourceStr
                if (srcTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const srcTmpValueForIdx0ForIdx0  = srcTmpValueForIdx0 as string
                    thisSerializer.writeString(srcTmpValueForIdx0ForIdx0)
                } else if (srcTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    thisSerializer.writeInt8((1).toByte())
                    const srcTmpValueForIdx0ForIdx1  = srcTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(thisSerializer, srcTmpValueForIdx0ForIdx1)
                }
            } else if (srcTmpValue instanceof PixelMap) {
                thisSerializer.writeInt8((1).toByte())
                const srcTmpValueForIdx1  = srcTmpValue as PixelMap
                image_PixelMap_serializer.write(thisSerializer, srcTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundImage2(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length(), repeat.valueOf())
        thisSerializer.release()
    }
    setBackgroundBlurStyleAttribute(style: BlurStyle | undefined, options?: BackgroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (style !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const styleTmpValue  = (style as BlurStyle)
            thisSerializer.writeInt32(styleTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            BackgroundBlurStyleOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (sysOptions !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const sysOptionsTmpValue  = sysOptions!
            SystemAdaptiveOptions_serializer.write(thisSerializer, sysOptionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundBlurStyle(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundEffectAttribute(options: BackgroundEffectOptions | undefined, sysOptions?: SystemAdaptiveOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            BackgroundEffectOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (sysOptions !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const sysOptionsTmpValue  = sysOptions!
            SystemAdaptiveOptions_serializer.write(thisSerializer, sysOptionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setForegroundBlurStyleAttribute(style: BlurStyle | undefined, options?: ForegroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (style !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const styleTmpValue  = (style as BlurStyle)
            thisSerializer.writeInt32(styleTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            ForegroundBlurStyleOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (sysOptions !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const sysOptionsTmpValue  = sysOptions!
            SystemAdaptiveOptions_serializer.write(thisSerializer, sysOptionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setForegroundBlurStyle(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnClick1Attribute(event: ((event: ClickEvent) => void) | undefined, distanceThreshold: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (event !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const eventTmpValue  = event!
            thisSerializer.holdAndWriteCallback(eventTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (distanceThreshold !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const distanceThresholdTmpValue  = distanceThreshold!
            thisSerializer.writeFloat64(distanceThresholdTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnClick1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFocusScopeIdAttribute(id: string | undefined, isGroup?: boolean, arrowStepOut?: boolean): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (id !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const idTmpValue  = id!
            thisSerializer.writeString(idTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (isGroup !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const isGroupTmpValue  = isGroup!
            thisSerializer.writeBoolean(isGroupTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (arrowStepOut !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const arrowStepOutTmpValue  = arrowStepOut!
            thisSerializer.writeBoolean(arrowStepOutTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFocusScopeId(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFocusScopePriorityAttribute(scopeId: string | undefined, priority?: FocusPriority): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (scopeId !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const scopeIdTmpValue  = scopeId!
            thisSerializer.writeString(scopeIdTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (priority !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const priorityTmpValue  = (priority as FocusPriority)
            thisSerializer.writeInt32(priorityTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFocusScopePriority(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTransition1Attribute(effect: TransitionEffect | undefined, onFinish: TransitionFinishCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (effect !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const effectTmpValue  = effect!
            TransitionEffect_serializer.write(thisSerializer, effectTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (onFinish !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const onFinishTmpValue  = onFinish!
            thisSerializer.holdAndWriteCallback(onFinishTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTransition1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBlurAttribute(blurRadius: double | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (blurRadius !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const blurRadiusTmpValue  = blurRadius!
            thisSerializer.writeFloat64(blurRadiusTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            BlurOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (sysOptions !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const sysOptionsTmpValue  = sysOptions!
            SystemAdaptiveOptions_serializer.write(thisSerializer, sysOptionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBlur(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setLinearGradientBlurAttribute(value: double | undefined, options: LinearGradientBlurOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            LinearGradientBlurOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setLinearGradientBlur(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSystemBarEffectAttribute(): void {
        ArkUIGeneratedNativeModule._CommonMethod_setSystemBarEffect(this.peer.ptr)
    }
    setUseEffect1Attribute(useEffect: boolean | undefined, effectType: EffectType | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (useEffect !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const useEffectTmpValue  = useEffect!
            thisSerializer.writeBoolean(useEffectTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (effectType !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const effectTypeTmpValue  = (effectType as EffectType)
            thisSerializer.writeInt32(effectTypeTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setUseEffect1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackdropBlurAttribute(radius: double | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (radius !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const radiusTmpValue  = radius!
            thisSerializer.writeFloat64(radiusTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            BlurOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (sysOptions !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const sysOptionsTmpValue  = sysOptions!
            SystemAdaptiveOptions_serializer.write(thisSerializer, sysOptionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackdropBlur(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSharedTransitionAttribute(id: string | undefined, options?: sharedTransitionOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (id !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const idTmpValue  = id!
            thisSerializer.writeString(idTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            sharedTransitionOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSharedTransition(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setChainModeAttribute(direction: Axis | undefined, style: ChainStyle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (direction !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const directionTmpValue  = (direction as Axis)
            thisSerializer.writeInt32(directionTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (style !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const styleTmpValue  = (style as ChainStyle)
            thisSerializer.writeInt32(styleTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setChainMode(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDrop1Attribute(eventCallback: OnDragEventCallback | undefined, dropOptions: DropOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (eventCallback !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const eventCallbackTmpValue  = eventCallback!
            thisSerializer.holdAndWriteCallback(eventCallbackTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        DropOptions_serializer.write(thisSerializer, dropOptions)
        ArkUIGeneratedNativeModule._CommonMethod_setOnDrop1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDragPreviewAttribute(preview: CustomBuilder | DragItemInfo | string | undefined, config?: PreviewConfiguration): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (preview !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const previewTmpValue  = preview!
            if (previewTmpValue instanceof CustomBuilder) {
                thisSerializer.writeInt8((0).toByte())
                const previewTmpValueForIdx0  = previewTmpValue as CustomBuilder
                thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(previewTmpValueForIdx0))
            } else if (previewTmpValue instanceof DragItemInfo) {
                thisSerializer.writeInt8((1).toByte())
                const previewTmpValueForIdx1  = previewTmpValue as DragItemInfo
                DragItemInfo_serializer.write(thisSerializer, previewTmpValueForIdx1)
            } else if (previewTmpValue instanceof string) {
                thisSerializer.writeInt8((2).toByte())
                const previewTmpValueForIdx2  = previewTmpValue as string
                thisSerializer.writeString(previewTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (config !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const configTmpValue  = config!
            PreviewConfiguration_serializer.write(thisSerializer, configTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDragPreview(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOverlayAttribute(value: string | CustomBuilder | ComponentContent<Object> | undefined, options?: OverlayOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof CustomBuilder) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as CustomBuilder
                thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(valueTmpValueForIdx1))
            } else if (valueTmpValue instanceof ComponentContent) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as ComponentContent
                ComponentContent_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            OverlayOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOverlay(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBlendModeAttribute(value: BlendMode | undefined, type?: BlendApplyType): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as BlendMode)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (type !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const typeTmpValue  = (type as BlendApplyType)
            thisSerializer.writeInt32(typeTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBlendMode(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAdvancedBlendModeAttribute(effect: BlendMode | Blender | undefined, type?: BlendApplyType): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (effect !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const effectTmpValue  = effect!
            if (effectTmpValue instanceof BlendMode) {
                thisSerializer.writeInt8((0).toByte())
                const effectTmpValueForIdx0  = effectTmpValue as BlendMode
                thisSerializer.writeInt32(effectTmpValueForIdx0.valueOf())
            } else if (effectTmpValue instanceof Blender) {
                thisSerializer.writeInt8((1).toByte())
                const effectTmpValueForIdx1  = effectTmpValue as Blender
                uiEffect_BrightnessBlender_serializer.write(thisSerializer, effectTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (type !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const typeTmpValue  = (type as BlendApplyType)
            thisSerializer.writeInt32(typeTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAdvancedBlendMode(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setGeometryTransitionAttribute(id: string | undefined, options?: GeometryTransitionOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (id !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const idTmpValue  = id!
            thisSerializer.writeString(idTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            GeometryTransitionOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setGeometryTransition(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindTipsAttribute(message: TipsMessageType | undefined, options?: TipsOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (message !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const messageTmpValue  = message!
            if (messageTmpValue instanceof arkui_component_units_ResourceStr) {
                thisSerializer.writeInt8((0).toByte())
                const messageTmpValueForIdx0  = messageTmpValue as arkui_component_units_ResourceStr
                if (messageTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const messageTmpValueForIdx0ForIdx0  = messageTmpValueForIdx0 as string
                    thisSerializer.writeString(messageTmpValueForIdx0ForIdx0)
                } else if (messageTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    thisSerializer.writeInt8((1).toByte())
                    const messageTmpValueForIdx0ForIdx1  = messageTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(thisSerializer, messageTmpValueForIdx0ForIdx1)
                }
            } else if (messageTmpValue instanceof StyledString) {
                thisSerializer.writeInt8((1).toByte())
                const messageTmpValueForIdx1  = messageTmpValue as StyledString
                StyledString_serializer.write(thisSerializer, messageTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            TipsOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindTips(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindPopupAttribute(show: boolean | undefined, popup: PopupOptions | CustomPopupOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (show !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const showTmpValue  = show!
            thisSerializer.writeBoolean(showTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (popup !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const popupTmpValue  = popup!
            if (popupTmpValue instanceof PopupOptions) {
                thisSerializer.writeInt8((0).toByte())
                const popupTmpValueForIdx0  = popupTmpValue as PopupOptions
                PopupOptions_serializer.write(thisSerializer, popupTmpValueForIdx0)
            } else if (popupTmpValue instanceof CustomPopupOptions) {
                thisSerializer.writeInt8((1).toByte())
                const popupTmpValueForIdx1  = popupTmpValue as CustomPopupOptions
                CustomPopupOptions_serializer.write(thisSerializer, popupTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindPopup(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindMenu0Attribute(content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (content !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const contentTmpValue  = content!
            if (contentTmpValue instanceof CustomBuilder) {
                thisSerializer.writeInt8((1).toByte())
                const contentTmpValueForIdx1  = contentTmpValue as CustomBuilder
                thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(contentTmpValueForIdx1))
            } else if (contentTmpValue instanceof Array) {
                if (contentTmpValue.length == 0) {
                    thisSerializer.writeInt8((0).toByte())
                    thisSerializer.writeInt32(0)
                } else {
                    const contentTmpValueElem  = contentTmpValue[0]
                    if (contentTmpValueElem instanceof MenuElement) {
                        thisSerializer.writeInt8((0).toByte())
                        const contentTmpValueForIdx0  = contentTmpValue as Array<MenuElement>
                        thisSerializer.writeInt32((contentTmpValueForIdx0.length).toInt())
                        for (let contentTmpValueForIdx0CounterI = 0; contentTmpValueForIdx0CounterI < contentTmpValueForIdx0.length; contentTmpValueForIdx0CounterI++) {
                            const contentTmpValueForIdx0TmpElement : MenuElement = contentTmpValueForIdx0[contentTmpValueForIdx0CounterI]
                            MenuElement_serializer.write(thisSerializer, contentTmpValueForIdx0TmpElement)
                        }
                    }
                }
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            MenuOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindMenu0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindMenu1Attribute(isShow: boolean | undefined, content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (isShow !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const isShowTmpValue  = isShow!
            thisSerializer.writeBoolean(isShowTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (content !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const contentTmpValue  = content!
            if (contentTmpValue instanceof CustomBuilder) {
                thisSerializer.writeInt8((1).toByte())
                const contentTmpValueForIdx1  = contentTmpValue as CustomBuilder
                thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(contentTmpValueForIdx1))
            } else if (contentTmpValue instanceof Array) {
                if (contentTmpValue.length == 0) {
                    thisSerializer.writeInt8((0).toByte())
                    thisSerializer.writeInt32(0)
                } else {
                    const contentTmpValueElem  = contentTmpValue[0]
                    if (contentTmpValueElem instanceof MenuElement) {
                        thisSerializer.writeInt8((0).toByte())
                        const contentTmpValueForIdx0  = contentTmpValue as Array<MenuElement>
                        thisSerializer.writeInt32((contentTmpValueForIdx0.length).toInt())
                        for (let contentTmpValueForIdx0CounterI = 0; contentTmpValueForIdx0CounterI < contentTmpValueForIdx0.length; contentTmpValueForIdx0CounterI++) {
                            const contentTmpValueForIdx0TmpElement : MenuElement = contentTmpValueForIdx0[contentTmpValueForIdx0CounterI]
                            MenuElement_serializer.write(thisSerializer, contentTmpValueForIdx0TmpElement)
                        }
                    }
                }
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            MenuOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindMenu1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindContextMenu0Attribute(content: CustomBuilder | undefined, responseType: ResponseType | undefined, options?: ContextMenuOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (content !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const contentTmpValue  = content!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(contentTmpValue))
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (responseType !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const responseTypeTmpValue  = (responseType as ResponseType)
            thisSerializer.writeInt32(responseTypeTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            ContextMenuOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindContextMenu0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindContextMenu1Attribute(isShown: boolean | undefined, content: CustomBuilder | undefined, options?: ContextMenuOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (isShown !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const isShownTmpValue  = isShown!
            thisSerializer.writeBoolean(isShownTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (content !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const contentTmpValue  = content!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(contentTmpValue))
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            ContextMenuOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindContextMenu1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindContentCover0Attribute(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, type?: ModalTransition): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (isShow !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const isShowTmpValue  = isShow!
            if (isShowTmpValue instanceof boolean) {
                thisSerializer.writeInt8((0).toByte())
                const isShowTmpValueForIdx0  = isShowTmpValue as boolean
                thisSerializer.writeBoolean(isShowTmpValueForIdx0)
            } else if (isShowTmpValue instanceof Bindable) {
                thisSerializer.writeInt8((1).toByte())
                const isShowTmpValueForIdx1  = isShowTmpValue as Bindable<boolean>
                Bindable_Boolean_serializer.write(thisSerializer, isShowTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (builder !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const builderTmpValue  = builder!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(builderTmpValue))
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (type !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const typeTmpValue  = (type as ModalTransition)
            thisSerializer.writeInt32(typeTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindContentCover0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindContentCover1Attribute(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, options?: ContentCoverOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (isShow !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const isShowTmpValue  = isShow!
            if (isShowTmpValue instanceof boolean) {
                thisSerializer.writeInt8((0).toByte())
                const isShowTmpValueForIdx0  = isShowTmpValue as boolean
                thisSerializer.writeBoolean(isShowTmpValueForIdx0)
            } else if (isShowTmpValue instanceof Bindable) {
                thisSerializer.writeInt8((1).toByte())
                const isShowTmpValueForIdx1  = isShowTmpValue as Bindable<boolean>
                Bindable_Boolean_serializer.write(thisSerializer, isShowTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (builder !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const builderTmpValue  = builder!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(builderTmpValue))
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            ContentCoverOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindContentCover1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindSheetAttribute(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, options?: SheetOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (isShow !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const isShowTmpValue  = isShow!
            if (isShowTmpValue instanceof boolean) {
                thisSerializer.writeInt8((0).toByte())
                const isShowTmpValueForIdx0  = isShowTmpValue as boolean
                thisSerializer.writeBoolean(isShowTmpValueForIdx0)
            } else if (isShowTmpValue instanceof Bindable) {
                thisSerializer.writeInt8((1).toByte())
                const isShowTmpValueForIdx1  = isShowTmpValue as Bindable<boolean>
                Bindable_Boolean_serializer.write(thisSerializer, isShowTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (builder !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const builderTmpValue  = builder!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(builderTmpValue))
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            SheetOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindSheet(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnVisibleAreaChangeAttribute(ratios: Array<double> | undefined, event: VisibleAreaChangeCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (ratios !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const ratiosTmpValue  = ratios!
            thisSerializer.writeInt32((ratiosTmpValue.length).toInt())
            for (let ratiosTmpValueCounterI = 0; ratiosTmpValueCounterI < ratiosTmpValue.length; ratiosTmpValueCounterI++) {
                const ratiosTmpValueTmpElement : double = ratiosTmpValue[ratiosTmpValueCounterI]
                thisSerializer.writeFloat64(ratiosTmpValueTmpElement)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (event !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const eventTmpValue  = event!
            thisSerializer.holdAndWriteCallback(eventTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnVisibleAreaChange(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnVisibleAreaApproximateChangeAttribute(options: VisibleAreaEventOptions | undefined, event: VisibleAreaChangeCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            VisibleAreaEventOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (event !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const eventTmpValue  = event!
            thisSerializer.holdAndWriteCallback(eventTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnVisibleAreaApproximateChange(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setKeyboardShortcutAttribute(value: string | FunctionKey | undefined, keys: Array<ModifierKey> | undefined, action?: (() => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof FunctionKey) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as FunctionKey
                thisSerializer.writeInt32(valueTmpValueForIdx1.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (keys !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const keysTmpValue  = keys!
            thisSerializer.writeInt32((keysTmpValue.length).toInt())
            for (let keysTmpValueCounterI = 0; keysTmpValueCounterI < keysTmpValue.length; keysTmpValueCounterI++) {
                const keysTmpValueTmpElement : ModifierKey = keysTmpValue[keysTmpValueCounterI]
                thisSerializer.writeInt32(keysTmpValueTmpElement.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (action !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const actionTmpValue  = action!
            thisSerializer.holdAndWriteCallback(actionTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setKeyboardShortcut(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityGroupAttribute(isGroup: boolean | undefined, accessibilityOptions?: AccessibilityOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (isGroup !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const isGroupTmpValue  = isGroup!
            thisSerializer.writeBoolean(isGroupTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (accessibilityOptions !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const accessibilityOptionsTmpValue  = accessibilityOptions!
            AccessibilityOptions_serializer.write(thisSerializer, accessibilityOptionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityGroup(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnGestureRecognizerJudgeBegin1Attribute(callback_: GestureRecognizerJudgeBeginCallback | undefined, exposeInnerGesture: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (exposeInnerGesture !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const exposeInnerGestureTmpValue  = exposeInnerGesture!
            thisSerializer.writeBoolean(exposeInnerGestureTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnGestureRecognizerJudgeBegin1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export class ArkCommonShapeMethodPeer extends ArkCommonMethodPeer {
    attributeSet?: CommonShapeMethodModifier;
    public constructor(peerPtr: KPointer, id: int32, name: string = '', flags: int32 = 0) {
        super(peerPtr, id, name, flags)
    }
    public static create(component?: ComponentBase, flags: int32 = 0): ArkCommonShapeMethodPeer {
        const peerId  = PeerNode.nextId()
        const _peerPtr  = ArkUIGeneratedNativeModule._CommonShapeMethod_construct(peerId, flags)
        const _peer  = new ArkCommonShapeMethodPeer(_peerPtr, peerId, 'CommonShapeMethod', flags)
        component?.setPeer(_peer)
        return _peer
    }
    setStrokeAttribute(value: ResourceColor | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof arkui_component_enums_Color) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as arkui_component_enums_Color
                thisSerializer.writeInt32((valueTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueTmpValue instanceof int32) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as int32
                thisSerializer.writeInt32(valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx2)
            } else if (valueTmpValue instanceof arkui_component_units_Resource) {
                thisSerializer.writeInt8((3).toByte())
                const valueTmpValueForIdx3  = valueTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx3)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStroke(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFillAttribute(value: ResourceColor | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof arkui_component_enums_Color) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as arkui_component_enums_Color
                thisSerializer.writeInt32((valueTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueTmpValue instanceof int32) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as int32
                thisSerializer.writeInt32(valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx2)
            } else if (valueTmpValue instanceof arkui_component_units_Resource) {
                thisSerializer.writeInt8((3).toByte())
                const valueTmpValueForIdx3  = valueTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx3)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setFill(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeDashOffsetAttribute(value: double | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof double) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as double
                thisSerializer.writeFloat64(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeDashOffset(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeLineCapAttribute(value: LineCapStyle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as LineCapStyle)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeLineCap(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeLineJoinAttribute(value: LineJoinStyle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as LineJoinStyle)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeLineJoin(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeMiterLimitAttribute(value: double | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof double) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as double
                thisSerializer.writeFloat64(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeMiterLimit(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeOpacityAttribute(value: double | string | global_resource_Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof double) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as double
                thisSerializer.writeFloat64(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof global_resource_Resource) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeOpacity(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFillOpacityAttribute(value: double | string | global_resource_Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof double) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as double
                thisSerializer.writeFloat64(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof global_resource_Resource) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setFillOpacity(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeWidthAttribute(value: Length | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof double) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as double
                thisSerializer.writeFloat64(valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof arkui_component_units_Resource) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeWidth(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAntiAliasAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setAntiAlias(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeDashArrayAttribute(value: Array<Length> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeInt32((valueTmpValue.length).toInt())
            for (let valueTmpValueCounterI = 0; valueTmpValueCounterI < valueTmpValue.length; valueTmpValueCounterI++) {
                const valueTmpValueTmpElement : Length = valueTmpValue[valueTmpValueCounterI]
                if (valueTmpValueTmpElement instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueTmpElementForIdx0  = valueTmpValueTmpElement as string
                    thisSerializer.writeString(valueTmpValueTmpElementForIdx0)
                } else if (valueTmpValueTmpElement instanceof double) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueTmpElementForIdx1  = valueTmpValueTmpElement as double
                    thisSerializer.writeFloat64(valueTmpValueTmpElementForIdx1)
                } else if (valueTmpValueTmpElement instanceof arkui_component_units_Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueTmpElementForIdx2  = valueTmpValueTmpElement as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(thisSerializer, valueTmpValueTmpElementForIdx2)
                }
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeDashArray(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export class ArkScrollableCommonMethodPeer extends ArkCommonMethodPeer {
    attributeSet?: ScrollableCommonMethodModifier;
    public constructor(peerPtr: KPointer, id: int32, name: string = '', flags: int32 = 0) {
        super(peerPtr, id, name, flags)
    }
    public static create(component?: ComponentBase, flags: int32 = 0): ArkScrollableCommonMethodPeer {
        const peerId  = PeerNode.nextId()
        const _peerPtr  = ArkUIGeneratedNativeModule._ScrollableCommonMethod_construct(peerId, flags)
        const _peer  = new ArkScrollableCommonMethodPeer(_peerPtr, peerId, 'ScrollableCommonMethod', flags)
        component?.setPeer(_peer)
        return _peer
    }
    setScrollBarAttribute(value: BarState | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as BarState)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setScrollBar(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setScrollBarColorAttribute(value: arkui_component_enums_Color | int32 | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof arkui_component_enums_Color) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as arkui_component_enums_Color
                thisSerializer.writeInt32((valueTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueTmpValue instanceof int32) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as int32
                thisSerializer.writeInt32(valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setScrollBarColor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setScrollBarWidthAttribute(value: double | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof double) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as double
                thisSerializer.writeFloat64(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setScrollBarWidth(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setNestedScrollAttribute(value: NestedScrollOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            NestedScrollOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setNestedScroll(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setEnableScrollInteractionAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setEnableScrollInteraction(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFrictionAttribute(value: double | global_resource_Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof double) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as double
                thisSerializer.writeFloat64(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof global_resource_Resource) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setFriction(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnReachStartAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setOnReachStart(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnReachEndAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setOnReachEnd(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnScrollStartAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setOnScrollStart(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnScrollStopAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setOnScrollStop(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFlingSpeedLimitAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setFlingSpeedLimit(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setClipContentAttribute(value: ContentClipMode | RectShape | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof ContentClipMode) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as ContentClipMode
                thisSerializer.writeInt32(valueTmpValueForIdx0.valueOf())
            } else if (valueTmpValue instanceof RectShape) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as RectShape
                RectShape_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setClipContent(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDigitalCrownSensitivityAttribute(value: CrownSensitivity | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as CrownSensitivity)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setDigitalCrownSensitivity(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackToTopAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setBackToTop(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setEdgeEffectAttribute(edgeEffect: EdgeEffect | undefined, options?: EdgeEffectOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (edgeEffect !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const edgeEffectTmpValue  = (edgeEffect as EdgeEffect)
            thisSerializer.writeInt32(edgeEffectTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            EdgeEffectOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setEdgeEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFadingEdgeAttribute(enabled: boolean | undefined, options?: FadingEdgeOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (enabled !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const enabledTmpValue  = enabled!
            thisSerializer.writeBoolean(enabledTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            FadingEdgeOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setFadingEdge(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface InputCounterOptions {
    thresholdPercentage?: double;
    highlightBorder?: boolean;
}
export interface TextDecorationOptions {
    type: TextDecorationType | undefined;
    color?: ResourceColor;
    style?: TextDecorationStyle;
}
export interface DividerStyle {
    strokeWidth: Length | undefined;
    color?: ResourceColor;
    startMargin?: Length;
    endMargin?: Length;
}
export type ReuseIdCallback = () => string;
export interface ReuseOptions {
    reuseId?: ReuseIdCallback;
}
export type Context = application_Context_Context;
export interface Configuration {
    readonly colorMode: string;
    readonly fontScale: double;
}
export interface Rectangle {
    x?: Length;
    y?: Length;
    width?: Length;
    height?: Length;
}
export interface ExpectedFrameRateRange {
    min: int32;
    max: int32;
    expected: int32;
}
export enum AccessibilitySamePageMode {
    SEMI_SILENT = 0,
    FULL_SILENT = 1
}
export enum AccessibilityRoleType {
    ACTION_SHEET = 0,
    ALERT_DIALOG = 1,
    INDEXER_COMPONENT = 2,
    BADGE_COMPONENT = 3,
    BLANK = 4,
    BUTTON = 5,
    BACK_BUTTON = 6,
    SHEET_DRAG_BAR = 7,
    CALENDAR_PICKER = 8,
    CALENDAR = 9,
    CANVAS = 10,
    CANVAS_GRADIENT = 11,
    CANVAS_PATTERN = 12,
    CHECKBOX = 13,
    CHECKBOX_GROUP = 14,
    CIRCLE = 15,
    COLUMN_SPLIT = 16,
    COLUMN = 17,
    CANVAS_RENDERING_CONTEXT_2D = 18,
    CHART = 19,
    COUNTER = 20,
    CONTAINER_MODAL = 21,
    DATA_PANEL = 22,
    DATE_PICKER = 23,
    DIALOG = 24,
    DIVIDER = 25,
    DRAG_BAR = 26,
    EFFECT_COMPONENT = 27,
    ELLIPSE = 28,
    FLEX = 29,
    FLOW_ITEM = 30,
    FORM_COMPONENT = 31,
    FORM_LINK = 32,
    GAUGE = 33,
    GRID = 34,
    GRID_COL = 35,
    GRID_CONTAINER = 36,
    GRID_ITEM = 37,
    GRID_ROW = 38,
    HYPERLINK = 39,
    IMAGE = 40,
    IMAGE_ANIMATOR = 41,
    IMAGE_BITMAP = 42,
    IMAGE_DATA = 43,
    IMAGE_SPAN = 44,
    LABEL = 45,
    LINE = 46,
    LIST = 47,
    LIST_ITEM = 48,
    LIST_ITEM_GROUP = 49,
    LOADING_PROGRESS = 50,
    MARQUEE = 51,
    MATRIX2D = 52,
    MENU = 53,
    MENU_ITEM = 54,
    MENU_ITEM_GROUP = 55,
    NAV_DESTINATION = 56,
    NAV_ROUTER = 57,
    NAVIGATION = 58,
    NAVIGATION_BAR = 59,
    NAVIGATION_MENU = 60,
    NAVIGATOR = 61,
    OFFSCREEN_CANVAS = 62,
    OFFSCREEN_CANVAS_RENDERING_CONTEXT2D = 63,
    OPTION = 64,
    PANEL = 65,
    PAPER_PAGE = 66,
    PATH = 67,
    PATH2D = 68,
    PATTERN_LOCK = 69,
    PICKER = 70,
    PICKER_VIEW = 71,
    PLUGIN_COMPONENT = 72,
    POLYGON = 73,
    POLYLINE = 74,
    POPUP = 75,
    PROGRESS = 76,
    QRCODE = 77,
    RADIO = 78,
    RATING = 79,
    RECT = 80,
    REFRESH = 81,
    RELATIVE_CONTAINER = 82,
    REMOTE_WINDOW = 83,
    RICH_EDITOR = 84,
    RICH_TEXT = 85,
    ROLE_PAGER = 86,
    ROW = 87,
    ROW_SPLIT = 88,
    SCROLL = 89,
    SCROLL_BAR = 90,
    SEARCH = 91,
    SEARCH_FIELD = 92,
    SELECT = 93,
    SHAPE = 94,
    SIDEBAR_CONTAINER = 95,
    SLIDER = 96,
    SPAN = 97,
    STACK = 98,
    STEPPER = 99,
    STEPPER_ITEM = 100,
    SWIPER = 101,
    SWIPER_INDICATOR = 102,
    SWITCH = 103,
    SYMBOL_GLYPH = 104,
    TAB_CONTENT = 105,
    TAB_BAR = 106,
    TABS = 107,
    TEXT = 108,
    TEXT_CLOCK = 109,
    TEXT_ENTRY = 110,
    TEXT_INPUT = 111,
    TEXT_PICKER = 112,
    TEXT_TIMER = 113,
    TEXT_AREA = 114,
    TEXT_FIELD = 115,
    TIME_PICKER = 116,
    TITLE_BAR = 117,
    TOGGLER = 118,
    UI_EXTENSION_COMPONENT = 119,
    VIDEO = 120,
    WATER_FLOW = 121,
    WEB = 122,
    XCOMPONENT = 123,
    ROLE_NONE = 124
}
export type AccessibilityFocusCallback = (isFocus: boolean) => void;
export enum AccessibilityAction {
    UNDEFINED_ACTION = 0,
    ACCESSIBILITY_CLICK = 1
}
export enum AccessibilityActionInterceptResult {
    ACTION_INTERCEPT = 0,
    ACTION_CONTINUE = 1,
    ACTION_RISE = 2
}
export type AccessibilityActionInterceptCallback = (action: AccessibilityAction) => AccessibilityActionInterceptResult;
export enum FinishCallbackType {
    REMOVED = 0,
    LOGICALLY = 1
}
export enum TouchTestStrategy {
    DEFAULT = 0,
    FORWARD_COMPETITION = 1,
    FORWARD = 2
}
export interface AnimateParam {
    duration?: int32;
    tempo?: double;
    curve?: Curve | string | ICurve;
    delay?: int32;
    iterations?: int32;
    playMode?: PlayMode;
    onFinish?: (() => void);
    finishCallbackType?: FinishCallbackType;
    expectedFrameRateRange?: ExpectedFrameRateRange;
}
export type ICurve = curves.ICurve;
export type Matrix4Transit = matrix4.Matrix4Transit;
export interface MotionPathOptions {
    path: string;
    from?: double;
    to?: double;
    rotatable?: boolean;
}
export interface sharedTransitionOptions {
    duration?: int32;
    curve?: Curve | string | ICurve;
    delay?: int32;
    motionPath?: MotionPathOptions;
    zIndex?: int32;
    type?: SharedTransitionEffectType;
}
export interface GeometryTransitionOptions {
    follow?: boolean;
    hierarchyStrategy?: TransitionHierarchyStrategy;
}
export interface LinearGradientOptions {
    angle?: double | string;
    direction?: GradientDirection;
    colors: Array<[ ResourceColor, double ]>;
    repeating?: boolean;
}
export enum TransitionHierarchyStrategy {
    NONE = 0,
    ADAPTIVE = 1
}
export interface SweepGradientOptions {
    center: [ Length, Length ];
    start?: double | string;
    end?: double | string;
    rotation?: double | string;
    colors: Array<[ ResourceColor, double ]>;
    repeating?: boolean;
}
export interface RadialGradientOptions {
    center: [ Length, Length ];
    radius: Length;
    colors: Array<[ ResourceColor, double ]>;
    repeating?: boolean;
}
export interface TranslateOptions {
    x?: double | string;
    y?: double | string;
    z?: double | string;
}
export interface ScaleOptions {
    x?: double;
    y?: double;
    z?: double;
    centerX?: double | string;
    centerY?: double | string;
}
export interface VerticalAlignParam {
    anchor: string;
    align: VerticalAlign;
}
export interface HorizontalAlignParam {
    anchor: string;
    align: HorizontalAlign;
}
export interface AlignRuleOption {
    left?: HorizontalAlignParam;
    right?: HorizontalAlignParam;
    middle?: HorizontalAlignParam;
    top?: VerticalAlignParam;
    bottom?: VerticalAlignParam;
    center?: VerticalAlignParam;
    bias?: Bias;
}
export interface LocalizedHorizontalAlignParam {
    anchor: string;
    align: HorizontalAlign;
}
export interface LocalizedVerticalAlignParam {
    anchor: string;
    align: VerticalAlign;
}
export interface LocalizedAlignRuleOptions {
    start?: LocalizedHorizontalAlignParam;
    end?: LocalizedHorizontalAlignParam;
    middle?: LocalizedHorizontalAlignParam;
    top?: LocalizedVerticalAlignParam;
    bottom?: LocalizedVerticalAlignParam;
    center?: LocalizedVerticalAlignParam;
    bias?: Bias;
}
export enum ChainStyle {
    SPREAD = 0,
    SPREAD_INSIDE = 1,
    PACKED = 2
}
export interface RotateOptions {
    x?: double;
    y?: double;
    z?: double;
    centerX?: double | string;
    centerY?: double | string;
    centerZ?: double;
    perspective?: double;
    angle: double | string;
}
export enum TransitionEdge {
    TOP = 0,
    BOTTOM = 1,
    START = 2,
    END = 3
}
export interface AsymmetricTransitionOption {
    appear: TransitionEffect;
    disappear: TransitionEffect;
}
export interface ItemDragInfo {
    x: double;
    y: double;
}
export enum EffectType {
    DEFAULT = 0,
    WINDOW_EFFECT = 1
}
export enum PreDragStatus {
    ACTION_DETECTING_STATUS = 0,
    READY_TO_TRIGGER_DRAG_ACTION = 1,
    PREVIEW_LIFT_STARTED = 2,
    PREVIEW_LIFT_FINISHED = 3,
    PREVIEW_LANDING_STARTED = 4,
    PREVIEW_LANDING_FINISHED = 5,
    ACTION_CANCELED_BEFORE_DRAG = 6,
    PREPARING_FOR_DRAG_DETECTION = 7
}
export interface DragItemInfo {
    pixelMap?: PixelMap;
    builder?: CustomBuilder;
    extraInfo?: string;
}
export type PointerStyle = pointer.PointerStyle;
export interface EventTarget {
    area: Area;
    id?: string;
}
export enum SourceType {
    Unknown = 0,
    Mouse = 1,
    TouchScreen = 2,
    UNKNOWN = 0,
    MOUSE = 1,
    TOUCH_SCREEN = 2
}
export enum SourceTool {
    Unknown = 0,
    Finger = 1,
    Pen = 2,
    MOUSE = 7,
    TOUCHPAD = 9,
    JOYSTICK = 10,
    UNKNOWN = 0,
    FINGER = 1,
    PEN = 2,
    MOUSE_DUMMY = 7,
    TOUCHPAD_DUMMY = 9,
    JOYSTICK_DUMMY = 10
}
export enum RepeatMode {
    Repeat = 0,
    Stretch = 1,
    Round = 2,
    Space = 3,
    REPEAT = 0,
    STRETCH = 1,
    ROUND = 2,
    SPACE = 3
}
export enum BlurStyle {
    Thin = 0,
    Regular = 1,
    Thick = 2,
    BACKGROUND_THIN = 3,
    BACKGROUND_REGULAR = 4,
    BACKGROUND_THICK = 5,
    BACKGROUND_ULTRA_THICK = 6,
    NONE = 7,
    COMPONENT_ULTRA_THIN = 8,
    COMPONENT_THIN = 9,
    COMPONENT_REGULAR = 10,
    COMPONENT_THICK = 11,
    COMPONENT_ULTRA_THICK = 12,
    THIN = 0,
    REGULAR = 1,
    THICK = 2,
    BACKGROUND_THIN_DUMMY = 3,
    BACKGROUND_REGULAR_DUMMY = 4,
    BACKGROUND_THICK_DUMMY = 5,
    BACKGROUND_ULTRA_THICK_DUMMY = 6,
    NONE_DUMMY = 7,
    COMPONENT_ULTRA_THIN_DUMMY = 8,
    COMPONENT_THIN_DUMMY = 9,
    COMPONENT_REGULAR_DUMMY = 10,
    COMPONENT_THICK_DUMMY = 11,
    COMPONENT_ULTRA_THICK_DUMMY = 12
}
export enum BlurStyleActivePolicy {
    FOLLOWS_WINDOW_ACTIVE_STATE = 0,
    ALWAYS_ACTIVE = 1,
    ALWAYS_INACTIVE = 2
}
export enum ThemeColorMode {
    SYSTEM = 0,
    LIGHT = 1,
    DARK = 2
}
export enum AdaptiveColor {
    DEFAULT = 0,
    AVERAGE = 1
}
export enum ModalTransition {
    DEFAULT = 0,
    NONE = 1,
    ALPHA = 2
}
export interface BackgroundBlurStyleOptions extends BlurStyleOptions {
    policy?: BlurStyleActivePolicy;
    inactiveColor?: ResourceColor;
}
export interface ForegroundBlurStyleOptions extends BlurStyleOptions {
}
export interface BlurOptions {
    grayscale: [ double, double ] | undefined;
}
export interface SystemAdaptiveOptions {
    disableSystemAdaptation?: boolean;
}
export interface BlurStyleOptions {
    colorMode?: ThemeColorMode;
    adaptiveColor?: AdaptiveColor;
    scale?: double;
    blurOptions?: BlurOptions;
}
export interface BackgroundEffectOptions {
    radius: double | undefined;
    saturation?: double;
    brightness?: double;
    color?: ResourceColor;
    adaptiveColor?: AdaptiveColor;
    blurOptions?: BlurOptions;
    policy?: BlurStyleActivePolicy;
    inactiveColor?: ResourceColor;
}
export interface ForegroundEffectOptions {
    radius: double | undefined;
}
export interface PickerTextStyle {
    color?: ResourceColor;
    font?: arkui_component_units_Font;
}
export interface PickerDialogButtonStyle {
    type?: ButtonType;
    style?: ButtonStyleMode;
    role?: ButtonRole;
    fontSize?: Length;
    fontColor?: ResourceColor;
    fontWeight?: FontWeight | int32 | string;
    fontStyle?: FontStyle;
    fontFamily?: global_resource_Resource | string;
    backgroundColor?: ResourceColor;
    borderRadius?: Length | BorderRadiuses;
    primary?: boolean;
}
export enum ShadowType {
    COLOR = 0,
    BLUR = 1
}
export interface ShadowOptions {
    radius: double | global_resource_Resource | undefined;
    type?: ShadowType;
    color?: arkui_component_enums_Color | string | global_resource_Resource | ColoringStrategy;
    offsetX?: double | global_resource_Resource;
    offsetY?: double | global_resource_Resource;
    fill?: boolean;
}
export enum ShadowStyle {
    OUTER_DEFAULT_XS = 0,
    OUTER_DEFAULT_SM = 1,
    OUTER_DEFAULT_MD = 2,
    OUTER_DEFAULT_LG = 3,
    OUTER_FLOATING_SM = 4,
    OUTER_FLOATING_MD = 5
}
export interface MultiShadowOptions {
    radius?: double | global_resource_Resource;
    offsetX?: double | global_resource_Resource;
    offsetY?: double | global_resource_Resource;
}
export enum SafeAreaType {
    SYSTEM = 0,
    CUTOUT = 1,
    KEYBOARD = 2
}
export enum SafeAreaEdge {
    TOP = 0,
    BOTTOM = 1,
    START = 2,
    END = 3
}
export enum LayoutSafeAreaType {
    SYSTEM = 0
}
export enum LayoutSafeAreaEdge {
    TOP = 0,
    BOTTOM = 1
}
export enum SheetSize {
    MEDIUM = 0,
    LARGE = 1,
    FIT_CONTENT = 2
}
export type ModifierKeyStateGetter = (keys: Array<string>) => boolean;
export interface BorderImageOption {
    slice?: Length | EdgeWidths | LocalizedEdgeWidths;
    repeat?: RepeatMode;
    source?: string | global_resource_Resource | LinearGradientOptions;
    width?: Length | EdgeWidths | LocalizedEdgeWidths;
    outset?: Length | EdgeWidths | LocalizedEdgeWidths;
    fill?: boolean;
}
export interface TouchObject {
    type: TouchType;
    id: int32;
    displayX: double;
    displayY: double;
    windowX: double;
    windowY: double;
    x: double;
    y: double;
    hand?: InteractionHand;
    pressedTime?: int64;
    pressure?: double;
    width?: double;
    height?: double;
}
export interface HistoricalPoint {
    touchObject: TouchObject;
    size: int32;
    force: double;
    timestamp: int64;
}
export type SizeChangeCallback = (oldValue: SizeOptions, newValue: SizeOptions) => void;
export type GestureRecognizerJudgeBeginCallback = (event: BaseGestureEvent, current: GestureRecognizer, recognizers: Array<GestureRecognizer>, touchRecognizers?: Array<TouchRecognizer>) => GestureJudgeResult;
export type ShouldBuiltInRecognizerParallelWithCallback = (current: GestureRecognizer, others: Array<GestureRecognizer>) => GestureRecognizer;
export type TransitionFinishCallback = (transitionIn: boolean) => void;
export type TouchTestDoneCallback = (event: BaseGestureEvent, recognizers: Array<GestureRecognizer>) => void;
export type PixelMap = image.PixelMap;
export enum DragBehavior {
    COPY = 0,
    MOVE = 1
}
export type UnifiedData = unifiedDataChannel.UnifiedData;
export type Summary = unifiedDataChannel.Summary;
export type UniformDataType = uniformTypeDescriptor.UniformDataType;
export type DataSyncOptions = unifiedDataChannel.GetDataParams;
export enum DragResult {
    UNKNOWN = -1,
    DRAG_SUCCESSFUL = 0,
    DRAG_FAILED = 1,
    DRAG_CANCELED = 2,
    DROP_ENABLED = 3,
    DROP_DISABLED = 4
}
export enum BlendMode {
    NONE = 0,
    CLEAR = 1,
    SRC = 2,
    DST = 3,
    SRC_OVER = 4,
    DST_OVER = 5,
    SRC_IN = 6,
    DST_IN = 7,
    SRC_OUT = 8,
    DST_OUT = 9,
    SRC_ATOP = 10,
    DST_ATOP = 11,
    XOR = 12,
    PLUS = 13,
    MODULATE = 14,
    SCREEN = 15,
    OVERLAY = 16,
    DARKEN = 17,
    LIGHTEN = 18,
    COLOR_DODGE = 19,
    COLOR_BURN = 20,
    HARD_LIGHT = 21,
    SOFT_LIGHT = 22,
    DIFFERENCE = 23,
    EXCLUSION = 24,
    MULTIPLY = 25,
    HUE = 26,
    SATURATION = 27,
    COLOR = 28,
    LUMINOSITY = 29
}
export enum BlendApplyType {
    FAST = 0,
    OFFSCREEN = 1
}
export type OnDragEventCallback = (event: DragEvent, extraParams?: string) => void;
export interface DropOptions {
    disableDataPrefetch?: boolean;
}
export interface BindOptions {
    backgroundColor?: ResourceColor;
    onAppear?: (() => void);
    onDisappear?: (() => void);
    onWillAppear?: (() => void);
    onWillDisappear?: (() => void);
}
export interface DismissContentCoverAction {
    dismiss: VoidCallback;
    reason: DismissReason;
}
export interface ContentCoverOptions extends BindOptions {
    modalTransition?: ModalTransition;
    onWillDismiss?: Callback<DismissContentCoverAction, void>;
    transition?: TransitionEffect;
}
export interface SheetTitleOptions {
    title: arkui_component_units_ResourceStr;
    subtitle?: arkui_component_units_ResourceStr;
}
export enum SheetType {
    BOTTOM = 0,
    CENTER = 1,
    POPUP = 2
}
export enum SheetMode {
    OVERLAY = 0,
    EMBEDDED = 1
}
export enum ScrollSizeMode {
    FOLLOW_DETENT = 0,
    CONTINUOUS = 1
}
export enum SheetKeyboardAvoidMode {
    NONE = 0,
    TRANSLATE_AND_RESIZE = 1,
    RESIZE_ONLY = 2,
    TRANSLATE_AND_SCROLL = 3
}
export interface SheetDismiss {
    dismiss: VoidCallback;
}
export interface DismissSheetAction {
    dismiss: VoidCallback;
    reason: DismissReason;
}
export type SingleLengthDetent = [
    SheetSize | Length
]
export type DoubleLengthDetents = [
    SheetSize | Length,
    SheetSize | Length | undefined
]
export type TripleLengthDetents = [
    SheetSize | Length,
    SheetSize | Length | undefined,
    SheetSize | Length | undefined
]
export interface SheetOptions extends BindOptions {
    height?: SheetSize | Length;
    dragBar?: boolean;
    maskColor?: ResourceColor;
    detents?: TripleLengthDetents;
    blurStyle?: BlurStyle;
    showClose?: boolean | global_resource_Resource;
    preferType?: SheetType;
    title?: SheetTitleOptions | CustomBuilder;
    shouldDismiss?: ((sheetDismiss: SheetDismiss) => void);
    onWillDismiss?: Callback<DismissSheetAction, void>;
    onWillSpringBackWhenDismiss?: Callback<SpringBackAction, void>;
    enableOutsideInteractive?: boolean;
    width?: Dimension;
    borderWidth?: Dimension | EdgeWidths | LocalizedEdgeWidths;
    borderColor?: ResourceColor | EdgeColors | LocalizedEdgeColors;
    borderStyle?: BorderStyle | EdgeStyles;
    shadow?: ShadowOptions | ShadowStyle;
    onHeightDidChange?: Callback<number, void>;
    mode?: SheetMode;
    scrollSizeMode?: ScrollSizeMode;
    onDetentsDidChange?: Callback<int32, void>;
    onWidthDidChange?: Callback<int32, void>;
    onTypeDidChange?: Callback<SheetType, void>;
    uiContext?: UIContext;
    keyboardAvoidMode?: SheetKeyboardAvoidMode;
    enableHoverMode?: boolean;
    hoverModeArea?: HoverModeAreaType;
    offset?: Position;
    effectEdge?: int32;
    radius?: arkui_Graphics_LengthMetrics | BorderRadiuses | LocalizedBorderRadiuses;
    detentSelection?: SheetSize | Length;
    showInSubWindow?: boolean;
    placement?: Placement;
    placementOnTarget?: boolean;
}
export interface StateStyles {
    normal?: CustomStyles;
    pressed?: CustomStyles;
    disabled?: CustomStyles;
    focused?: CustomStyles;
    clicked?: CustomStyles;
    selected?: CustomStyles;
}
export interface PopupMessageOptions {
    textColor?: ResourceColor;
    font?: arkui_component_units_Font;
}
export enum DismissReason {
    PRESS_BACK = 0,
    TOUCH_OUTSIDE = 1,
    CLOSE_BUTTON = 2,
    SLIDE_DOWN = 3
}
export interface PopupStateChangeParam {
    isVisible: boolean;
}
export type PopupStateChangeCallback = (event: PopupStateChangeParam) => void;
export interface PopupMaskType {
    color: ResourceColor;
}
export interface PopupBorderLinearGradient {
    direction?: GradientDirection;
    colors: Array<[ ResourceColor, double ]>;
}
export interface PopupCommonOptions {
    placement?: Placement;
    popupColor?: ResourceColor;
    enableArrow?: boolean;
    autoCancel?: boolean;
    onStateChange?: PopupStateChangeCallback;
    arrowOffset?: Length;
    showInSubWindow?: boolean;
    mask?: boolean | PopupMaskType;
    targetSpace?: Length;
    offset?: Position;
    width?: Dimension;
    arrowPointPosition?: ArrowPointPosition;
    arrowWidth?: Dimension;
    arrowHeight?: Dimension;
    radius?: Dimension;
    shadow?: ShadowOptions | ShadowStyle;
    backgroundBlurStyle?: BlurStyle;
    focusable?: boolean;
    transition?: TransitionEffect;
    onWillDismiss?: boolean | Callback<DismissPopupAction, void>;
    enableHoverMode?: boolean;
    followTransformOfTarget?: boolean;
}
export interface TipsOptions {
    appearingTime?: int32;
    disappearingTime?: int32;
    appearingTimeWithContinuousOperation?: int32;
    disappearingTimeWithContinuousOperation?: int32;
    enableArrow?: boolean;
    arrowPointPosition?: ArrowPointPosition;
    arrowWidth?: Dimension;
    arrowHeight?: Dimension;
}
export interface PopupButton {
    value: string;
    action: VoidCallback;
}
export interface PopupOptions {
    message: string;
    placement?: Placement;
    primaryButton?: PopupButton;
    secondaryButton?: PopupButton;
    onStateChange?: PopupStateChangeCallback;
    arrowOffset?: Length;
    showInSubWindow?: boolean;
    mask?: boolean | PopupMaskType;
    messageOptions?: PopupMessageOptions;
    targetSpace?: Length;
    enableArrow?: boolean;
    offset?: Position;
    popupColor?: arkui_component_enums_Color | string | global_resource_Resource | int64;
    autoCancel?: boolean;
    width?: Dimension;
    arrowPointPosition?: ArrowPointPosition;
    arrowWidth?: Dimension;
    arrowHeight?: Dimension;
    radius?: Dimension;
    shadow?: ShadowOptions | ShadowStyle;
    backgroundBlurStyle?: BlurStyle;
    transition?: TransitionEffect;
    onWillDismiss?: boolean | Callback<DismissPopupAction, void>;
    enableHoverMode?: boolean;
    followTransformOfTarget?: boolean;
    keyboardAvoidMode?: KeyboardAvoidMode;
}
export interface CustomPopupOptions {
    builder: CustomBuilder;
    placement?: Placement;
    popupColor?: arkui_component_enums_Color | string | global_resource_Resource | int64;
    enableArrow?: boolean;
    autoCancel?: boolean;
    onStateChange?: PopupStateChangeCallback;
    arrowOffset?: Length;
    showInSubWindow?: boolean;
    mask?: boolean | PopupMaskType;
    targetSpace?: Length;
    offset?: Position;
    width?: Dimension;
    arrowPointPosition?: ArrowPointPosition;
    arrowWidth?: Dimension;
    arrowHeight?: Dimension;
    radius?: Dimension;
    shadow?: ShadowOptions | ShadowStyle;
    backgroundBlurStyle?: BlurStyle;
    focusable?: boolean;
    transition?: TransitionEffect;
    onWillDismiss?: boolean | Callback<DismissPopupAction, void>;
    enableHoverMode?: boolean;
    followTransformOfTarget?: boolean;
    keyboardAvoidMode?: KeyboardAvoidMode;
}
export enum MenuPreviewMode {
    NONE = 0,
    IMAGE = 1
}
export type AnimationNumberRange = [
    double,
    double
]
export interface ContextMenuAnimationOptions {
    scale?: AnimationNumberRange;
    transition?: TransitionEffect;
    hoverScale?: AnimationNumberRange;
}
export enum PreviewScaleMode {
    AUTO = 0,
    CONSTANT = 1,
    MAINTAIN = 2
}
export type BorderRadiusType = Length | BorderRadiuses | LocalizedBorderRadiuses;
export enum HapticFeedbackMode {
    DISABLED = 0,
    ENABLED = 1,
    AUTO = 2
}
export interface ContextMenuOptions {
    offset?: Position;
    placement?: Placement;
    enableArrow?: boolean;
    arrowOffset?: Length;
    preview?: MenuPreviewMode | CustomBuilder;
    previewBorderRadius?: BorderRadiusType;
    borderRadius?: Length | BorderRadiuses | LocalizedBorderRadiuses;
    onAppear?: (() => void);
    onDisappear?: (() => void);
    aboutToAppear?: (() => void);
    aboutToDisappear?: (() => void);
    layoutRegionMargin?: Margin;
    previewAnimationOptions?: ContextMenuAnimationOptions;
    backgroundColor?: ResourceColor;
    backgroundBlurStyle?: BlurStyle;
    backgroundBlurStyleOptions?: BackgroundBlurStyleOptions;
    backgroundEffect?: BackgroundEffectOptions;
    transition?: TransitionEffect;
    enableHoverMode?: boolean;
    outlineColor?: ResourceColor | EdgeColors;
    outlineWidth?: Dimension | EdgeOutlineWidths;
    hapticFeedbackMode?: HapticFeedbackMode;
}
export interface MenuOptions extends ContextMenuOptions {
    title?: arkui_component_units_ResourceStr;
    showInSubWindow?: boolean;
}
export class TouchTestInfo {
    windowX: double = initializers.arkui.component.common.TouchTestInfoNS.windowX;
    windowY: double = initializers.arkui.component.common.TouchTestInfoNS.windowY;
    parentX: double = initializers.arkui.component.common.TouchTestInfoNS.parentX;
    parentY: double = initializers.arkui.component.common.TouchTestInfoNS.parentY;
    x: double = initializers.arkui.component.common.TouchTestInfoNS.x;
    y: double = initializers.arkui.component.common.TouchTestInfoNS.y;
    rect: RectResult = initializers.arkui.component.common.TouchTestInfoNS.rect;
    id: string = initializers.arkui.component.common.TouchTestInfoNS.id;
}
export class TouchResult {
    strategy: TouchTestStrategy = initializers.arkui.component.common.TouchResultNS.strategy;
    id?: string | undefined;
}
export interface PixelStretchEffectOptions {
    top?: Length;
    bottom?: Length;
    left?: Length;
    right?: Length;
}
export interface ClickEffect {
    level: ClickEffectLevel;
    scale?: double;
}
export interface FadingEdgeOptions {
    fadingEdgeLength?: arkui_Graphics_LengthMetrics;
}
export interface NestedScrollOptions {
    scrollForward: NestedScrollMode;
    scrollBackward: NestedScrollMode;
}
export interface MenuElement {
    value: arkui_component_units_ResourceStr;
    icon?: arkui_component_units_ResourceStr;
    symbolIcon?: SymbolGlyphModifier;
    enabled?: boolean;
    action: (() => void);
}
export interface CommonConfiguration<T> {
    enabled: boolean;
    contentModifier: ContentModifier<T>;
}
export enum OutlineStyle {
    SOLID = 0,
    DASHED = 1,
    DOTTED = 2
}
export enum DragPreviewMode {
    AUTO = 1,
    DISABLE_SCALE = 2,
    ENABLE_DEFAULT_SHADOW = 3,
    ENABLE_DEFAULT_RADIUS = 4,
    ENABLE_DRAG_ITEM_GRAY_EFFECT = 5,
    ENABLE_MULTI_TILE_EFFECT = 6,
    ENABLE_TOUCH_POINT_CALCULATION_BASED_ON_FINAL_PREVIEW = 7
}
export enum DraggingSizeChangeEffect {
    DEFAULT = 0,
    SIZE_TRANSITION = 1,
    SIZE_CONTENT_TRANSITION = 2
}
export enum MenuPolicy {
    DEFAULT = 0,
    HIDE = 1,
    SHOW = 2
}
export interface DragPreviewOptions {
    mode?: DragPreviewMode | Array<DragPreviewMode>;
    modifier?: ImageModifier;
    numberBadge?: boolean | int64;
    sizeChangeEffect?: DraggingSizeChangeEffect;
}
export interface DragInteractionOptions {
    isMultiSelectionEnabled?: boolean;
    defaultAnimationBeforeLifting?: boolean;
    enableEdgeAutoScroll?: boolean;
    enableHapticFeedback?: boolean;
    isLiftingDisabled?: boolean;
}
export interface PreviewConfiguration {
    onlyForLifting?: boolean;
    delayCreating?: boolean;
}
export interface InvertOptions {
    low: double;
    high: double;
    threshold: double;
    thresholdRange: double;
}
export type TipsMessageType = arkui_component_units_ResourceStr | StyledString;
export enum ModalMode {
    AUTO = 0,
    NONE = 1,
    TARGET_WINDOW = 2
}
export interface MenuMaskType {
    color?: ResourceColor;
    backgroundBlurStyle?: BlurStyle;
}
export enum AvailableLayoutArea {
    SAFE_AREA = 0
}
export interface BackgroundImageOptions {
    syncLoad?: boolean;
    repeat?: ImageRepeat;
}
export interface BackgroundOptions {
    align?: Alignment;
}
// instructive change start
export type CustomProperty = undefined | null | Object | Record<string, CustomProperty> | Array<CustomProperty>;
// instructive change end
export interface CommonMethod {
    width(value: Length | LayoutPolicy | undefined): this {
        throw new Error('Unimplemented method width')
    }
    height(value: Length | LayoutPolicy | undefined): this {
        throw new Error('Unimplemented method height')
    }
    drawModifier(value: DrawModifier | undefined): this {
        throw new Error('Unimplemented method drawModifier')
    }
    responseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        throw new Error('Unimplemented method responseRegion')
    }
    mouseResponseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        throw new Error('Unimplemented method mouseResponseRegion')
    }
    size(value: SizeOptions | undefined): this {
        throw new Error('Unimplemented method size')
    }
    constraintSize(value: ConstraintSizeOptions | undefined): this {
        throw new Error('Unimplemented method constraintSize')
    }
    hitTestBehavior(value: HitTestMode | undefined): this {
        throw new Error('Unimplemented method hitTestBehavior')
    }
    onChildTouchTest(value: ((value: Array<TouchTestInfo>) => TouchResult) | undefined): this {
        throw new Error('Unimplemented method onChildTouchTest')
    }
    layoutWeight(value: double | string | undefined): this {
        throw new Error('Unimplemented method layoutWeight')
    }
    chainWeight(value: ChainWeightOptions | undefined): this {
        throw new Error('Unimplemented method chainWeight')
    }
    padding(value: Padding | Length | LocalizedPadding | undefined): this {
        throw new Error('Unimplemented method padding')
    }
    safeAreaPadding(value: Padding | arkui_Graphics_LengthMetrics | LocalizedPadding | undefined): this {
        throw new Error('Unimplemented method safeAreaPadding')
    }
    margin(value: Margin | Length | LocalizedMargin | undefined): this {
        throw new Error('Unimplemented method margin')
    }
    backgroundColor(value: ResourceColor | arkui_component_units_ColorMetrics | undefined): this {
        throw new Error('Unimplemented method backgroundColor')
    }
    pixelRound(value: PixelRoundPolicy | undefined): this {
        throw new Error('Unimplemented method pixelRound')
    }
    backgroundImage(value: arkui_component_units_ResourceStr | PixelMap | undefined): this {
        throw new Error('Unimplemented method backgroundImage')
    }
    backgroundImageSize(value: SizeOptions | ImageSize | undefined): this {
        throw new Error('Unimplemented method backgroundImageSize')
    }
    backgroundImagePosition(value: Position | Alignment | undefined): this {
        throw new Error('Unimplemented method backgroundImagePosition')
    }
    backgroundImageResizable(value: ResizableOptions | undefined): this {
        throw new Error('Unimplemented method backgroundImageResizable')
    }
    foregroundEffect(value: ForegroundEffectOptions | undefined): this {
        throw new Error('Unimplemented method foregroundEffect')
    }
    visualEffect(value: VisualEffect | undefined): this {
        throw new Error('Unimplemented method visualEffect')
    }
    backgroundFilter(value: Filter | undefined): this {
        throw new Error('Unimplemented method backgroundFilter')
    }
    foregroundFilter(value: Filter | undefined): this {
        throw new Error('Unimplemented method foregroundFilter')
    }
    compositingFilter(value: Filter | undefined): this {
        throw new Error('Unimplemented method compositingFilter')
    }
    opacity(value: double | global_resource_Resource | undefined): this {
        throw new Error('Unimplemented method opacity')
    }
    border(value: BorderOptions | undefined): this {
        throw new Error('Unimplemented method border')
    }
    borderStyle(value: BorderStyle | EdgeStyles | undefined): this {
        throw new Error('Unimplemented method borderStyle')
    }
    borderWidth(value: Length | EdgeWidths | LocalizedEdgeWidths | undefined): this {
        throw new Error('Unimplemented method borderWidth')
    }
    borderColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        throw new Error('Unimplemented method borderColor')
    }
    borderRadius(value: Length | BorderRadiuses | LocalizedBorderRadiuses | undefined): this {
        throw new Error('Unimplemented method borderRadius')
    }
    borderImage(value: BorderImageOption | undefined): this {
        throw new Error('Unimplemented method borderImage')
    }
    outline(value: OutlineOptions | undefined): this {
        throw new Error('Unimplemented method outline')
    }
    outlineStyle(value: OutlineStyle | EdgeOutlineStyles | undefined): this {
        throw new Error('Unimplemented method outlineStyle')
    }
    outlineWidth(value: Dimension | EdgeOutlineWidths | undefined): this {
        throw new Error('Unimplemented method outlineWidth')
    }
    outlineColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        throw new Error('Unimplemented method outlineColor')
    }
    outlineRadius(value: Dimension | OutlineRadiuses | undefined): this {
        throw new Error('Unimplemented method outlineRadius')
    }
    foregroundColor(value: ResourceColor | ColoringStrategy | undefined): this {
        throw new Error('Unimplemented method foregroundColor')
    }
    onClick(value: ((event: ClickEvent) => void) | undefined): this {
        throw new Error('Unimplemented method onClick')
    }
    onHover(value: ((isHover: boolean,event: HoverEvent) => void) | undefined): this {
        throw new Error('Unimplemented method onHover')
    }
    onHoverMove(value: Callback<HoverEvent, void> | undefined): this {
        throw new Error('Unimplemented method onHoverMove')
    }
    onAccessibilityHover(value: AccessibilityCallback | undefined): this {
        throw new Error('Unimplemented method onAccessibilityHover')
    }
    onAccessibilityHoverTransparent(value: AccessibilityTransparentCallback | undefined): this {
        throw new Error('Unimplemented method onAccessibilityHoverTransparent')
    }
    hoverEffect(value: HoverEffect | undefined): this {
        throw new Error('Unimplemented method hoverEffect')
    }
    onMouse(value: ((event: MouseEvent) => void) | undefined): this {
        throw new Error('Unimplemented method onMouse')
    }
    onTouch(value: ((event: TouchEvent) => void) | undefined): this {
        throw new Error('Unimplemented method onTouch')
    }
    onKeyEvent(value: Callback<KeyEvent, boolean> | undefined): this {
        throw new Error('Unimplemented method onKeyEvent')
    }
    onDigitalCrown(value: Callback<CrownEvent, void> | undefined): this {
        throw new Error('Unimplemented method onDigitalCrown')
    }
    onKeyPreIme(value: Callback<KeyEvent, boolean> | undefined): this {
        throw new Error('Unimplemented method onKeyPreIme')
    }
    onKeyEventDispatch(value: Callback<KeyEvent, boolean> | undefined): this {
        throw new Error('Unimplemented method onKeyEventDispatch')
    }
    onFocusAxisEvent(value: Callback<FocusAxisEvent, void> | undefined): this {
        throw new Error('Unimplemented method onFocusAxisEvent')
    }
    onAxisEvent(value: Callback<AxisEvent, void> | undefined): this {
        throw new Error('Unimplemented method onAxisEvent')
    }
    focusable(value: boolean | undefined): this {
        throw new Error('Unimplemented method focusable')
    }
    nextFocus(value: FocusMovement | undefined): this {
        throw new Error('Unimplemented method nextFocus')
    }
    tabStop(value: boolean | undefined): this {
        throw new Error('Unimplemented method tabStop')
    }
    onFocus(value: (() => void) | undefined): this {
        throw new Error('Unimplemented method onFocus')
    }
    onBlur(value: (() => void) | undefined): this {
        throw new Error('Unimplemented method onBlur')
    }
    tabIndex(value: int32 | undefined): this {
        throw new Error('Unimplemented method tabIndex')
    }
    defaultFocus(value: boolean | undefined): this {
        throw new Error('Unimplemented method defaultFocus')
    }
    groupDefaultFocus(value: boolean | undefined): this {
        throw new Error('Unimplemented method groupDefaultFocus')
    }
    focusOnTouch(value: boolean | undefined): this {
        throw new Error('Unimplemented method focusOnTouch')
    }
    focusBox(value: FocusBoxStyle | undefined): this {
        throw new Error('Unimplemented method focusBox')
    }
    // instructive change start
    animationStart(value: AnimateParam | undefined): this {
        throw new Error("Unimplemented method animationStart")
    }
    animationStop(value: AnimateParam | undefined): this {
        throw new Error("Unimplemented method animationStop")
    }
    // instructive change end
    transition(value: TransitionEffect | undefined): this {
        throw new Error('Unimplemented method transition')
    }
    motionBlur(value: MotionBlurOptions | undefined): this {
        throw new Error('Unimplemented method motionBlur')
    }
    brightness(value: double | undefined): this {
        throw new Error('Unimplemented method brightness')
    }
    contrast(value: double | undefined): this {
        throw new Error('Unimplemented method contrast')
    }
    grayscale(value: double | undefined): this {
        throw new Error('Unimplemented method grayscale')
    }
    colorBlend(value: arkui_component_enums_Color | string | global_resource_Resource | undefined): this {
        throw new Error('Unimplemented method colorBlend')
    }
    saturate(value: double | undefined): this {
        throw new Error('Unimplemented method saturate')
    }
    sepia(value: double | undefined): this {
        throw new Error('Unimplemented method sepia')
    }
    invert(value: double | InvertOptions | undefined): this {
        throw new Error('Unimplemented method invert')
    }
    hueRotate(value: double | string | undefined): this {
        throw new Error('Unimplemented method hueRotate')
    }
    useShadowBatching(value: boolean | undefined): this {
        throw new Error('Unimplemented method useShadowBatching')
    }
    useEffect(value: boolean | undefined): this {
        throw new Error('Unimplemented method useEffect')
    }
    renderGroup(value: boolean | undefined): this {
        throw new Error('Unimplemented method renderGroup')
    }
    freeze(value: boolean | undefined): this {
        throw new Error('Unimplemented method freeze')
    }
    translate(value: TranslateOptions | undefined): this {
        throw new Error('Unimplemented method translate')
    }
    scale(value: ScaleOptions | undefined): this {
        throw new Error('Unimplemented method scale')
    }
    rotate(value: RotateOptions | undefined): this {
        throw new Error('Unimplemented method rotate')
    }
    transform(value: Matrix4Transit | undefined): this {
        throw new Error('Unimplemented method transform')
    }
    onAppear(value: (() => void) | undefined): this {
        throw new Error('Unimplemented method onAppear')
    }
    onDisAppear(value: (() => void) | undefined): this {
        throw new Error('Unimplemented method onDisAppear')
    }
    onAttach(value: VoidCallback | undefined): this {
        throw new Error('Unimplemented method onAttach')
    }
    onDetach(value: VoidCallback | undefined): this {
        throw new Error('Unimplemented method onDetach')
    }
    onAreaChange(value: ((oldValue: Area,newValue: Area) => void) | undefined): this {
        throw new Error('Unimplemented method onAreaChange')
    }
    visibility(value: Visibility | undefined): this {
        throw new Error('Unimplemented method visibility')
    }
    flexGrow(value: double | undefined): this {
        throw new Error('Unimplemented method flexGrow')
    }
    flexShrink(value: double | undefined): this {
        throw new Error('Unimplemented method flexShrink')
    }
    flexBasis(value: double | string | undefined): this {
        throw new Error('Unimplemented method flexBasis')
    }
    alignSelf(value: ItemAlign | undefined): this {
        throw new Error('Unimplemented method alignSelf')
    }
    displayPriority(value: double | undefined): this {
        throw new Error('Unimplemented method displayPriority')
    }
    zIndex(value: int32 | undefined): this {
        throw new Error('Unimplemented method zIndex')
    }
    direction(value: Direction | undefined): this {
        throw new Error('Unimplemented method direction')
    }
    align(value: Alignment | undefined): this {
        throw new Error('Unimplemented method align')
    }
    position(value: Position | Edges | LocalizedEdges | undefined): this {
        throw new Error('Unimplemented method position')
    }
    markAnchor(value: Position | LocalizedPosition | undefined): this {
        throw new Error('Unimplemented method markAnchor')
    }
    offset(value: Position | Edges | LocalizedEdges | undefined): this {
        throw new Error('Unimplemented method offset')
    }
    enabled(value: boolean | undefined): this {
        throw new Error('Unimplemented method enabled')
    }
    alignRules(value: AlignRuleOption | LocalizedAlignRuleOptions | undefined): this {
        throw new Error('Unimplemented method alignRules')
    }
    aspectRatio(value: double | undefined): this {
        throw new Error('Unimplemented method aspectRatio')
    }
    clickEffect(value: ClickEffect | null | undefined): this {
        throw new Error('Unimplemented method clickEffect')
    }
    onDragStart(value: ((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined): this {
        throw new Error('Unimplemented method onDragStart')
    }
    onDragEnter(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        throw new Error('Unimplemented method onDragEnter')
    }
    onDragMove(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        throw new Error('Unimplemented method onDragMove')
    }
    onDragLeave(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        throw new Error('Unimplemented method onDragLeave')
    }
    onDrop(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        throw new Error('Unimplemented method onDrop')
    }
    onDragEnd(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        throw new Error('Unimplemented method onDragEnd')
    }
    allowDrop(value: Array<UniformDataType> | Array<string> | null | undefined): this {
        throw new Error('Unimplemented method allowDrop')
    }
    draggable(value: boolean | undefined): this {
        throw new Error('Unimplemented method draggable')
    }
    onPreDrag(value: Callback<PreDragStatus, void> | undefined): this {
        throw new Error('Unimplemented method onPreDrag')
    }
    linearGradient(value: LinearGradientOptions | undefined): this {
        throw new Error('Unimplemented method linearGradient')
    }
    sweepGradient(value: SweepGradientOptions | undefined): this {
        throw new Error('Unimplemented method sweepGradient')
    }
    radialGradient(value: RadialGradientOptions | undefined): this {
        throw new Error('Unimplemented method radialGradient')
    }
    motionPath(value: MotionPathOptions | undefined): this {
        throw new Error('Unimplemented method motionPath')
    }
    shadow(value: ShadowOptions | ShadowStyle | undefined): this {
        throw new Error('Unimplemented method shadow')
    }
    clip(value: boolean | undefined): this {
        throw new Error('Unimplemented method clip')
    }
    clipShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        throw new Error('Unimplemented method clipShape')
    }
    mask(value: ProgressMask | undefined): this {
        throw new Error('Unimplemented method mask')
    }
    maskShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        throw new Error('Unimplemented method maskShape')
    }
    key(value: string | undefined): this {
        throw new Error('Unimplemented method key')
    }
    id(value: string | undefined): this {
        throw new Error('Unimplemented method id')
    }
    stateStyles(value: StateStyles | undefined): this {
        throw new Error('Unimplemented method stateStyles')
    }
    restoreId(value: int32 | undefined): this {
        throw new Error('Unimplemented method restoreId')
    }
    sphericalEffect(value: double | undefined): this {
        throw new Error('Unimplemented method sphericalEffect')
    }
    lightUpEffect(value: double | undefined): this {
        throw new Error('Unimplemented method lightUpEffect')
    }
    pixelStretchEffect(value: PixelStretchEffectOptions | undefined): this {
        throw new Error('Unimplemented method pixelStretchEffect')
    }
    accessibilityNextFocusId(value: string | undefined): this {
        throw new Error('Unimplemented method accessibilityNextFocusId')
    }
    accessibilityDefaultFocus(value: boolean | undefined): this {
        throw new Error('Unimplemented method accessibilityDefaultFocus')
    }
    accessibilityUseSamePage(value: AccessibilitySamePageMode | undefined): this {
        throw new Error('Unimplemented method accessibilityUseSamePage')
    }
    accessibilityScrollTriggerable(value: boolean | undefined): this {
        throw new Error('Unimplemented method accessibilityScrollTriggerable')
    }
    accessibilityText(value: global_resource_Resource | string | undefined): this {
        throw new Error('Unimplemented method accessibilityText')
    }
    accessibilityRole(value: AccessibilityRoleType | undefined): this {
        throw new Error('Unimplemented method accessibilityRole')
    }
    onAccessibilityFocus(value: AccessibilityFocusCallback | undefined): this {
        throw new Error('Unimplemented method onAccessibilityFocus')
    }
    onAccessibilityActionIntercept(value: AccessibilityActionInterceptCallback | undefined): this {
        throw new Error('Unimplemented method onAccessibilityActionIntercept')
    }
    accessibilityTextHint(value: string | undefined): this {
        throw new Error('Unimplemented method accessibilityTextHint')
    }
    accessibilityDescription(value: global_resource_Resource | string | undefined): this {
        throw new Error('Unimplemented method accessibilityDescription')
    }
    accessibilityLevel(value: string | undefined): this {
        throw new Error('Unimplemented method accessibilityLevel')
    }
    accessibilityVirtualNode(value: CustomBuilder | undefined): this {
        throw new Error('Unimplemented method accessibilityVirtualNode')
    }
    accessibilityChecked(value: boolean | undefined): this {
        throw new Error('Unimplemented method accessibilityChecked')
    }
    accessibilitySelected(value: boolean | undefined): this {
        throw new Error('Unimplemented method accessibilitySelected')
    }
    obscured(value: Array<ObscuredReasons> | undefined): this {
        throw new Error('Unimplemented method obscured')
    }
    reuseId(value: string | undefined): this {
        throw new Error('Unimplemented method reuseId')
    }
    reuse(value: ReuseOptions | undefined): this {
        throw new Error('Unimplemented method reuse')
    }
    renderFit(value: RenderFit | undefined): this {
        throw new Error('Unimplemented method renderFit')
    }
    gestureModifier(value: GestureModifier | undefined): this {
        throw new Error('Unimplemented method gestureModifier')
    }
    backgroundBrightness(value: BackgroundBrightnessOptions | undefined): this {
        throw new Error('Unimplemented method backgroundBrightness')
    }
    onGestureJudgeBegin(value: ((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined): this {
        throw new Error('Unimplemented method onGestureJudgeBegin')
    }
    onGestureRecognizerJudgeBegin(value: GestureRecognizerJudgeBeginCallback | undefined): this {
        throw new Error('Unimplemented method onGestureRecognizerJudgeBegin')
    }
    shouldBuiltInRecognizerParallelWith(value: ShouldBuiltInRecognizerParallelWithCallback | undefined): this {
        throw new Error('Unimplemented method shouldBuiltInRecognizerParallelWith')
    }
    monopolizeEvents(value: boolean | undefined): this {
        throw new Error('Unimplemented method monopolizeEvents')
    }
    onTouchIntercept(value: Callback<TouchEvent, HitTestMode> | undefined): this {
        throw new Error('Unimplemented method onTouchIntercept')
    }
    onSizeChange(value: SizeChangeCallback | undefined): this {
        throw new Error('Unimplemented method onSizeChange')
    }
    accessibilityFocusDrawLevel(value: FocusDrawLevel | undefined): this {
        throw new Error('Unimplemented method accessibilityFocusDrawLevel')
    }
    onTouchTestDone(value: TouchTestDoneCallback | undefined): this {
        throw new Error('Unimplemented method onTouchTestDone')
    }
    customProperty(name: string, value: CustomProperty): this {
        throw new Error('Unimplemented method customProperty')
    }
    expandSafeArea(types?: Array<SafeAreaType>, edges?: Array<SafeAreaEdge>): this {
        throw new Error('Unimplemented method expandSafeArea')
    }
    background(builder: CustomBuilder | undefined, options?: BackgroundOptions): this {
        throw new Error('Unimplemented method background')
    }
    backgroundImage(src: arkui_component_units_ResourceStr | PixelMap | undefined, options: BackgroundImageOptions): this {
        throw new Error('Unimplemented method backgroundImage')
    }
    backgroundImage(src: arkui_component_units_ResourceStr | PixelMap | undefined, repeat: ImageRepeat): this {
        throw new Error('Unimplemented method backgroundImage')
    }
    backgroundBlurStyle(style: BlurStyle | undefined, options?: BackgroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        throw new Error('Unimplemented method backgroundBlurStyle')
    }
    backgroundEffect(options: BackgroundEffectOptions | undefined, sysOptions?: SystemAdaptiveOptions): this {
        throw new Error('Unimplemented method backgroundEffect')
    }
    foregroundBlurStyle(style: BlurStyle | undefined, options?: ForegroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        throw new Error('Unimplemented method foregroundBlurStyle')
    }
    onClick(event: ((event: ClickEvent) => void) | undefined, distanceThreshold: double | undefined): this {
        throw new Error('Unimplemented method onClick')
    }
    focusScopeId(id: string | undefined, isGroup?: boolean, arrowStepOut?: boolean): this {
        throw new Error('Unimplemented method focusScopeId')
    }
    focusScopePriority(scopeId: string | undefined, priority?: FocusPriority): this {
        throw new Error('Unimplemented method focusScopePriority')
    }
    transition(effect: TransitionEffect | undefined, onFinish: TransitionFinishCallback | undefined): this {
        throw new Error('Unimplemented method transition')
    }
    gesture(gesture: GestureType, mask?: GestureMask): this {
        throw new Error('Unimplemented method gesture')
    }
    priorityGesture(gesture: GestureType, mask?: GestureMask): this {
        throw new Error('Unimplemented method priorityGesture')
    }
    parallelGesture(gesture: GestureType, mask?: GestureMask): this {
        throw new Error('Unimplemented method parallelGesture')
    }
    blur(blurRadius: double | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        throw new Error('Unimplemented method blur')
    }
    linearGradientBlur(value: double | undefined, options: LinearGradientBlurOptions | undefined): this {
        throw new Error('Unimplemented method linearGradientBlur')
    }
    systemBarEffect(): this {
        throw new Error('Unimplemented method systemBarEffect')
    }
    useEffect(useEffect: boolean | undefined, effectType: EffectType | undefined): this {
        throw new Error('Unimplemented method useEffect')
    }
    backdropBlur(radius: double | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        throw new Error('Unimplemented method backdropBlur')
    }
    sharedTransition(id: string | undefined, options?: sharedTransitionOptions): this {
        throw new Error('Unimplemented method sharedTransition')
    }
    chainMode(direction: Axis | undefined, style: ChainStyle | undefined): this {
        throw new Error('Unimplemented method chainMode')
    }
    onDrop(eventCallback: OnDragEventCallback | undefined, dropOptions: DropOptions): this {
        throw new Error('Unimplemented method onDrop')
    }
    dragPreview(preview: CustomBuilder | DragItemInfo | string | undefined, config?: PreviewConfiguration): this {
        throw new Error('Unimplemented method dragPreview')
    }
    dragPreviewOptions(value: DragPreviewOptions | undefined, options?: DragInteractionOptions): this {
        throw new Error('Unimplemented method dragPreviewOptions')
    }
    overlay(value: string | CustomBuilder | ComponentContent<Object> | undefined, options?: OverlayOptions): this {
        throw new Error('Unimplemented method overlay')
    }
    blendMode(value: BlendMode | undefined, type?: BlendApplyType): this {
        throw new Error('Unimplemented method blendMode')
    }
    advancedBlendMode(effect: BlendMode | Blender | undefined, type?: BlendApplyType): this {
        throw new Error('Unimplemented method advancedBlendMode')
    }
    geometryTransition(id: string | undefined, options?: GeometryTransitionOptions): this {
        throw new Error('Unimplemented method geometryTransition')
    }
    bindTips(message: TipsMessageType | undefined, options?: TipsOptions): this {
        throw new Error('Unimplemented method bindTips')
    }
    bindPopup(show: boolean | undefined, popup: PopupOptions | CustomPopupOptions | undefined): this {
        throw new Error('Unimplemented method bindPopup')
    }
    bindMenu(content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): this {
        throw new Error('Unimplemented method bindMenu')
    }
    bindMenu(isShow: boolean | undefined, content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): this {
        throw new Error('Unimplemented method bindMenu')
    }
    bindContextMenu(content: CustomBuilder | undefined, responseType: ResponseType | undefined, options?: ContextMenuOptions): this {
        throw new Error('Unimplemented method bindContextMenu')
    }
    bindContextMenu(isShown: boolean | undefined, content: CustomBuilder | undefined, options?: ContextMenuOptions): this {
        throw new Error('Unimplemented method bindContextMenu')
    }
    bindContentCover(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, type?: ModalTransition): this {
        throw new Error('Unimplemented method bindContentCover')
    }
    bindContentCover(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, options?: ContentCoverOptions): this {
        throw new Error('Unimplemented method bindContentCover')
    }
    bindSheet(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, options?: SheetOptions): this {
        throw new Error('Unimplemented method bindSheet')
    }
    onVisibleAreaChange(ratios: Array<double> | undefined, event: VisibleAreaChangeCallback | undefined): this {
        throw new Error('Unimplemented method onVisibleAreaChange')
    }
    onVisibleAreaApproximateChange(options: VisibleAreaEventOptions | undefined, event: VisibleAreaChangeCallback | undefined): this {
        throw new Error('Unimplemented method onVisibleAreaApproximateChange')
    }
    keyboardShortcut(value: string | FunctionKey | undefined, keys: Array<ModifierKey> | undefined, action?: (() => void)): this {
        throw new Error('Unimplemented method keyboardShortcut')
    }
    accessibilityGroup(isGroup: boolean | undefined, accessibilityOptions?: AccessibilityOptions): this {
        throw new Error('Unimplemented method accessibilityGroup')
    }
    onGestureRecognizerJudgeBegin(callback_: GestureRecognizerJudgeBeginCallback | undefined, exposeInnerGesture: boolean | undefined): this {
        throw new Error('Unimplemented method onGestureRecognizerJudgeBegin')
    }
    applyAttributesFinish(): void {
    }
}
export type CommonAttribute = CommonMethod;
export interface OverlayOptions {
    align?: Alignment;
    offset?: OverlayOffset;
}
export interface OverlayOffset {
    x?: double;
    y?: double;
}
export type FractionStop = [
    double,
    double
]
export interface CommonShapeMethod extends CommonMethod {
    stroke(value: ResourceColor | undefined): this {
        throw new Error('Unimplemented method stroke')
    }
    fill(value: ResourceColor | undefined): this {
        throw new Error('Unimplemented method fill')
    }
    strokeDashOffset(value: double | string | undefined): this {
        throw new Error('Unimplemented method strokeDashOffset')
    }
    strokeLineCap(value: LineCapStyle | undefined): this {
        throw new Error('Unimplemented method strokeLineCap')
    }
    strokeLineJoin(value: LineJoinStyle | undefined): this {
        throw new Error('Unimplemented method strokeLineJoin')
    }
    strokeMiterLimit(value: double | string | undefined): this {
        throw new Error('Unimplemented method strokeMiterLimit')
    }
    strokeOpacity(value: double | string | global_resource_Resource | undefined): this {
        throw new Error('Unimplemented method strokeOpacity')
    }
    fillOpacity(value: double | string | global_resource_Resource | undefined): this {
        throw new Error('Unimplemented method fillOpacity')
    }
    strokeWidth(value: Length | undefined): this {
        throw new Error('Unimplemented method strokeWidth')
    }
    antiAlias(value: boolean | undefined): this {
        throw new Error('Unimplemented method antiAlias')
    }
    strokeDashArray(value: Array<Length> | undefined): this {
        throw new Error('Unimplemented method strokeDashArray')
    }
    attributeModifier(value: AttributeModifier<CommonShapeMethod> | AttributeModifier<CommonMethod> | undefined): this {
        throw new Error('Unimplemented method attributeModifier')
    }
}
export interface PixelRoundPolicy {
    start?: PixelRoundCalcPolicy;
    top?: PixelRoundCalcPolicy;
    end?: PixelRoundCalcPolicy;
    bottom?: PixelRoundCalcPolicy;
}
export interface LinearGradientBlurOptions {
    fractionStops: Array<FractionStop> | undefined;
    direction: GradientDirection | undefined;
}
export interface MotionBlurAnchor {
    x: double | undefined;
    y: double | undefined;
}
export interface MotionBlurOptions {
    radius: double | undefined;
    anchor: MotionBlurAnchor | undefined;
}
export interface GeometryInfo extends SizeResult {
    borderWidth: EdgeWidth;
    margin: Margin;
    padding: Padding;
}
export interface SizeResult {
    width: double;
    height: double;
}
export interface MeasureResult extends SizeResult {
}
export type NavDestinationInfo = uiObserver.NavDestinationInfo;
export type NavigationInfo = uiObserver.NavigationInfo;
export type RouterPageInfo = uiObserver.RouterPageInfo;
export type UIContext = ohos_arkui_UIContext_UIContext;
export type DrawContext = arkui_Graphics_DrawContext;
export type VisualEffect = uiEffect.VisualEffect;
export type Filter = uiEffect.Filter;
export type Blender = uiEffect.Blender;
export type PromptActionDialogController = promptAction.DialogController;
export interface RectResult {
    x: double;
    y: double;
    width: double;
    height: double;
}
export interface CaretOffset {
    index: int32;
    x: int32;
    y: int32;
}
export interface TextContentControllerOptions {
    offset?: int32;
}
export enum ContentClipMode {
    CONTENT_ONLY = 0,
    BOUNDARY = 1,
    SAFE_AREA = 2
}
export interface ScrollableCommonMethod extends CommonMethod {
    scrollBar(value: BarState | undefined): this {
        throw new Error('Unimplemented method scrollBar')
    }
    scrollBarColor(value: arkui_component_enums_Color | int32 | string | undefined): this {
        throw new Error('Unimplemented method scrollBarColor')
    }
    scrollBarWidth(value: double | string | undefined): this {
        throw new Error('Unimplemented method scrollBarWidth')
    }
    nestedScroll(value: NestedScrollOptions | undefined): this {
        throw new Error('Unimplemented method nestedScroll')
    }
    enableScrollInteraction(value: boolean | undefined): this {
        throw new Error('Unimplemented method enableScrollInteraction')
    }
    friction(value: double | global_resource_Resource | undefined): this {
        throw new Error('Unimplemented method friction')
    }
    onReachStart(value: (() => void) | undefined): this {
        throw new Error('Unimplemented method onReachStart')
    }
    onReachEnd(value: (() => void) | undefined): this {
        throw new Error('Unimplemented method onReachEnd')
    }
    onScrollStart(value: (() => void) | undefined): this {
        throw new Error('Unimplemented method onScrollStart')
    }
    onScrollStop(value: (() => void) | undefined): this {
        throw new Error('Unimplemented method onScrollStop')
    }
    flingSpeedLimit(value: double | undefined): this {
        throw new Error('Unimplemented method flingSpeedLimit')
    }
    clipContent(value: ContentClipMode | RectShape | undefined): this {
        throw new Error('Unimplemented method clipContent')
    }
    digitalCrownSensitivity(value: CrownSensitivity | undefined): this {
        throw new Error('Unimplemented method digitalCrownSensitivity')
    }
    backToTop(value: boolean | undefined): this {
        throw new Error('Unimplemented method backToTop')
    }
    edgeEffect(edgeEffect: EdgeEffect | undefined, options?: EdgeEffectOptions): this {
        throw new Error('Unimplemented method edgeEffect')
    }
    fadingEdge(enabled: boolean | undefined, options?: FadingEdgeOptions): this {
        throw new Error('Unimplemented method fadingEdge')
    }
    attributeModifier(value: AttributeModifier<ScrollableCommonMethod> | AttributeModifier<CommonMethod> | undefined): this {
        throw new Error('Unimplemented method attributeModifier')
    }
}
export type OnWillScrollCallback = (scrollOffset: double, scrollState: ScrollState, scrollSource: ScrollSource) => ScrollResult | undefined;
export type OnScrollCallback = (scrollOffset: double, scrollState: ScrollState) => void;
export type OnItemDragStartCallback = (event: ItemDragInfo, itemIndex: int32) => CustomBuilder | undefined;
export type OnMoveHandler = (from: int32, to: int32) => void;
export interface ItemDragEventHandler {
    onLongPress?: Callback<int32, void>;
    onDragStart?: Callback<int32, void>;
    onMoveThrough?: OnMoveHandler;
    onDrop?: Callback<int32, void>;
}
export interface EdgeEffectOptions {
    alwaysEnabled: boolean;
    effectEdge?: int32;
}
export enum EffectEdge {
    START = 1,
    END = 2
}
export interface BackgroundBrightnessOptions {
    rate: double;
    lightUpDegree: double;
}
export interface PointLightStyle {
    lightSource?: LightSource;
    illuminated?: IlluminatedType;
    bloom?: double;
}
export interface LightSource {
    positionX: Dimension;
    positionY: Dimension;
    positionZ: Dimension;
    intensity: double;
    color?: ResourceColor;
}
export interface KeyframeAnimateParam {
    delay?: int32;
    iterations?: int32;
    onFinish?: (() => void);
    expectedFrameRateRange?: ExpectedFrameRateRange;
}
export interface KeyframeState {
    duration: int32;
    curve?: Curve | string | ICurve;
    event: (() => void);
}
export type Callback<T,V = void> = (data: T) => V;
export type HoverCallback = (isHover: boolean, event: HoverEvent) => void;
export type AccessibilityCallback = (isHover: boolean, event: AccessibilityHoverEvent) => void;
export type AccessibilityTransparentCallback = (event: TouchEvent) => void;
export interface VisibleAreaEventOptions {
    ratios: Array<double>;
    expectedUpdateInterval?: int32;
}
export type VisibleAreaChangeCallback = (isExpanding: boolean, currentRatio: double) => void;
export interface SelectionOptions {
    menuPolicy?: MenuPolicy;
}
export interface FocusMovement {
    forward?: string;
    backward?: string;
    up?: string;
    down?: string;
    left?: string;
    right?: string;
}
export enum KeyboardAvoidMode {
    DEFAULT = 0,
    NONE = 1
}
export enum HoverModeAreaType {
    TOP_SCREEN = 0,
    BOTTOM_SCREEN = 1
}
export interface DateRange {
    start?: Date;
    end?: Date;
}
export interface TerminationInfo {
    code: int32;
    want?: Want;
}
export type DateTimeOptions = intl.DateTimeOptions;
export interface Bindable<T> {
    readonly value: T;
    readonly onChange: Callback<T, void>;
}
export type BindableResourceStr = arkui_component_units_ResourceStr | Bindable<arkui_component_units_ResourceStr> | Bindable<global_resource_Resource> | Bindable<string>;
export type BindableResourceStrArray = Array<arkui_component_units_ResourceStr> | Bindable<Array<arkui_component_units_ResourceStr>> | Bindable<Array<global_resource_Resource>> | Bindable<Array<string>>;
export class ArkCommonMethodComponent extends ComponentBase implements CommonMethod {
    getPeer(): ArkCommonMethodPeer {
        return (this.peer as ArkCommonMethodPeer)
    }
    public width(value: Length | LayoutPolicy | undefined): this {
        if (this.checkPriority('width')) {
            const value_casted = value as (Length | LayoutPolicy | undefined)
            this.getPeer()?.setWidthAttribute(value_casted)
            return this
        }
        return this
    }
    public height(value: Length | LayoutPolicy | undefined): this {
        if (this.checkPriority('height')) {
            const value_casted = value as (Length | LayoutPolicy | undefined)
            this.getPeer()?.setHeightAttribute(value_casted)
            return this
        }
        return this
    }
    public drawModifier(value: DrawModifier | undefined): this {
        if (this.checkPriority('drawModifier')) {
            hookDrawModifier(this, value)
        }
        return this
    }
    public responseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        if (this.checkPriority('responseRegion')) {
            const value_casted = value as (Array<Rectangle> | Rectangle | undefined)
            this.getPeer()?.setResponseRegionAttribute(value_casted)
            return this
        }
        return this
    }
    public mouseResponseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        if (this.checkPriority('mouseResponseRegion')) {
            const value_casted = value as (Array<Rectangle> | Rectangle | undefined)
            this.getPeer()?.setMouseResponseRegionAttribute(value_casted)
            return this
        }
        return this
    }
    public size(value: SizeOptions | undefined): this {
        if (this.checkPriority('size')) {
            const value_casted = value as (SizeOptions | undefined)
            this.getPeer()?.setSizeAttribute(value_casted)
            return this
        }
        return this
    }
    public constraintSize(value: ConstraintSizeOptions | undefined): this {
        if (this.checkPriority('constraintSize')) {
            const value_casted = value as (ConstraintSizeOptions | undefined)
            this.getPeer()?.setConstraintSizeAttribute(value_casted)
            return this
        }
        return this
    }
    public hitTestBehavior(value: HitTestMode | undefined): this {
        if (this.checkPriority('hitTestBehavior')) {
            const value_casted = value as (HitTestMode | undefined)
            this.getPeer()?.setHitTestBehaviorAttribute(value_casted)
            return this
        }
        return this
    }
    public onChildTouchTest(value: ((value: Array<TouchTestInfo>) => TouchResult) | undefined): this {
        if (this.checkPriority('onChildTouchTest')) {
            const value_casted = value as (((value: Array<TouchTestInfo>) => TouchResult) | undefined)
            this.getPeer()?.setOnChildTouchTestAttribute(value_casted)
            return this
        }
        return this
    }
    public layoutWeight(value: double | string | undefined): this {
        if (this.checkPriority('layoutWeight')) {
            const value_casted = value as (double | string | undefined)
            this.getPeer()?.setLayoutWeightAttribute(value_casted)
            return this
        }
        return this
    }
    public chainWeight(value: ChainWeightOptions | undefined): this {
        if (this.checkPriority('chainWeight')) {
            const value_casted = value as (ChainWeightOptions | undefined)
            this.getPeer()?.setChainWeightAttribute(value_casted)
            return this
        }
        return this
    }
    public padding(value: Padding | Length | LocalizedPadding | undefined): this {
        if (this.checkPriority('padding')) {
            const value_casted = value as (Padding | Length | LocalizedPadding | undefined)
            this.getPeer()?.setPaddingAttribute(value_casted)
            return this
        }
        return this
    }
    public safeAreaPadding(value: Padding | arkui_Graphics_LengthMetrics | LocalizedPadding | undefined): this {
        if (this.checkPriority('safeAreaPadding')) {
            const value_casted = value as (Padding | arkui_Graphics_LengthMetrics | LocalizedPadding | undefined)
            this.getPeer()?.setSafeAreaPaddingAttribute(value_casted)
            return this
        }
        return this
    }
    public margin(value: Margin | Length | LocalizedMargin | undefined): this {
        if (this.checkPriority('margin')) {
            const value_casted = value as (Margin | Length | LocalizedMargin | undefined)
            this.getPeer()?.setMarginAttribute(value_casted)
            return this
        }
        return this
    }
    public backgroundColor(value: ResourceColor | arkui_component_units_ColorMetrics | undefined): this {
        if (this.checkPriority('backgroundColor')) {
            const value_casted = value as (ResourceColor | arkui_component_units_ColorMetrics | undefined)
            this.getPeer()?.setBackgroundColorAttribute(value_casted)
            return this
        }
        return this
    }
    public pixelRound(value: PixelRoundPolicy | undefined): this {
        if (this.checkPriority('pixelRound')) {
            const value_casted = value as (PixelRoundPolicy | undefined)
            this.getPeer()?.setPixelRoundAttribute(value_casted)
            return this
        }
        return this
    }
    public backgroundImage(value: arkui_component_units_ResourceStr | PixelMap | undefined): this {
        if (this.checkPriority('backgroundImage')) {
            const value_casted = value as (arkui_component_units_ResourceStr | PixelMap | undefined)
            this.getPeer()?.setBackgroundImage0Attribute(value_casted)
            return this
        }
        return this
    }
    public backgroundImageSize(value: SizeOptions | ImageSize | undefined): this {
        if (this.checkPriority('backgroundImageSize')) {
            const value_casted = value as (SizeOptions | ImageSize | undefined)
            this.getPeer()?.setBackgroundImageSizeAttribute(value_casted)
            return this
        }
        return this
    }
    public backgroundImagePosition(value: Position | Alignment | undefined): this {
        if (this.checkPriority('backgroundImagePosition')) {
            const value_casted = value as (Position | Alignment | undefined)
            this.getPeer()?.setBackgroundImagePositionAttribute(value_casted)
            return this
        }
        return this
    }
    public backgroundImageResizable(value: ResizableOptions | undefined): this {
        if (this.checkPriority('backgroundImageResizable')) {
            const value_casted = value as (ResizableOptions | undefined)
            this.getPeer()?.setBackgroundImageResizableAttribute(value_casted)
            return this
        }
        return this
    }
    public foregroundEffect(value: ForegroundEffectOptions | undefined): this {
        if (this.checkPriority('foregroundEffect')) {
            const value_casted = value as (ForegroundEffectOptions | undefined)
            this.getPeer()?.setForegroundEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public visualEffect(value: VisualEffect | undefined): this {
        if (this.checkPriority('visualEffect')) {
            const value_casted = value as (VisualEffect | undefined)
            this.getPeer()?.setVisualEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public backgroundFilter(value: Filter | undefined): this {
        if (this.checkPriority('backgroundFilter')) {
            const value_casted = value as (Filter | undefined)
            this.getPeer()?.setBackgroundFilterAttribute(value_casted)
            return this
        }
        return this
    }
    public foregroundFilter(value: Filter | undefined): this {
        if (this.checkPriority('foregroundFilter')) {
            const value_casted = value as (Filter | undefined)
            this.getPeer()?.setForegroundFilterAttribute(value_casted)
            return this
        }
        return this
    }
    public compositingFilter(value: Filter | undefined): this {
        if (this.checkPriority('compositingFilter')) {
            const value_casted = value as (Filter | undefined)
            this.getPeer()?.setCompositingFilterAttribute(value_casted)
            return this
        }
        return this
    }
    public opacity(value: double | global_resource_Resource | undefined): this {
        if (this.checkPriority('opacity')) {
            const value_casted = value as (double | global_resource_Resource | undefined)
            this.getPeer()?.setOpacityAttribute(value_casted)
            return this
        }
        return this
    }
    public border(value: BorderOptions | undefined): this {
        if (this.checkPriority('border')) {
            const value_casted = value as (BorderOptions | undefined)
            this.getPeer()?.setBorderAttribute(value_casted)
            return this
        }
        return this
    }
    public borderStyle(value: BorderStyle | EdgeStyles | undefined): this {
        if (this.checkPriority('borderStyle')) {
            const value_casted = value as (BorderStyle | EdgeStyles | undefined)
            this.getPeer()?.setBorderStyleAttribute(value_casted)
            return this
        }
        return this
    }
    public borderWidth(value: Length | EdgeWidths | LocalizedEdgeWidths | undefined): this {
        if (this.checkPriority('borderWidth')) {
            const value_casted = value as (Length | EdgeWidths | LocalizedEdgeWidths | undefined)
            this.getPeer()?.setBorderWidthAttribute(value_casted)
            return this
        }
        return this
    }
    public borderColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        if (this.checkPriority('borderColor')) {
            const value_casted = value as (ResourceColor | EdgeColors | LocalizedEdgeColors | undefined)
            this.getPeer()?.setBorderColorAttribute(value_casted)
            return this
        }
        return this
    }
    public borderRadius(value: Length | BorderRadiuses | LocalizedBorderRadiuses | undefined): this {
        if (this.checkPriority('borderRadius')) {
            const value_casted = value as (Length | BorderRadiuses | LocalizedBorderRadiuses | undefined)
            this.getPeer()?.setBorderRadiusAttribute(value_casted)
            return this
        }
        return this
    }
    public borderImage(value: BorderImageOption | undefined): this {
        if (this.checkPriority('borderImage')) {
            const value_casted = value as (BorderImageOption | undefined)
            this.getPeer()?.setBorderImageAttribute(value_casted)
            return this
        }
        return this
    }
    public outline(value: OutlineOptions | undefined): this {
        if (this.checkPriority('outline')) {
            const value_casted = value as (OutlineOptions | undefined)
            this.getPeer()?.setOutlineAttribute(value_casted)
            return this
        }
        return this
    }
    public outlineStyle(value: OutlineStyle | EdgeOutlineStyles | undefined): this {
        if (this.checkPriority('outlineStyle')) {
            const value_casted = value as (OutlineStyle | EdgeOutlineStyles | undefined)
            this.getPeer()?.setOutlineStyleAttribute(value_casted)
            return this
        }
        return this
    }
    public outlineWidth(value: Dimension | EdgeOutlineWidths | undefined): this {
        if (this.checkPriority('outlineWidth')) {
            const value_casted = value as (Dimension | EdgeOutlineWidths | undefined)
            this.getPeer()?.setOutlineWidthAttribute(value_casted)
            return this
        }
        return this
    }
    public outlineColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        if (this.checkPriority('outlineColor')) {
            const value_casted = value as (ResourceColor | EdgeColors | LocalizedEdgeColors | undefined)
            this.getPeer()?.setOutlineColorAttribute(value_casted)
            return this
        }
        return this
    }
    public outlineRadius(value: Dimension | OutlineRadiuses | undefined): this {
        if (this.checkPriority('outlineRadius')) {
            const value_casted = value as (Dimension | OutlineRadiuses | undefined)
            this.getPeer()?.setOutlineRadiusAttribute(value_casted)
            return this
        }
        return this
    }
    public foregroundColor(value: ResourceColor | ColoringStrategy | undefined): this {
        if (this.checkPriority('foregroundColor')) {
            const value_casted = value as (ResourceColor | ColoringStrategy | undefined)
            this.getPeer()?.setForegroundColorAttribute(value_casted)
            return this
        }
        return this
    }
    public onClick(value: ((event: ClickEvent) => void) | undefined): this {
        if (this.checkPriority('onClick')) {
            const value_casted = value as (((event: ClickEvent) => void) | undefined)
            this.getPeer()?.setOnClick0Attribute(value_casted)
            return this
        }
        return this
    }
    public onHover(value: ((isHover: boolean,event: HoverEvent) => void) | undefined): this {
        if (this.checkPriority('onHover')) {
            const value_casted = value as (((isHover: boolean,event: HoverEvent) => void) | undefined)
            this.getPeer()?.setOnHoverAttribute(value_casted)
            return this
        }
        return this
    }
    public onHoverMove(value: Callback<HoverEvent, void> | undefined): this {
        if (this.checkPriority('onHoverMove')) {
            const value_casted = value as (Callback<HoverEvent, void> | undefined)
            this.getPeer()?.setOnHoverMoveAttribute(value_casted)
            return this
        }
        return this
    }
    public onAccessibilityHover(value: AccessibilityCallback | undefined): this {
        if (this.checkPriority('onAccessibilityHover')) {
            const value_casted = value as (AccessibilityCallback | undefined)
            this.getPeer()?.setOnAccessibilityHoverAttribute(value_casted)
            return this
        }
        return this
    }
    public onAccessibilityHoverTransparent(value: AccessibilityTransparentCallback | undefined): this {
        if (this.checkPriority('onAccessibilityHoverTransparent')) {
            const value_casted = value as (AccessibilityTransparentCallback | undefined)
            this.getPeer()?.setOnAccessibilityHoverTransparentAttribute(value_casted)
            return this
        }
        return this
    }
    public hoverEffect(value: HoverEffect | undefined): this {
        if (this.checkPriority('hoverEffect')) {
            const value_casted = value as (HoverEffect | undefined)
            this.getPeer()?.setHoverEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public onMouse(value: ((event: MouseEvent) => void) | undefined): this {
        if (this.checkPriority('onMouse')) {
            const value_casted = value as (((event: MouseEvent) => void) | undefined)
            this.getPeer()?.setOnMouseAttribute(value_casted)
            return this
        }
        return this
    }
    public onTouch(value: ((event: TouchEvent) => void) | undefined): this {
        if (this.checkPriority('onTouch')) {
            const value_casted = value as (((event: TouchEvent) => void) | undefined)
            this.getPeer()?.setOnTouchAttribute(value_casted)
            return this
        }
        return this
    }
    public onKeyEvent(value: Callback<KeyEvent, boolean> | undefined): this {
        if (this.checkPriority('onKeyEvent')) {
            const value_casted = value as (Callback<KeyEvent, boolean> | undefined)
            this.getPeer()?.setOnKeyEventAttribute(value_casted)
            return this
        }
        return this
    }
    public onDigitalCrown(value: Callback<CrownEvent, void> | undefined): this {
        if (this.checkPriority('onDigitalCrown')) {
            const value_casted = value as (Callback<CrownEvent, void> | undefined)
            this.getPeer()?.setOnDigitalCrownAttribute(value_casted)
            return this
        }
        return this
    }
    public onKeyPreIme(value: Callback<KeyEvent, boolean> | undefined): this {
        if (this.checkPriority('onKeyPreIme')) {
            const value_casted = value as (Callback<KeyEvent, boolean> | undefined)
            this.getPeer()?.setOnKeyPreImeAttribute(value_casted)
            return this
        }
        return this
    }
    public onKeyEventDispatch(value: Callback<KeyEvent, boolean> | undefined): this {
        if (this.checkPriority('onKeyEventDispatch')) {
            const value_casted = value as (Callback<KeyEvent, boolean> | undefined)
            this.getPeer()?.setOnKeyEventDispatchAttribute(value_casted)
            return this
        }
        return this
    }
    public onFocusAxisEvent(value: Callback<FocusAxisEvent, void> | undefined): this {
        if (this.checkPriority('onFocusAxisEvent')) {
            const value_casted = value as (Callback<FocusAxisEvent, void> | undefined)
            this.getPeer()?.setOnFocusAxisEventAttribute(value_casted)
            return this
        }
        return this
    }
    public onAxisEvent(value: Callback<AxisEvent, void> | undefined): this {
        if (this.checkPriority('onAxisEvent')) {
            const value_casted = value as (Callback<AxisEvent, void> | undefined)
            this.getPeer()?.setOnAxisEventAttribute(value_casted)
            return this
        }
        return this
    }
    public focusable(value: boolean | undefined): this {
        if (this.checkPriority('focusable')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setFocusableAttribute(value_casted)
            return this
        }
        return this
    }
    public nextFocus(value: FocusMovement | undefined): this {
        if (this.checkPriority('nextFocus')) {
            const value_casted = value as (FocusMovement | undefined)
            this.getPeer()?.setNextFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public tabStop(value: boolean | undefined): this {
        if (this.checkPriority('tabStop')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setTabStopAttribute(value_casted)
            return this
        }
        return this
    }
    public onFocus(value: (() => void) | undefined): this {
        if (this.checkPriority('onFocus')) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public onBlur(value: (() => void) | undefined): this {
        if (this.checkPriority('onBlur')) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnBlurAttribute(value_casted)
            return this
        }
        return this
    }
    public tabIndex(value: int32 | undefined): this {
        if (this.checkPriority('tabIndex')) {
            const value_casted = value as (int32 | undefined)
            this.getPeer()?.setTabIndexAttribute(value_casted)
            return this
        }
        return this
    }
    public defaultFocus(value: boolean | undefined): this {
        if (this.checkPriority('defaultFocus')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setDefaultFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public groupDefaultFocus(value: boolean | undefined): this {
        if (this.checkPriority('groupDefaultFocus')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setGroupDefaultFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public focusOnTouch(value: boolean | undefined): this {
        if (this.checkPriority('focusOnTouch')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setFocusOnTouchAttribute(value_casted)
            return this
        }
        return this
    }
    public focusBox(value: FocusBoxStyle | undefined): this {
        if (this.checkPriority('focusBox')) {
            const value_casted = value as (FocusBoxStyle | undefined)
            this.getPeer()?.setFocusBoxAttribute(value_casted)
            return this
        }
        return this
    }
    // instructive change start
    public animationStart(value: AnimateParam | undefined): this {
        if (this.checkPriority("animationStart")) {
            _animationStart(this.getPeer()?.getPeerPtr(), value, this.isFirstBuild);
            return this
        }
        return this
    }
    public animationStop(value: AnimateParam | undefined): this {
        if (this.checkPriority("animationStop")) {
            _animationStop(this.getPeer()?.getPeerPtr(), value, this.isFirstBuild);
            return this
        }
        return this
    }
    // instructive change end
    public transition(value: TransitionEffect | undefined): this {
        if (this.checkPriority('transition')) {
            const value_casted = value as (TransitionEffect | undefined)
            this.getPeer()?.setTransition0Attribute(value_casted)
            return this
        }
        return this
    }
    public motionBlur(value: MotionBlurOptions | undefined): this {
        if (this.checkPriority('motionBlur')) {
            const value_casted = value as (MotionBlurOptions | undefined)
            this.getPeer()?.setMotionBlurAttribute(value_casted)
            return this
        }
        return this
    }
    public brightness(value: double | undefined): this {
        if (this.checkPriority('brightness')) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setBrightnessAttribute(value_casted)
            return this
        }
        return this
    }
    public contrast(value: double | undefined): this {
        if (this.checkPriority('contrast')) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setContrastAttribute(value_casted)
            return this
        }
        return this
    }
    public grayscale(value: double | undefined): this {
        if (this.checkPriority('grayscale')) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setGrayscaleAttribute(value_casted)
            return this
        }
        return this
    }
    public colorBlend(value: arkui_component_enums_Color | string | global_resource_Resource | undefined): this {
        if (this.checkPriority('colorBlend')) {
            const value_casted = value as (arkui_component_enums_Color | string | global_resource_Resource | undefined)
            this.getPeer()?.setColorBlendAttribute(value_casted)
            return this
        }
        return this
    }
    public saturate(value: double | undefined): this {
        if (this.checkPriority('saturate')) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setSaturateAttribute(value_casted)
            return this
        }
        return this
    }
    public sepia(value: double | undefined): this {
        if (this.checkPriority('sepia')) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setSepiaAttribute(value_casted)
            return this
        }
        return this
    }
    public invert(value: double | InvertOptions | undefined): this {
        if (this.checkPriority('invert')) {
            const value_casted = value as (double | InvertOptions | undefined)
            this.getPeer()?.setInvertAttribute(value_casted)
            return this
        }
        return this
    }
    public hueRotate(value: double | string | undefined): this {
        if (this.checkPriority('hueRotate')) {
            const value_casted = value as (double | string | undefined)
            this.getPeer()?.setHueRotateAttribute(value_casted)
            return this
        }
        return this
    }
    public useShadowBatching(value: boolean | undefined): this {
        if (this.checkPriority('useShadowBatching')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setUseShadowBatchingAttribute(value_casted)
            return this
        }
        return this
    }
    public useEffect(value: boolean | undefined): this {
        if (this.checkPriority('useEffect')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setUseEffect0Attribute(value_casted)
            return this
        }
        return this
    }
    public renderGroup(value: boolean | undefined): this {
        if (this.checkPriority('renderGroup')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setRenderGroupAttribute(value_casted)
            return this
        }
        return this
    }
    public freeze(value: boolean | undefined): this {
        if (this.checkPriority('freeze')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setFreezeAttribute(value_casted)
            return this
        }
        return this
    }
    public translate(value: TranslateOptions | undefined): this {
        if (this.checkPriority('translate')) {
            const value_casted = value as (TranslateOptions | undefined)
            this.getPeer()?.setTranslateAttribute(value_casted)
            return this
        }
        return this
    }
    public scale(value: ScaleOptions | undefined): this {
        if (this.checkPriority('scale')) {
            const value_casted = value as (ScaleOptions | undefined)
            this.getPeer()?.setScaleAttribute(value_casted)
            return this
        }
        return this
    }
    public rotate(value: RotateOptions | undefined): this {
        if (this.checkPriority('rotate')) {
            const value_casted = value as (RotateOptions | undefined)
            this.getPeer()?.setRotateAttribute(value_casted)
            return this
        }
        return this
    }
    public transform(value: Matrix4Transit | undefined): this {
        if (this.checkPriority('transform')) {
            const value_casted = value as (Matrix4Transit | undefined)
            this.getPeer()?.setTransformAttribute(value_casted)
            return this
        }
        return this
    }
    public onAppear(value: (() => void) | undefined): this {
        if (this.checkPriority('onAppear')) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnAppearAttribute(value_casted)
            return this
        }
        return this
    }
    public onDisAppear(value: (() => void) | undefined): this {
        if (this.checkPriority('onDisAppear')) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnDisAppearAttribute(value_casted)
            return this
        }
        return this
    }
    public onAttach(value: VoidCallback | undefined): this {
        if (this.checkPriority('onAttach')) {
            const value_casted = value as (VoidCallback | undefined)
            this.getPeer()?.setOnAttachAttribute(value_casted)
            return this
        }
        return this
    }
    public onDetach(value: VoidCallback | undefined): this {
        if (this.checkPriority('onDetach')) {
            const value_casted = value as (VoidCallback | undefined)
            this.getPeer()?.setOnDetachAttribute(value_casted)
            return this
        }
        return this
    }
    public onAreaChange(value: ((oldValue: Area,newValue: Area) => void) | undefined): this {
        if (this.checkPriority('onAreaChange')) {
            const value_casted = value as (((oldValue: Area,newValue: Area) => void) | undefined)
            this.getPeer()?.setOnAreaChangeAttribute(value_casted)
            return this
        }
        return this
    }
    public visibility(value: Visibility | undefined): this {
        if (this.checkPriority('visibility')) {
            const value_casted = value as (Visibility | undefined)
            this.getPeer()?.setVisibilityAttribute(value_casted)
            return this
        }
        return this
    }
    public flexGrow(value: double | undefined): this {
        if (this.checkPriority('flexGrow')) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setFlexGrowAttribute(value_casted)
            return this
        }
        return this
    }
    public flexShrink(value: double | undefined): this {
        if (this.checkPriority('flexShrink')) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setFlexShrinkAttribute(value_casted)
            return this
        }
        return this
    }
    public flexBasis(value: double | string | undefined): this {
        if (this.checkPriority('flexBasis')) {
            const value_casted = value as (double | string | undefined)
            this.getPeer()?.setFlexBasisAttribute(value_casted)
            return this
        }
        return this
    }
    public alignSelf(value: ItemAlign | undefined): this {
        if (this.checkPriority('alignSelf')) {
            const value_casted = value as (ItemAlign | undefined)
            this.getPeer()?.setAlignSelfAttribute(value_casted)
            return this
        }
        return this
    }
    public displayPriority(value: double | undefined): this {
        if (this.checkPriority('displayPriority')) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setDisplayPriorityAttribute(value_casted)
            return this
        }
        return this
    }
    public zIndex(value: int32 | undefined): this {
        if (this.checkPriority('zIndex')) {
            const value_casted = value as (int32 | undefined)
            this.getPeer()?.setZIndexAttribute(value_casted)
            return this
        }
        return this
    }
    public direction(value: Direction | undefined): this {
        if (this.checkPriority('direction')) {
            const value_casted = value as (Direction | undefined)
            this.getPeer()?.setDirectionAttribute(value_casted)
            return this
        }
        return this
    }
    public align(value: Alignment | undefined): this {
        if (this.checkPriority('align')) {
            const value_casted = value as (Alignment | undefined)
            this.getPeer()?.setAlignAttribute(value_casted)
            return this
        }
        return this
    }
    public position(value: Position | Edges | LocalizedEdges | undefined): this {
        if (this.checkPriority('position')) {
            const value_casted = value as (Position | Edges | LocalizedEdges | undefined)
            this.getPeer()?.setPositionAttribute(value_casted)
            return this
        }
        return this
    }
    public markAnchor(value: Position | LocalizedPosition | undefined): this {
        if (this.checkPriority('markAnchor')) {
            const value_casted = value as (Position | LocalizedPosition | undefined)
            this.getPeer()?.setMarkAnchorAttribute(value_casted)
            return this
        }
        return this
    }
    public offset(value: Position | Edges | LocalizedEdges | undefined): this {
        if (this.checkPriority('offset')) {
            const value_casted = value as (Position | Edges | LocalizedEdges | undefined)
            this.getPeer()?.setOffsetAttribute(value_casted)
            return this
        }
        return this
    }
    public enabled(value: boolean | undefined): this {
        if (this.checkPriority('enabled')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setEnabledAttribute(value_casted)
            return this
        }
        return this
    }
    public alignRules(value: AlignRuleOption | LocalizedAlignRuleOptions | undefined): this {
        if (this.checkPriority('alignRules')) {
            const value_casted = value as (AlignRuleOption | LocalizedAlignRuleOptions | undefined)
            this.getPeer()?.setAlignRulesAttribute(value_casted)
            return this
        }
        return this
    }
    public aspectRatio(value: double | undefined): this {
        if (this.checkPriority('aspectRatio')) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setAspectRatioAttribute(value_casted)
            return this
        }
        return this
    }
    public clickEffect(value: ClickEffect | null | undefined): this {
        if (this.checkPriority('clickEffect')) {
            const value_casted = value as (ClickEffect | null | undefined)
            this.getPeer()?.setClickEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public onDragStart(value: ((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined): this {
        if (this.checkPriority('onDragStart')) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined)
            this.getPeer()?.setOnDragStartAttribute(value_casted)
            return this
        }
        return this
    }
    public onDragEnter(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        if (this.checkPriority('onDragEnter')) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => void) | undefined)
            this.getPeer()?.setOnDragEnterAttribute(value_casted)
            return this
        }
        return this
    }
    public onDragMove(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        if (this.checkPriority('onDragMove')) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => void) | undefined)
            this.getPeer()?.setOnDragMoveAttribute(value_casted)
            return this
        }
        return this
    }
    public onDragLeave(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        if (this.checkPriority('onDragLeave')) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => void) | undefined)
            this.getPeer()?.setOnDragLeaveAttribute(value_casted)
            return this
        }
        return this
    }
    public onDrop(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        if (this.checkPriority('onDrop')) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => void) | undefined)
            this.getPeer()?.setOnDrop0Attribute(value_casted)
            return this
        }
        return this
    }
    public onDragEnd(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        if (this.checkPriority('onDragEnd')) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => void) | undefined)
            this.getPeer()?.setOnDragEndAttribute(value_casted)
            return this
        }
        return this
    }
    public allowDrop(value: Array<UniformDataType> | Array<string> | null | undefined): this {
        if (this.checkPriority('allowDrop')) {
            hookAllowDrop(this, value)
        }
        return this
    }
    public draggable(value: boolean | undefined): this {
        if (this.checkPriority('draggable')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setDraggableAttribute(value_casted)
            return this
        }
        return this
    }
    public onPreDrag(value: Callback<PreDragStatus, void> | undefined): this {
        if (this.checkPriority('onPreDrag')) {
            const value_casted = value as (Callback<PreDragStatus, void> | undefined)
            this.getPeer()?.setOnPreDragAttribute(value_casted)
            return this
        }
        return this
    }
    public linearGradient(value: LinearGradientOptions | undefined): this {
        if (this.checkPriority('linearGradient')) {
            const value_casted = value as (LinearGradientOptions | undefined)
            this.getPeer()?.setLinearGradientAttribute(value_casted)
            return this
        }
        return this
    }
    public sweepGradient(value: SweepGradientOptions | undefined): this {
        if (this.checkPriority('sweepGradient')) {
            const value_casted = value as (SweepGradientOptions | undefined)
            this.getPeer()?.setSweepGradientAttribute(value_casted)
            return this
        }
        return this
    }
    public radialGradient(value: RadialGradientOptions | undefined): this {
        if (this.checkPriority('radialGradient')) {
            const value_casted = value as (RadialGradientOptions | undefined)
            this.getPeer()?.setRadialGradientAttribute(value_casted)
            return this
        }
        return this
    }
    public motionPath(value: MotionPathOptions | undefined): this {
        if (this.checkPriority('motionPath')) {
            const value_casted = value as (MotionPathOptions | undefined)
            this.getPeer()?.setMotionPathAttribute(value_casted)
            return this
        }
        return this
    }
    public shadow(value: ShadowOptions | ShadowStyle | undefined): this {
        if (this.checkPriority('shadow')) {
            const value_casted = value as (ShadowOptions | ShadowStyle | undefined)
            this.getPeer()?.setShadowAttribute(value_casted)
            return this
        }
        return this
    }
    public clip(value: boolean | undefined): this {
        if (this.checkPriority('clip')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setClipAttribute(value_casted)
            return this
        }
        return this
    }
    public clipShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        if (this.checkPriority('clipShape')) {
            const value_casted = value as (CircleShape | EllipseShape | PathShape | RectShape | undefined)
            this.getPeer()?.setClipShapeAttribute(value_casted)
            return this
        }
        return this
    }
    public mask(value: ProgressMask | undefined): this {
        if (this.checkPriority('mask')) {
            const value_casted = value as (ProgressMask | undefined)
            this.getPeer()?.setMaskAttribute(value_casted)
            return this
        }
        return this
    }
    public maskShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        if (this.checkPriority('maskShape')) {
            const value_casted = value as (CircleShape | EllipseShape | PathShape | RectShape | undefined)
            this.getPeer()?.setMaskShapeAttribute(value_casted)
            return this
        }
        return this
    }
    public key(value: string | undefined): this {
        if (this.checkPriority('key')) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setKeyAttribute(value_casted)
            return this
        }
        return this
    }
    public id(value: string | undefined): this {
        if (this.checkPriority('id')) {
            hookId(this, value)
            const value_casted = value as (string | undefined)
            this.getPeer()?.setIdAttribute(value_casted)
            return this
        }
        return this
    }
    public stateStyles(value: StateStyles | undefined): this {
        if (this.checkPriority('stateStyles')) {
            hookStateStyleImpl(this, value)
        }
        return this
    }
    public restoreId(value: int32 | undefined): this {
        if (this.checkPriority('restoreId')) {
            const value_casted = value as (int32 | undefined)
            this.getPeer()?.setRestoreIdAttribute(value_casted)
            return this
        }
        return this
    }
    public sphericalEffect(value: double | undefined): this {
        if (this.checkPriority('sphericalEffect')) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setSphericalEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public lightUpEffect(value: double | undefined): this {
        if (this.checkPriority('lightUpEffect')) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setLightUpEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public pixelStretchEffect(value: PixelStretchEffectOptions | undefined): this {
        if (this.checkPriority('pixelStretchEffect')) {
            const value_casted = value as (PixelStretchEffectOptions | undefined)
            this.getPeer()?.setPixelStretchEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityNextFocusId(value: string | undefined): this {
        if (this.checkPriority('accessibilityNextFocusId')) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setAccessibilityNextFocusIdAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityDefaultFocus(value: boolean | undefined): this {
        if (this.checkPriority('accessibilityDefaultFocus')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setAccessibilityDefaultFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityUseSamePage(value: AccessibilitySamePageMode | undefined): this {
        if (this.checkPriority('accessibilityUseSamePage')) {
            const value_casted = value as (AccessibilitySamePageMode | undefined)
            this.getPeer()?.setAccessibilityUseSamePageAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityScrollTriggerable(value: boolean | undefined): this {
        if (this.checkPriority('accessibilityScrollTriggerable')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setAccessibilityScrollTriggerableAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityText(value: global_resource_Resource | string | undefined): this {
        if (this.checkPriority('accessibilityText')) {
            const value_casted = value as (global_resource_Resource | string | undefined)
            this.getPeer()?.setAccessibilityTextAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityRole(value: AccessibilityRoleType | undefined): this {
        if (this.checkPriority('accessibilityRole')) {
            const value_casted = value as (AccessibilityRoleType | undefined)
            this.getPeer()?.setAccessibilityRoleAttribute(value_casted)
            return this
        }
        return this
    }
    public onAccessibilityFocus(value: AccessibilityFocusCallback | undefined): this {
        if (this.checkPriority('onAccessibilityFocus')) {
            const value_casted = value as (AccessibilityFocusCallback | undefined)
            this.getPeer()?.setOnAccessibilityFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public onAccessibilityActionIntercept(value: AccessibilityActionInterceptCallback | undefined): this {
        if (this.checkPriority('onAccessibilityActionIntercept')) {
            const value_casted = value as (AccessibilityActionInterceptCallback | undefined)
            this.getPeer()?.setOnAccessibilityActionInterceptAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityTextHint(value: string | undefined): this {
        if (this.checkPriority('accessibilityTextHint')) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setAccessibilityTextHintAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityDescription(value: global_resource_Resource | string | undefined): this {
        if (this.checkPriority('accessibilityDescription')) {
            const value_casted = value as (global_resource_Resource | string | undefined)
            this.getPeer()?.setAccessibilityDescriptionAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityLevel(value: string | undefined): this {
        if (this.checkPriority('accessibilityLevel')) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setAccessibilityLevelAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityVirtualNode(value: CustomBuilder | undefined): this {
        if (this.checkPriority('accessibilityVirtualNode')) {
            const value_casted = value as (CustomBuilder | undefined)
            this.getPeer()?.setAccessibilityVirtualNodeAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityChecked(value: boolean | undefined): this {
        if (this.checkPriority('accessibilityChecked')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setAccessibilityCheckedAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilitySelected(value: boolean | undefined): this {
        if (this.checkPriority('accessibilitySelected')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setAccessibilitySelectedAttribute(value_casted)
            return this
        }
        return this
    }
    public obscured(value: Array<ObscuredReasons> | undefined): this {
        if (this.checkPriority('obscured')) {
            const value_casted = value as (Array<ObscuredReasons> | undefined)
            this.getPeer()?.setObscuredAttribute(value_casted)
            return this
        }
        return this
    }
    public reuseId(value: string | undefined): this {
        if (this.checkPriority('reuseId')) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setReuseIdAttribute(value_casted)
            return this
        }
        return this
    }
    public reuse(value: ReuseOptions | undefined): this {
        if (this.checkPriority('reuse')) {
            const value_casted = value as (ReuseOptions | undefined)
            this.getPeer()?.setReuseAttribute(value_casted)
            return this
        }
        return this
    }
    public renderFit(value: RenderFit | undefined): this {
        if (this.checkPriority('renderFit')) {
            const value_casted = value as (RenderFit | undefined)
            this.getPeer()?.setRenderFitAttribute(value_casted)
            return this
        }
        return this
    }
    public gestureModifier(value: GestureModifier | undefined): this {
        if (this.checkPriority('gestureModifier')) {
            hookGestureModifier(this, value)
        }
        return this
    }
    public backgroundBrightness(value: BackgroundBrightnessOptions | undefined): this {
        if (this.checkPriority('backgroundBrightness')) {
            const value_casted = value as (BackgroundBrightnessOptions | undefined)
            this.getPeer()?.setBackgroundBrightnessAttribute(value_casted)
            return this
        }
        return this
    }
    public onGestureJudgeBegin(value: ((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined): this {
        if (this.checkPriority('onGestureJudgeBegin')) {
            const value_casted = value as (((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined)
            this.getPeer()?.setOnGestureJudgeBeginAttribute(value_casted)
            return this
        }
        return this
    }
    public onGestureRecognizerJudgeBegin(value: GestureRecognizerJudgeBeginCallback | undefined): this {
        if (this.checkPriority('onGestureRecognizerJudgeBegin')) {
            const value_casted = value as (GestureRecognizerJudgeBeginCallback | undefined)
            this.getPeer()?.setOnGestureRecognizerJudgeBegin0Attribute(value_casted)
            return this
        }
        return this
    }
    public shouldBuiltInRecognizerParallelWith(value: ShouldBuiltInRecognizerParallelWithCallback | undefined): this {
        if (this.checkPriority('shouldBuiltInRecognizerParallelWith')) {
            const value_casted = value as (ShouldBuiltInRecognizerParallelWithCallback | undefined)
            this.getPeer()?.setShouldBuiltInRecognizerParallelWithAttribute(value_casted)
            return this
        }
        return this
    }
    public monopolizeEvents(value: boolean | undefined): this {
        if (this.checkPriority('monopolizeEvents')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setMonopolizeEventsAttribute(value_casted)
            return this
        }
        return this
    }
    public onTouchIntercept(value: Callback<TouchEvent, HitTestMode> | undefined): this {
        if (this.checkPriority('onTouchIntercept')) {
            const value_casted = value as (Callback<TouchEvent, HitTestMode> | undefined)
            this.getPeer()?.setOnTouchInterceptAttribute(value_casted)
            return this
        }
        return this
    }
    public onSizeChange(value: SizeChangeCallback | undefined): this {
        if (this.checkPriority('onSizeChange')) {
            const value_casted = value as (SizeChangeCallback | undefined)
            this.getPeer()?.setOnSizeChangeAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityFocusDrawLevel(value: FocusDrawLevel | undefined): this {
        if (this.checkPriority('accessibilityFocusDrawLevel')) {
            const value_casted = value as (FocusDrawLevel | undefined)
            this.getPeer()?.setAccessibilityFocusDrawLevelAttribute(value_casted)
            return this
        }
        return this
    }
    public onTouchTestDone(value: TouchTestDoneCallback | undefined): this {
        if (this.checkPriority('onTouchTestDone')) {
            const value_casted = value as (TouchTestDoneCallback | undefined)
            this.getPeer()?.setOnTouchTestDoneAttribute(value_casted)
            return this
        }
        return this
    }
    public customProperty(name: string, value: CustomProperty): this {
        if (this.checkPriority('customProperty')) {
            hookCustomPropertyImpl(this, name, value)
        }
        return this
    }
    public expandSafeArea(types?: Array<SafeAreaType>, edges?: Array<SafeAreaEdge>): this {
        if (this.checkPriority('expandSafeArea')) {
            const types_casted = types as (Array<SafeAreaType> | undefined)
            const edges_casted = edges as (Array<SafeAreaEdge> | undefined)
            this.getPeer()?.setExpandSafeAreaAttribute(types_casted, edges_casted)
            return this
        }
        return this
    }
    public background(builder: CustomBuilder | undefined, options?: BackgroundOptions): this {
        if (this.checkPriority('background')) {
            const builder_casted = builder as (CustomBuilder | undefined)
            const options_casted = options as (BackgroundOptions | undefined)
            this.getPeer()?.setBackgroundAttribute(builder_casted, options_casted)
            return this
        }
        return this
    }
    public backgroundImage(src: arkui_component_units_ResourceStr | PixelMap | undefined, options: BackgroundImageOptions): this {
        if (this.checkPriority('backgroundImage')) {
            const src_casted = src as (arkui_component_units_ResourceStr | PixelMap | undefined)
            const options_casted = options as (BackgroundImageOptions)
            this.getPeer()?.setBackgroundImage1Attribute(src_casted, options_casted)
            return this
        }
        return this
    }
    public backgroundImage(src: arkui_component_units_ResourceStr | PixelMap | undefined, repeat: ImageRepeat): this {
        if (this.checkPriority('backgroundImage')) {
            const src_casted = src as (arkui_component_units_ResourceStr | PixelMap | undefined)
            const repeat_casted = repeat as (ImageRepeat)
            this.getPeer()?.setBackgroundImage2Attribute(src_casted, repeat_casted)
            return this
        }
        return this
    }
    public backgroundBlurStyle(style: BlurStyle | undefined, options?: BackgroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        if (this.checkPriority('backgroundBlurStyle')) {
            const style_casted = style as (BlurStyle | undefined)
            const options_casted = options as (BackgroundBlurStyleOptions | undefined)
            const sysOptions_casted = sysOptions as (SystemAdaptiveOptions | undefined)
            this.getPeer()?.setBackgroundBlurStyleAttribute(style_casted, options_casted, sysOptions_casted)
            return this
        }
        return this
    }
    public backgroundEffect(options: BackgroundEffectOptions | undefined, sysOptions?: SystemAdaptiveOptions): this {
        if (this.checkPriority('backgroundEffect')) {
            const options_casted = options as (BackgroundEffectOptions | undefined)
            const sysOptions_casted = sysOptions as (SystemAdaptiveOptions | undefined)
            this.getPeer()?.setBackgroundEffectAttribute(options_casted, sysOptions_casted)
            return this
        }
        return this
    }
    public foregroundBlurStyle(style: BlurStyle | undefined, options?: ForegroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        if (this.checkPriority('foregroundBlurStyle')) {
            const style_casted = style as (BlurStyle | undefined)
            const options_casted = options as (ForegroundBlurStyleOptions | undefined)
            const sysOptions_casted = sysOptions as (SystemAdaptiveOptions | undefined)
            this.getPeer()?.setForegroundBlurStyleAttribute(style_casted, options_casted, sysOptions_casted)
            return this
        }
        return this
    }
    public onClick(event: ((event: ClickEvent) => void) | undefined, distanceThreshold: double | undefined): this {
        if (this.checkPriority('onClick')) {
            const event_casted = event as (((event: ClickEvent) => void) | undefined)
            const distanceThreshold_casted = distanceThreshold as (double | undefined)
            this.getPeer()?.setOnClick1Attribute(event_casted, distanceThreshold_casted)
            return this
        }
        return this
    }
    public focusScopeId(id: string | undefined, isGroup?: boolean, arrowStepOut?: boolean): this {
        if (this.checkPriority('focusScopeId')) {
            const id_casted = id as (string | undefined)
            const isGroup_casted = isGroup as (boolean | undefined)
            const arrowStepOut_casted = arrowStepOut as (boolean | undefined)
            this.getPeer()?.setFocusScopeIdAttribute(id_casted, isGroup_casted, arrowStepOut_casted)
            return this
        }
        return this
    }
    public focusScopePriority(scopeId: string | undefined, priority?: FocusPriority): this {
        if (this.checkPriority('focusScopePriority')) {
            const scopeId_casted = scopeId as (string | undefined)
            const priority_casted = priority as (FocusPriority | undefined)
            this.getPeer()?.setFocusScopePriorityAttribute(scopeId_casted, priority_casted)
            return this
        }
        return this
    }
    public transition(effect: TransitionEffect | undefined, onFinish: TransitionFinishCallback | undefined): this {
        if (this.checkPriority('transition')) {
            const effect_casted = effect as (TransitionEffect | undefined)
            const onFinish_casted = onFinish as (TransitionFinishCallback | undefined)
            this.getPeer()?.setTransition1Attribute(effect_casted, onFinish_casted)
            return this
        }
        return this
    }
    public gesture(gesture: GestureType, mask?: GestureMask): this {
        if (this.checkPriority('gesture')) {
            hookGesture(this, gesture, mask)
        }
        return this
    }
    public priorityGesture(gesture: GestureType, mask?: GestureMask): this {
        if (this.checkPriority('priorityGesture')) {
            hookPriorityGesture(this, gesture, mask)
        }
        return this
    }
    public parallelGesture(gesture: GestureType, mask?: GestureMask): this {
        if (this.checkPriority('parallelGesture')) {
            hookParallelGesture(this, gesture, mask)
        }
        return this
    }
    public blur(blurRadius: double | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        if (this.checkPriority('blur')) {
            const blurRadius_casted = blurRadius as (double | undefined)
            const options_casted = options as (BlurOptions | undefined)
            const sysOptions_casted = sysOptions as (SystemAdaptiveOptions | undefined)
            this.getPeer()?.setBlurAttribute(blurRadius_casted, options_casted, sysOptions_casted)
            return this
        }
        return this
    }
    public linearGradientBlur(value: double | undefined, options: LinearGradientBlurOptions | undefined): this {
        if (this.checkPriority('linearGradientBlur')) {
            const value_casted = value as (double | undefined)
            const options_casted = options as (LinearGradientBlurOptions | undefined)
            this.getPeer()?.setLinearGradientBlurAttribute(value_casted, options_casted)
            return this
        }
        return this
    }
    public systemBarEffect(): this {
        if (this.checkPriority('systemBarEffect')) {
            this.getPeer()?.setSystemBarEffectAttribute()
            return this
        }
        return this
    }
    public useEffect(useEffect: boolean | undefined, effectType: EffectType | undefined): this {
        if (this.checkPriority('useEffect')) {
            const useEffect_casted = useEffect as (boolean | undefined)
            const effectType_casted = effectType as (EffectType | undefined)
            this.getPeer()?.setUseEffect1Attribute(useEffect_casted, effectType_casted)
            return this
        }
        return this
    }
    public backdropBlur(radius: double | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        if (this.checkPriority('backdropBlur')) {
            const radius_casted = radius as (double | undefined)
            const options_casted = options as (BlurOptions | undefined)
            const sysOptions_casted = sysOptions as (SystemAdaptiveOptions | undefined)
            this.getPeer()?.setBackdropBlurAttribute(radius_casted, options_casted, sysOptions_casted)
            return this
        }
        return this
    }
    public sharedTransition(id: string | undefined, options?: sharedTransitionOptions): this {
        if (this.checkPriority('sharedTransition')) {
            const id_casted = id as (string | undefined)
            const options_casted = options as (sharedTransitionOptions | undefined)
            this.getPeer()?.setSharedTransitionAttribute(id_casted, options_casted)
            return this
        }
        return this
    }
    public chainMode(direction: Axis | undefined, style: ChainStyle | undefined): this {
        if (this.checkPriority('chainMode')) {
            const direction_casted = direction as (Axis | undefined)
            const style_casted = style as (ChainStyle | undefined)
            this.getPeer()?.setChainModeAttribute(direction_casted, style_casted)
            return this
        }
        return this
    }
    public onDrop(eventCallback: OnDragEventCallback | undefined, dropOptions: DropOptions): this {
        if (this.checkPriority('onDrop')) {
            const eventCallback_casted = eventCallback as (OnDragEventCallback | undefined)
            const dropOptions_casted = dropOptions as (DropOptions)
            this.getPeer()?.setOnDrop1Attribute(eventCallback_casted, dropOptions_casted)
            return this
        }
        return this
    }
    public dragPreview(preview: CustomBuilder | DragItemInfo | string | undefined, config?: PreviewConfiguration): this {
        if (this.checkPriority('dragPreview')) {
            const preview_casted = preview as (CustomBuilder | DragItemInfo | string | undefined)
            const config_casted = config as (PreviewConfiguration | undefined)
            this.getPeer()?.setDragPreviewAttribute(preview_casted, config_casted)
            return this
        }
        return this
    }
    public dragPreviewOptions(value: DragPreviewOptions | undefined, options?: DragInteractionOptions): this {
        if (this.checkPriority('dragPreviewOptions')) {
            hookDragPreviewOptions(this, value, options)
        }
        return this
    }
    public overlay(value: string | CustomBuilder | ComponentContent<Object> | undefined, options?: OverlayOptions): this {
        if (this.checkPriority('overlay')) {
            const value_casted = value as (string | CustomBuilder | ComponentContent<Object> | undefined)
            const options_casted = options as (OverlayOptions | undefined)
            this.getPeer()?.setOverlayAttribute(value_casted, options_casted)
            return this
        }
        return this
    }
    public blendMode(value: BlendMode | undefined, type?: BlendApplyType): this {
        if (this.checkPriority('blendMode')) {
            const value_casted = value as (BlendMode | undefined)
            const type_casted = type as (BlendApplyType | undefined)
            this.getPeer()?.setBlendModeAttribute(value_casted, type_casted)
            return this
        }
        return this
    }
    public advancedBlendMode(effect: BlendMode | Blender | undefined, type?: BlendApplyType): this {
        if (this.checkPriority('advancedBlendMode')) {
            const effect_casted = effect as (BlendMode | Blender | undefined)
            const type_casted = type as (BlendApplyType | undefined)
            this.getPeer()?.setAdvancedBlendModeAttribute(effect_casted, type_casted)
            return this
        }
        return this
    }
    public geometryTransition(id: string | undefined, options?: GeometryTransitionOptions): this {
        if (this.checkPriority('geometryTransition')) {
            const id_casted = id as (string | undefined)
            const options_casted = options as (GeometryTransitionOptions | undefined)
            this.getPeer()?.setGeometryTransitionAttribute(id_casted, options_casted)
            return this
        }
        return this
    }
    public bindTips(message: TipsMessageType | undefined, options?: TipsOptions): this {
        if (this.checkPriority('bindTips')) {
            const message_casted = message as (TipsMessageType | undefined)
            const options_casted = options as (TipsOptions | undefined)
            this.getPeer()?.setBindTipsAttribute(message_casted, options_casted)
            return this
        }
        return this
    }
    public bindPopup(show: boolean | undefined, popup: PopupOptions | CustomPopupOptions | undefined): this {
        if (this.checkPriority('bindPopup')) {
            const show_casted = show as (boolean | undefined)
            const popup_casted = popup as (PopupOptions | CustomPopupOptions | undefined)
            this.getPeer()?.setBindPopupAttribute(show_casted, popup_casted)
            return this
        }
        return this
    }
    public bindMenu(content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): this {
        if (this.checkPriority('bindMenu')) {
            const content_casted = content as (Array<MenuElement> | CustomBuilder | undefined)
            const options_casted = options as (MenuOptions | undefined)
            this.getPeer()?.setBindMenu0Attribute(content_casted, options_casted)
            return this
        }
        return this
    }
    public bindMenu(isShow: boolean | undefined, content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): this {
        if (this.checkPriority('bindMenu')) {
            const isShow_casted = isShow as (boolean | undefined)
            const content_casted = content as (Array<MenuElement> | CustomBuilder | undefined)
            const options_casted = options as (MenuOptions | undefined)
            this.getPeer()?.setBindMenu1Attribute(isShow_casted, content_casted, options_casted)
            return this
        }
        return this
    }
    public bindContextMenu(content: CustomBuilder | undefined, responseType: ResponseType | undefined, options?: ContextMenuOptions): this {
        if (this.checkPriority('bindContextMenu')) {
            const content_casted = content as (CustomBuilder | undefined)
            const responseType_casted = responseType as (ResponseType | undefined)
            const options_casted = options as (ContextMenuOptions | undefined)
            this.getPeer()?.setBindContextMenu0Attribute(content_casted, responseType_casted, options_casted)
            return this
        }
        return this
    }
    public bindContextMenu(isShown: boolean | undefined, content: CustomBuilder | undefined, options?: ContextMenuOptions): this {
        if (this.checkPriority('bindContextMenu')) {
            const isShown_casted = isShown as (boolean | undefined)
            const content_casted = content as (CustomBuilder | undefined)
            const options_casted = options as (ContextMenuOptions | undefined)
            this.getPeer()?.setBindContextMenu1Attribute(isShown_casted, content_casted, options_casted)
            return this
        }
        return this
    }
    public bindContentCover(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, type?: ModalTransition): this {
        if (this.checkPriority('bindContentCover')) {
            const isShow_casted = isShow as (boolean | Bindable<boolean> | undefined)
            const builder_casted = builder as (CustomBuilder | undefined)
            const type_casted = type as (ModalTransition | undefined)
            this.getPeer()?.setBindContentCover0Attribute(isShow_casted, builder_casted, type_casted)
            return this
        }
        return this
    }
    public bindContentCover(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, options?: ContentCoverOptions): this {
        if (this.checkPriority('bindContentCover')) {
            const isShow_casted = isShow as (boolean | Bindable<boolean> | undefined)
            const builder_casted = builder as (CustomBuilder | undefined)
            const options_casted = options as (ContentCoverOptions | undefined)
            this.getPeer()?.setBindContentCover1Attribute(isShow_casted, builder_casted, options_casted)
            return this
        }
        return this
    }
    public bindSheet(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, options?: SheetOptions): this {
        if (this.checkPriority('bindSheet')) {
            const isShow_casted = isShow as (boolean | Bindable<boolean> | undefined)
            const builder_casted = builder as (CustomBuilder | undefined)
            const options_casted = options as (SheetOptions | undefined)
            this.getPeer()?.setBindSheetAttribute(isShow_casted, builder_casted, options_casted)
            return this
        }
        return this
    }
    public onVisibleAreaChange(ratios: Array<double> | undefined, event: VisibleAreaChangeCallback | undefined): this {
        if (this.checkPriority('onVisibleAreaChange')) {
            const ratios_casted = ratios as (Array<double> | undefined)
            const event_casted = event as (VisibleAreaChangeCallback | undefined)
            this.getPeer()?.setOnVisibleAreaChangeAttribute(ratios_casted, event_casted)
            return this
        }
        return this
    }
    public onVisibleAreaApproximateChange(options: VisibleAreaEventOptions | undefined, event: VisibleAreaChangeCallback | undefined): this {
        if (this.checkPriority('onVisibleAreaApproximateChange')) {
            const options_casted = options as (VisibleAreaEventOptions | undefined)
            const event_casted = event as (VisibleAreaChangeCallback | undefined)
            this.getPeer()?.setOnVisibleAreaApproximateChangeAttribute(options_casted, event_casted)
            return this
        }
        return this
    }
    public keyboardShortcut(value: string | FunctionKey | undefined, keys: Array<ModifierKey> | undefined, action?: (() => void)): this {
        if (this.checkPriority('keyboardShortcut')) {
            const value_casted = value as (string | FunctionKey | undefined)
            const keys_casted = keys as (Array<ModifierKey> | undefined)
            const action_casted = action as ((() => void) | undefined)
            this.getPeer()?.setKeyboardShortcutAttribute(value_casted, keys_casted, action_casted)
            return this
        }
        return this
    }
    public accessibilityGroup(isGroup: boolean | undefined, accessibilityOptions?: AccessibilityOptions): this {
        if (this.checkPriority('accessibilityGroup')) {
            const isGroup_casted = isGroup as (boolean | undefined)
            const accessibilityOptions_casted = accessibilityOptions as (AccessibilityOptions | undefined)
            this.getPeer()?.setAccessibilityGroupAttribute(isGroup_casted, accessibilityOptions_casted)
            return this
        }
        return this
    }
    public onGestureRecognizerJudgeBegin(callback_: GestureRecognizerJudgeBeginCallback | undefined, exposeInnerGesture: boolean | undefined): this {
        if (this.checkPriority('onGestureRecognizerJudgeBegin')) {
            const callback__casted = callback_ as (GestureRecognizerJudgeBeginCallback | undefined)
            const exposeInnerGesture_casted = exposeInnerGesture as (boolean | undefined)
            this.getPeer()?.setOnGestureRecognizerJudgeBegin1Attribute(callback__casted, exposeInnerGesture_casted)
            return this
        }
        return this
    }
    public attributeModifier(value: AttributeModifier<CommonMethod> | undefined): this {
        ModifierStateManager.INSTANCE.scope(() => {
            hookCommonMethodAttributeModifier(this, value);
        })
        return this
    }
    public applyAttributesFinish(): void {
        // we call this function outside of class, so need to make it public
        super.applyAttributesFinish()
    }
    public applyOptionsFinish(traceName: string): void {
        super.applyOptionsFinish(traceName)
    }
}
export class ArkCommonShapeMethodComponent extends ArkCommonMethodComponent implements CommonShapeMethod {
    getPeer(): ArkCommonShapeMethodPeer {
        return (this.peer as ArkCommonShapeMethodPeer)
    }
    public stroke(value: ResourceColor | undefined): this {
        if (this.checkPriority('stroke')) {
            const value_casted = value as (ResourceColor | undefined)
            this.getPeer()?.setStrokeAttribute(value_casted)
            return this
        }
        return this
    }
    public fill(value: ResourceColor | undefined): this {
        if (this.checkPriority('fill')) {
            const value_casted = value as (ResourceColor | undefined)
            this.getPeer()?.setFillAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeDashOffset(value: double | string | undefined): this {
        if (this.checkPriority('strokeDashOffset')) {
            const value_casted = value as (double | string | undefined)
            this.getPeer()?.setStrokeDashOffsetAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeLineCap(value: LineCapStyle | undefined): this {
        if (this.checkPriority('strokeLineCap')) {
            const value_casted = value as (LineCapStyle | undefined)
            this.getPeer()?.setStrokeLineCapAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeLineJoin(value: LineJoinStyle | undefined): this {
        if (this.checkPriority('strokeLineJoin')) {
            const value_casted = value as (LineJoinStyle | undefined)
            this.getPeer()?.setStrokeLineJoinAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeMiterLimit(value: double | string | undefined): this {
        if (this.checkPriority('strokeMiterLimit')) {
            const value_casted = value as (double | string | undefined)
            this.getPeer()?.setStrokeMiterLimitAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeOpacity(value: double | string | global_resource_Resource | undefined): this {
        if (this.checkPriority('strokeOpacity')) {
            const value_casted = value as (double | string | global_resource_Resource | undefined)
            this.getPeer()?.setStrokeOpacityAttribute(value_casted)
            return this
        }
        return this
    }
    public fillOpacity(value: double | string | global_resource_Resource | undefined): this {
        if (this.checkPriority('fillOpacity')) {
            const value_casted = value as (double | string | global_resource_Resource | undefined)
            this.getPeer()?.setFillOpacityAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeWidth(value: Length | undefined): this {
        if (this.checkPriority('strokeWidth')) {
            const value_casted = value as (Length | undefined)
            this.getPeer()?.setStrokeWidthAttribute(value_casted)
            return this
        }
        return this
    }
    public antiAlias(value: boolean | undefined): this {
        if (this.checkPriority('antiAlias')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setAntiAliasAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeDashArray(value: Array<Length> | undefined): this {
        if (this.checkPriority('strokeDashArray')) {
            const value_casted = value as (Array<Length> | undefined)
            this.getPeer()?.setStrokeDashArrayAttribute(value_casted)
            return this
        }
        return this
    }
    public attributeModifier(value: AttributeModifier<CommonShapeMethod> | AttributeModifier<CommonMethod> | undefined): this {
        ModifierStateManager.INSTANCE.scope(() => {
            hookCommonShapeMethodAttributeModifier(this, value);
        })
        return this
    }
    public applyAttributesFinish(): void {
        // we call this function outside of class, so need to make it public
        super.applyAttributesFinish()
    }
    public applyOptionsFinish(traceName: string): void {
        super.applyOptionsFinish(traceName)
    }
}
export class ArkScrollableCommonMethodComponent extends ArkCommonMethodComponent implements ScrollableCommonMethod {
    getPeer(): ArkScrollableCommonMethodPeer {
        return (this.peer as ArkScrollableCommonMethodPeer)
    }
    public scrollBar(value: BarState | undefined): this {
        if (this.checkPriority('scrollBar')) {
            const value_casted = value as (BarState | undefined)
            this.getPeer()?.setScrollBarAttribute(value_casted)
            return this
        }
        return this
    }
    public scrollBarColor(value: arkui_component_enums_Color | int32 | string | undefined): this {
        if (this.checkPriority('scrollBarColor')) {
            const value_casted = value as (arkui_component_enums_Color | int32 | string | undefined)
            this.getPeer()?.setScrollBarColorAttribute(value_casted)
            return this
        }
        return this
    }
    public scrollBarWidth(value: double | string | undefined): this {
        if (this.checkPriority('scrollBarWidth')) {
            const value_casted = value as (double | string | undefined)
            this.getPeer()?.setScrollBarWidthAttribute(value_casted)
            return this
        }
        return this
    }
    public nestedScroll(value: NestedScrollOptions | undefined): this {
        if (this.checkPriority('nestedScroll')) {
            const value_casted = value as (NestedScrollOptions | undefined)
            this.getPeer()?.setNestedScrollAttribute(value_casted)
            return this
        }
        return this
    }
    public enableScrollInteraction(value: boolean | undefined): this {
        if (this.checkPriority('enableScrollInteraction')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setEnableScrollInteractionAttribute(value_casted)
            return this
        }
        return this
    }
    public friction(value: double | global_resource_Resource | undefined): this {
        if (this.checkPriority('friction')) {
            const value_casted = value as (double | global_resource_Resource | undefined)
            this.getPeer()?.setFrictionAttribute(value_casted)
            return this
        }
        return this
    }
    public onReachStart(value: (() => void) | undefined): this {
        if (this.checkPriority('onReachStart')) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnReachStartAttribute(value_casted)
            return this
        }
        return this
    }
    public onReachEnd(value: (() => void) | undefined): this {
        if (this.checkPriority('onReachEnd')) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnReachEndAttribute(value_casted)
            return this
        }
        return this
    }
    public onScrollStart(value: (() => void) | undefined): this {
        if (this.checkPriority('onScrollStart')) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnScrollStartAttribute(value_casted)
            return this
        }
        return this
    }
    public onScrollStop(value: (() => void) | undefined): this {
        if (this.checkPriority('onScrollStop')) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnScrollStopAttribute(value_casted)
            return this
        }
        return this
    }
    public flingSpeedLimit(value: double | undefined): this {
        if (this.checkPriority('flingSpeedLimit')) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setFlingSpeedLimitAttribute(value_casted)
            return this
        }
        return this
    }
    public clipContent(value: ContentClipMode | RectShape | undefined): this {
        if (this.checkPriority('clipContent')) {
            const value_casted = value as (ContentClipMode | RectShape | undefined)
            this.getPeer()?.setClipContentAttribute(value_casted)
            return this
        }
        return this
    }
    public digitalCrownSensitivity(value: CrownSensitivity | undefined): this {
        if (this.checkPriority('digitalCrownSensitivity')) {
            const value_casted = value as (CrownSensitivity | undefined)
            this.getPeer()?.setDigitalCrownSensitivityAttribute(value_casted)
            return this
        }
        return this
    }
    public backToTop(value: boolean | undefined): this {
        if (this.checkPriority('backToTop')) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setBackToTopAttribute(value_casted)
            return this
        }
        return this
    }
    public edgeEffect(edgeEffect: EdgeEffect | undefined, options?: EdgeEffectOptions): this {
        if (this.checkPriority('edgeEffect')) {
            const edgeEffect_casted = edgeEffect as (EdgeEffect | undefined)
            const options_casted = options as (EdgeEffectOptions | undefined)
            this.getPeer()?.setEdgeEffectAttribute(edgeEffect_casted, options_casted)
            return this
        }
        return this
    }
    public fadingEdge(enabled: boolean | undefined, options?: FadingEdgeOptions): this {
        if (this.checkPriority('fadingEdge')) {
            const enabled_casted = enabled as (boolean | undefined)
            const options_casted = options as (FadingEdgeOptions | undefined)
            this.getPeer()?.setFadingEdgeAttribute(enabled_casted, options_casted)
            return this
        }
        return this
    }
    public attributeModifier(value: AttributeModifier<ScrollableCommonMethod> | AttributeModifier<CommonMethod> | undefined): this {
        ModifierStateManager.INSTANCE.scope(() => {
            hookScrollableCommonMethodAttributeModifier(this, value);
        })
        return this
    }
    public applyAttributesFinish(): void {
        // we call this function outside of class, so need to make it public
        super.applyAttributesFinish()
    }
    public applyOptionsFinish(traceName: string): void {
        super.applyOptionsFinish(traceName)
    }
}
export function postCardAction(component: Object, action: Object): void {
    GlobalScope.postCardAction(component, action)
}
export function $r(value: string, params: Array<RecordData>): global_resource_Resource {
    return GlobalScope.$r(value, params)
}
export function $rawfile(value: string): global_resource_Resource {
    return GlobalScope.$rawfile(value)
}
export function animateTo(value: AnimateParam, event: (() => void)): void {
    // instructive change start
    _animateTo(value, event)
    // instructive change end
}
export function animateToImmediately(value: AnimateParam, event: (() => void)): void {
    // instructive change start
    AnimationExtender.AnimateToImmediatelyImpl(value, event)
    // instructive change end
}
export class AccessibilityHoverEvent_serializer {
    public static write(buffer: SerializerBase, value: AccessibilityHoverEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): AccessibilityHoverEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return AccessibilityHoverEventInternal.fromPtr(ptr)
    }
}
export class AxisEvent_serializer {
    public static write(buffer: SerializerBase, value: AxisEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): AxisEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return AxisEventInternal.fromPtr(ptr)
    }
}
export class BaseEvent_serializer {
    public static write(buffer: SerializerBase, value: BaseEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): BaseEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return BaseEventInternal.fromPtr(ptr)
    }
}
export class ClickEvent_serializer {
    public static write(buffer: SerializerBase, value: ClickEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): ClickEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return ClickEventInternal.fromPtr(ptr)
    }
}
export class CrownEvent_serializer {
    public static write(buffer: SerializerBase, value: CrownEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): CrownEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return CrownEventInternal.fromPtr(ptr)
    }
}
export class DismissPopupAction_serializer {
    public static write(buffer: SerializerBase, value: DismissPopupAction): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): DismissPopupAction {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return DismissPopupActionInternal.fromPtr(ptr)
    }
}
export class DragEvent_serializer {
    public static write(buffer: SerializerBase, value: DragEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): DragEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return DragEventInternal.fromPtr(ptr)
    }
}
export class FocusAxisEvent_serializer {
    public static write(buffer: SerializerBase, value: FocusAxisEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): FocusAxisEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return FocusAxisEventInternal.fromPtr(ptr)
    }
}
export class HoverEvent_serializer {
    public static write(buffer: SerializerBase, value: HoverEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): HoverEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return HoverEventInternal.fromPtr(ptr)
    }
}
export class InvertOptions_serializer {
    public static write(buffer: SerializerBase, value: InvertOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForLow  = value.low
        valueSerializer.writeFloat64(valueHolderForLow)
        const valueHolderForHigh  = value.high
        valueSerializer.writeFloat64(valueHolderForHigh)
        const valueHolderForThreshold  = value.threshold
        valueSerializer.writeFloat64(valueHolderForThreshold)
        const valueHolderForThresholdRange  = value.thresholdRange
        valueSerializer.writeFloat64(valueHolderForThresholdRange)
    }
    public static read(buffer: DeserializerBase): InvertOptions {
        let valueDeserializer : DeserializerBase = buffer
        const lowTmpResult : double = valueDeserializer.readFloat64()
        const highTmpResult : double = valueDeserializer.readFloat64()
        const thresholdTmpResult : double = valueDeserializer.readFloat64()
        const thresholdRangeTmpResult : double = valueDeserializer.readFloat64()
        let value : InvertOptions = ({low: lowTmpResult, high: highTmpResult, threshold: thresholdTmpResult, thresholdRange: thresholdRangeTmpResult} as InvertOptions)
        return value
    }
}
export class ItemDragInfo_serializer {
    public static write(buffer: SerializerBase, value: ItemDragInfo): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForX  = value.x
        valueSerializer.writeFloat64(valueHolderForX)
        const valueHolderForY  = value.y
        valueSerializer.writeFloat64(valueHolderForY)
    }
    public static read(buffer: DeserializerBase): ItemDragInfo {
        let valueDeserializer : DeserializerBase = buffer
        const xTmpResult : double = valueDeserializer.readFloat64()
        const yTmpResult : double = valueDeserializer.readFloat64()
        let value : ItemDragInfo = ({x: xTmpResult, y: yTmpResult} as ItemDragInfo)
        return value
    }
}
export class KeyEvent_serializer {
    public static write(buffer: SerializerBase, value: KeyEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): KeyEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return KeyEventInternal.fromPtr(ptr)
    }
}
export class Layoutable_serializer {
    public static write(buffer: SerializerBase, value: Layoutable): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): Layoutable {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return LayoutableInternal.fromPtr(ptr)
    }
}
export class LayoutPolicy_serializer {
    public static write(buffer: SerializerBase, value: LayoutPolicy): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): LayoutPolicy {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return LayoutPolicyInternal.fromPtr(ptr)
    }
}
export class Measurable_serializer {
    public static write(buffer: SerializerBase, value: Measurable): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): Measurable {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return MeasurableInternal.fromPtr(ptr)
    }
}
export class MeasureResult_serializer {
    public static write(buffer: SerializerBase, value: MeasureResult): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForWidth  = value.width
        valueSerializer.writeFloat64(valueHolderForWidth)
        const valueHolderForHeight  = value.height
        valueSerializer.writeFloat64(valueHolderForHeight)
    }
    public static read(buffer: DeserializerBase): MeasureResult {
        let valueDeserializer : DeserializerBase = buffer
        const widthTmpResult : double = valueDeserializer.readFloat64()
        const heightTmpResult : double = valueDeserializer.readFloat64()
        let value : MeasureResult = ({width: widthTmpResult, height: heightTmpResult} as MeasureResult)
        return value
    }
}
export class MouseEvent_serializer {
    public static write(buffer: SerializerBase, value: MouseEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): MouseEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return MouseEventInternal.fromPtr(ptr)
    }
}
export class NestedScrollOptions_serializer {
    public static write(buffer: SerializerBase, value: NestedScrollOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForScrollForward  = value.scrollForward
        valueSerializer.writeInt32(valueHolderForScrollForward.valueOf())
        const valueHolderForScrollBackward  = value.scrollBackward
        valueSerializer.writeInt32(valueHolderForScrollBackward.valueOf())
    }
    public static read(buffer: DeserializerBase): NestedScrollOptions {
        let valueDeserializer : DeserializerBase = buffer
        const scrollForwardTmpResult : NestedScrollMode = NestedScrollMode.fromValue(valueDeserializer.readInt32())
        const scrollBackwardTmpResult : NestedScrollMode = NestedScrollMode.fromValue(valueDeserializer.readInt32())
        let value : NestedScrollOptions = ({scrollForward: scrollForwardTmpResult, scrollBackward: scrollBackwardTmpResult} as NestedScrollOptions)
        return value
    }
}
export class PixelMapMock_serializer {
    public static write(buffer: SerializerBase, value: PixelMapMock): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): PixelMapMock {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return PixelMapMockInternal.fromPtr(ptr)
    }
}
export class PopupStateChangeParam_serializer {
    public static write(buffer: SerializerBase, value: PopupStateChangeParam): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForIsVisible  = value.isVisible
        valueSerializer.writeBoolean(valueHolderForIsVisible)
    }
    public static read(buffer: DeserializerBase): PopupStateChangeParam {
        let valueDeserializer : DeserializerBase = buffer
        const isVisibleTmpResult : boolean = valueDeserializer.readBoolean()
        let value : PopupStateChangeParam = ({isVisible: isVisibleTmpResult} as PopupStateChangeParam)
        return value
    }
}
export class ProgressMask_serializer {
    public static write(buffer: SerializerBase, value: ProgressMask): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): ProgressMask {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return ProgressMaskInternal.fromPtr(ptr)
    }
}
export class RectResult_serializer {
    public static write(buffer: SerializerBase, value: RectResult): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForX  = value.x
        valueSerializer.writeFloat64(valueHolderForX)
        const valueHolderForY  = value.y
        valueSerializer.writeFloat64(valueHolderForY)
        const valueHolderForWidth  = value.width
        valueSerializer.writeFloat64(valueHolderForWidth)
        const valueHolderForHeight  = value.height
        valueSerializer.writeFloat64(valueHolderForHeight)
    }
    public static read(buffer: DeserializerBase): RectResult {
        let valueDeserializer : DeserializerBase = buffer
        const xTmpResult : double = valueDeserializer.readFloat64()
        const yTmpResult : double = valueDeserializer.readFloat64()
        const widthTmpResult : double = valueDeserializer.readFloat64()
        const heightTmpResult : double = valueDeserializer.readFloat64()
        let value : RectResult = ({x: xTmpResult, y: yTmpResult, width: widthTmpResult, height: heightTmpResult} as RectResult)
        return value
    }
}
export class ScrollResult_serializer {
    public static write(buffer: SerializerBase, value: ScrollResult): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): ScrollResult {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return ScrollResultInternal.fromPtr(ptr)
    }
}
export class SizeResult_serializer {
    public static write(buffer: SerializerBase, value: SizeResult): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForWidth  = value.width
        valueSerializer.writeFloat64(valueHolderForWidth)
        const valueHolderForHeight  = value.height
        valueSerializer.writeFloat64(valueHolderForHeight)
    }
    public static read(buffer: DeserializerBase): SizeResult {
        let valueDeserializer : DeserializerBase = buffer
        const widthTmpResult : double = valueDeserializer.readFloat64()
        const heightTmpResult : double = valueDeserializer.readFloat64()
        let value : SizeResult = ({width: widthTmpResult, height: heightTmpResult} as SizeResult)
        return value
    }
}
export class SpringBackAction_serializer {
    public static write(buffer: SerializerBase, value: SpringBackAction): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): SpringBackAction {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return SpringBackActionInternal.fromPtr(ptr)
    }
}
export class TextContentControllerBase_serializer {
    public static write(buffer: SerializerBase, value: TextContentControllerBase): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): TextContentControllerBase {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return TextContentControllerBaseInternal.fromPtr(ptr)
    }
}
export class TouchEvent_serializer {
    public static write(buffer: SerializerBase, value: TouchEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): TouchEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return TouchEventInternal.fromPtr(ptr)
    }
}
export class TouchTestInfo_serializer {
    public static write(buffer: SerializerBase, value: TouchTestInfo): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForWindowX  = value.windowX
        valueSerializer.writeFloat64(valueHolderForWindowX)
        const valueHolderForWindowY  = value.windowY
        valueSerializer.writeFloat64(valueHolderForWindowY)
        const valueHolderForParentX  = value.parentX
        valueSerializer.writeFloat64(valueHolderForParentX)
        const valueHolderForParentY  = value.parentY
        valueSerializer.writeFloat64(valueHolderForParentY)
        const valueHolderForX  = value.x
        valueSerializer.writeFloat64(valueHolderForX)
        const valueHolderForY  = value.y
        valueSerializer.writeFloat64(valueHolderForY)
        const valueHolderForRect  = value.rect
        RectResult_serializer.write(valueSerializer, valueHolderForRect)
        const valueHolderForId  = value.id
        valueSerializer.writeString(valueHolderForId)
    }
    public static read(buffer: DeserializerBase): TouchTestInfo {
        let valueDeserializer : DeserializerBase = buffer
        const windowXTmpResult : double = valueDeserializer.readFloat64()
        const windowYTmpResult : double = valueDeserializer.readFloat64()
        const parentXTmpResult : double = valueDeserializer.readFloat64()
        const parentYTmpResult : double = valueDeserializer.readFloat64()
        const xTmpResult : double = valueDeserializer.readFloat64()
        const yTmpResult : double = valueDeserializer.readFloat64()
        const rectTmpResult : RectResult = RectResult_serializer.read(valueDeserializer)
        const idTmpResult : string = (valueDeserializer.readString() as string)
        let value : TouchTestInfo = ({windowX: windowXTmpResult, windowY: windowYTmpResult, parentX: parentXTmpResult, parentY: parentYTmpResult, x: xTmpResult, y: yTmpResult, rect: rectTmpResult, id: idTmpResult} as TouchTestInfo)
        return value
    }
}
export class TransitionEffect_serializer {
    public static write(buffer: SerializerBase, value: TransitionEffect): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): TransitionEffect {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return TransitionEffectInternal.fromPtr(ptr)
    }
}
export class UICommonEvent_serializer {
    public static write(buffer: SerializerBase, value: UICommonEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): UICommonEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return UICommonEventInternal.fromPtr(ptr)
    }
}
export class VerticalAlignParam_serializer {
    public static write(buffer: SerializerBase, value: VerticalAlignParam): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAnchor  = value.anchor
        valueSerializer.writeString(valueHolderForAnchor)
        const valueHolderForAlign  = value.align
        valueSerializer.writeInt32(valueHolderForAlign.valueOf())
    }
    public static read(buffer: DeserializerBase): VerticalAlignParam {
        let valueDeserializer : DeserializerBase = buffer
        const anchorTmpResult : string = (valueDeserializer.readString() as string)
        const alignTmpResult : VerticalAlign = VerticalAlign.fromValue(valueDeserializer.readInt32())
        let value : VerticalAlignParam = ({anchor: anchorTmpResult, align: alignTmpResult} as VerticalAlignParam)
        return value
    }
}
export class AsymmetricTransitionOption_serializer {
    public static write(buffer: SerializerBase, value: AsymmetricTransitionOption): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAppear  = value.appear
        TransitionEffect_serializer.write(valueSerializer, valueHolderForAppear)
        const valueHolderForDisappear  = value.disappear
        TransitionEffect_serializer.write(valueSerializer, valueHolderForDisappear)
    }
    public static read(buffer: DeserializerBase): AsymmetricTransitionOption {
        let valueDeserializer : DeserializerBase = buffer
        const appearTmpResult : TransitionEffect = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        const disappearTmpResult : TransitionEffect = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        let value : AsymmetricTransitionOption = ({appear: appearTmpResult, disappear: disappearTmpResult} as AsymmetricTransitionOption)
        return value
    }
}
export class BackgroundBrightnessOptions_serializer {
    public static write(buffer: SerializerBase, value: BackgroundBrightnessOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForRate  = value.rate
        valueSerializer.writeFloat64(valueHolderForRate)
        const valueHolderForLightUpDegree  = value.lightUpDegree
        valueSerializer.writeFloat64(valueHolderForLightUpDegree)
    }
    public static read(buffer: DeserializerBase): BackgroundBrightnessOptions {
        let valueDeserializer : DeserializerBase = buffer
        const rateTmpResult : double = valueDeserializer.readFloat64()
        const lightUpDegreeTmpResult : double = valueDeserializer.readFloat64()
        let value : BackgroundBrightnessOptions = ({rate: rateTmpResult, lightUpDegree: lightUpDegreeTmpResult} as BackgroundBrightnessOptions)
        return value
    }
}
export class BackgroundImageOptions_serializer {
    public static write(buffer: SerializerBase, value: BackgroundImageOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForSyncLoad  = value.syncLoad
        if (valueHolderForSyncLoad !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForSyncLoadTmpValue  = valueHolderForSyncLoad!
            valueSerializer.writeBoolean(valueHolderForSyncLoadTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRepeat  = value.repeat
        if (valueHolderForRepeat !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRepeatTmpValue  = (valueHolderForRepeat as ImageRepeat)
            valueSerializer.writeInt32(valueHolderForRepeatTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): BackgroundImageOptions {
        let valueDeserializer : DeserializerBase = buffer
        const syncLoadTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let syncLoadTmpBuf : boolean | undefined = undefined
        if ((syncLoadTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            syncLoadTmpBuf = valueDeserializer.readBoolean()
        }
        const syncLoadTmpResult : boolean | undefined = syncLoadTmpBuf
        const repeatTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let repeatTmpBuf : ImageRepeat | undefined = undefined
        if ((repeatTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            repeatTmpBuf = ImageRepeat.fromValue(valueDeserializer.readInt32())
        }
        const repeatTmpResult : ImageRepeat | undefined = repeatTmpBuf
        let value : BackgroundImageOptions = ({syncLoad: syncLoadTmpResult, repeat: repeatTmpResult} as BackgroundImageOptions)
        return value
    }
}
export class BackgroundOptions_serializer {
    public static write(buffer: SerializerBase, value: BackgroundOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAlign  = value.align
        if (valueHolderForAlign !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAlignTmpValue  = (valueHolderForAlign as Alignment)
            valueSerializer.writeInt32(valueHolderForAlignTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): BackgroundOptions {
        let valueDeserializer : DeserializerBase = buffer
        const alignTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let alignTmpBuf : Alignment | undefined = undefined
        if ((alignTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            alignTmpBuf = Alignment.fromValue(valueDeserializer.readInt32())
        }
        const alignTmpResult : Alignment | undefined = alignTmpBuf
        let value : BackgroundOptions = ({align: alignTmpResult} as BackgroundOptions)
        return value
    }
}
export class Bindable_Array_I32_serializer {
    public static write(buffer: SerializerBase, value: Bindable<Array<int32>>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeInt32((valueHolderForValue.length).toInt())
        for (let valueHolderForValueCounterI = 0; valueHolderForValueCounterI < valueHolderForValue.length; valueHolderForValueCounterI++) {
            const valueHolderForValueTmpElement : int32 = valueHolderForValue[valueHolderForValueCounterI]
            valueSerializer.writeInt32(valueHolderForValueTmpElement)
        }
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<Array<int32>> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpBufLength : int32 = valueDeserializer.readInt32()
        let valueTmpBuf : Array<int32> = new Array<int32>(valueTmpBufLength)
        for (let valueTmpBufBufCounterI = 0; valueTmpBufBufCounterI < valueTmpBufLength; valueTmpBufBufCounterI++) {
            valueTmpBuf[valueTmpBufBufCounterI] = valueDeserializer.readInt32()
        }
        const valueTmpResult : Array<int32> = valueTmpBuf
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufClosure  = (data: Array<int32>):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            onChangeTmpBufBufArgsSerializer.writeInt32((data.length).toInt());
            for (let dataCounterI = 0; dataCounterI < data.length; dataCounterI++) {
                const dataTmpElement : int32 = data[dataCounterI];
                onChangeTmpBufBufArgsSerializer.writeInt32(dataTmpElement);
            }
            InteropNativeModule._CallCallbackSync(10, 81037473, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(onChangeTmpBufClosure, onChangeTmpBufBufResource)
        const onChangeTmpResult : Callback<Array<int32>, void> = onChangeTmpBufClosure
        let value : Bindable<Array<int32>> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<Array<int32>>)
        return value
    }
}
export class Bindable_Array_Resource_serializer {
    public static write(buffer: SerializerBase, value: Bindable<Array<global_resource_Resource>>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeInt32((valueHolderForValue.length).toInt())
        for (let valueHolderForValueCounterI = 0; valueHolderForValueCounterI < valueHolderForValue.length; valueHolderForValueCounterI++) {
            const valueHolderForValueTmpElement : global_resource_Resource = valueHolderForValue[valueHolderForValueCounterI]
            global_resource_Resource_serializer.write(valueSerializer, valueHolderForValueTmpElement)
        }
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<Array<global_resource_Resource>> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpBufLength : int32 = valueDeserializer.readInt32()
        let valueTmpBuf : Array<global_resource_Resource> = new Array<global_resource_Resource>(valueTmpBufLength)
        for (let valueTmpBufBufCounterI = 0; valueTmpBufBufCounterI < valueTmpBufLength; valueTmpBufBufCounterI++) {
            valueTmpBuf[valueTmpBufBufCounterI] = global_resource_Resource_serializer.read(valueDeserializer)
        }
        const valueTmpResult : Array<global_resource_Resource> = valueTmpBuf
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufClosure  = (data: Array<global_resource_Resource>):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            onChangeTmpBufBufArgsSerializer.writeInt32((data.length).toInt());
            for (let dataCounterI = 0; dataCounterI < data.length; dataCounterI++) {
                const dataTmpElement : global_resource_Resource = data[dataCounterI];
                global_resource_Resource_serializer.write(onChangeTmpBufBufArgsSerializer, dataTmpElement);
            }
            InteropNativeModule._CallCallbackSync(10, -709276125, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(onChangeTmpBufClosure, onChangeTmpBufBufResource)
        const onChangeTmpResult : Callback<Array<global_resource_Resource>, void> = onChangeTmpBufClosure
        let value : Bindable<Array<global_resource_Resource>> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<Array<global_resource_Resource>>)
        return value
    }
}
export class Bindable_Array_ResourceStr_serializer {
    public static write(buffer: SerializerBase, value: Bindable<Array<arkui_component_units_ResourceStr>>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeInt32((valueHolderForValue.length).toInt())
        for (let valueHolderForValueCounterI = 0; valueHolderForValueCounterI < valueHolderForValue.length; valueHolderForValueCounterI++) {
            const valueHolderForValueTmpElement : arkui_component_units_ResourceStr = valueHolderForValue[valueHolderForValueCounterI]
            if (valueHolderForValueTmpElement instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForValueTmpElementForIdx0  = valueHolderForValueTmpElement as string
                valueSerializer.writeString(valueHolderForValueTmpElementForIdx0)
            } else if (valueHolderForValueTmpElement instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForValueTmpElementForIdx1  = valueHolderForValueTmpElement as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForValueTmpElementForIdx1)
            }
        }
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<Array<arkui_component_units_ResourceStr>> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpBufLength : int32 = valueDeserializer.readInt32()
        let valueTmpBuf : Array<arkui_component_units_ResourceStr> = new Array<arkui_component_units_ResourceStr>(valueTmpBufLength)
        for (let valueTmpBufBufCounterI = 0; valueTmpBufBufCounterI < valueTmpBufLength; valueTmpBufBufCounterI++) {
            const valueTmpBufTempBufUnionSelector : int32 = valueDeserializer.readInt8()
            let valueTmpBufTempBuf : string | arkui_component_units_Resource | undefined
            if (valueTmpBufTempBufUnionSelector == (0).toByte()) {
                valueTmpBufTempBuf = (valueDeserializer.readString() as string)
            } else if (valueTmpBufTempBufUnionSelector == (1).toByte()) {
                valueTmpBufTempBuf = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for valueTmpBufTempBuf has to be chosen through deserialisation.')
            }
            valueTmpBuf[valueTmpBufBufCounterI] = (valueTmpBufTempBuf as string | arkui_component_units_Resource)
        }
        const valueTmpResult : Array<arkui_component_units_ResourceStr> = valueTmpBuf
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufClosure  = (data: Array<arkui_component_units_ResourceStr>):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            onChangeTmpBufBufArgsSerializer.writeInt32((data.length).toInt());
            for (let dataCounterI = 0; dataCounterI < data.length; dataCounterI++) {
                const dataTmpElement : arkui_component_units_ResourceStr = data[dataCounterI];
                if (dataTmpElement instanceof string) {
                    onChangeTmpBufBufArgsSerializer.writeInt8((0).toByte());
                    const dataTmpElementForIdx0  = dataTmpElement as string;
                    onChangeTmpBufBufArgsSerializer.writeString(dataTmpElementForIdx0);
                } else if (dataTmpElement instanceof arkui_component_units_Resource) {
                    onChangeTmpBufBufArgsSerializer.writeInt8((1).toByte());
                    const dataTmpElementForIdx1  = dataTmpElement as arkui_component_units_Resource;
                    global_resource_Resource_serializer.write(onChangeTmpBufBufArgsSerializer, dataTmpElementForIdx1);
                }
            }
            InteropNativeModule._CallCallbackSync(10, 810300950, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(onChangeTmpBufClosure, onChangeTmpBufBufResource)
        const onChangeTmpResult : Callback<Array<arkui_component_units_ResourceStr>, void> = onChangeTmpBufClosure
        let value : Bindable<Array<arkui_component_units_ResourceStr>> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<Array<arkui_component_units_ResourceStr>>)
        return value
    }
}
export class Bindable_Array_String_serializer {
    public static write(buffer: SerializerBase, value: Bindable<Array<string>>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeInt32((valueHolderForValue.length).toInt())
        for (let valueHolderForValueCounterI = 0; valueHolderForValueCounterI < valueHolderForValue.length; valueHolderForValueCounterI++) {
            const valueHolderForValueTmpElement : string = valueHolderForValue[valueHolderForValueCounterI]
            valueSerializer.writeString(valueHolderForValueTmpElement)
        }
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<Array<string>> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpBufLength : int32 = valueDeserializer.readInt32()
        let valueTmpBuf : Array<string> = new Array<string>(valueTmpBufLength)
        for (let valueTmpBufBufCounterI = 0; valueTmpBufBufCounterI < valueTmpBufLength; valueTmpBufBufCounterI++) {
            valueTmpBuf[valueTmpBufBufCounterI] = (valueDeserializer.readString() as string)
        }
        const valueTmpResult : Array<string> = valueTmpBuf
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufClosure  = (data: Array<string>):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            onChangeTmpBufBufArgsSerializer.writeInt32((data.length).toInt());
            for (let dataCounterI = 0; dataCounterI < data.length; dataCounterI++) {
                const dataTmpElement : string = data[dataCounterI];
                onChangeTmpBufBufArgsSerializer.writeString(dataTmpElement);
            }
            InteropNativeModule._CallCallbackSync(10, -1345362468, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(onChangeTmpBufClosure, onChangeTmpBufBufResource)
        const onChangeTmpResult : Callback<Array<string>, void> = onChangeTmpBufClosure
        let value : Bindable<Array<string>> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<Array<string>>)
        return value
    }
}
export class Bindable_Boolean_serializer {
    public static write(buffer: SerializerBase, value: Bindable<boolean>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeBoolean(valueHolderForValue)
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<boolean> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpResult : boolean = valueDeserializer.readBoolean()
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufClosure  = (data: boolean):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            onChangeTmpBufBufArgsSerializer.writeBoolean(data);
            InteropNativeModule._CallCallbackSync(10, -1691789173, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(onChangeTmpBufClosure, onChangeTmpBufBufResource)
        const onChangeTmpResult : Callback<boolean, void> = onChangeTmpBufClosure
        let value : Bindable<boolean> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<boolean>)
        return value
    }
}
export class Bindable_Date_serializer {
    public static write(buffer: SerializerBase, value: Bindable<Date>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeInt64(valueHolderForValue.getTime()!.toLong())
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<Date> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpResult : Date = new Date(valueDeserializer.readInt64())
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufClosure  = (data: Date):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            onChangeTmpBufBufArgsSerializer.writeInt64(data.getTime()!.toLong());
            InteropNativeModule._CallCallbackSync(10, -1865664613, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(onChangeTmpBufClosure, onChangeTmpBufBufResource)
        const onChangeTmpResult : Callback<Date, void> = onChangeTmpBufClosure
        let value : Bindable<Date> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<Date>)
        return value
    }
}
export class Bindable_F64_serializer {
    public static write(buffer: SerializerBase, value: Bindable<double>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeFloat64(valueHolderForValue)
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<double> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpResult : double = valueDeserializer.readFloat64()
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufClosure  = (data: double):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            onChangeTmpBufBufArgsSerializer.writeFloat64(data);
            InteropNativeModule._CallCallbackSync(10, 2113690827, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(onChangeTmpBufClosure, onChangeTmpBufBufResource)
        const onChangeTmpResult : Callback<double, void> = onChangeTmpBufClosure
        let value : Bindable<double> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<double>)
        return value
    }
}
export class Bindable_I32_serializer {
    public static write(buffer: SerializerBase, value: Bindable<int32>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeInt32(valueHolderForValue)
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<int32> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpResult : int32 = valueDeserializer.readInt32()
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufClosure  = (data: int32):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            onChangeTmpBufBufArgsSerializer.writeInt32(data);
            InteropNativeModule._CallCallbackSync(10, 220612455, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(onChangeTmpBufClosure, onChangeTmpBufBufResource)
        const onChangeTmpResult : Callback<int32, void> = onChangeTmpBufClosure
        let value : Bindable<int32> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<int32>)
        return value
    }
}
export class Bindable_String_serializer {
    public static write(buffer: SerializerBase, value: Bindable<string>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeString(valueHolderForValue)
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<string> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpResult : string = (valueDeserializer.readString() as string)
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufClosure  = (data: string):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            onChangeTmpBufBufArgsSerializer.writeString(data);
            InteropNativeModule._CallCallbackSync(10, 657413210, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(onChangeTmpBufClosure, onChangeTmpBufBufResource)
        const onChangeTmpResult : Callback<string, void> = onChangeTmpBufClosure
        let value : Bindable<string> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<string>)
        return value
    }
}
export class BlurOptions_serializer {
    public static write(buffer: SerializerBase, value: BlurOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForGrayscale  = value.grayscale
        if (valueHolderForGrayscale !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForGrayscaleTmpValue  = valueHolderForGrayscale!
            const valueHolderForGrayscaleTmpValue_0  = valueHolderForGrayscaleTmpValue[0]
            valueSerializer.writeFloat64(valueHolderForGrayscaleTmpValue_0)
            const valueHolderForGrayscaleTmpValue_1  = valueHolderForGrayscaleTmpValue[1]
            valueSerializer.writeFloat64(valueHolderForGrayscaleTmpValue_1)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): BlurOptions {
        let valueDeserializer : DeserializerBase = buffer
        const grayscaleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let grayscaleTmpBuf : [ double, double ] | undefined = undefined
        if ((grayscaleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const grayscaleTmpBufOptValue0 : double = valueDeserializer.readFloat64()
            const grayscaleTmpBufOptValue1 : double = valueDeserializer.readFloat64()
            grayscaleTmpBuf = ([grayscaleTmpBufOptValue0, grayscaleTmpBufOptValue1] as [ double, double ])
        }
        const grayscaleTmpResult : [ double, double ] | undefined = grayscaleTmpBuf
        let value : BlurOptions = ({grayscale: grayscaleTmpResult} as BlurOptions)
        return value
    }
}
export class CaretOffset_serializer {
    public static write(buffer: SerializerBase, value: CaretOffset): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForIndex  = value.index
        valueSerializer.writeInt32(valueHolderForIndex)
        const valueHolderForX  = value.x
        valueSerializer.writeInt32(valueHolderForX)
        const valueHolderForY  = value.y
        valueSerializer.writeInt32(valueHolderForY)
    }
    public static read(buffer: DeserializerBase): CaretOffset {
        let valueDeserializer : DeserializerBase = buffer
        const indexTmpResult : int32 = valueDeserializer.readInt32()
        const xTmpResult : int32 = valueDeserializer.readInt32()
        const yTmpResult : int32 = valueDeserializer.readInt32()
        let value : CaretOffset = ({index: indexTmpResult, x: xTmpResult, y: yTmpResult} as CaretOffset)
        return value
    }
}
export class ClickEffect_serializer {
    public static write(buffer: SerializerBase, value: ClickEffect): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForLevel  = value.level
        valueSerializer.writeInt32(valueHolderForLevel.valueOf())
        const valueHolderForScale  = value.scale
        if (valueHolderForScale !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForScaleTmpValue  = valueHolderForScale!
            valueSerializer.writeFloat64(valueHolderForScaleTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ClickEffect {
        let valueDeserializer : DeserializerBase = buffer
        const levelTmpResult : ClickEffectLevel = ClickEffectLevel.fromValue(valueDeserializer.readInt32())
        const scaleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let scaleTmpBuf : double | undefined = undefined
        if ((scaleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            scaleTmpBuf = valueDeserializer.readFloat64()
        }
        const scaleTmpResult : double | undefined = scaleTmpBuf
        let value : ClickEffect = ({level: levelTmpResult, scale: scaleTmpResult} as ClickEffect)
        return value
    }
}
export class DateRange_serializer {
    public static write(buffer: SerializerBase, value: DateRange): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForStart  = value.start
        if (valueHolderForStart !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForStartTmpValue  = valueHolderForStart!
            valueSerializer.writeInt64(valueHolderForStartTmpValue.getTime()!.toLong())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnd  = value.end
        if (valueHolderForEnd !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEndTmpValue  = valueHolderForEnd!
            valueSerializer.writeInt64(valueHolderForEndTmpValue.getTime()!.toLong())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): DateRange {
        let valueDeserializer : DeserializerBase = buffer
        const startTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let startTmpBuf : Date | undefined = undefined
        if ((startTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            startTmpBuf = new Date(valueDeserializer.readInt64())
        }
        const startTmpResult : Date | undefined = startTmpBuf
        const endTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let endTmpBuf : Date | undefined = undefined
        if ((endTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            endTmpBuf = new Date(valueDeserializer.readInt64())
        }
        const endTmpResult : Date | undefined = endTmpBuf
        let value : DateRange = ({start: startTmpResult, end: endTmpResult} as DateRange)
        return value
    }
}
export class DismissContentCoverAction_serializer {
    public static write(buffer: SerializerBase, value: DismissContentCoverAction): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDismiss  = value.dismiss
        valueSerializer.holdAndWriteCallback(valueHolderForDismiss)
        const valueHolderForReason  = value.reason
        valueSerializer.writeInt32(valueHolderForReason.valueOf())
    }
    public static read(buffer: DeserializerBase): DismissContentCoverAction {
        let valueDeserializer : DeserializerBase = buffer
        const dismissTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const dismissTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const dismissTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const dismissTmpBufClosure  = ():void => {
            const dismissTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            dismissTmpBufBufArgsSerializer.writeInt32(dismissTmpBufBufResource.resourceId);
            dismissTmpBufBufArgsSerializer.writePointer(dismissTmpBufBufCall);
            dismissTmpBufBufArgsSerializer.writePointer(dismissTmpBufBufCallSync);
            InteropNativeModule._CallCallbackSync(10, 553494831, dismissTmpBufBufArgsSerializer.asBuffer(), dismissTmpBufBufArgsSerializer.length());
            dismissTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(dismissTmpBufClosure, dismissTmpBufBufResource)
        const dismissTmpResult : VoidCallback = dismissTmpBufClosure
        const reasonTmpResult : DismissReason = DismissReason.fromValue(valueDeserializer.readInt32())
        let value : DismissContentCoverAction = ({dismiss: dismissTmpResult, reason: reasonTmpResult} as DismissContentCoverAction)
        return value
    }
}
export class DismissSheetAction_serializer {
    public static write(buffer: SerializerBase, value: DismissSheetAction): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDismiss  = value.dismiss
        valueSerializer.holdAndWriteCallback(valueHolderForDismiss)
        const valueHolderForReason  = value.reason
        valueSerializer.writeInt32(valueHolderForReason.valueOf())
    }
    public static read(buffer: DeserializerBase): DismissSheetAction {
        let valueDeserializer : DeserializerBase = buffer
        const dismissTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const dismissTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const dismissTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const dismissTmpBufClosure  = ():void => {
            const dismissTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            dismissTmpBufBufArgsSerializer.writeInt32(dismissTmpBufBufResource.resourceId);
            dismissTmpBufBufArgsSerializer.writePointer(dismissTmpBufBufCall);
            dismissTmpBufBufArgsSerializer.writePointer(dismissTmpBufBufCallSync);
            InteropNativeModule._CallCallbackSync(10, 553494831, dismissTmpBufBufArgsSerializer.asBuffer(), dismissTmpBufBufArgsSerializer.length());
            dismissTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(dismissTmpBufClosure, dismissTmpBufBufResource)
        const dismissTmpResult : VoidCallback = dismissTmpBufClosure
        const reasonTmpResult : DismissReason = DismissReason.fromValue(valueDeserializer.readInt32())
        let value : DismissSheetAction = ({dismiss: dismissTmpResult, reason: reasonTmpResult} as DismissSheetAction)
        return value
    }
}
export class DragInteractionOptions_serializer {
    public static write(buffer: SerializerBase, value: DragInteractionOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForIsMultiSelectionEnabled  = value.isMultiSelectionEnabled
        if (valueHolderForIsMultiSelectionEnabled !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForIsMultiSelectionEnabledTmpValue  = valueHolderForIsMultiSelectionEnabled!
            valueSerializer.writeBoolean(valueHolderForIsMultiSelectionEnabledTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDefaultAnimationBeforeLifting  = value.defaultAnimationBeforeLifting
        if (valueHolderForDefaultAnimationBeforeLifting !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDefaultAnimationBeforeLiftingTmpValue  = valueHolderForDefaultAnimationBeforeLifting!
            valueSerializer.writeBoolean(valueHolderForDefaultAnimationBeforeLiftingTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableEdgeAutoScroll  = value.enableEdgeAutoScroll
        if (valueHolderForEnableEdgeAutoScroll !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableEdgeAutoScrollTmpValue  = valueHolderForEnableEdgeAutoScroll!
            valueSerializer.writeBoolean(valueHolderForEnableEdgeAutoScrollTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableHapticFeedback  = value.enableHapticFeedback
        if (valueHolderForEnableHapticFeedback !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableHapticFeedbackTmpValue  = valueHolderForEnableHapticFeedback!
            valueSerializer.writeBoolean(valueHolderForEnableHapticFeedbackTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForIsLiftingDisabled  = value.isLiftingDisabled
        if (valueHolderForIsLiftingDisabled !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForIsLiftingDisabledTmpValue  = valueHolderForIsLiftingDisabled!
            valueSerializer.writeBoolean(valueHolderForIsLiftingDisabledTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): DragInteractionOptions {
        let valueDeserializer : DeserializerBase = buffer
        const isMultiSelectionEnabledTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let isMultiSelectionEnabledTmpBuf : boolean | undefined = undefined
        if ((isMultiSelectionEnabledTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            isMultiSelectionEnabledTmpBuf = valueDeserializer.readBoolean()
        }
        const isMultiSelectionEnabledTmpResult : boolean | undefined = isMultiSelectionEnabledTmpBuf
        const defaultAnimationBeforeLiftingTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let defaultAnimationBeforeLiftingTmpBuf : boolean | undefined = undefined
        if ((defaultAnimationBeforeLiftingTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            defaultAnimationBeforeLiftingTmpBuf = valueDeserializer.readBoolean()
        }
        const defaultAnimationBeforeLiftingTmpResult : boolean | undefined = defaultAnimationBeforeLiftingTmpBuf
        const enableEdgeAutoScrollTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let enableEdgeAutoScrollTmpBuf : boolean | undefined = undefined
        if ((enableEdgeAutoScrollTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableEdgeAutoScrollTmpBuf = valueDeserializer.readBoolean()
        }
        const enableEdgeAutoScrollTmpResult : boolean | undefined = enableEdgeAutoScrollTmpBuf
        const enableHapticFeedbackTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let enableHapticFeedbackTmpBuf : boolean | undefined = undefined
        if ((enableHapticFeedbackTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableHapticFeedbackTmpBuf = valueDeserializer.readBoolean()
        }
        const enableHapticFeedbackTmpResult : boolean | undefined = enableHapticFeedbackTmpBuf
        const isLiftingDisabledTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let isLiftingDisabledTmpBuf : boolean | undefined = undefined
        if ((isLiftingDisabledTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            isLiftingDisabledTmpBuf = valueDeserializer.readBoolean()
        }
        const isLiftingDisabledTmpResult : boolean | undefined = isLiftingDisabledTmpBuf
        let value : DragInteractionOptions = ({isMultiSelectionEnabled: isMultiSelectionEnabledTmpResult, defaultAnimationBeforeLifting: defaultAnimationBeforeLiftingTmpResult, enableEdgeAutoScroll: enableEdgeAutoScrollTmpResult, enableHapticFeedback: enableHapticFeedbackTmpResult, isLiftingDisabled: isLiftingDisabledTmpResult} as DragInteractionOptions)
        return value
    }
}
export class DragItemInfo_serializer {
    public static write(buffer: SerializerBase, value: DragItemInfo): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForPixelMap  = value.pixelMap
        if (valueHolderForPixelMap !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPixelMapTmpValue  = valueHolderForPixelMap!
            image_PixelMap_serializer.write(valueSerializer, valueHolderForPixelMapTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBuilder  = value.builder
        if (valueHolderForBuilder !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBuilderTmpValue  = valueHolderForBuilder!
            valueSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(valueHolderForBuilderTmpValue))
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForExtraInfo  = value.extraInfo
        if (valueHolderForExtraInfo !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForExtraInfoTmpValue  = valueHolderForExtraInfo!
            valueSerializer.writeString(valueHolderForExtraInfoTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): DragItemInfo {
        let valueDeserializer : DeserializerBase = buffer
        const pixelMapTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let pixelMapTmpBuf : PixelMap | undefined = undefined
        if ((pixelMapTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            pixelMapTmpBuf = (image_PixelMap_serializer.read(valueDeserializer) as image.PixelMap)
        }
        const pixelMapTmpResult : PixelMap | undefined = pixelMapTmpBuf
        const builderTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let builderTmpBuf : CustomBuilder | undefined = undefined
        if ((builderTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const builderTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const builderTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const builderTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const builderTmpBufOptClosure  = ():void => {
                const builderTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                builderTmpBufOptBufArgsSerializer.writeInt32(builderTmpBufOptBufResource.resourceId);
                builderTmpBufOptBufArgsSerializer.writePointer(builderTmpBufOptBufCall);
                builderTmpBufOptBufArgsSerializer.writePointer(builderTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1834072896, builderTmpBufOptBufArgsSerializer.asBuffer(), builderTmpBufOptBufArgsSerializer.length());
                builderTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(builderTmpBufOptClosure, builderTmpBufOptBufResource)
            builderTmpBuf = builderTmpBufOptClosure
        }
        const builderTmpResult : CustomBuilder | undefined = builderTmpBuf
        const extraInfoTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let extraInfoTmpBuf : string | undefined = undefined
        if ((extraInfoTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            extraInfoTmpBuf = (valueDeserializer.readString() as string)
        }
        const extraInfoTmpResult : string | undefined = extraInfoTmpBuf
        let value : DragItemInfo = ({pixelMap: pixelMapTmpResult, builder: builderTmpResult, extraInfo: extraInfoTmpResult} as DragItemInfo)
        return value
    }
}
export class DropOptions_serializer {
    public static write(buffer: SerializerBase, value: DropOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDisableDataPrefetch  = value.disableDataPrefetch
        if (valueHolderForDisableDataPrefetch !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDisableDataPrefetchTmpValue  = valueHolderForDisableDataPrefetch!
            valueSerializer.writeBoolean(valueHolderForDisableDataPrefetchTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): DropOptions {
        let valueDeserializer : DeserializerBase = buffer
        const disableDataPrefetchTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let disableDataPrefetchTmpBuf : boolean | undefined = undefined
        if ((disableDataPrefetchTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            disableDataPrefetchTmpBuf = valueDeserializer.readBoolean()
        }
        const disableDataPrefetchTmpResult : boolean | undefined = disableDataPrefetchTmpBuf
        let value : DropOptions = ({disableDataPrefetch: disableDataPrefetchTmpResult} as DropOptions)
        return value
    }
}
export class EdgeEffectOptions_serializer {
    public static write(buffer: SerializerBase, value: EdgeEffectOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAlwaysEnabled  = value.alwaysEnabled
        valueSerializer.writeBoolean(valueHolderForAlwaysEnabled)
        const valueHolderForEffectEdge  = value.effectEdge
        if (valueHolderForEffectEdge !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEffectEdgeTmpValue  = valueHolderForEffectEdge!
            valueSerializer.writeInt32(valueHolderForEffectEdgeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): EdgeEffectOptions {
        let valueDeserializer : DeserializerBase = buffer
        const alwaysEnabledTmpResult : boolean = valueDeserializer.readBoolean()
        const effectEdgeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let effectEdgeTmpBuf : int32 | undefined = undefined
        if ((effectEdgeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            effectEdgeTmpBuf = valueDeserializer.readInt32()
        }
        const effectEdgeTmpResult : int32 | undefined = effectEdgeTmpBuf
        let value : EdgeEffectOptions = ({alwaysEnabled: alwaysEnabledTmpResult, effectEdge: effectEdgeTmpResult} as EdgeEffectOptions)
        return value
    }
}
export class ExpectedFrameRateRange_serializer {
    public static write(buffer: SerializerBase, value: ExpectedFrameRateRange): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForMin  = value.min
        valueSerializer.writeInt32(valueHolderForMin)
        const valueHolderForMax  = value.max
        valueSerializer.writeInt32(valueHolderForMax)
        const valueHolderForExpected  = value.expected
        valueSerializer.writeInt32(valueHolderForExpected)
    }
    public static read(buffer: DeserializerBase): ExpectedFrameRateRange {
        let valueDeserializer : DeserializerBase = buffer
        const minTmpResult : int32 = valueDeserializer.readInt32()
        const maxTmpResult : int32 = valueDeserializer.readInt32()
        const expectedTmpResult : int32 = valueDeserializer.readInt32()
        let value : ExpectedFrameRateRange = ({min: minTmpResult, max: maxTmpResult, expected: expectedTmpResult} as ExpectedFrameRateRange)
        return value
    }
}
export class FocusMovement_serializer {
    public static write(buffer: SerializerBase, value: FocusMovement): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForForward  = value.forward
        if (valueHolderForForward !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForForwardTmpValue  = valueHolderForForward!
            valueSerializer.writeString(valueHolderForForwardTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackward  = value.backward
        if (valueHolderForBackward !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackwardTmpValue  = valueHolderForBackward!
            valueSerializer.writeString(valueHolderForBackwardTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForUp  = value.up
        if (valueHolderForUp !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForUpTmpValue  = valueHolderForUp!
            valueSerializer.writeString(valueHolderForUpTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDown  = value.down
        if (valueHolderForDown !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDownTmpValue  = valueHolderForDown!
            valueSerializer.writeString(valueHolderForDownTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForLeft  = value.left
        if (valueHolderForLeft !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForLeftTmpValue  = valueHolderForLeft!
            valueSerializer.writeString(valueHolderForLeftTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRight  = value.right
        if (valueHolderForRight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRightTmpValue  = valueHolderForRight!
            valueSerializer.writeString(valueHolderForRightTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): FocusMovement {
        let valueDeserializer : DeserializerBase = buffer
        const forwardTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let forwardTmpBuf : string | undefined = undefined
        if ((forwardTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            forwardTmpBuf = (valueDeserializer.readString() as string)
        }
        const forwardTmpResult : string | undefined = forwardTmpBuf
        const backwardTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let backwardTmpBuf : string | undefined = undefined
        if ((backwardTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backwardTmpBuf = (valueDeserializer.readString() as string)
        }
        const backwardTmpResult : string | undefined = backwardTmpBuf
        const upTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let upTmpBuf : string | undefined = undefined
        if ((upTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            upTmpBuf = (valueDeserializer.readString() as string)
        }
        const upTmpResult : string | undefined = upTmpBuf
        const downTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let downTmpBuf : string | undefined = undefined
        if ((downTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            downTmpBuf = (valueDeserializer.readString() as string)
        }
        const downTmpResult : string | undefined = downTmpBuf
        const leftTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let leftTmpBuf : string | undefined = undefined
        if ((leftTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            leftTmpBuf = (valueDeserializer.readString() as string)
        }
        const leftTmpResult : string | undefined = leftTmpBuf
        const rightTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let rightTmpBuf : string | undefined = undefined
        if ((rightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            rightTmpBuf = (valueDeserializer.readString() as string)
        }
        const rightTmpResult : string | undefined = rightTmpBuf
        let value : FocusMovement = ({forward: forwardTmpResult, backward: backwardTmpResult, up: upTmpResult, down: downTmpResult, left: leftTmpResult, right: rightTmpResult} as FocusMovement)
        return value
    }
}
export class ForegroundEffectOptions_serializer {
    public static write(buffer: SerializerBase, value: ForegroundEffectOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForRadius  = value.radius
        if (valueHolderForRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRadiusTmpValue  = valueHolderForRadius!
            valueSerializer.writeFloat64(valueHolderForRadiusTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ForegroundEffectOptions {
        let valueDeserializer : DeserializerBase = buffer
        const radiusTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let radiusTmpBuf : double | undefined = undefined
        if ((radiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            radiusTmpBuf = valueDeserializer.readFloat64()
        }
        const radiusTmpResult : double | undefined = radiusTmpBuf
        let value : ForegroundEffectOptions = ({radius: radiusTmpResult} as ForegroundEffectOptions)
        return value
    }
}
export class GeometryTransitionOptions_serializer {
    public static write(buffer: SerializerBase, value: GeometryTransitionOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForFollow  = value.follow
        if (valueHolderForFollow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFollowTmpValue  = valueHolderForFollow!
            valueSerializer.writeBoolean(valueHolderForFollowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHierarchyStrategy  = value.hierarchyStrategy
        if (valueHolderForHierarchyStrategy !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHierarchyStrategyTmpValue  = (valueHolderForHierarchyStrategy as TransitionHierarchyStrategy)
            valueSerializer.writeInt32(valueHolderForHierarchyStrategyTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): GeometryTransitionOptions {
        let valueDeserializer : DeserializerBase = buffer
        const followTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let followTmpBuf : boolean | undefined = undefined
        if ((followTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            followTmpBuf = valueDeserializer.readBoolean()
        }
        const followTmpResult : boolean | undefined = followTmpBuf
        const hierarchyStrategyTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let hierarchyStrategyTmpBuf : TransitionHierarchyStrategy | undefined = undefined
        if ((hierarchyStrategyTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            hierarchyStrategyTmpBuf = TransitionHierarchyStrategy.fromValue(valueDeserializer.readInt32())
        }
        const hierarchyStrategyTmpResult : TransitionHierarchyStrategy | undefined = hierarchyStrategyTmpBuf
        let value : GeometryTransitionOptions = ({follow: followTmpResult, hierarchyStrategy: hierarchyStrategyTmpResult} as GeometryTransitionOptions)
        return value
    }
}
export class HorizontalAlignParam_serializer {
    public static write(buffer: SerializerBase, value: HorizontalAlignParam): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAnchor  = value.anchor
        valueSerializer.writeString(valueHolderForAnchor)
        const valueHolderForAlign  = value.align
        valueSerializer.writeInt32(valueHolderForAlign.valueOf())
    }
    public static read(buffer: DeserializerBase): HorizontalAlignParam {
        let valueDeserializer : DeserializerBase = buffer
        const anchorTmpResult : string = (valueDeserializer.readString() as string)
        const alignTmpResult : HorizontalAlign = HorizontalAlign.fromValue(valueDeserializer.readInt32())
        let value : HorizontalAlignParam = ({anchor: anchorTmpResult, align: alignTmpResult} as HorizontalAlignParam)
        return value
    }
}
export class InputCounterOptions_serializer {
    public static write(buffer: SerializerBase, value: InputCounterOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForThresholdPercentage  = value.thresholdPercentage
        if (valueHolderForThresholdPercentage !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForThresholdPercentageTmpValue  = valueHolderForThresholdPercentage!
            valueSerializer.writeFloat64(valueHolderForThresholdPercentageTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHighlightBorder  = value.highlightBorder
        if (valueHolderForHighlightBorder !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHighlightBorderTmpValue  = valueHolderForHighlightBorder!
            valueSerializer.writeBoolean(valueHolderForHighlightBorderTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): InputCounterOptions {
        let valueDeserializer : DeserializerBase = buffer
        const thresholdPercentageTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let thresholdPercentageTmpBuf : double | undefined = undefined
        if ((thresholdPercentageTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            thresholdPercentageTmpBuf = valueDeserializer.readFloat64()
        }
        const thresholdPercentageTmpResult : double | undefined = thresholdPercentageTmpBuf
        const highlightBorderTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let highlightBorderTmpBuf : boolean | undefined = undefined
        if ((highlightBorderTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            highlightBorderTmpBuf = valueDeserializer.readBoolean()
        }
        const highlightBorderTmpResult : boolean | undefined = highlightBorderTmpBuf
        let value : InputCounterOptions = ({thresholdPercentage: thresholdPercentageTmpResult, highlightBorder: highlightBorderTmpResult} as InputCounterOptions)
        return value
    }
}
export class ItemDragEventHandler_serializer {
    public static write(buffer: SerializerBase, value: ItemDragEventHandler): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForOnLongPress  = value.onLongPress
        if (valueHolderForOnLongPress !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnLongPressTmpValue  = valueHolderForOnLongPress!
            valueSerializer.holdAndWriteCallback(valueHolderForOnLongPressTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnDragStart  = value.onDragStart
        if (valueHolderForOnDragStart !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnDragStartTmpValue  = valueHolderForOnDragStart!
            valueSerializer.holdAndWriteCallback(valueHolderForOnDragStartTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnMoveThrough  = value.onMoveThrough
        if (valueHolderForOnMoveThrough !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnMoveThroughTmpValue  = valueHolderForOnMoveThrough!
            valueSerializer.holdAndWriteCallback(valueHolderForOnMoveThroughTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnDrop  = value.onDrop
        if (valueHolderForOnDrop !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnDropTmpValue  = valueHolderForOnDrop!
            valueSerializer.holdAndWriteCallback(valueHolderForOnDropTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ItemDragEventHandler {
        let valueDeserializer : DeserializerBase = buffer
        const onLongPressTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onLongPressTmpBuf : Callback<int32, void> | undefined = undefined
        if ((onLongPressTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onLongPressTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onLongPressTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onLongPressTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onLongPressTmpBufOptClosure  = (data: int32):void => {
                const onLongPressTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onLongPressTmpBufOptBufArgsSerializer.writeInt32(onLongPressTmpBufOptBufResource.resourceId);
                onLongPressTmpBufOptBufArgsSerializer.writePointer(onLongPressTmpBufOptBufCall);
                onLongPressTmpBufOptBufArgsSerializer.writePointer(onLongPressTmpBufOptBufCallSync);
                onLongPressTmpBufOptBufArgsSerializer.writeInt32(data);
                InteropNativeModule._CallCallbackSync(10, 220612455, onLongPressTmpBufOptBufArgsSerializer.asBuffer(), onLongPressTmpBufOptBufArgsSerializer.length());
                onLongPressTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onLongPressTmpBufOptClosure, onLongPressTmpBufOptBufResource)
            onLongPressTmpBuf = onLongPressTmpBufOptClosure
        }
        const onLongPressTmpResult : Callback<int32, void> | undefined = onLongPressTmpBuf
        const onDragStartTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onDragStartTmpBuf : Callback<int32, void> | undefined = undefined
        if ((onDragStartTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onDragStartTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDragStartTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onDragStartTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onDragStartTmpBufOptClosure  = (data: int32):void => {
                const onDragStartTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onDragStartTmpBufOptBufArgsSerializer.writeInt32(onDragStartTmpBufOptBufResource.resourceId);
                onDragStartTmpBufOptBufArgsSerializer.writePointer(onDragStartTmpBufOptBufCall);
                onDragStartTmpBufOptBufArgsSerializer.writePointer(onDragStartTmpBufOptBufCallSync);
                onDragStartTmpBufOptBufArgsSerializer.writeInt32(data);
                InteropNativeModule._CallCallbackSync(10, 220612455, onDragStartTmpBufOptBufArgsSerializer.asBuffer(), onDragStartTmpBufOptBufArgsSerializer.length());
                onDragStartTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onDragStartTmpBufOptClosure, onDragStartTmpBufOptBufResource)
            onDragStartTmpBuf = onDragStartTmpBufOptClosure
        }
        const onDragStartTmpResult : Callback<int32, void> | undefined = onDragStartTmpBuf
        const onMoveThroughTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onMoveThroughTmpBuf : OnMoveHandler | undefined = undefined
        if ((onMoveThroughTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onMoveThroughTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onMoveThroughTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onMoveThroughTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onMoveThroughTmpBufOptClosure  = (from: int32, to: int32):void => {
                const onMoveThroughTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onMoveThroughTmpBufOptBufArgsSerializer.writeInt32(onMoveThroughTmpBufOptBufResource.resourceId);
                onMoveThroughTmpBufOptBufArgsSerializer.writePointer(onMoveThroughTmpBufOptBufCall);
                onMoveThroughTmpBufOptBufArgsSerializer.writePointer(onMoveThroughTmpBufOptBufCallSync);
                onMoveThroughTmpBufOptBufArgsSerializer.writeInt32(from);
                onMoveThroughTmpBufOptBufArgsSerializer.writeInt32(to);
                InteropNativeModule._CallCallbackSync(10, 1544818266, onMoveThroughTmpBufOptBufArgsSerializer.asBuffer(), onMoveThroughTmpBufOptBufArgsSerializer.length());
                onMoveThroughTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onMoveThroughTmpBufOptClosure, onMoveThroughTmpBufOptBufResource)
            onMoveThroughTmpBuf = onMoveThroughTmpBufOptClosure
        }
        const onMoveThroughTmpResult : OnMoveHandler | undefined = onMoveThroughTmpBuf
        const onDropTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onDropTmpBuf : Callback<int32, void> | undefined = undefined
        if ((onDropTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onDropTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDropTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onDropTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onDropTmpBufOptClosure  = (data: int32):void => {
                const onDropTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onDropTmpBufOptBufArgsSerializer.writeInt32(onDropTmpBufOptBufResource.resourceId);
                onDropTmpBufOptBufArgsSerializer.writePointer(onDropTmpBufOptBufCall);
                onDropTmpBufOptBufArgsSerializer.writePointer(onDropTmpBufOptBufCallSync);
                onDropTmpBufOptBufArgsSerializer.writeInt32(data);
                InteropNativeModule._CallCallbackSync(10, 220612455, onDropTmpBufOptBufArgsSerializer.asBuffer(), onDropTmpBufOptBufArgsSerializer.length());
                onDropTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onDropTmpBufOptClosure, onDropTmpBufOptBufResource)
            onDropTmpBuf = onDropTmpBufOptClosure
        }
        const onDropTmpResult : Callback<int32, void> | undefined = onDropTmpBuf
        let value : ItemDragEventHandler = ({onLongPress: onLongPressTmpResult, onDragStart: onDragStartTmpResult, onMoveThrough: onMoveThroughTmpResult, onDrop: onDropTmpResult} as ItemDragEventHandler)
        return value
    }
}
export class KeyframeState_serializer {
    public static write(buffer: SerializerBase, value: KeyframeState): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDuration  = value.duration
        valueSerializer.writeInt32(valueHolderForDuration)
        const valueHolderForCurve  = value.curve
        if (valueHolderForCurve !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCurveTmpValue  = valueHolderForCurve!
            if (valueHolderForCurveTmpValue instanceof Curve) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForCurveTmpValueForIdx0  = valueHolderForCurveTmpValue as Curve
                valueSerializer.writeInt32(valueHolderForCurveTmpValueForIdx0.valueOf())
            } else if (valueHolderForCurveTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForCurveTmpValueForIdx1  = valueHolderForCurveTmpValue as string
                valueSerializer.writeString(valueHolderForCurveTmpValueForIdx1)
            } else if (valueHolderForCurveTmpValue instanceof ICurve) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForCurveTmpValueForIdx2  = valueHolderForCurveTmpValue as ICurve
                curves_ICurve_serializer.write(valueSerializer, valueHolderForCurveTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEvent  = value.event
        valueSerializer.holdAndWriteCallback(valueHolderForEvent)
    }
    public static read(buffer: DeserializerBase): KeyframeState {
        let valueDeserializer : DeserializerBase = buffer
        const durationTmpResult : int32 = valueDeserializer.readInt32()
        const curveTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let curveTmpBuf : Curve | string | ICurve | undefined = undefined
        if ((curveTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const curveTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let curveTmpBufOpt : Curve | string | ICurve | undefined
            if (curveTmpBufOptUnionSelector == (0).toByte()) {
                curveTmpBufOpt = curves.Curve.fromValue(valueDeserializer.readInt32())
            } else if (curveTmpBufOptUnionSelector == (1).toByte()) {
                curveTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (curveTmpBufOptUnionSelector == (2).toByte()) {
                curveTmpBufOpt = (curves_ICurve_serializer.read(valueDeserializer) as curves.ICurve)
            } else {
                throw new Error('One of the branches for curveTmpBufOpt has to be chosen through deserialisation.')
            }
            curveTmpBuf = (curveTmpBufOpt as Curve | string | ICurve)
        }
        const curveTmpResult : Curve | string | ICurve | undefined = curveTmpBuf
        const eventTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const eventTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const eventTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const eventTmpBufClosure  = ():void => {
            const eventTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            eventTmpBufBufArgsSerializer.writeInt32(eventTmpBufBufResource.resourceId);
            eventTmpBufBufArgsSerializer.writePointer(eventTmpBufBufCall);
            eventTmpBufBufArgsSerializer.writePointer(eventTmpBufBufCallSync);
            InteropNativeModule._CallCallbackSync(10, -1225416436, eventTmpBufBufArgsSerializer.asBuffer(), eventTmpBufBufArgsSerializer.length());
            eventTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(eventTmpBufClosure, eventTmpBufBufResource)
        const eventTmpResult : (() => void) = eventTmpBufClosure
        let value : KeyframeState = ({duration: durationTmpResult, curve: curveTmpResult, event: eventTmpResult} as KeyframeState)
        return value
    }
}
export class LinearGradientBlurOptions_serializer {
    public static write(buffer: SerializerBase, value: LinearGradientBlurOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForFractionStops  = value.fractionStops
        if (valueHolderForFractionStops !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFractionStopsTmpValue  = valueHolderForFractionStops!
            valueSerializer.writeInt32((valueHolderForFractionStopsTmpValue.length).toInt())
            for (let valueHolderForFractionStopsTmpValueCounterI = 0; valueHolderForFractionStopsTmpValueCounterI < valueHolderForFractionStopsTmpValue.length; valueHolderForFractionStopsTmpValueCounterI++) {
                const valueHolderForFractionStopsTmpValueTmpElement : FractionStop = valueHolderForFractionStopsTmpValue[valueHolderForFractionStopsTmpValueCounterI]
                const valueHolderForFractionStopsTmpValueTmpElement_0  = valueHolderForFractionStopsTmpValueTmpElement[0]
                valueSerializer.writeFloat64(valueHolderForFractionStopsTmpValueTmpElement_0)
                const valueHolderForFractionStopsTmpValueTmpElement_1  = valueHolderForFractionStopsTmpValueTmpElement[1]
                valueSerializer.writeFloat64(valueHolderForFractionStopsTmpValueTmpElement_1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDirection  = value.direction
        if (valueHolderForDirection !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDirectionTmpValue  = (valueHolderForDirection as GradientDirection)
            valueSerializer.writeInt32(valueHolderForDirectionTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): LinearGradientBlurOptions {
        let valueDeserializer : DeserializerBase = buffer
        const fractionStopsTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let fractionStopsTmpBuf : Array<FractionStop> | undefined = undefined
        if ((fractionStopsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const fractionStopsTmpBufOptLength : int32 = valueDeserializer.readInt32()
            let fractionStopsTmpBufOpt : Array<FractionStop> = new Array<FractionStop>(fractionStopsTmpBufOptLength)
            for (let fractionStopsTmpBufOptBufCounterI = 0; fractionStopsTmpBufOptBufCounterI < fractionStopsTmpBufOptLength; fractionStopsTmpBufOptBufCounterI++) {
                const fractionStopsTmpBufOptTempBufValue0 : double = valueDeserializer.readFloat64()
                const fractionStopsTmpBufOptTempBufValue1 : double = valueDeserializer.readFloat64()
                fractionStopsTmpBufOpt[fractionStopsTmpBufOptBufCounterI] = ([fractionStopsTmpBufOptTempBufValue0, fractionStopsTmpBufOptTempBufValue1] as FractionStop)
            }
            fractionStopsTmpBuf = fractionStopsTmpBufOpt
        }
        const fractionStopsTmpResult : Array<FractionStop> | undefined = fractionStopsTmpBuf
        const directionTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let directionTmpBuf : GradientDirection | undefined = undefined
        if ((directionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            directionTmpBuf = GradientDirection.fromValue(valueDeserializer.readInt32())
        }
        const directionTmpResult : GradientDirection | undefined = directionTmpBuf
        let value : LinearGradientBlurOptions = ({fractionStops: fractionStopsTmpResult, direction: directionTmpResult} as LinearGradientBlurOptions)
        return value
    }
}
export class LinearGradientOptions_serializer {
    public static write(buffer: SerializerBase, value: LinearGradientOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAngle  = value.angle
        if (valueHolderForAngle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAngleTmpValue  = valueHolderForAngle!
            if (valueHolderForAngleTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForAngleTmpValueForIdx0  = valueHolderForAngleTmpValue as double
                valueSerializer.writeFloat64(valueHolderForAngleTmpValueForIdx0)
            } else if (valueHolderForAngleTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForAngleTmpValueForIdx1  = valueHolderForAngleTmpValue as string
                valueSerializer.writeString(valueHolderForAngleTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDirection  = value.direction
        if (valueHolderForDirection !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDirectionTmpValue  = (valueHolderForDirection as GradientDirection)
            valueSerializer.writeInt32(valueHolderForDirectionTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForColors  = value.colors
        valueSerializer.writeInt32((valueHolderForColors.length).toInt())
        for (let valueHolderForColorsCounterI = 0; valueHolderForColorsCounterI < valueHolderForColors.length; valueHolderForColorsCounterI++) {
            const valueHolderForColorsTmpElement : [ ResourceColor, double ] = valueHolderForColors[valueHolderForColorsCounterI]
            const valueHolderForColorsTmpElement_0  = valueHolderForColorsTmpElement[0]
            if (valueHolderForColorsTmpElement_0 instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorsTmpElement_0ForIdx0  = valueHolderForColorsTmpElement_0 as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForColorsTmpElement_0ForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForColorsTmpElement_0 instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorsTmpElement_0ForIdx1  = valueHolderForColorsTmpElement_0 as int32
                valueSerializer.writeInt32(valueHolderForColorsTmpElement_0ForIdx1)
            } else if (valueHolderForColorsTmpElement_0 instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorsTmpElement_0ForIdx2  = valueHolderForColorsTmpElement_0 as string
                valueSerializer.writeString(valueHolderForColorsTmpElement_0ForIdx2)
            } else if (valueHolderForColorsTmpElement_0 instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorsTmpElement_0ForIdx3  = valueHolderForColorsTmpElement_0 as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForColorsTmpElement_0ForIdx3)
            }
            const valueHolderForColorsTmpElement_1  = valueHolderForColorsTmpElement[1]
            valueSerializer.writeFloat64(valueHolderForColorsTmpElement_1)
        }
        const valueHolderForRepeating  = value.repeating
        if (valueHolderForRepeating !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRepeatingTmpValue  = valueHolderForRepeating!
            valueSerializer.writeBoolean(valueHolderForRepeatingTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): LinearGradientOptions {
        let valueDeserializer : DeserializerBase = buffer
        const angleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let angleTmpBuf : double | string | undefined = undefined
        if ((angleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const angleTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let angleTmpBufOpt : double | string | undefined
            if (angleTmpBufOptUnionSelector == (0).toByte()) {
                angleTmpBufOpt = valueDeserializer.readFloat64()
            } else if (angleTmpBufOptUnionSelector == (1).toByte()) {
                angleTmpBufOpt = (valueDeserializer.readString() as string)
            } else {
                throw new Error('One of the branches for angleTmpBufOpt has to be chosen through deserialisation.')
            }
            angleTmpBuf = (angleTmpBufOpt as double | string)
        }
        const angleTmpResult : double | string | undefined = angleTmpBuf
        const directionTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let directionTmpBuf : GradientDirection | undefined = undefined
        if ((directionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            directionTmpBuf = GradientDirection.fromValue(valueDeserializer.readInt32())
        }
        const directionTmpResult : GradientDirection | undefined = directionTmpBuf
        const colorsTmpBufLength : int32 = valueDeserializer.readInt32()
        let colorsTmpBuf : Array<[ ResourceColor, double ]> = new Array<[ ResourceColor, double ]>(colorsTmpBufLength)
        for (let colorsTmpBufBufCounterI = 0; colorsTmpBufBufCounterI < colorsTmpBufLength; colorsTmpBufBufCounterI++) {
            const colorsTmpBufTempBufValue0TempBufUnionSelector : int32 = valueDeserializer.readInt8()
            let colorsTmpBufTempBufValue0TempBuf : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (colorsTmpBufTempBufValue0TempBufUnionSelector == (0).toByte()) {
                colorsTmpBufTempBufValue0TempBuf = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (1).toByte()) {
                colorsTmpBufTempBufValue0TempBuf = valueDeserializer.readInt32()
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (2).toByte()) {
                colorsTmpBufTempBufValue0TempBuf = (valueDeserializer.readString() as string)
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (3).toByte()) {
                colorsTmpBufTempBufValue0TempBuf = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for colorsTmpBufTempBufValue0TempBuf has to be chosen through deserialisation.')
            }
            const colorsTmpBufTempBufValue0 : ResourceColor = (colorsTmpBufTempBufValue0TempBuf as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
            const colorsTmpBufTempBufValue1 : double = valueDeserializer.readFloat64()
            colorsTmpBuf[colorsTmpBufBufCounterI] = ([colorsTmpBufTempBufValue0, colorsTmpBufTempBufValue1] as [ ResourceColor, double ])
        }
        const colorsTmpResult : Array<[ ResourceColor, double ]> = colorsTmpBuf
        const repeatingTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let repeatingTmpBuf : boolean | undefined = undefined
        if ((repeatingTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            repeatingTmpBuf = valueDeserializer.readBoolean()
        }
        const repeatingTmpResult : boolean | undefined = repeatingTmpBuf
        let value : LinearGradientOptions = ({angle: angleTmpResult, direction: directionTmpResult, colors: colorsTmpResult, repeating: repeatingTmpResult} as LinearGradientOptions)
        return value
    }
}
export class LocalizedHorizontalAlignParam_serializer {
    public static write(buffer: SerializerBase, value: LocalizedHorizontalAlignParam): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAnchor  = value.anchor
        valueSerializer.writeString(valueHolderForAnchor)
        const valueHolderForAlign  = value.align
        valueSerializer.writeInt32(valueHolderForAlign.valueOf())
    }
    public static read(buffer: DeserializerBase): LocalizedHorizontalAlignParam {
        let valueDeserializer : DeserializerBase = buffer
        const anchorTmpResult : string = (valueDeserializer.readString() as string)
        const alignTmpResult : HorizontalAlign = HorizontalAlign.fromValue(valueDeserializer.readInt32())
        let value : LocalizedHorizontalAlignParam = ({anchor: anchorTmpResult, align: alignTmpResult} as LocalizedHorizontalAlignParam)
        return value
    }
}
export class LocalizedVerticalAlignParam_serializer {
    public static write(buffer: SerializerBase, value: LocalizedVerticalAlignParam): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAnchor  = value.anchor
        valueSerializer.writeString(valueHolderForAnchor)
        const valueHolderForAlign  = value.align
        valueSerializer.writeInt32(valueHolderForAlign.valueOf())
    }
    public static read(buffer: DeserializerBase): LocalizedVerticalAlignParam {
        let valueDeserializer : DeserializerBase = buffer
        const anchorTmpResult : string = (valueDeserializer.readString() as string)
        const alignTmpResult : VerticalAlign = VerticalAlign.fromValue(valueDeserializer.readInt32())
        let value : LocalizedVerticalAlignParam = ({anchor: anchorTmpResult, align: alignTmpResult} as LocalizedVerticalAlignParam)
        return value
    }
}
export class MotionBlurAnchor_serializer {
    public static write(buffer: SerializerBase, value: MotionBlurAnchor): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForX  = value.x
        if (valueHolderForX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForXTmpValue  = valueHolderForX!
            valueSerializer.writeFloat64(valueHolderForXTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForY  = value.y
        if (valueHolderForY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForYTmpValue  = valueHolderForY!
            valueSerializer.writeFloat64(valueHolderForYTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): MotionBlurAnchor {
        let valueDeserializer : DeserializerBase = buffer
        const xTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let xTmpBuf : double | undefined = undefined
        if ((xTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            xTmpBuf = valueDeserializer.readFloat64()
        }
        const xTmpResult : double | undefined = xTmpBuf
        const yTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let yTmpBuf : double | undefined = undefined
        if ((yTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            yTmpBuf = valueDeserializer.readFloat64()
        }
        const yTmpResult : double | undefined = yTmpBuf
        let value : MotionBlurAnchor = ({x: xTmpResult, y: yTmpResult} as MotionBlurAnchor)
        return value
    }
}
export class MotionPathOptions_serializer {
    public static write(buffer: SerializerBase, value: MotionPathOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForPath  = value.path
        valueSerializer.writeString(valueHolderForPath)
        const valueHolderForFrom  = value.from
        if (valueHolderForFrom !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFromTmpValue  = valueHolderForFrom!
            valueSerializer.writeFloat64(valueHolderForFromTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTo  = value.to
        if (valueHolderForTo !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForToTmpValue  = valueHolderForTo!
            valueSerializer.writeFloat64(valueHolderForToTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRotatable  = value.rotatable
        if (valueHolderForRotatable !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRotatableTmpValue  = valueHolderForRotatable!
            valueSerializer.writeBoolean(valueHolderForRotatableTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): MotionPathOptions {
        let valueDeserializer : DeserializerBase = buffer
        const pathTmpResult : string = (valueDeserializer.readString() as string)
        const fromTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let fromTmpBuf : double | undefined = undefined
        if ((fromTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            fromTmpBuf = valueDeserializer.readFloat64()
        }
        const fromTmpResult : double | undefined = fromTmpBuf
        const toTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let toTmpBuf : double | undefined = undefined
        if ((toTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            toTmpBuf = valueDeserializer.readFloat64()
        }
        const toTmpResult : double | undefined = toTmpBuf
        const rotatableTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let rotatableTmpBuf : boolean | undefined = undefined
        if ((rotatableTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            rotatableTmpBuf = valueDeserializer.readBoolean()
        }
        const rotatableTmpResult : boolean | undefined = rotatableTmpBuf
        let value : MotionPathOptions = ({path: pathTmpResult, from: fromTmpResult, to: toTmpResult, rotatable: rotatableTmpResult} as MotionPathOptions)
        return value
    }
}
export class OverlayOffset_serializer {
    public static write(buffer: SerializerBase, value: OverlayOffset): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForX  = value.x
        if (valueHolderForX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForXTmpValue  = valueHolderForX!
            valueSerializer.writeFloat64(valueHolderForXTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForY  = value.y
        if (valueHolderForY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForYTmpValue  = valueHolderForY!
            valueSerializer.writeFloat64(valueHolderForYTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): OverlayOffset {
        let valueDeserializer : DeserializerBase = buffer
        const xTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let xTmpBuf : double | undefined = undefined
        if ((xTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            xTmpBuf = valueDeserializer.readFloat64()
        }
        const xTmpResult : double | undefined = xTmpBuf
        const yTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let yTmpBuf : double | undefined = undefined
        if ((yTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            yTmpBuf = valueDeserializer.readFloat64()
        }
        const yTmpResult : double | undefined = yTmpBuf
        let value : OverlayOffset = ({x: xTmpResult, y: yTmpResult} as OverlayOffset)
        return value
    }
}
export class PixelRoundPolicy_serializer {
    public static write(buffer: SerializerBase, value: PixelRoundPolicy): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForStart  = value.start
        if (valueHolderForStart !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForStartTmpValue  = (valueHolderForStart as PixelRoundCalcPolicy)
            valueSerializer.writeInt32(valueHolderForStartTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTop  = value.top
        if (valueHolderForTop !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTopTmpValue  = (valueHolderForTop as PixelRoundCalcPolicy)
            valueSerializer.writeInt32(valueHolderForTopTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnd  = value.end
        if (valueHolderForEnd !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEndTmpValue  = (valueHolderForEnd as PixelRoundCalcPolicy)
            valueSerializer.writeInt32(valueHolderForEndTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBottom  = value.bottom
        if (valueHolderForBottom !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBottomTmpValue  = (valueHolderForBottom as PixelRoundCalcPolicy)
            valueSerializer.writeInt32(valueHolderForBottomTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PixelRoundPolicy {
        let valueDeserializer : DeserializerBase = buffer
        const startTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let startTmpBuf : PixelRoundCalcPolicy | undefined = undefined
        if ((startTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            startTmpBuf = PixelRoundCalcPolicy.fromValue(valueDeserializer.readInt32())
        }
        const startTmpResult : PixelRoundCalcPolicy | undefined = startTmpBuf
        const topTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let topTmpBuf : PixelRoundCalcPolicy | undefined = undefined
        if ((topTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            topTmpBuf = PixelRoundCalcPolicy.fromValue(valueDeserializer.readInt32())
        }
        const topTmpResult : PixelRoundCalcPolicy | undefined = topTmpBuf
        const endTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let endTmpBuf : PixelRoundCalcPolicy | undefined = undefined
        if ((endTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            endTmpBuf = PixelRoundCalcPolicy.fromValue(valueDeserializer.readInt32())
        }
        const endTmpResult : PixelRoundCalcPolicy | undefined = endTmpBuf
        const bottomTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let bottomTmpBuf : PixelRoundCalcPolicy | undefined = undefined
        if ((bottomTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            bottomTmpBuf = PixelRoundCalcPolicy.fromValue(valueDeserializer.readInt32())
        }
        const bottomTmpResult : PixelRoundCalcPolicy | undefined = bottomTmpBuf
        let value : PixelRoundPolicy = ({start: startTmpResult, top: topTmpResult, end: endTmpResult, bottom: bottomTmpResult} as PixelRoundPolicy)
        return value
    }
}
export class PopupButton_serializer {
    public static write(buffer: SerializerBase, value: PopupButton): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeString(valueHolderForValue)
        const valueHolderForAction  = value.action
        valueSerializer.holdAndWriteCallback(valueHolderForAction)
    }
    public static read(buffer: DeserializerBase): PopupButton {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpResult : string = (valueDeserializer.readString() as string)
        const actionTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const actionTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const actionTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const actionTmpBufClosure  = ():void => {
            const actionTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            actionTmpBufBufArgsSerializer.writeInt32(actionTmpBufBufResource.resourceId);
            actionTmpBufBufArgsSerializer.writePointer(actionTmpBufBufCall);
            actionTmpBufBufArgsSerializer.writePointer(actionTmpBufBufCallSync);
            InteropNativeModule._CallCallbackSync(10, 553494831, actionTmpBufBufArgsSerializer.asBuffer(), actionTmpBufBufArgsSerializer.length());
            actionTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(actionTmpBufClosure, actionTmpBufBufResource)
        const actionTmpResult : VoidCallback = actionTmpBufClosure
        let value : PopupButton = ({value: valueTmpResult, action: actionTmpResult} as PopupButton)
        return value
    }
}
export class PreviewConfiguration_serializer {
    public static write(buffer: SerializerBase, value: PreviewConfiguration): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForOnlyForLifting  = value.onlyForLifting
        if (valueHolderForOnlyForLifting !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnlyForLiftingTmpValue  = valueHolderForOnlyForLifting!
            valueSerializer.writeBoolean(valueHolderForOnlyForLiftingTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDelayCreating  = value.delayCreating
        if (valueHolderForDelayCreating !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDelayCreatingTmpValue  = valueHolderForDelayCreating!
            valueSerializer.writeBoolean(valueHolderForDelayCreatingTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PreviewConfiguration {
        let valueDeserializer : DeserializerBase = buffer
        const onlyForLiftingTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onlyForLiftingTmpBuf : boolean | undefined = undefined
        if ((onlyForLiftingTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            onlyForLiftingTmpBuf = valueDeserializer.readBoolean()
        }
        const onlyForLiftingTmpResult : boolean | undefined = onlyForLiftingTmpBuf
        const delayCreatingTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let delayCreatingTmpBuf : boolean | undefined = undefined
        if ((delayCreatingTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            delayCreatingTmpBuf = valueDeserializer.readBoolean()
        }
        const delayCreatingTmpResult : boolean | undefined = delayCreatingTmpBuf
        let value : PreviewConfiguration = ({onlyForLifting: onlyForLiftingTmpResult, delayCreating: delayCreatingTmpResult} as PreviewConfiguration)
        return value
    }
}
export class RotateOptions_serializer {
    public static write(buffer: SerializerBase, value: RotateOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForX  = value.x
        if (valueHolderForX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForXTmpValue  = valueHolderForX!
            valueSerializer.writeFloat64(valueHolderForXTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForY  = value.y
        if (valueHolderForY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForYTmpValue  = valueHolderForY!
            valueSerializer.writeFloat64(valueHolderForYTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForZ  = value.z
        if (valueHolderForZ !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForZTmpValue  = valueHolderForZ!
            valueSerializer.writeFloat64(valueHolderForZTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCenterX  = value.centerX
        if (valueHolderForCenterX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCenterXTmpValue  = valueHolderForCenterX!
            if (valueHolderForCenterXTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForCenterXTmpValueForIdx0  = valueHolderForCenterXTmpValue as double
                valueSerializer.writeFloat64(valueHolderForCenterXTmpValueForIdx0)
            } else if (valueHolderForCenterXTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForCenterXTmpValueForIdx1  = valueHolderForCenterXTmpValue as string
                valueSerializer.writeString(valueHolderForCenterXTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCenterY  = value.centerY
        if (valueHolderForCenterY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCenterYTmpValue  = valueHolderForCenterY!
            if (valueHolderForCenterYTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForCenterYTmpValueForIdx0  = valueHolderForCenterYTmpValue as double
                valueSerializer.writeFloat64(valueHolderForCenterYTmpValueForIdx0)
            } else if (valueHolderForCenterYTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForCenterYTmpValueForIdx1  = valueHolderForCenterYTmpValue as string
                valueSerializer.writeString(valueHolderForCenterYTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCenterZ  = value.centerZ
        if (valueHolderForCenterZ !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCenterZTmpValue  = valueHolderForCenterZ!
            valueSerializer.writeFloat64(valueHolderForCenterZTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPerspective  = value.perspective
        if (valueHolderForPerspective !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPerspectiveTmpValue  = valueHolderForPerspective!
            valueSerializer.writeFloat64(valueHolderForPerspectiveTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAngle  = value.angle
        if (valueHolderForAngle instanceof double) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForAngleForIdx0  = valueHolderForAngle as double
            valueSerializer.writeFloat64(valueHolderForAngleForIdx0)
        } else if (valueHolderForAngle instanceof string) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForAngleForIdx1  = valueHolderForAngle as string
            valueSerializer.writeString(valueHolderForAngleForIdx1)
        }
    }
    public static read(buffer: DeserializerBase): RotateOptions {
        let valueDeserializer : DeserializerBase = buffer
        const xTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let xTmpBuf : double | undefined = undefined
        if ((xTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            xTmpBuf = valueDeserializer.readFloat64()
        }
        const xTmpResult : double | undefined = xTmpBuf
        const yTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let yTmpBuf : double | undefined = undefined
        if ((yTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            yTmpBuf = valueDeserializer.readFloat64()
        }
        const yTmpResult : double | undefined = yTmpBuf
        const zTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let zTmpBuf : double | undefined = undefined
        if ((zTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            zTmpBuf = valueDeserializer.readFloat64()
        }
        const zTmpResult : double | undefined = zTmpBuf
        const centerXTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let centerXTmpBuf : double | string | undefined = undefined
        if ((centerXTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const centerXTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let centerXTmpBufOpt : double | string | undefined
            if (centerXTmpBufOptUnionSelector == (0).toByte()) {
                centerXTmpBufOpt = valueDeserializer.readFloat64()
            } else if (centerXTmpBufOptUnionSelector == (1).toByte()) {
                centerXTmpBufOpt = (valueDeserializer.readString() as string)
            } else {
                throw new Error('One of the branches for centerXTmpBufOpt has to be chosen through deserialisation.')
            }
            centerXTmpBuf = (centerXTmpBufOpt as double | string)
        }
        const centerXTmpResult : double | string | undefined = centerXTmpBuf
        const centerYTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let centerYTmpBuf : double | string | undefined = undefined
        if ((centerYTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const centerYTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let centerYTmpBufOpt : double | string | undefined
            if (centerYTmpBufOptUnionSelector == (0).toByte()) {
                centerYTmpBufOpt = valueDeserializer.readFloat64()
            } else if (centerYTmpBufOptUnionSelector == (1).toByte()) {
                centerYTmpBufOpt = (valueDeserializer.readString() as string)
            } else {
                throw new Error('One of the branches for centerYTmpBufOpt has to be chosen through deserialisation.')
            }
            centerYTmpBuf = (centerYTmpBufOpt as double | string)
        }
        const centerYTmpResult : double | string | undefined = centerYTmpBuf
        const centerZTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let centerZTmpBuf : double | undefined = undefined
        if ((centerZTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            centerZTmpBuf = valueDeserializer.readFloat64()
        }
        const centerZTmpResult : double | undefined = centerZTmpBuf
        const perspectiveTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let perspectiveTmpBuf : double | undefined = undefined
        if ((perspectiveTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            perspectiveTmpBuf = valueDeserializer.readFloat64()
        }
        const perspectiveTmpResult : double | undefined = perspectiveTmpBuf
        const angleTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let angleTmpBuf : double | string | undefined
        if (angleTmpBufUnionSelector == (0).toByte()) {
            angleTmpBuf = valueDeserializer.readFloat64()
        } else if (angleTmpBufUnionSelector == (1).toByte()) {
            angleTmpBuf = (valueDeserializer.readString() as string)
        } else {
            throw new Error('One of the branches for angleTmpBuf has to be chosen through deserialisation.')
        }
        const angleTmpResult : double | string = (angleTmpBuf as double | string)
        let value : RotateOptions = ({x: xTmpResult, y: yTmpResult, z: zTmpResult, centerX: centerXTmpResult, centerY: centerYTmpResult, centerZ: centerZTmpResult, perspective: perspectiveTmpResult, angle: angleTmpResult} as RotateOptions)
        return value
    }
}
export class ScaleOptions_serializer {
    public static write(buffer: SerializerBase, value: ScaleOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForX  = value.x
        if (valueHolderForX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForXTmpValue  = valueHolderForX!
            valueSerializer.writeFloat64(valueHolderForXTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForY  = value.y
        if (valueHolderForY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForYTmpValue  = valueHolderForY!
            valueSerializer.writeFloat64(valueHolderForYTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForZ  = value.z
        if (valueHolderForZ !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForZTmpValue  = valueHolderForZ!
            valueSerializer.writeFloat64(valueHolderForZTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCenterX  = value.centerX
        if (valueHolderForCenterX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCenterXTmpValue  = valueHolderForCenterX!
            if (valueHolderForCenterXTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForCenterXTmpValueForIdx0  = valueHolderForCenterXTmpValue as double
                valueSerializer.writeFloat64(valueHolderForCenterXTmpValueForIdx0)
            } else if (valueHolderForCenterXTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForCenterXTmpValueForIdx1  = valueHolderForCenterXTmpValue as string
                valueSerializer.writeString(valueHolderForCenterXTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCenterY  = value.centerY
        if (valueHolderForCenterY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCenterYTmpValue  = valueHolderForCenterY!
            if (valueHolderForCenterYTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForCenterYTmpValueForIdx0  = valueHolderForCenterYTmpValue as double
                valueSerializer.writeFloat64(valueHolderForCenterYTmpValueForIdx0)
            } else if (valueHolderForCenterYTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForCenterYTmpValueForIdx1  = valueHolderForCenterYTmpValue as string
                valueSerializer.writeString(valueHolderForCenterYTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ScaleOptions {
        let valueDeserializer : DeserializerBase = buffer
        const xTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let xTmpBuf : double | undefined = undefined
        if ((xTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            xTmpBuf = valueDeserializer.readFloat64()
        }
        const xTmpResult : double | undefined = xTmpBuf
        const yTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let yTmpBuf : double | undefined = undefined
        if ((yTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            yTmpBuf = valueDeserializer.readFloat64()
        }
        const yTmpResult : double | undefined = yTmpBuf
        const zTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let zTmpBuf : double | undefined = undefined
        if ((zTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            zTmpBuf = valueDeserializer.readFloat64()
        }
        const zTmpResult : double | undefined = zTmpBuf
        const centerXTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let centerXTmpBuf : double | string | undefined = undefined
        if ((centerXTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const centerXTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let centerXTmpBufOpt : double | string | undefined
            if (centerXTmpBufOptUnionSelector == (0).toByte()) {
                centerXTmpBufOpt = valueDeserializer.readFloat64()
            } else if (centerXTmpBufOptUnionSelector == (1).toByte()) {
                centerXTmpBufOpt = (valueDeserializer.readString() as string)
            } else {
                throw new Error('One of the branches for centerXTmpBufOpt has to be chosen through deserialisation.')
            }
            centerXTmpBuf = (centerXTmpBufOpt as double | string)
        }
        const centerXTmpResult : double | string | undefined = centerXTmpBuf
        const centerYTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let centerYTmpBuf : double | string | undefined = undefined
        if ((centerYTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const centerYTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let centerYTmpBufOpt : double | string | undefined
            if (centerYTmpBufOptUnionSelector == (0).toByte()) {
                centerYTmpBufOpt = valueDeserializer.readFloat64()
            } else if (centerYTmpBufOptUnionSelector == (1).toByte()) {
                centerYTmpBufOpt = (valueDeserializer.readString() as string)
            } else {
                throw new Error('One of the branches for centerYTmpBufOpt has to be chosen through deserialisation.')
            }
            centerYTmpBuf = (centerYTmpBufOpt as double | string)
        }
        const centerYTmpResult : double | string | undefined = centerYTmpBuf
        let value : ScaleOptions = ({x: xTmpResult, y: yTmpResult, z: zTmpResult, centerX: centerXTmpResult, centerY: centerYTmpResult} as ScaleOptions)
        return value
    }
}
export class SelectionOptions_serializer {
    public static write(buffer: SerializerBase, value: SelectionOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForMenuPolicy  = value.menuPolicy
        if (valueHolderForMenuPolicy !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMenuPolicyTmpValue  = (valueHolderForMenuPolicy as MenuPolicy)
            valueSerializer.writeInt32(valueHolderForMenuPolicyTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): SelectionOptions {
        let valueDeserializer : DeserializerBase = buffer
        const menuPolicyTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let menuPolicyTmpBuf : MenuPolicy | undefined = undefined
        if ((menuPolicyTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            menuPolicyTmpBuf = MenuPolicy.fromValue(valueDeserializer.readInt32())
        }
        const menuPolicyTmpResult : MenuPolicy | undefined = menuPolicyTmpBuf
        let value : SelectionOptions = ({menuPolicy: menuPolicyTmpResult} as SelectionOptions)
        return value
    }
}
export class SheetDismiss_serializer {
    public static write(buffer: SerializerBase, value: SheetDismiss): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDismiss  = value.dismiss
        valueSerializer.holdAndWriteCallback(valueHolderForDismiss)
    }
    public static read(buffer: DeserializerBase): SheetDismiss {
        let valueDeserializer : DeserializerBase = buffer
        const dismissTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const dismissTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const dismissTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const dismissTmpBufClosure  = ():void => {
            const dismissTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            dismissTmpBufBufArgsSerializer.writeInt32(dismissTmpBufBufResource.resourceId);
            dismissTmpBufBufArgsSerializer.writePointer(dismissTmpBufBufCall);
            dismissTmpBufBufArgsSerializer.writePointer(dismissTmpBufBufCallSync);
            InteropNativeModule._CallCallbackSync(10, 553494831, dismissTmpBufBufArgsSerializer.asBuffer(), dismissTmpBufBufArgsSerializer.length());
            dismissTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(dismissTmpBufClosure, dismissTmpBufBufResource)
        const dismissTmpResult : VoidCallback = dismissTmpBufClosure
        let value : SheetDismiss = ({dismiss: dismissTmpResult} as SheetDismiss)
        return value
    }
}
export class SystemAdaptiveOptions_serializer {
    public static write(buffer: SerializerBase, value: SystemAdaptiveOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDisableSystemAdaptation  = value.disableSystemAdaptation
        if (valueHolderForDisableSystemAdaptation !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDisableSystemAdaptationTmpValue  = valueHolderForDisableSystemAdaptation!
            valueSerializer.writeBoolean(valueHolderForDisableSystemAdaptationTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): SystemAdaptiveOptions {
        let valueDeserializer : DeserializerBase = buffer
        const disableSystemAdaptationTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let disableSystemAdaptationTmpBuf : boolean | undefined = undefined
        if ((disableSystemAdaptationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            disableSystemAdaptationTmpBuf = valueDeserializer.readBoolean()
        }
        const disableSystemAdaptationTmpResult : boolean | undefined = disableSystemAdaptationTmpBuf
        let value : SystemAdaptiveOptions = ({disableSystemAdaptation: disableSystemAdaptationTmpResult} as SystemAdaptiveOptions)
        return value
    }
}
export class TerminationInfo_serializer {
    public static write(buffer: SerializerBase, value: TerminationInfo): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForCode  = value.code
        valueSerializer.writeInt32(valueHolderForCode)
        const valueHolderForWant  = value.want
        if (valueHolderForWant !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForWantTmpValue  = valueHolderForWant!
            Want_serializer.write(valueSerializer, valueHolderForWantTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): TerminationInfo {
        let valueDeserializer : DeserializerBase = buffer
        const codeTmpResult : int32 = valueDeserializer.readInt32()
        const wantTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let wantTmpBuf : Want | undefined = undefined
        if ((wantTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            wantTmpBuf = (Want_serializer.read(valueDeserializer) as Want)
        }
        const wantTmpResult : Want | undefined = wantTmpBuf
        let value : TerminationInfo = ({code: codeTmpResult, want: wantTmpResult} as TerminationInfo)
        return value
    }
}
export class TextContentControllerOptions_serializer {
    public static write(buffer: SerializerBase, value: TextContentControllerOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForOffset  = value.offset
        if (valueHolderForOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetTmpValue  = valueHolderForOffset!
            valueSerializer.writeInt32(valueHolderForOffsetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): TextContentControllerOptions {
        let valueDeserializer : DeserializerBase = buffer
        const offsetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let offsetTmpBuf : int32 | undefined = undefined
        if ((offsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            offsetTmpBuf = valueDeserializer.readInt32()
        }
        const offsetTmpResult : int32 | undefined = offsetTmpBuf
        let value : TextContentControllerOptions = ({offset: offsetTmpResult} as TextContentControllerOptions)
        return value
    }
}
export class TouchObject_serializer {
    public static write(buffer: SerializerBase, value: TouchObject): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForType  = value.type
        valueSerializer.writeInt32(valueHolderForType.valueOf())
        const valueHolderForId  = value.id
        valueSerializer.writeInt32(valueHolderForId)
        const valueHolderForDisplayX  = value.displayX
        valueSerializer.writeFloat64(valueHolderForDisplayX)
        const valueHolderForDisplayY  = value.displayY
        valueSerializer.writeFloat64(valueHolderForDisplayY)
        const valueHolderForWindowX  = value.windowX
        valueSerializer.writeFloat64(valueHolderForWindowX)
        const valueHolderForWindowY  = value.windowY
        valueSerializer.writeFloat64(valueHolderForWindowY)
        const valueHolderForX  = value.x
        valueSerializer.writeFloat64(valueHolderForX)
        const valueHolderForY  = value.y
        valueSerializer.writeFloat64(valueHolderForY)
        const valueHolderForHand  = value.hand
        if (valueHolderForHand !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHandTmpValue  = (valueHolderForHand as InteractionHand)
            valueSerializer.writeInt32(valueHolderForHandTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPressedTime  = value.pressedTime
        if (valueHolderForPressedTime !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPressedTimeTmpValue  = valueHolderForPressedTime!
            valueSerializer.writeInt64(valueHolderForPressedTimeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPressure  = value.pressure
        if (valueHolderForPressure !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPressureTmpValue  = valueHolderForPressure!
            valueSerializer.writeFloat64(valueHolderForPressureTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForWidth  = value.width
        if (valueHolderForWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForWidthTmpValue  = valueHolderForWidth!
            valueSerializer.writeFloat64(valueHolderForWidthTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHeight  = value.height
        if (valueHolderForHeight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHeightTmpValue  = valueHolderForHeight!
            valueSerializer.writeFloat64(valueHolderForHeightTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): TouchObject {
        let valueDeserializer : DeserializerBase = buffer
        const typeTmpResult : TouchType = TouchType.fromValue(valueDeserializer.readInt32())
        const idTmpResult : int32 = valueDeserializer.readInt32()
        const displayXTmpResult : double = valueDeserializer.readFloat64()
        const displayYTmpResult : double = valueDeserializer.readFloat64()
        const windowXTmpResult : double = valueDeserializer.readFloat64()
        const windowYTmpResult : double = valueDeserializer.readFloat64()
        const xTmpResult : double = valueDeserializer.readFloat64()
        const yTmpResult : double = valueDeserializer.readFloat64()
        const handTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let handTmpBuf : InteractionHand | undefined = undefined
        if ((handTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            handTmpBuf = InteractionHand.fromValue(valueDeserializer.readInt32())
        }
        const handTmpResult : InteractionHand | undefined = handTmpBuf
        const pressedTimeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let pressedTimeTmpBuf : int64 | undefined = undefined
        if ((pressedTimeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            pressedTimeTmpBuf = valueDeserializer.readInt64()
        }
        const pressedTimeTmpResult : int64 | undefined = pressedTimeTmpBuf
        const pressureTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let pressureTmpBuf : double | undefined = undefined
        if ((pressureTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            pressureTmpBuf = valueDeserializer.readFloat64()
        }
        const pressureTmpResult : double | undefined = pressureTmpBuf
        const widthTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let widthTmpBuf : double | undefined = undefined
        if ((widthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            widthTmpBuf = valueDeserializer.readFloat64()
        }
        const widthTmpResult : double | undefined = widthTmpBuf
        const heightTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let heightTmpBuf : double | undefined = undefined
        if ((heightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            heightTmpBuf = valueDeserializer.readFloat64()
        }
        const heightTmpResult : double | undefined = heightTmpBuf
        let value : TouchObject = ({type: typeTmpResult, id: idTmpResult, displayX: displayXTmpResult, displayY: displayYTmpResult, windowX: windowXTmpResult, windowY: windowYTmpResult, x: xTmpResult, y: yTmpResult, hand: handTmpResult, pressedTime: pressedTimeTmpResult, pressure: pressureTmpResult, width: widthTmpResult, height: heightTmpResult} as TouchObject)
        return value
    }
}
export class TouchResult_serializer {
    public static write(buffer: SerializerBase, value: TouchResult): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForStrategy  = value.strategy
        valueSerializer.writeInt32(valueHolderForStrategy.valueOf())
        const valueHolderForId  = value.id
        if (valueHolderForId !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForIdTmpValue  = valueHolderForId!
            valueSerializer.writeString(valueHolderForIdTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): TouchResult {
        let valueDeserializer : DeserializerBase = buffer
        const strategyTmpResult : TouchTestStrategy = TouchTestStrategy.fromValue(valueDeserializer.readInt32())
        const idTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let idTmpBuf : string | undefined = undefined
        if ((idTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            idTmpBuf = (valueDeserializer.readString() as string)
        }
        const idTmpResult : string | undefined = idTmpBuf
        let value : TouchResult = ({strategy: strategyTmpResult, id: idTmpResult} as TouchResult)
        return value
    }
}
export class TranslateOptions_serializer {
    public static write(buffer: SerializerBase, value: TranslateOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForX  = value.x
        if (valueHolderForX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForXTmpValue  = valueHolderForX!
            if (valueHolderForXTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForXTmpValueForIdx0  = valueHolderForXTmpValue as double
                valueSerializer.writeFloat64(valueHolderForXTmpValueForIdx0)
            } else if (valueHolderForXTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForXTmpValueForIdx1  = valueHolderForXTmpValue as string
                valueSerializer.writeString(valueHolderForXTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForY  = value.y
        if (valueHolderForY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForYTmpValue  = valueHolderForY!
            if (valueHolderForYTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForYTmpValueForIdx0  = valueHolderForYTmpValue as double
                valueSerializer.writeFloat64(valueHolderForYTmpValueForIdx0)
            } else if (valueHolderForYTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForYTmpValueForIdx1  = valueHolderForYTmpValue as string
                valueSerializer.writeString(valueHolderForYTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForZ  = value.z
        if (valueHolderForZ !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForZTmpValue  = valueHolderForZ!
            if (valueHolderForZTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForZTmpValueForIdx0  = valueHolderForZTmpValue as double
                valueSerializer.writeFloat64(valueHolderForZTmpValueForIdx0)
            } else if (valueHolderForZTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForZTmpValueForIdx1  = valueHolderForZTmpValue as string
                valueSerializer.writeString(valueHolderForZTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): TranslateOptions {
        let valueDeserializer : DeserializerBase = buffer
        const xTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let xTmpBuf : double | string | undefined = undefined
        if ((xTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const xTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let xTmpBufOpt : double | string | undefined
            if (xTmpBufOptUnionSelector == (0).toByte()) {
                xTmpBufOpt = valueDeserializer.readFloat64()
            } else if (xTmpBufOptUnionSelector == (1).toByte()) {
                xTmpBufOpt = (valueDeserializer.readString() as string)
            } else {
                throw new Error('One of the branches for xTmpBufOpt has to be chosen through deserialisation.')
            }
            xTmpBuf = (xTmpBufOpt as double | string)
        }
        const xTmpResult : double | string | undefined = xTmpBuf
        const yTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let yTmpBuf : double | string | undefined = undefined
        if ((yTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const yTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let yTmpBufOpt : double | string | undefined
            if (yTmpBufOptUnionSelector == (0).toByte()) {
                yTmpBufOpt = valueDeserializer.readFloat64()
            } else if (yTmpBufOptUnionSelector == (1).toByte()) {
                yTmpBufOpt = (valueDeserializer.readString() as string)
            } else {
                throw new Error('One of the branches for yTmpBufOpt has to be chosen through deserialisation.')
            }
            yTmpBuf = (yTmpBufOpt as double | string)
        }
        const yTmpResult : double | string | undefined = yTmpBuf
        const zTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let zTmpBuf : double | string | undefined = undefined
        if ((zTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const zTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let zTmpBufOpt : double | string | undefined
            if (zTmpBufOptUnionSelector == (0).toByte()) {
                zTmpBufOpt = valueDeserializer.readFloat64()
            } else if (zTmpBufOptUnionSelector == (1).toByte()) {
                zTmpBufOpt = (valueDeserializer.readString() as string)
            } else {
                throw new Error('One of the branches for zTmpBufOpt has to be chosen through deserialisation.')
            }
            zTmpBuf = (zTmpBufOpt as double | string)
        }
        const zTmpResult : double | string | undefined = zTmpBuf
        let value : TranslateOptions = ({x: xTmpResult, y: yTmpResult, z: zTmpResult} as TranslateOptions)
        return value
    }
}
export class VisibleAreaEventOptions_serializer {
    public static write(buffer: SerializerBase, value: VisibleAreaEventOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForRatios  = value.ratios
        valueSerializer.writeInt32((valueHolderForRatios.length).toInt())
        for (let valueHolderForRatiosCounterI = 0; valueHolderForRatiosCounterI < valueHolderForRatios.length; valueHolderForRatiosCounterI++) {
            const valueHolderForRatiosTmpElement : double = valueHolderForRatios[valueHolderForRatiosCounterI]
            valueSerializer.writeFloat64(valueHolderForRatiosTmpElement)
        }
        const valueHolderForExpectedUpdateInterval  = value.expectedUpdateInterval
        if (valueHolderForExpectedUpdateInterval !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForExpectedUpdateIntervalTmpValue  = valueHolderForExpectedUpdateInterval!
            valueSerializer.writeInt32(valueHolderForExpectedUpdateIntervalTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): VisibleAreaEventOptions {
        let valueDeserializer : DeserializerBase = buffer
        const ratiosTmpBufLength : int32 = valueDeserializer.readInt32()
        let ratiosTmpBuf : Array<double> = new Array<double>(ratiosTmpBufLength)
        for (let ratiosTmpBufBufCounterI = 0; ratiosTmpBufBufCounterI < ratiosTmpBufLength; ratiosTmpBufBufCounterI++) {
            ratiosTmpBuf[ratiosTmpBufBufCounterI] = valueDeserializer.readFloat64()
        }
        const ratiosTmpResult : Array<double> = ratiosTmpBuf
        const expectedUpdateIntervalTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let expectedUpdateIntervalTmpBuf : int32 | undefined = undefined
        if ((expectedUpdateIntervalTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            expectedUpdateIntervalTmpBuf = valueDeserializer.readInt32()
        }
        const expectedUpdateIntervalTmpResult : int32 | undefined = expectedUpdateIntervalTmpBuf
        let value : VisibleAreaEventOptions = ({ratios: ratiosTmpResult, expectedUpdateInterval: expectedUpdateIntervalTmpResult} as VisibleAreaEventOptions)
        return value
    }
}
export class AlignRuleOption_serializer {
    public static write(buffer: SerializerBase, value: AlignRuleOption): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForLeft  = value.left
        if (valueHolderForLeft !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForLeftTmpValue  = valueHolderForLeft!
            HorizontalAlignParam_serializer.write(valueSerializer, valueHolderForLeftTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRight  = value.right
        if (valueHolderForRight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRightTmpValue  = valueHolderForRight!
            HorizontalAlignParam_serializer.write(valueSerializer, valueHolderForRightTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMiddle  = value.middle
        if (valueHolderForMiddle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMiddleTmpValue  = valueHolderForMiddle!
            HorizontalAlignParam_serializer.write(valueSerializer, valueHolderForMiddleTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTop  = value.top
        if (valueHolderForTop !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTopTmpValue  = valueHolderForTop!
            VerticalAlignParam_serializer.write(valueSerializer, valueHolderForTopTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBottom  = value.bottom
        if (valueHolderForBottom !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBottomTmpValue  = valueHolderForBottom!
            VerticalAlignParam_serializer.write(valueSerializer, valueHolderForBottomTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCenter  = value.center
        if (valueHolderForCenter !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCenterTmpValue  = valueHolderForCenter!
            VerticalAlignParam_serializer.write(valueSerializer, valueHolderForCenterTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBias  = value.bias
        if (valueHolderForBias !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBiasTmpValue  = valueHolderForBias!
            Bias_serializer.write(valueSerializer, valueHolderForBiasTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): AlignRuleOption {
        let valueDeserializer : DeserializerBase = buffer
        const leftTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let leftTmpBuf : HorizontalAlignParam | undefined = undefined
        if ((leftTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            leftTmpBuf = HorizontalAlignParam_serializer.read(valueDeserializer)
        }
        const leftTmpResult : HorizontalAlignParam | undefined = leftTmpBuf
        const rightTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let rightTmpBuf : HorizontalAlignParam | undefined = undefined
        if ((rightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            rightTmpBuf = HorizontalAlignParam_serializer.read(valueDeserializer)
        }
        const rightTmpResult : HorizontalAlignParam | undefined = rightTmpBuf
        const middleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let middleTmpBuf : HorizontalAlignParam | undefined = undefined
        if ((middleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            middleTmpBuf = HorizontalAlignParam_serializer.read(valueDeserializer)
        }
        const middleTmpResult : HorizontalAlignParam | undefined = middleTmpBuf
        const topTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let topTmpBuf : VerticalAlignParam | undefined = undefined
        if ((topTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            topTmpBuf = VerticalAlignParam_serializer.read(valueDeserializer)
        }
        const topTmpResult : VerticalAlignParam | undefined = topTmpBuf
        const bottomTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let bottomTmpBuf : VerticalAlignParam | undefined = undefined
        if ((bottomTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            bottomTmpBuf = VerticalAlignParam_serializer.read(valueDeserializer)
        }
        const bottomTmpResult : VerticalAlignParam | undefined = bottomTmpBuf
        const centerTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let centerTmpBuf : VerticalAlignParam | undefined = undefined
        if ((centerTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            centerTmpBuf = VerticalAlignParam_serializer.read(valueDeserializer)
        }
        const centerTmpResult : VerticalAlignParam | undefined = centerTmpBuf
        const biasTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let biasTmpBuf : Bias | undefined = undefined
        if ((biasTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            biasTmpBuf = Bias_serializer.read(valueDeserializer)
        }
        const biasTmpResult : Bias | undefined = biasTmpBuf
        let value : AlignRuleOption = ({left: leftTmpResult, right: rightTmpResult, middle: middleTmpResult, top: topTmpResult, bottom: bottomTmpResult, center: centerTmpResult, bias: biasTmpResult} as AlignRuleOption)
        return value
    }
}
export class AnimateParam_serializer {
    public static write(buffer: SerializerBase, value: AnimateParam): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDuration  = value.duration
        if (valueHolderForDuration !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDurationTmpValue  = valueHolderForDuration!
            valueSerializer.writeInt32(valueHolderForDurationTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTempo  = value.tempo
        if (valueHolderForTempo !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTempoTmpValue  = valueHolderForTempo!
            valueSerializer.writeFloat64(valueHolderForTempoTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCurve  = value.curve
        if (valueHolderForCurve !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCurveTmpValue  = valueHolderForCurve!
            if (valueHolderForCurveTmpValue instanceof Curve) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForCurveTmpValueForIdx0  = valueHolderForCurveTmpValue as Curve
                valueSerializer.writeInt32(valueHolderForCurveTmpValueForIdx0.valueOf())
            } else if (valueHolderForCurveTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForCurveTmpValueForIdx1  = valueHolderForCurveTmpValue as string
                valueSerializer.writeString(valueHolderForCurveTmpValueForIdx1)
            } else if (valueHolderForCurveTmpValue instanceof ICurve) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForCurveTmpValueForIdx2  = valueHolderForCurveTmpValue as ICurve
                curves_ICurve_serializer.write(valueSerializer, valueHolderForCurveTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDelay  = value.delay
        if (valueHolderForDelay !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDelayTmpValue  = valueHolderForDelay!
            valueSerializer.writeInt32(valueHolderForDelayTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForIterations  = value.iterations
        if (valueHolderForIterations !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForIterationsTmpValue  = valueHolderForIterations!
            valueSerializer.writeInt32(valueHolderForIterationsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPlayMode  = value.playMode
        if (valueHolderForPlayMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPlayModeTmpValue  = (valueHolderForPlayMode as PlayMode)
            valueSerializer.writeInt32(valueHolderForPlayModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnFinish  = value.onFinish
        if (valueHolderForOnFinish !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnFinishTmpValue  = valueHolderForOnFinish!
            valueSerializer.holdAndWriteCallback(valueHolderForOnFinishTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFinishCallbackType  = value.finishCallbackType
        if (valueHolderForFinishCallbackType !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFinishCallbackTypeTmpValue  = (valueHolderForFinishCallbackType as FinishCallbackType)
            valueSerializer.writeInt32(valueHolderForFinishCallbackTypeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForExpectedFrameRateRange  = value.expectedFrameRateRange
        if (valueHolderForExpectedFrameRateRange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForExpectedFrameRateRangeTmpValue  = valueHolderForExpectedFrameRateRange!
            ExpectedFrameRateRange_serializer.write(valueSerializer, valueHolderForExpectedFrameRateRangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): AnimateParam {
        let valueDeserializer : DeserializerBase = buffer
        const durationTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let durationTmpBuf : int32 | undefined = undefined
        if ((durationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            durationTmpBuf = valueDeserializer.readInt32()
        }
        const durationTmpResult : int32 | undefined = durationTmpBuf
        const tempoTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let tempoTmpBuf : double | undefined = undefined
        if ((tempoTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            tempoTmpBuf = valueDeserializer.readFloat64()
        }
        const tempoTmpResult : double | undefined = tempoTmpBuf
        const curveTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let curveTmpBuf : Curve | string | ICurve | undefined = undefined
        if ((curveTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const curveTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let curveTmpBufOpt : Curve | string | ICurve | undefined
            if (curveTmpBufOptUnionSelector == (0).toByte()) {
                curveTmpBufOpt = curves.Curve.fromValue(valueDeserializer.readInt32())
            } else if (curveTmpBufOptUnionSelector == (1).toByte()) {
                curveTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (curveTmpBufOptUnionSelector == (2).toByte()) {
                curveTmpBufOpt = (curves_ICurve_serializer.read(valueDeserializer) as curves.ICurve)
            } else {
                throw new Error('One of the branches for curveTmpBufOpt has to be chosen through deserialisation.')
            }
            curveTmpBuf = (curveTmpBufOpt as Curve | string | ICurve)
        }
        const curveTmpResult : Curve | string | ICurve | undefined = curveTmpBuf
        const delayTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let delayTmpBuf : int32 | undefined = undefined
        if ((delayTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            delayTmpBuf = valueDeserializer.readInt32()
        }
        const delayTmpResult : int32 | undefined = delayTmpBuf
        const iterationsTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let iterationsTmpBuf : int32 | undefined = undefined
        if ((iterationsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            iterationsTmpBuf = valueDeserializer.readInt32()
        }
        const iterationsTmpResult : int32 | undefined = iterationsTmpBuf
        const playModeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let playModeTmpBuf : PlayMode | undefined = undefined
        if ((playModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            playModeTmpBuf = PlayMode.fromValue(valueDeserializer.readInt32())
        }
        const playModeTmpResult : PlayMode | undefined = playModeTmpBuf
        const onFinishTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onFinishTmpBuf : (() => void) | undefined = undefined
        if ((onFinishTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onFinishTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onFinishTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onFinishTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onFinishTmpBufOptClosure  = ():void => {
                const onFinishTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onFinishTmpBufOptBufArgsSerializer.writeInt32(onFinishTmpBufOptBufResource.resourceId);
                onFinishTmpBufOptBufArgsSerializer.writePointer(onFinishTmpBufOptBufCall);
                onFinishTmpBufOptBufArgsSerializer.writePointer(onFinishTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, onFinishTmpBufOptBufArgsSerializer.asBuffer(), onFinishTmpBufOptBufArgsSerializer.length());
                onFinishTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onFinishTmpBufOptClosure, onFinishTmpBufOptBufResource)
            onFinishTmpBuf = onFinishTmpBufOptClosure
        }
        const onFinishTmpResult : (() => void) | undefined = onFinishTmpBuf
        const finishCallbackTypeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let finishCallbackTypeTmpBuf : FinishCallbackType | undefined = undefined
        if ((finishCallbackTypeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            finishCallbackTypeTmpBuf = FinishCallbackType.fromValue(valueDeserializer.readInt32())
        }
        const finishCallbackTypeTmpResult : FinishCallbackType | undefined = finishCallbackTypeTmpBuf
        const expectedFrameRateRangeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let expectedFrameRateRangeTmpBuf : ExpectedFrameRateRange | undefined = undefined
        if ((expectedFrameRateRangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            expectedFrameRateRangeTmpBuf = ExpectedFrameRateRange_serializer.read(valueDeserializer)
        }
        const expectedFrameRateRangeTmpResult : ExpectedFrameRateRange | undefined = expectedFrameRateRangeTmpBuf
        let value : AnimateParam = ({duration: durationTmpResult, tempo: tempoTmpResult, curve: curveTmpResult, delay: delayTmpResult, iterations: iterationsTmpResult, playMode: playModeTmpResult, onFinish: onFinishTmpResult, finishCallbackType: finishCallbackTypeTmpResult, expectedFrameRateRange: expectedFrameRateRangeTmpResult} as AnimateParam)
        return value
    }
}
export class BackgroundBlurStyleOptions_serializer {
    public static write(buffer: SerializerBase, value: BackgroundBlurStyleOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForColorMode  = value.colorMode
        if (valueHolderForColorMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForColorModeTmpValue  = (valueHolderForColorMode as ThemeColorMode)
            valueSerializer.writeInt32(valueHolderForColorModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAdaptiveColor  = value.adaptiveColor
        if (valueHolderForAdaptiveColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAdaptiveColorTmpValue  = (valueHolderForAdaptiveColor as AdaptiveColor)
            valueSerializer.writeInt32(valueHolderForAdaptiveColorTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForScale  = value.scale
        if (valueHolderForScale !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForScaleTmpValue  = valueHolderForScale!
            valueSerializer.writeFloat64(valueHolderForScaleTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBlurOptions  = value.blurOptions
        if (valueHolderForBlurOptions !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBlurOptionsTmpValue  = valueHolderForBlurOptions!
            BlurOptions_serializer.write(valueSerializer, valueHolderForBlurOptionsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPolicy  = value.policy
        if (valueHolderForPolicy !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPolicyTmpValue  = (valueHolderForPolicy as BlurStyleActivePolicy)
            valueSerializer.writeInt32(valueHolderForPolicyTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForInactiveColor  = value.inactiveColor
        if (valueHolderForInactiveColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForInactiveColorTmpValue  = valueHolderForInactiveColor!
            if (valueHolderForInactiveColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForInactiveColorTmpValueForIdx0  = valueHolderForInactiveColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForInactiveColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForInactiveColorTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForInactiveColorTmpValueForIdx1  = valueHolderForInactiveColorTmpValue as int32
                valueSerializer.writeInt32(valueHolderForInactiveColorTmpValueForIdx1)
            } else if (valueHolderForInactiveColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForInactiveColorTmpValueForIdx2  = valueHolderForInactiveColorTmpValue as string
                valueSerializer.writeString(valueHolderForInactiveColorTmpValueForIdx2)
            } else if (valueHolderForInactiveColorTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForInactiveColorTmpValueForIdx3  = valueHolderForInactiveColorTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForInactiveColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): BackgroundBlurStyleOptions {
        let valueDeserializer : DeserializerBase = buffer
        const colorModeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let colorModeTmpBuf : ThemeColorMode | undefined = undefined
        if ((colorModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            colorModeTmpBuf = ThemeColorMode.fromValue(valueDeserializer.readInt32())
        }
        const colorModeTmpResult : ThemeColorMode | undefined = colorModeTmpBuf
        const adaptiveColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let adaptiveColorTmpBuf : AdaptiveColor | undefined = undefined
        if ((adaptiveColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            adaptiveColorTmpBuf = AdaptiveColor.fromValue(valueDeserializer.readInt32())
        }
        const adaptiveColorTmpResult : AdaptiveColor | undefined = adaptiveColorTmpBuf
        const scaleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let scaleTmpBuf : double | undefined = undefined
        if ((scaleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            scaleTmpBuf = valueDeserializer.readFloat64()
        }
        const scaleTmpResult : double | undefined = scaleTmpBuf
        const blurOptionsTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let blurOptionsTmpBuf : BlurOptions | undefined = undefined
        if ((blurOptionsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            blurOptionsTmpBuf = BlurOptions_serializer.read(valueDeserializer)
        }
        const blurOptionsTmpResult : BlurOptions | undefined = blurOptionsTmpBuf
        const policyTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let policyTmpBuf : BlurStyleActivePolicy | undefined = undefined
        if ((policyTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            policyTmpBuf = BlurStyleActivePolicy.fromValue(valueDeserializer.readInt32())
        }
        const policyTmpResult : BlurStyleActivePolicy | undefined = policyTmpBuf
        const inactiveColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let inactiveColorTmpBuf : ResourceColor | undefined = undefined
        if ((inactiveColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const inactiveColorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let inactiveColorTmpBufOpt : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (inactiveColorTmpBufOptUnionSelector == (0).toByte()) {
                inactiveColorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (inactiveColorTmpBufOptUnionSelector == (1).toByte()) {
                inactiveColorTmpBufOpt = valueDeserializer.readInt32()
            } else if (inactiveColorTmpBufOptUnionSelector == (2).toByte()) {
                inactiveColorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (inactiveColorTmpBufOptUnionSelector == (3).toByte()) {
                inactiveColorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for inactiveColorTmpBufOpt has to be chosen through deserialisation.')
            }
            inactiveColorTmpBuf = (inactiveColorTmpBufOpt as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
        }
        const inactiveColorTmpResult : ResourceColor | undefined = inactiveColorTmpBuf
        let value : BackgroundBlurStyleOptions = ({colorMode: colorModeTmpResult, adaptiveColor: adaptiveColorTmpResult, scale: scaleTmpResult, blurOptions: blurOptionsTmpResult, policy: policyTmpResult, inactiveColor: inactiveColorTmpResult} as BackgroundBlurStyleOptions)
        return value
    }
}
export class BackgroundEffectOptions_serializer {
    public static write(buffer: SerializerBase, value: BackgroundEffectOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForRadius  = value.radius
        if (valueHolderForRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRadiusTmpValue  = valueHolderForRadius!
            valueSerializer.writeFloat64(valueHolderForRadiusTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForSaturation  = value.saturation
        if (valueHolderForSaturation !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForSaturationTmpValue  = valueHolderForSaturation!
            valueSerializer.writeFloat64(valueHolderForSaturationTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBrightness  = value.brightness
        if (valueHolderForBrightness !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBrightnessTmpValue  = valueHolderForBrightness!
            valueSerializer.writeFloat64(valueHolderForBrightnessTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForColor  = value.color
        if (valueHolderForColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForColorTmpValue  = valueHolderForColor!
            if (valueHolderForColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorTmpValueForIdx0  = valueHolderForColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForColorTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorTmpValueForIdx1  = valueHolderForColorTmpValue as int32
                valueSerializer.writeInt32(valueHolderForColorTmpValueForIdx1)
            } else if (valueHolderForColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorTmpValueForIdx2  = valueHolderForColorTmpValue as string
                valueSerializer.writeString(valueHolderForColorTmpValueForIdx2)
            } else if (valueHolderForColorTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorTmpValueForIdx3  = valueHolderForColorTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAdaptiveColor  = value.adaptiveColor
        if (valueHolderForAdaptiveColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAdaptiveColorTmpValue  = (valueHolderForAdaptiveColor as AdaptiveColor)
            valueSerializer.writeInt32(valueHolderForAdaptiveColorTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBlurOptions  = value.blurOptions
        if (valueHolderForBlurOptions !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBlurOptionsTmpValue  = valueHolderForBlurOptions!
            BlurOptions_serializer.write(valueSerializer, valueHolderForBlurOptionsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPolicy  = value.policy
        if (valueHolderForPolicy !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPolicyTmpValue  = (valueHolderForPolicy as BlurStyleActivePolicy)
            valueSerializer.writeInt32(valueHolderForPolicyTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForInactiveColor  = value.inactiveColor
        if (valueHolderForInactiveColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForInactiveColorTmpValue  = valueHolderForInactiveColor!
            if (valueHolderForInactiveColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForInactiveColorTmpValueForIdx0  = valueHolderForInactiveColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForInactiveColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForInactiveColorTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForInactiveColorTmpValueForIdx1  = valueHolderForInactiveColorTmpValue as int32
                valueSerializer.writeInt32(valueHolderForInactiveColorTmpValueForIdx1)
            } else if (valueHolderForInactiveColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForInactiveColorTmpValueForIdx2  = valueHolderForInactiveColorTmpValue as string
                valueSerializer.writeString(valueHolderForInactiveColorTmpValueForIdx2)
            } else if (valueHolderForInactiveColorTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForInactiveColorTmpValueForIdx3  = valueHolderForInactiveColorTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForInactiveColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): BackgroundEffectOptions {
        let valueDeserializer : DeserializerBase = buffer
        const radiusTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let radiusTmpBuf : double | undefined = undefined
        if ((radiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            radiusTmpBuf = valueDeserializer.readFloat64()
        }
        const radiusTmpResult : double | undefined = radiusTmpBuf
        const saturationTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let saturationTmpBuf : double | undefined = undefined
        if ((saturationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            saturationTmpBuf = valueDeserializer.readFloat64()
        }
        const saturationTmpResult : double | undefined = saturationTmpBuf
        const brightnessTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let brightnessTmpBuf : double | undefined = undefined
        if ((brightnessTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            brightnessTmpBuf = valueDeserializer.readFloat64()
        }
        const brightnessTmpResult : double | undefined = brightnessTmpBuf
        const colorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let colorTmpBuf : ResourceColor | undefined = undefined
        if ((colorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const colorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let colorTmpBufOpt : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (colorTmpBufOptUnionSelector == (0).toByte()) {
                colorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (colorTmpBufOptUnionSelector == (1).toByte()) {
                colorTmpBufOpt = valueDeserializer.readInt32()
            } else if (colorTmpBufOptUnionSelector == (2).toByte()) {
                colorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (colorTmpBufOptUnionSelector == (3).toByte()) {
                colorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for colorTmpBufOpt has to be chosen through deserialisation.')
            }
            colorTmpBuf = (colorTmpBufOpt as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
        }
        const colorTmpResult : ResourceColor | undefined = colorTmpBuf
        const adaptiveColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let adaptiveColorTmpBuf : AdaptiveColor | undefined = undefined
        if ((adaptiveColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            adaptiveColorTmpBuf = AdaptiveColor.fromValue(valueDeserializer.readInt32())
        }
        const adaptiveColorTmpResult : AdaptiveColor | undefined = adaptiveColorTmpBuf
        const blurOptionsTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let blurOptionsTmpBuf : BlurOptions | undefined = undefined
        if ((blurOptionsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            blurOptionsTmpBuf = BlurOptions_serializer.read(valueDeserializer)
        }
        const blurOptionsTmpResult : BlurOptions | undefined = blurOptionsTmpBuf
        const policyTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let policyTmpBuf : BlurStyleActivePolicy | undefined = undefined
        if ((policyTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            policyTmpBuf = BlurStyleActivePolicy.fromValue(valueDeserializer.readInt32())
        }
        const policyTmpResult : BlurStyleActivePolicy | undefined = policyTmpBuf
        const inactiveColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let inactiveColorTmpBuf : ResourceColor | undefined = undefined
        if ((inactiveColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const inactiveColorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let inactiveColorTmpBufOpt : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (inactiveColorTmpBufOptUnionSelector == (0).toByte()) {
                inactiveColorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (inactiveColorTmpBufOptUnionSelector == (1).toByte()) {
                inactiveColorTmpBufOpt = valueDeserializer.readInt32()
            } else if (inactiveColorTmpBufOptUnionSelector == (2).toByte()) {
                inactiveColorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (inactiveColorTmpBufOptUnionSelector == (3).toByte()) {
                inactiveColorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for inactiveColorTmpBufOpt has to be chosen through deserialisation.')
            }
            inactiveColorTmpBuf = (inactiveColorTmpBufOpt as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
        }
        const inactiveColorTmpResult : ResourceColor | undefined = inactiveColorTmpBuf
        let value : BackgroundEffectOptions = ({radius: radiusTmpResult, saturation: saturationTmpResult, brightness: brightnessTmpResult, color: colorTmpResult, adaptiveColor: adaptiveColorTmpResult, blurOptions: blurOptionsTmpResult, policy: policyTmpResult, inactiveColor: inactiveColorTmpResult} as BackgroundEffectOptions)
        return value
    }
}
export class Bindable_Resource_serializer {
    public static write(buffer: SerializerBase, value: Bindable<global_resource_Resource>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        global_resource_Resource_serializer.write(valueSerializer, valueHolderForValue)
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<global_resource_Resource> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpResult : global_resource_Resource = global_resource_Resource_serializer.read(valueDeserializer)
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufClosure  = (data: global_resource_Resource):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            global_resource_Resource_serializer.write(onChangeTmpBufBufArgsSerializer, data);
            InteropNativeModule._CallCallbackSync(10, -1883906011, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(onChangeTmpBufClosure, onChangeTmpBufBufResource)
        const onChangeTmpResult : Callback<global_resource_Resource, void> = onChangeTmpBufClosure
        let value : Bindable<global_resource_Resource> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<global_resource_Resource>)
        return value
    }
}
export class Bindable_ResourceStr_serializer {
    public static write(buffer: SerializerBase, value: Bindable<arkui_component_units_ResourceStr>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        if (valueHolderForValue instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForValueForIdx0  = valueHolderForValue as string
            valueSerializer.writeString(valueHolderForValueForIdx0)
        } else if (valueHolderForValue instanceof arkui_component_units_Resource) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForValueForIdx1  = valueHolderForValue as arkui_component_units_Resource
            global_resource_Resource_serializer.write(valueSerializer, valueHolderForValueForIdx1)
        }
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<arkui_component_units_ResourceStr> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let valueTmpBuf : string | arkui_component_units_Resource | undefined
        if (valueTmpBufUnionSelector == (0).toByte()) {
            valueTmpBuf = (valueDeserializer.readString() as string)
        } else if (valueTmpBufUnionSelector == (1).toByte()) {
            valueTmpBuf = global_resource_Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error('One of the branches for valueTmpBuf has to be chosen through deserialisation.')
        }
        const valueTmpResult : arkui_component_units_ResourceStr = (valueTmpBuf as string | arkui_component_units_Resource)
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufClosure  = (data: arkui_component_units_ResourceStr):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            if (data instanceof string) {
                onChangeTmpBufBufArgsSerializer.writeInt8((0).toByte());
                const dataForIdx0  = data as string;
                onChangeTmpBufBufArgsSerializer.writeString(dataForIdx0);
            } else if (data instanceof arkui_component_units_Resource) {
                onChangeTmpBufBufArgsSerializer.writeInt8((1).toByte());
                const dataForIdx1  = data as arkui_component_units_Resource;
                global_resource_Resource_serializer.write(onChangeTmpBufBufArgsSerializer, dataForIdx1);
            }
            InteropNativeModule._CallCallbackSync(10, 1290588496, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(onChangeTmpBufClosure, onChangeTmpBufBufResource)
        const onChangeTmpResult : Callback<arkui_component_units_ResourceStr, void> = onChangeTmpBufClosure
        let value : Bindable<arkui_component_units_ResourceStr> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<arkui_component_units_ResourceStr>)
        return value
    }
}
export class ContentCoverOptions_serializer {
    public static write(buffer: SerializerBase, value: ContentCoverOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForBackgroundColor  = value.backgroundColor
        if (valueHolderForBackgroundColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundColorTmpValue  = valueHolderForBackgroundColor!
            if (valueHolderForBackgroundColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx0  = valueHolderForBackgroundColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForBackgroundColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForBackgroundColorTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx1  = valueHolderForBackgroundColorTmpValue as int32
                valueSerializer.writeInt32(valueHolderForBackgroundColorTmpValueForIdx1)
            } else if (valueHolderForBackgroundColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx2  = valueHolderForBackgroundColorTmpValue as string
                valueSerializer.writeString(valueHolderForBackgroundColorTmpValueForIdx2)
            } else if (valueHolderForBackgroundColorTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx3  = valueHolderForBackgroundColorTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForBackgroundColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnAppear  = value.onAppear
        if (valueHolderForOnAppear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnAppearTmpValue  = valueHolderForOnAppear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnAppearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnDisappear  = value.onDisappear
        if (valueHolderForOnDisappear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnDisappearTmpValue  = valueHolderForOnDisappear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnDisappearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillAppear  = value.onWillAppear
        if (valueHolderForOnWillAppear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillAppearTmpValue  = valueHolderForOnWillAppear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnWillAppearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillDisappear  = value.onWillDisappear
        if (valueHolderForOnWillDisappear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillDisappearTmpValue  = valueHolderForOnWillDisappear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnWillDisappearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForModalTransition  = value.modalTransition
        if (valueHolderForModalTransition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForModalTransitionTmpValue  = (valueHolderForModalTransition as ModalTransition)
            valueSerializer.writeInt32(valueHolderForModalTransitionTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillDismiss  = value.onWillDismiss
        if (valueHolderForOnWillDismiss !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillDismissTmpValue  = valueHolderForOnWillDismiss!
            valueSerializer.holdAndWriteCallback(valueHolderForOnWillDismissTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTransition  = value.transition
        if (valueHolderForTransition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTransitionTmpValue  = valueHolderForTransition!
            TransitionEffect_serializer.write(valueSerializer, valueHolderForTransitionTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ContentCoverOptions {
        let valueDeserializer : DeserializerBase = buffer
        const backgroundColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let backgroundColorTmpBuf : ResourceColor | undefined = undefined
        if ((backgroundColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const backgroundColorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let backgroundColorTmpBufOpt : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (backgroundColorTmpBufOptUnionSelector == (0).toByte()) {
                backgroundColorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (backgroundColorTmpBufOptUnionSelector == (1).toByte()) {
                backgroundColorTmpBufOpt = valueDeserializer.readInt32()
            } else if (backgroundColorTmpBufOptUnionSelector == (2).toByte()) {
                backgroundColorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (backgroundColorTmpBufOptUnionSelector == (3).toByte()) {
                backgroundColorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for backgroundColorTmpBufOpt has to be chosen through deserialisation.')
            }
            backgroundColorTmpBuf = (backgroundColorTmpBufOpt as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
        }
        const backgroundColorTmpResult : ResourceColor | undefined = backgroundColorTmpBuf
        const onAppearTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onAppearTmpBuf : (() => void) | undefined = undefined
        if ((onAppearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onAppearTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onAppearTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onAppearTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onAppearTmpBufOptClosure  = ():void => {
                const onAppearTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onAppearTmpBufOptBufArgsSerializer.writeInt32(onAppearTmpBufOptBufResource.resourceId);
                onAppearTmpBufOptBufArgsSerializer.writePointer(onAppearTmpBufOptBufCall);
                onAppearTmpBufOptBufArgsSerializer.writePointer(onAppearTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, onAppearTmpBufOptBufArgsSerializer.asBuffer(), onAppearTmpBufOptBufArgsSerializer.length());
                onAppearTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onAppearTmpBufOptClosure, onAppearTmpBufOptBufResource)
            onAppearTmpBuf = onAppearTmpBufOptClosure
        }
        const onAppearTmpResult : (() => void) | undefined = onAppearTmpBuf
        const onDisappearTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onDisappearTmpBuf : (() => void) | undefined = undefined
        if ((onDisappearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onDisappearTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDisappearTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onDisappearTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onDisappearTmpBufOptClosure  = ():void => {
                const onDisappearTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onDisappearTmpBufOptBufArgsSerializer.writeInt32(onDisappearTmpBufOptBufResource.resourceId);
                onDisappearTmpBufOptBufArgsSerializer.writePointer(onDisappearTmpBufOptBufCall);
                onDisappearTmpBufOptBufArgsSerializer.writePointer(onDisappearTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, onDisappearTmpBufOptBufArgsSerializer.asBuffer(), onDisappearTmpBufOptBufArgsSerializer.length());
                onDisappearTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onDisappearTmpBufOptClosure, onDisappearTmpBufOptBufResource)
            onDisappearTmpBuf = onDisappearTmpBufOptClosure
        }
        const onDisappearTmpResult : (() => void) | undefined = onDisappearTmpBuf
        const onWillAppearTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onWillAppearTmpBuf : (() => void) | undefined = undefined
        if ((onWillAppearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillAppearTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillAppearTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onWillAppearTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onWillAppearTmpBufOptClosure  = ():void => {
                const onWillAppearTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onWillAppearTmpBufOptBufArgsSerializer.writeInt32(onWillAppearTmpBufOptBufResource.resourceId);
                onWillAppearTmpBufOptBufArgsSerializer.writePointer(onWillAppearTmpBufOptBufCall);
                onWillAppearTmpBufOptBufArgsSerializer.writePointer(onWillAppearTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, onWillAppearTmpBufOptBufArgsSerializer.asBuffer(), onWillAppearTmpBufOptBufArgsSerializer.length());
                onWillAppearTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onWillAppearTmpBufOptClosure, onWillAppearTmpBufOptBufResource)
            onWillAppearTmpBuf = onWillAppearTmpBufOptClosure
        }
        const onWillAppearTmpResult : (() => void) | undefined = onWillAppearTmpBuf
        const onWillDisappearTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onWillDisappearTmpBuf : (() => void) | undefined = undefined
        if ((onWillDisappearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillDisappearTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillDisappearTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onWillDisappearTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onWillDisappearTmpBufOptClosure  = ():void => {
                const onWillDisappearTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onWillDisappearTmpBufOptBufArgsSerializer.writeInt32(onWillDisappearTmpBufOptBufResource.resourceId);
                onWillDisappearTmpBufOptBufArgsSerializer.writePointer(onWillDisappearTmpBufOptBufCall);
                onWillDisappearTmpBufOptBufArgsSerializer.writePointer(onWillDisappearTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, onWillDisappearTmpBufOptBufArgsSerializer.asBuffer(), onWillDisappearTmpBufOptBufArgsSerializer.length());
                onWillDisappearTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onWillDisappearTmpBufOptClosure, onWillDisappearTmpBufOptBufResource)
            onWillDisappearTmpBuf = onWillDisappearTmpBufOptClosure
        }
        const onWillDisappearTmpResult : (() => void) | undefined = onWillDisappearTmpBuf
        const modalTransitionTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let modalTransitionTmpBuf : ModalTransition | undefined = undefined
        if ((modalTransitionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            modalTransitionTmpBuf = ModalTransition.fromValue(valueDeserializer.readInt32())
        }
        const modalTransitionTmpResult : ModalTransition | undefined = modalTransitionTmpBuf
        const onWillDismissTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onWillDismissTmpBuf : Callback<DismissContentCoverAction, void> | undefined = undefined
        if ((onWillDismissTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillDismissTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillDismissTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onWillDismissTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onWillDismissTmpBufOptClosure  = (data: DismissContentCoverAction):void => {
                const onWillDismissTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onWillDismissTmpBufOptBufArgsSerializer.writeInt32(onWillDismissTmpBufOptBufResource.resourceId);
                onWillDismissTmpBufOptBufArgsSerializer.writePointer(onWillDismissTmpBufOptBufCall);
                onWillDismissTmpBufOptBufArgsSerializer.writePointer(onWillDismissTmpBufOptBufCallSync);
                DismissContentCoverAction_serializer.write(onWillDismissTmpBufOptBufArgsSerializer, data);
                InteropNativeModule._CallCallbackSync(10, 756392751, onWillDismissTmpBufOptBufArgsSerializer.asBuffer(), onWillDismissTmpBufOptBufArgsSerializer.length());
                onWillDismissTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onWillDismissTmpBufOptClosure, onWillDismissTmpBufOptBufResource)
            onWillDismissTmpBuf = onWillDismissTmpBufOptClosure
        }
        const onWillDismissTmpResult : Callback<DismissContentCoverAction, void> | undefined = onWillDismissTmpBuf
        const transitionTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let transitionTmpBuf : TransitionEffect | undefined = undefined
        if ((transitionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            transitionTmpBuf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transitionTmpResult : TransitionEffect | undefined = transitionTmpBuf
        let value : ContentCoverOptions = ({backgroundColor: backgroundColorTmpResult, onAppear: onAppearTmpResult, onDisappear: onDisappearTmpResult, onWillAppear: onWillAppearTmpResult, onWillDisappear: onWillDisappearTmpResult, modalTransition: modalTransitionTmpResult, onWillDismiss: onWillDismissTmpResult, transition: transitionTmpResult} as ContentCoverOptions)
        return value
    }
}
export class ContextMenuAnimationOptions_serializer {
    public static write(buffer: SerializerBase, value: ContextMenuAnimationOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForScale  = value.scale
        if (valueHolderForScale !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForScaleTmpValue  = valueHolderForScale!
            const valueHolderForScaleTmpValue_0  = valueHolderForScaleTmpValue[0]
            valueSerializer.writeFloat64(valueHolderForScaleTmpValue_0)
            const valueHolderForScaleTmpValue_1  = valueHolderForScaleTmpValue[1]
            valueSerializer.writeFloat64(valueHolderForScaleTmpValue_1)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTransition  = value.transition
        if (valueHolderForTransition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTransitionTmpValue  = valueHolderForTransition!
            TransitionEffect_serializer.write(valueSerializer, valueHolderForTransitionTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHoverScale  = value.hoverScale
        if (valueHolderForHoverScale !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHoverScaleTmpValue  = valueHolderForHoverScale!
            const valueHolderForHoverScaleTmpValue_0  = valueHolderForHoverScaleTmpValue[0]
            valueSerializer.writeFloat64(valueHolderForHoverScaleTmpValue_0)
            const valueHolderForHoverScaleTmpValue_1  = valueHolderForHoverScaleTmpValue[1]
            valueSerializer.writeFloat64(valueHolderForHoverScaleTmpValue_1)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ContextMenuAnimationOptions {
        let valueDeserializer : DeserializerBase = buffer
        const scaleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let scaleTmpBuf : AnimationNumberRange | undefined = undefined
        if ((scaleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const scaleTmpBufOptValue0 : double = valueDeserializer.readFloat64()
            const scaleTmpBufOptValue1 : double = valueDeserializer.readFloat64()
            scaleTmpBuf = ([scaleTmpBufOptValue0, scaleTmpBufOptValue1] as AnimationNumberRange)
        }
        const scaleTmpResult : AnimationNumberRange | undefined = scaleTmpBuf
        const transitionTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let transitionTmpBuf : TransitionEffect | undefined = undefined
        if ((transitionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            transitionTmpBuf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transitionTmpResult : TransitionEffect | undefined = transitionTmpBuf
        const hoverScaleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let hoverScaleTmpBuf : AnimationNumberRange | undefined = undefined
        if ((hoverScaleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const hoverScaleTmpBufOptValue0 : double = valueDeserializer.readFloat64()
            const hoverScaleTmpBufOptValue1 : double = valueDeserializer.readFloat64()
            hoverScaleTmpBuf = ([hoverScaleTmpBufOptValue0, hoverScaleTmpBufOptValue1] as AnimationNumberRange)
        }
        const hoverScaleTmpResult : AnimationNumberRange | undefined = hoverScaleTmpBuf
        let value : ContextMenuAnimationOptions = ({scale: scaleTmpResult, transition: transitionTmpResult, hoverScale: hoverScaleTmpResult} as ContextMenuAnimationOptions)
        return value
    }
}
export class DragPreviewOptions_serializer {
    public static write(buffer: SerializerBase, value: DragPreviewOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForMode  = value.mode
        if (valueHolderForMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForModeTmpValue  = valueHolderForMode!
            if (valueHolderForModeTmpValue instanceof DragPreviewMode) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForModeTmpValueForIdx0  = valueHolderForModeTmpValue as DragPreviewMode
                valueSerializer.writeInt32(valueHolderForModeTmpValueForIdx0.valueOf())
            } else if (valueHolderForModeTmpValue instanceof Array) {
                if (valueHolderForModeTmpValue.length == 0) {
                    valueSerializer.writeInt8((1).toByte())
                    valueSerializer.writeInt32(0)
                } else {
                    const valueHolderForModeTmpValueElem  = valueHolderForModeTmpValue[0]
                    if (valueHolderForModeTmpValueElem instanceof DragPreviewMode) {
                        valueSerializer.writeInt8((1).toByte())
                        const valueHolderForModeTmpValueForIdx1  = valueHolderForModeTmpValue as Array<DragPreviewMode>
                        valueSerializer.writeInt32((valueHolderForModeTmpValueForIdx1.length).toInt())
                        for (let valueHolderForModeTmpValueForIdx1CounterI = 0; valueHolderForModeTmpValueForIdx1CounterI < valueHolderForModeTmpValueForIdx1.length; valueHolderForModeTmpValueForIdx1CounterI++) {
                            const valueHolderForModeTmpValueForIdx1TmpElement : DragPreviewMode = valueHolderForModeTmpValueForIdx1[valueHolderForModeTmpValueForIdx1CounterI]
                            valueSerializer.writeInt32(valueHolderForModeTmpValueForIdx1TmpElement.valueOf())
                        }
                    }
                }
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForModifier  = value.modifier
        if (valueHolderForModifier !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForModifierTmpValue  = valueHolderForModifier!
            ImageModifier_serializer.write(valueSerializer, valueHolderForModifierTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForNumberBadge  = value.numberBadge
        if (valueHolderForNumberBadge !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForNumberBadgeTmpValue  = valueHolderForNumberBadge!
            if (valueHolderForNumberBadgeTmpValue instanceof boolean) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForNumberBadgeTmpValueForIdx0  = valueHolderForNumberBadgeTmpValue as boolean
                valueSerializer.writeBoolean(valueHolderForNumberBadgeTmpValueForIdx0)
            } else if (valueHolderForNumberBadgeTmpValue instanceof int64) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForNumberBadgeTmpValueForIdx1  = valueHolderForNumberBadgeTmpValue as int64
                valueSerializer.writeInt64(valueHolderForNumberBadgeTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForSizeChangeEffect  = value.sizeChangeEffect
        if (valueHolderForSizeChangeEffect !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForSizeChangeEffectTmpValue  = (valueHolderForSizeChangeEffect as DraggingSizeChangeEffect)
            valueSerializer.writeInt32(valueHolderForSizeChangeEffectTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): DragPreviewOptions {
        let valueDeserializer : DeserializerBase = buffer
        const modeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let modeTmpBuf : DragPreviewMode | Array<DragPreviewMode> | undefined = undefined
        if ((modeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const modeTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let modeTmpBufOpt : DragPreviewMode | Array<DragPreviewMode> | undefined
            if (modeTmpBufOptUnionSelector == (0).toByte()) {
                modeTmpBufOpt = DragPreviewMode.fromValue(valueDeserializer.readInt32())
            } else if (modeTmpBufOptUnionSelector == (1).toByte()) {
                const modeTmpBufOptBufULength : int32 = valueDeserializer.readInt32()
                let modeTmpBufOptBufU : Array<DragPreviewMode> = new Array<DragPreviewMode>(modeTmpBufOptBufULength)
                for (let modeTmpBufOptBufUBufCounterI = 0; modeTmpBufOptBufUBufCounterI < modeTmpBufOptBufULength; modeTmpBufOptBufUBufCounterI++) {
                    modeTmpBufOptBufU[modeTmpBufOptBufUBufCounterI] = DragPreviewMode.fromValue(valueDeserializer.readInt32())
                }
                modeTmpBufOpt = modeTmpBufOptBufU
            } else {
                throw new Error('One of the branches for modeTmpBufOpt has to be chosen through deserialisation.')
            }
            modeTmpBuf = (modeTmpBufOpt as DragPreviewMode | Array<DragPreviewMode>)
        }
        const modeTmpResult : DragPreviewMode | Array<DragPreviewMode> | undefined = modeTmpBuf
        const modifierTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let modifierTmpBuf : ImageModifier | undefined = undefined
        if ((modifierTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            modifierTmpBuf = (ImageModifier_serializer.read(valueDeserializer) as ImageModifier)
        }
        const modifierTmpResult : ImageModifier | undefined = modifierTmpBuf
        const numberBadgeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let numberBadgeTmpBuf : boolean | int64 | undefined = undefined
        if ((numberBadgeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const numberBadgeTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let numberBadgeTmpBufOpt : boolean | int64 | undefined
            if (numberBadgeTmpBufOptUnionSelector == (0).toByte()) {
                numberBadgeTmpBufOpt = valueDeserializer.readBoolean()
            } else if (numberBadgeTmpBufOptUnionSelector == (1).toByte()) {
                numberBadgeTmpBufOpt = valueDeserializer.readInt64()
            } else {
                throw new Error('One of the branches for numberBadgeTmpBufOpt has to be chosen through deserialisation.')
            }
            numberBadgeTmpBuf = (numberBadgeTmpBufOpt as boolean | int64)
        }
        const numberBadgeTmpResult : boolean | int64 | undefined = numberBadgeTmpBuf
        const sizeChangeEffectTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let sizeChangeEffectTmpBuf : DraggingSizeChangeEffect | undefined = undefined
        if ((sizeChangeEffectTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            sizeChangeEffectTmpBuf = DraggingSizeChangeEffect.fromValue(valueDeserializer.readInt32())
        }
        const sizeChangeEffectTmpResult : DraggingSizeChangeEffect | undefined = sizeChangeEffectTmpBuf
        let value : DragPreviewOptions = ({mode: modeTmpResult, modifier: modifierTmpResult, numberBadge: numberBadgeTmpResult, sizeChangeEffect: sizeChangeEffectTmpResult} as DragPreviewOptions)
        return value
    }
}
export class FadingEdgeOptions_serializer {
    public static write(buffer: SerializerBase, value: FadingEdgeOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForFadingEdgeLength  = value.fadingEdgeLength
        if (valueHolderForFadingEdgeLength !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFadingEdgeLengthTmpValue  = valueHolderForFadingEdgeLength!
            arkui_Graphics_LengthMetrics_serializer.write(valueSerializer, valueHolderForFadingEdgeLengthTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): FadingEdgeOptions {
        let valueDeserializer : DeserializerBase = buffer
        const fadingEdgeLengthTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let fadingEdgeLengthTmpBuf : arkui_Graphics_LengthMetrics | undefined = undefined
        if ((fadingEdgeLengthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            fadingEdgeLengthTmpBuf = arkui_Graphics_LengthMetrics_serializer.read(valueDeserializer)
        }
        const fadingEdgeLengthTmpResult : arkui_Graphics_LengthMetrics | undefined = fadingEdgeLengthTmpBuf
        let value : FadingEdgeOptions = ({fadingEdgeLength: fadingEdgeLengthTmpResult} as FadingEdgeOptions)
        return value
    }
}
export class ForegroundBlurStyleOptions_serializer {
    public static write(buffer: SerializerBase, value: ForegroundBlurStyleOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForColorMode  = value.colorMode
        if (valueHolderForColorMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForColorModeTmpValue  = (valueHolderForColorMode as ThemeColorMode)
            valueSerializer.writeInt32(valueHolderForColorModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAdaptiveColor  = value.adaptiveColor
        if (valueHolderForAdaptiveColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAdaptiveColorTmpValue  = (valueHolderForAdaptiveColor as AdaptiveColor)
            valueSerializer.writeInt32(valueHolderForAdaptiveColorTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForScale  = value.scale
        if (valueHolderForScale !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForScaleTmpValue  = valueHolderForScale!
            valueSerializer.writeFloat64(valueHolderForScaleTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBlurOptions  = value.blurOptions
        if (valueHolderForBlurOptions !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBlurOptionsTmpValue  = valueHolderForBlurOptions!
            BlurOptions_serializer.write(valueSerializer, valueHolderForBlurOptionsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ForegroundBlurStyleOptions {
        let valueDeserializer : DeserializerBase = buffer
        const colorModeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let colorModeTmpBuf : ThemeColorMode | undefined = undefined
        if ((colorModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            colorModeTmpBuf = ThemeColorMode.fromValue(valueDeserializer.readInt32())
        }
        const colorModeTmpResult : ThemeColorMode | undefined = colorModeTmpBuf
        const adaptiveColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let adaptiveColorTmpBuf : AdaptiveColor | undefined = undefined
        if ((adaptiveColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            adaptiveColorTmpBuf = AdaptiveColor.fromValue(valueDeserializer.readInt32())
        }
        const adaptiveColorTmpResult : AdaptiveColor | undefined = adaptiveColorTmpBuf
        const scaleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let scaleTmpBuf : double | undefined = undefined
        if ((scaleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            scaleTmpBuf = valueDeserializer.readFloat64()
        }
        const scaleTmpResult : double | undefined = scaleTmpBuf
        const blurOptionsTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let blurOptionsTmpBuf : BlurOptions | undefined = undefined
        if ((blurOptionsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            blurOptionsTmpBuf = BlurOptions_serializer.read(valueDeserializer)
        }
        const blurOptionsTmpResult : BlurOptions | undefined = blurOptionsTmpBuf
        let value : ForegroundBlurStyleOptions = ({colorMode: colorModeTmpResult, adaptiveColor: adaptiveColorTmpResult, scale: scaleTmpResult, blurOptions: blurOptionsTmpResult} as ForegroundBlurStyleOptions)
        return value
    }
}
export class HistoricalPoint_serializer {
    public static write(buffer: SerializerBase, value: HistoricalPoint): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForTouchObject  = value.touchObject
        TouchObject_serializer.write(valueSerializer, valueHolderForTouchObject)
        const valueHolderForSize  = value.size
        valueSerializer.writeInt32(valueHolderForSize)
        const valueHolderForForce  = value.force
        valueSerializer.writeFloat64(valueHolderForForce)
        const valueHolderForTimestamp  = value.timestamp
        valueSerializer.writeInt64(valueHolderForTimestamp)
    }
    public static read(buffer: DeserializerBase): HistoricalPoint {
        let valueDeserializer : DeserializerBase = buffer
        const touchObjectTmpResult : TouchObject = TouchObject_serializer.read(valueDeserializer)
        const sizeTmpResult : int32 = valueDeserializer.readInt32()
        const forceTmpResult : double = valueDeserializer.readFloat64()
        const timestampTmpResult : int64 = valueDeserializer.readInt64()
        let value : HistoricalPoint = ({touchObject: touchObjectTmpResult, size: sizeTmpResult, force: forceTmpResult, timestamp: timestampTmpResult} as HistoricalPoint)
        return value
    }
}
export class KeyframeAnimateParam_serializer {
    public static write(buffer: SerializerBase, value: KeyframeAnimateParam): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDelay  = value.delay
        if (valueHolderForDelay !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDelayTmpValue  = valueHolderForDelay!
            valueSerializer.writeInt32(valueHolderForDelayTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForIterations  = value.iterations
        if (valueHolderForIterations !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForIterationsTmpValue  = valueHolderForIterations!
            valueSerializer.writeInt32(valueHolderForIterationsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnFinish  = value.onFinish
        if (valueHolderForOnFinish !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnFinishTmpValue  = valueHolderForOnFinish!
            valueSerializer.holdAndWriteCallback(valueHolderForOnFinishTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForExpectedFrameRateRange  = value.expectedFrameRateRange
        if (valueHolderForExpectedFrameRateRange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForExpectedFrameRateRangeTmpValue  = valueHolderForExpectedFrameRateRange!
            ExpectedFrameRateRange_serializer.write(valueSerializer, valueHolderForExpectedFrameRateRangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): KeyframeAnimateParam {
        let valueDeserializer : DeserializerBase = buffer
        const delayTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let delayTmpBuf : int32 | undefined = undefined
        if ((delayTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            delayTmpBuf = valueDeserializer.readInt32()
        }
        const delayTmpResult : int32 | undefined = delayTmpBuf
        const iterationsTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let iterationsTmpBuf : int32 | undefined = undefined
        if ((iterationsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            iterationsTmpBuf = valueDeserializer.readInt32()
        }
        const iterationsTmpResult : int32 | undefined = iterationsTmpBuf
        const onFinishTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onFinishTmpBuf : (() => void) | undefined = undefined
        if ((onFinishTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onFinishTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onFinishTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onFinishTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onFinishTmpBufOptClosure  = ():void => {
                const onFinishTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onFinishTmpBufOptBufArgsSerializer.writeInt32(onFinishTmpBufOptBufResource.resourceId);
                onFinishTmpBufOptBufArgsSerializer.writePointer(onFinishTmpBufOptBufCall);
                onFinishTmpBufOptBufArgsSerializer.writePointer(onFinishTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, onFinishTmpBufOptBufArgsSerializer.asBuffer(), onFinishTmpBufOptBufArgsSerializer.length());
                onFinishTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onFinishTmpBufOptClosure, onFinishTmpBufOptBufResource)
            onFinishTmpBuf = onFinishTmpBufOptClosure
        }
        const onFinishTmpResult : (() => void) | undefined = onFinishTmpBuf
        const expectedFrameRateRangeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let expectedFrameRateRangeTmpBuf : ExpectedFrameRateRange | undefined = undefined
        if ((expectedFrameRateRangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            expectedFrameRateRangeTmpBuf = ExpectedFrameRateRange_serializer.read(valueDeserializer)
        }
        const expectedFrameRateRangeTmpResult : ExpectedFrameRateRange | undefined = expectedFrameRateRangeTmpBuf
        let value : KeyframeAnimateParam = ({delay: delayTmpResult, iterations: iterationsTmpResult, onFinish: onFinishTmpResult, expectedFrameRateRange: expectedFrameRateRangeTmpResult} as KeyframeAnimateParam)
        return value
    }
}
export class LightSource_serializer {
    public static write(buffer: SerializerBase, value: LightSource): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForPositionX  = value.positionX
        if (valueHolderForPositionX instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForPositionXForIdx0  = valueHolderForPositionX as string
            valueSerializer.writeString(valueHolderForPositionXForIdx0)
        } else if (valueHolderForPositionX instanceof number) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForPositionXForIdx1  = valueHolderForPositionX as number
            valueSerializer.writeNumber(valueHolderForPositionXForIdx1)
        } else if (valueHolderForPositionX instanceof global_resource_Resource) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForPositionXForIdx2  = valueHolderForPositionX as global_resource_Resource
            global_resource_Resource_serializer.write(valueSerializer, valueHolderForPositionXForIdx2)
        }
        const valueHolderForPositionY  = value.positionY
        if (valueHolderForPositionY instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForPositionYForIdx0  = valueHolderForPositionY as string
            valueSerializer.writeString(valueHolderForPositionYForIdx0)
        } else if (valueHolderForPositionY instanceof number) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForPositionYForIdx1  = valueHolderForPositionY as number
            valueSerializer.writeNumber(valueHolderForPositionYForIdx1)
        } else if (valueHolderForPositionY instanceof global_resource_Resource) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForPositionYForIdx2  = valueHolderForPositionY as global_resource_Resource
            global_resource_Resource_serializer.write(valueSerializer, valueHolderForPositionYForIdx2)
        }
        const valueHolderForPositionZ  = value.positionZ
        if (valueHolderForPositionZ instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForPositionZForIdx0  = valueHolderForPositionZ as string
            valueSerializer.writeString(valueHolderForPositionZForIdx0)
        } else if (valueHolderForPositionZ instanceof number) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForPositionZForIdx1  = valueHolderForPositionZ as number
            valueSerializer.writeNumber(valueHolderForPositionZForIdx1)
        } else if (valueHolderForPositionZ instanceof global_resource_Resource) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForPositionZForIdx2  = valueHolderForPositionZ as global_resource_Resource
            global_resource_Resource_serializer.write(valueSerializer, valueHolderForPositionZForIdx2)
        }
        const valueHolderForIntensity  = value.intensity
        valueSerializer.writeFloat64(valueHolderForIntensity)
        const valueHolderForColor  = value.color
        if (valueHolderForColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForColorTmpValue  = valueHolderForColor!
            if (valueHolderForColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorTmpValueForIdx0  = valueHolderForColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForColorTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorTmpValueForIdx1  = valueHolderForColorTmpValue as int32
                valueSerializer.writeInt32(valueHolderForColorTmpValueForIdx1)
            } else if (valueHolderForColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorTmpValueForIdx2  = valueHolderForColorTmpValue as string
                valueSerializer.writeString(valueHolderForColorTmpValueForIdx2)
            } else if (valueHolderForColorTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorTmpValueForIdx3  = valueHolderForColorTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): LightSource {
        let valueDeserializer : DeserializerBase = buffer
        const positionXTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let positionXTmpBuf : string | number | global_resource_Resource | undefined
        if (positionXTmpBufUnionSelector == (0).toByte()) {
            positionXTmpBuf = (valueDeserializer.readString() as string)
        } else if (positionXTmpBufUnionSelector == (1).toByte()) {
            positionXTmpBuf = (valueDeserializer.readNumber() as number)
        } else if (positionXTmpBufUnionSelector == (2).toByte()) {
            positionXTmpBuf = global_resource_Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error('One of the branches for positionXTmpBuf has to be chosen through deserialisation.')
        }
        const positionXTmpResult : Dimension = (positionXTmpBuf as string | number | global_resource_Resource)
        const positionYTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let positionYTmpBuf : string | number | global_resource_Resource | undefined
        if (positionYTmpBufUnionSelector == (0).toByte()) {
            positionYTmpBuf = (valueDeserializer.readString() as string)
        } else if (positionYTmpBufUnionSelector == (1).toByte()) {
            positionYTmpBuf = (valueDeserializer.readNumber() as number)
        } else if (positionYTmpBufUnionSelector == (2).toByte()) {
            positionYTmpBuf = global_resource_Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error('One of the branches for positionYTmpBuf has to be chosen through deserialisation.')
        }
        const positionYTmpResult : Dimension = (positionYTmpBuf as string | number | global_resource_Resource)
        const positionZTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let positionZTmpBuf : string | number | global_resource_Resource | undefined
        if (positionZTmpBufUnionSelector == (0).toByte()) {
            positionZTmpBuf = (valueDeserializer.readString() as string)
        } else if (positionZTmpBufUnionSelector == (1).toByte()) {
            positionZTmpBuf = (valueDeserializer.readNumber() as number)
        } else if (positionZTmpBufUnionSelector == (2).toByte()) {
            positionZTmpBuf = global_resource_Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error('One of the branches for positionZTmpBuf has to be chosen through deserialisation.')
        }
        const positionZTmpResult : Dimension = (positionZTmpBuf as string | number | global_resource_Resource)
        const intensityTmpResult : double = valueDeserializer.readFloat64()
        const colorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let colorTmpBuf : ResourceColor | undefined = undefined
        if ((colorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const colorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let colorTmpBufOpt : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (colorTmpBufOptUnionSelector == (0).toByte()) {
                colorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (colorTmpBufOptUnionSelector == (1).toByte()) {
                colorTmpBufOpt = valueDeserializer.readInt32()
            } else if (colorTmpBufOptUnionSelector == (2).toByte()) {
                colorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (colorTmpBufOptUnionSelector == (3).toByte()) {
                colorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for colorTmpBufOpt has to be chosen through deserialisation.')
            }
            colorTmpBuf = (colorTmpBufOpt as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
        }
        const colorTmpResult : ResourceColor | undefined = colorTmpBuf
        let value : LightSource = ({positionX: positionXTmpResult, positionY: positionYTmpResult, positionZ: positionZTmpResult, intensity: intensityTmpResult, color: colorTmpResult} as LightSource)
        return value
    }
}
export class LocalizedAlignRuleOptions_serializer {
    public static write(buffer: SerializerBase, value: LocalizedAlignRuleOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForStart  = value.start
        if (valueHolderForStart !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForStartTmpValue  = valueHolderForStart!
            LocalizedHorizontalAlignParam_serializer.write(valueSerializer, valueHolderForStartTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnd  = value.end
        if (valueHolderForEnd !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEndTmpValue  = valueHolderForEnd!
            LocalizedHorizontalAlignParam_serializer.write(valueSerializer, valueHolderForEndTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMiddle  = value.middle
        if (valueHolderForMiddle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMiddleTmpValue  = valueHolderForMiddle!
            LocalizedHorizontalAlignParam_serializer.write(valueSerializer, valueHolderForMiddleTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTop  = value.top
        if (valueHolderForTop !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTopTmpValue  = valueHolderForTop!
            LocalizedVerticalAlignParam_serializer.write(valueSerializer, valueHolderForTopTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBottom  = value.bottom
        if (valueHolderForBottom !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBottomTmpValue  = valueHolderForBottom!
            LocalizedVerticalAlignParam_serializer.write(valueSerializer, valueHolderForBottomTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCenter  = value.center
        if (valueHolderForCenter !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCenterTmpValue  = valueHolderForCenter!
            LocalizedVerticalAlignParam_serializer.write(valueSerializer, valueHolderForCenterTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBias  = value.bias
        if (valueHolderForBias !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBiasTmpValue  = valueHolderForBias!
            Bias_serializer.write(valueSerializer, valueHolderForBiasTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): LocalizedAlignRuleOptions {
        let valueDeserializer : DeserializerBase = buffer
        const startTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let startTmpBuf : LocalizedHorizontalAlignParam | undefined = undefined
        if ((startTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            startTmpBuf = LocalizedHorizontalAlignParam_serializer.read(valueDeserializer)
        }
        const startTmpResult : LocalizedHorizontalAlignParam | undefined = startTmpBuf
        const endTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let endTmpBuf : LocalizedHorizontalAlignParam | undefined = undefined
        if ((endTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            endTmpBuf = LocalizedHorizontalAlignParam_serializer.read(valueDeserializer)
        }
        const endTmpResult : LocalizedHorizontalAlignParam | undefined = endTmpBuf
        const middleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let middleTmpBuf : LocalizedHorizontalAlignParam | undefined = undefined
        if ((middleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            middleTmpBuf = LocalizedHorizontalAlignParam_serializer.read(valueDeserializer)
        }
        const middleTmpResult : LocalizedHorizontalAlignParam | undefined = middleTmpBuf
        const topTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let topTmpBuf : LocalizedVerticalAlignParam | undefined = undefined
        if ((topTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            topTmpBuf = LocalizedVerticalAlignParam_serializer.read(valueDeserializer)
        }
        const topTmpResult : LocalizedVerticalAlignParam | undefined = topTmpBuf
        const bottomTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let bottomTmpBuf : LocalizedVerticalAlignParam | undefined = undefined
        if ((bottomTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            bottomTmpBuf = LocalizedVerticalAlignParam_serializer.read(valueDeserializer)
        }
        const bottomTmpResult : LocalizedVerticalAlignParam | undefined = bottomTmpBuf
        const centerTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let centerTmpBuf : LocalizedVerticalAlignParam | undefined = undefined
        if ((centerTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            centerTmpBuf = LocalizedVerticalAlignParam_serializer.read(valueDeserializer)
        }
        const centerTmpResult : LocalizedVerticalAlignParam | undefined = centerTmpBuf
        const biasTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let biasTmpBuf : Bias | undefined = undefined
        if ((biasTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            biasTmpBuf = Bias_serializer.read(valueDeserializer)
        }
        const biasTmpResult : Bias | undefined = biasTmpBuf
        let value : LocalizedAlignRuleOptions = ({start: startTmpResult, end: endTmpResult, middle: middleTmpResult, top: topTmpResult, bottom: bottomTmpResult, center: centerTmpResult, bias: biasTmpResult} as LocalizedAlignRuleOptions)
        return value
    }
}
export class MenuElement_serializer {
    public static write(buffer: SerializerBase, value: MenuElement): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        if (valueHolderForValue instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForValueForIdx0  = valueHolderForValue as string
            valueSerializer.writeString(valueHolderForValueForIdx0)
        } else if (valueHolderForValue instanceof arkui_component_units_Resource) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForValueForIdx1  = valueHolderForValue as arkui_component_units_Resource
            global_resource_Resource_serializer.write(valueSerializer, valueHolderForValueForIdx1)
        }
        const valueHolderForIcon  = value.icon
        if (valueHolderForIcon !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForIconTmpValue  = valueHolderForIcon!
            if (valueHolderForIconTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForIconTmpValueForIdx0  = valueHolderForIconTmpValue as string
                valueSerializer.writeString(valueHolderForIconTmpValueForIdx0)
            } else if (valueHolderForIconTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForIconTmpValueForIdx1  = valueHolderForIconTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForIconTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForSymbolIcon  = value.symbolIcon
        if (valueHolderForSymbolIcon !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForSymbolIconTmpValue  = valueHolderForSymbolIcon!
            SymbolGlyphModifier_serializer.write(valueSerializer, valueHolderForSymbolIconTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnabled  = value.enabled
        if (valueHolderForEnabled !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnabledTmpValue  = valueHolderForEnabled!
            valueSerializer.writeBoolean(valueHolderForEnabledTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAction  = value.action
        valueSerializer.holdAndWriteCallback(valueHolderForAction)
    }
    public static read(buffer: DeserializerBase): MenuElement {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let valueTmpBuf : string | arkui_component_units_Resource | undefined
        if (valueTmpBufUnionSelector == (0).toByte()) {
            valueTmpBuf = (valueDeserializer.readString() as string)
        } else if (valueTmpBufUnionSelector == (1).toByte()) {
            valueTmpBuf = global_resource_Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error('One of the branches for valueTmpBuf has to be chosen through deserialisation.')
        }
        const valueTmpResult : arkui_component_units_ResourceStr = (valueTmpBuf as string | arkui_component_units_Resource)
        const iconTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let iconTmpBuf : arkui_component_units_ResourceStr | undefined = undefined
        if ((iconTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const iconTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let iconTmpBufOpt : string | arkui_component_units_Resource | undefined
            if (iconTmpBufOptUnionSelector == (0).toByte()) {
                iconTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (iconTmpBufOptUnionSelector == (1).toByte()) {
                iconTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for iconTmpBufOpt has to be chosen through deserialisation.')
            }
            iconTmpBuf = (iconTmpBufOpt as string | arkui_component_units_Resource)
        }
        const iconTmpResult : arkui_component_units_ResourceStr | undefined = iconTmpBuf
        const symbolIconTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let symbolIconTmpBuf : SymbolGlyphModifier | undefined = undefined
        if ((symbolIconTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            symbolIconTmpBuf = (SymbolGlyphModifier_serializer.read(valueDeserializer) as SymbolGlyphModifier)
        }
        const symbolIconTmpResult : SymbolGlyphModifier | undefined = symbolIconTmpBuf
        const enabledTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let enabledTmpBuf : boolean | undefined = undefined
        if ((enabledTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enabledTmpBuf = valueDeserializer.readBoolean()
        }
        const enabledTmpResult : boolean | undefined = enabledTmpBuf
        const actionTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const actionTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const actionTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const actionTmpBufClosure  = ():void => {
            const actionTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            actionTmpBufBufArgsSerializer.writeInt32(actionTmpBufBufResource.resourceId);
            actionTmpBufBufArgsSerializer.writePointer(actionTmpBufBufCall);
            actionTmpBufBufArgsSerializer.writePointer(actionTmpBufBufCallSync);
            InteropNativeModule._CallCallbackSync(10, -1225416436, actionTmpBufBufArgsSerializer.asBuffer(), actionTmpBufBufArgsSerializer.length());
            actionTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(actionTmpBufClosure, actionTmpBufBufResource)
        const actionTmpResult : (() => void) = actionTmpBufClosure
        let value : MenuElement = ({value: valueTmpResult, icon: iconTmpResult, symbolIcon: symbolIconTmpResult, enabled: enabledTmpResult, action: actionTmpResult} as MenuElement)
        return value
    }
}
export class MotionBlurOptions_serializer {
    public static write(buffer: SerializerBase, value: MotionBlurOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForRadius  = value.radius
        if (valueHolderForRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRadiusTmpValue  = valueHolderForRadius!
            valueSerializer.writeFloat64(valueHolderForRadiusTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAnchor  = value.anchor
        if (valueHolderForAnchor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAnchorTmpValue  = valueHolderForAnchor!
            MotionBlurAnchor_serializer.write(valueSerializer, valueHolderForAnchorTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): MotionBlurOptions {
        let valueDeserializer : DeserializerBase = buffer
        const radiusTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let radiusTmpBuf : double | undefined = undefined
        if ((radiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            radiusTmpBuf = valueDeserializer.readFloat64()
        }
        const radiusTmpResult : double | undefined = radiusTmpBuf
        const anchorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let anchorTmpBuf : MotionBlurAnchor | undefined = undefined
        if ((anchorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            anchorTmpBuf = MotionBlurAnchor_serializer.read(valueDeserializer)
        }
        const anchorTmpResult : MotionBlurAnchor | undefined = anchorTmpBuf
        let value : MotionBlurOptions = ({radius: radiusTmpResult, anchor: anchorTmpResult} as MotionBlurOptions)
        return value
    }
}
export class OverlayOptions_serializer {
    public static write(buffer: SerializerBase, value: OverlayOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAlign  = value.align
        if (valueHolderForAlign !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAlignTmpValue  = (valueHolderForAlign as Alignment)
            valueSerializer.writeInt32(valueHolderForAlignTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOffset  = value.offset
        if (valueHolderForOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetTmpValue  = valueHolderForOffset!
            OverlayOffset_serializer.write(valueSerializer, valueHolderForOffsetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): OverlayOptions {
        let valueDeserializer : DeserializerBase = buffer
        const alignTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let alignTmpBuf : Alignment | undefined = undefined
        if ((alignTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            alignTmpBuf = Alignment.fromValue(valueDeserializer.readInt32())
        }
        const alignTmpResult : Alignment | undefined = alignTmpBuf
        const offsetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let offsetTmpBuf : OverlayOffset | undefined = undefined
        if ((offsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            offsetTmpBuf = OverlayOffset_serializer.read(valueDeserializer)
        }
        const offsetTmpResult : OverlayOffset | undefined = offsetTmpBuf
        let value : OverlayOptions = ({align: alignTmpResult, offset: offsetTmpResult} as OverlayOptions)
        return value
    }
}
export class PopupMaskType_serializer {
    public static write(buffer: SerializerBase, value: PopupMaskType): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForColor  = value.color
        if (valueHolderForColor instanceof arkui_component_enums_Color) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForColorForIdx0  = valueHolderForColor as arkui_component_enums_Color
            valueSerializer.writeInt32((valueHolderForColorForIdx0.getOrdinal()) % (12))
        } else if (valueHolderForColor instanceof int32) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForColorForIdx1  = valueHolderForColor as int32
            valueSerializer.writeInt32(valueHolderForColorForIdx1)
        } else if (valueHolderForColor instanceof string) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForColorForIdx2  = valueHolderForColor as string
            valueSerializer.writeString(valueHolderForColorForIdx2)
        } else if (valueHolderForColor instanceof arkui_component_units_Resource) {
            valueSerializer.writeInt8((3).toByte())
            const valueHolderForColorForIdx3  = valueHolderForColor as arkui_component_units_Resource
            global_resource_Resource_serializer.write(valueSerializer, valueHolderForColorForIdx3)
        }
    }
    public static read(buffer: DeserializerBase): PopupMaskType {
        let valueDeserializer : DeserializerBase = buffer
        const colorTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let colorTmpBuf : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
        if (colorTmpBufUnionSelector == (0).toByte()) {
            colorTmpBuf = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
        } else if (colorTmpBufUnionSelector == (1).toByte()) {
            colorTmpBuf = valueDeserializer.readInt32()
        } else if (colorTmpBufUnionSelector == (2).toByte()) {
            colorTmpBuf = (valueDeserializer.readString() as string)
        } else if (colorTmpBufUnionSelector == (3).toByte()) {
            colorTmpBuf = global_resource_Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error('One of the branches for colorTmpBuf has to be chosen through deserialisation.')
        }
        const colorTmpResult : ResourceColor = (colorTmpBuf as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
        let value : PopupMaskType = ({color: colorTmpResult} as PopupMaskType)
        return value
    }
}
export class ReuseOptions_serializer {
    public static write(buffer: SerializerBase, value: ReuseOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForReuseId  = value.reuseId
        if (valueHolderForReuseId !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForReuseIdTmpValue  = valueHolderForReuseId!
            valueSerializer.holdAndWriteCallback(valueHolderForReuseIdTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ReuseOptions {
        let valueDeserializer : DeserializerBase = buffer
        const reuseIdTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let reuseIdTmpBuf : ReuseIdCallback | undefined = undefined
        if ((reuseIdTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const reuseIdTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const reuseIdTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const reuseIdTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const reuseIdTmpBufOptClosure  = ():string => {
                const reuseIdTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                reuseIdTmpBufOptBufArgsSerializer.writeInt32(reuseIdTmpBufOptBufResource.resourceId);
                reuseIdTmpBufOptBufArgsSerializer.writePointer(reuseIdTmpBufOptBufCall);
                reuseIdTmpBufOptBufArgsSerializer.writePointer(reuseIdTmpBufOptBufCallSync);
                let reuseIdTmpBufOptBufContinuationValue : string | undefined;
                const reuseIdTmpBufOptBufContinuationCallback : ((breakpoints: string) => void) = (value: string):void => {
                reuseIdTmpBufOptBufContinuationValue = value;
            }
                reuseIdTmpBufOptBufArgsSerializer.holdAndWriteCallback(reuseIdTmpBufOptBufContinuationCallback);
                InteropNativeModule._CallCallbackSync(10, -2044386078, reuseIdTmpBufOptBufArgsSerializer.asBuffer(), reuseIdTmpBufOptBufArgsSerializer.length());
                reuseIdTmpBufOptBufArgsSerializer.release();
                return (reuseIdTmpBufOptBufContinuationValue as string);
            }
            resourceFinalizerRegister(reuseIdTmpBufOptClosure, reuseIdTmpBufOptBufResource)
            reuseIdTmpBuf = reuseIdTmpBufOptClosure
        }
        const reuseIdTmpResult : ReuseIdCallback | undefined = reuseIdTmpBuf
        let value : ReuseOptions = ({reuseId: reuseIdTmpResult} as ReuseOptions)
        return value
    }
}
export class ShadowOptions_serializer {
    public static write(buffer: SerializerBase, value: ShadowOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForRadius  = value.radius
        if (valueHolderForRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRadiusTmpValue  = valueHolderForRadius!
            if (valueHolderForRadiusTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForRadiusTmpValueForIdx0  = valueHolderForRadiusTmpValue as double
                valueSerializer.writeFloat64(valueHolderForRadiusTmpValueForIdx0)
            } else if (valueHolderForRadiusTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForRadiusTmpValueForIdx1  = valueHolderForRadiusTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForRadiusTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForType  = value.type
        if (valueHolderForType !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTypeTmpValue  = (valueHolderForType as ShadowType)
            valueSerializer.writeInt32(valueHolderForTypeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForColor  = value.color
        if (valueHolderForColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForColorTmpValue  = valueHolderForColor!
            if (valueHolderForColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorTmpValueForIdx0  = valueHolderForColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForColorTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorTmpValueForIdx1  = valueHolderForColorTmpValue as string
                valueSerializer.writeString(valueHolderForColorTmpValueForIdx1)
            } else if (valueHolderForColorTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorTmpValueForIdx2  = valueHolderForColorTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForColorTmpValueForIdx2)
            } else if (valueHolderForColorTmpValue instanceof ColoringStrategy) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorTmpValueForIdx3  = valueHolderForColorTmpValue as ColoringStrategy
                valueSerializer.writeInt32(valueHolderForColorTmpValueForIdx3.getOrdinal())
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOffsetX  = value.offsetX
        if (valueHolderForOffsetX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetXTmpValue  = valueHolderForOffsetX!
            if (valueHolderForOffsetXTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOffsetXTmpValueForIdx0  = valueHolderForOffsetXTmpValue as double
                valueSerializer.writeFloat64(valueHolderForOffsetXTmpValueForIdx0)
            } else if (valueHolderForOffsetXTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOffsetXTmpValueForIdx1  = valueHolderForOffsetXTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForOffsetXTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOffsetY  = value.offsetY
        if (valueHolderForOffsetY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetYTmpValue  = valueHolderForOffsetY!
            if (valueHolderForOffsetYTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOffsetYTmpValueForIdx0  = valueHolderForOffsetYTmpValue as double
                valueSerializer.writeFloat64(valueHolderForOffsetYTmpValueForIdx0)
            } else if (valueHolderForOffsetYTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOffsetYTmpValueForIdx1  = valueHolderForOffsetYTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForOffsetYTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFill  = value.fill
        if (valueHolderForFill !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFillTmpValue  = valueHolderForFill!
            valueSerializer.writeBoolean(valueHolderForFillTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ShadowOptions {
        let valueDeserializer : DeserializerBase = buffer
        const radiusTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let radiusTmpBuf : double | global_resource_Resource | undefined = undefined
        if ((radiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const radiusTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let radiusTmpBufOpt : double | global_resource_Resource | undefined
            if (radiusTmpBufOptUnionSelector == (0).toByte()) {
                radiusTmpBufOpt = valueDeserializer.readFloat64()
            } else if (radiusTmpBufOptUnionSelector == (1).toByte()) {
                radiusTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for radiusTmpBufOpt has to be chosen through deserialisation.')
            }
            radiusTmpBuf = (radiusTmpBufOpt as double | global_resource_Resource)
        }
        const radiusTmpResult : double | global_resource_Resource | undefined = radiusTmpBuf
        const typeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let typeTmpBuf : ShadowType | undefined = undefined
        if ((typeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            typeTmpBuf = ShadowType.fromValue(valueDeserializer.readInt32())
        }
        const typeTmpResult : ShadowType | undefined = typeTmpBuf
        const colorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let colorTmpBuf : arkui_component_enums_Color | string | global_resource_Resource | ColoringStrategy | undefined = undefined
        if ((colorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const colorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let colorTmpBufOpt : arkui_component_enums_Color | string | global_resource_Resource | ColoringStrategy | undefined
            if (colorTmpBufOptUnionSelector == (0).toByte()) {
                colorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (colorTmpBufOptUnionSelector == (1).toByte()) {
                colorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (colorTmpBufOptUnionSelector == (2).toByte()) {
                colorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else if (colorTmpBufOptUnionSelector == (3).toByte()) {
                colorTmpBufOpt = ColoringStrategy.values()[valueDeserializer.readInt32()]
            } else {
                throw new Error('One of the branches for colorTmpBufOpt has to be chosen through deserialisation.')
            }
            colorTmpBuf = (colorTmpBufOpt as arkui_component_enums_Color | string | global_resource_Resource | ColoringStrategy)
        }
        const colorTmpResult : arkui_component_enums_Color | string | global_resource_Resource | ColoringStrategy | undefined = colorTmpBuf
        const offsetXTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let offsetXTmpBuf : double | global_resource_Resource | undefined = undefined
        if ((offsetXTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const offsetXTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let offsetXTmpBufOpt : double | global_resource_Resource | undefined
            if (offsetXTmpBufOptUnionSelector == (0).toByte()) {
                offsetXTmpBufOpt = valueDeserializer.readFloat64()
            } else if (offsetXTmpBufOptUnionSelector == (1).toByte()) {
                offsetXTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for offsetXTmpBufOpt has to be chosen through deserialisation.')
            }
            offsetXTmpBuf = (offsetXTmpBufOpt as double | global_resource_Resource)
        }
        const offsetXTmpResult : double | global_resource_Resource | undefined = offsetXTmpBuf
        const offsetYTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let offsetYTmpBuf : double | global_resource_Resource | undefined = undefined
        if ((offsetYTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const offsetYTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let offsetYTmpBufOpt : double | global_resource_Resource | undefined
            if (offsetYTmpBufOptUnionSelector == (0).toByte()) {
                offsetYTmpBufOpt = valueDeserializer.readFloat64()
            } else if (offsetYTmpBufOptUnionSelector == (1).toByte()) {
                offsetYTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for offsetYTmpBufOpt has to be chosen through deserialisation.')
            }
            offsetYTmpBuf = (offsetYTmpBufOpt as double | global_resource_Resource)
        }
        const offsetYTmpResult : double | global_resource_Resource | undefined = offsetYTmpBuf
        const fillTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let fillTmpBuf : boolean | undefined = undefined
        if ((fillTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            fillTmpBuf = valueDeserializer.readBoolean()
        }
        const fillTmpResult : boolean | undefined = fillTmpBuf
        let value : ShadowOptions = ({radius: radiusTmpResult, type: typeTmpResult, color: colorTmpResult, offsetX: offsetXTmpResult, offsetY: offsetYTmpResult, fill: fillTmpResult} as ShadowOptions)
        return value
    }
}
export class sharedTransitionOptions_serializer {
    public static write(buffer: SerializerBase, value: sharedTransitionOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDuration  = value.duration
        if (valueHolderForDuration !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDurationTmpValue  = valueHolderForDuration!
            valueSerializer.writeInt32(valueHolderForDurationTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCurve  = value.curve
        if (valueHolderForCurve !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCurveTmpValue  = valueHolderForCurve!
            if (valueHolderForCurveTmpValue instanceof Curve) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForCurveTmpValueForIdx0  = valueHolderForCurveTmpValue as Curve
                valueSerializer.writeInt32(valueHolderForCurveTmpValueForIdx0.valueOf())
            } else if (valueHolderForCurveTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForCurveTmpValueForIdx1  = valueHolderForCurveTmpValue as string
                valueSerializer.writeString(valueHolderForCurveTmpValueForIdx1)
            } else if (valueHolderForCurveTmpValue instanceof ICurve) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForCurveTmpValueForIdx2  = valueHolderForCurveTmpValue as ICurve
                curves_ICurve_serializer.write(valueSerializer, valueHolderForCurveTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDelay  = value.delay
        if (valueHolderForDelay !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDelayTmpValue  = valueHolderForDelay!
            valueSerializer.writeInt32(valueHolderForDelayTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMotionPath  = value.motionPath
        if (valueHolderForMotionPath !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMotionPathTmpValue  = valueHolderForMotionPath!
            MotionPathOptions_serializer.write(valueSerializer, valueHolderForMotionPathTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForZIndex  = value.zIndex
        if (valueHolderForZIndex !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForZIndexTmpValue  = valueHolderForZIndex!
            valueSerializer.writeInt32(valueHolderForZIndexTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForType  = value.type
        if (valueHolderForType !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTypeTmpValue  = (valueHolderForType as SharedTransitionEffectType)
            valueSerializer.writeInt32(valueHolderForTypeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): sharedTransitionOptions {
        let valueDeserializer : DeserializerBase = buffer
        const durationTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let durationTmpBuf : int32 | undefined = undefined
        if ((durationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            durationTmpBuf = valueDeserializer.readInt32()
        }
        const durationTmpResult : int32 | undefined = durationTmpBuf
        const curveTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let curveTmpBuf : Curve | string | ICurve | undefined = undefined
        if ((curveTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const curveTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let curveTmpBufOpt : Curve | string | ICurve | undefined
            if (curveTmpBufOptUnionSelector == (0).toByte()) {
                curveTmpBufOpt = curves.Curve.fromValue(valueDeserializer.readInt32())
            } else if (curveTmpBufOptUnionSelector == (1).toByte()) {
                curveTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (curveTmpBufOptUnionSelector == (2).toByte()) {
                curveTmpBufOpt = (curves_ICurve_serializer.read(valueDeserializer) as curves.ICurve)
            } else {
                throw new Error('One of the branches for curveTmpBufOpt has to be chosen through deserialisation.')
            }
            curveTmpBuf = (curveTmpBufOpt as Curve | string | ICurve)
        }
        const curveTmpResult : Curve | string | ICurve | undefined = curveTmpBuf
        const delayTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let delayTmpBuf : int32 | undefined = undefined
        if ((delayTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            delayTmpBuf = valueDeserializer.readInt32()
        }
        const delayTmpResult : int32 | undefined = delayTmpBuf
        const motionPathTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let motionPathTmpBuf : MotionPathOptions | undefined = undefined
        if ((motionPathTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            motionPathTmpBuf = MotionPathOptions_serializer.read(valueDeserializer)
        }
        const motionPathTmpResult : MotionPathOptions | undefined = motionPathTmpBuf
        const zIndexTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let zIndexTmpBuf : int32 | undefined = undefined
        if ((zIndexTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            zIndexTmpBuf = valueDeserializer.readInt32()
        }
        const zIndexTmpResult : int32 | undefined = zIndexTmpBuf
        const typeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let typeTmpBuf : SharedTransitionEffectType | undefined = undefined
        if ((typeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            typeTmpBuf = SharedTransitionEffectType.fromValue(valueDeserializer.readInt32())
        }
        const typeTmpResult : SharedTransitionEffectType | undefined = typeTmpBuf
        let value : sharedTransitionOptions = ({duration: durationTmpResult, curve: curveTmpResult, delay: delayTmpResult, motionPath: motionPathTmpResult, zIndex: zIndexTmpResult, type: typeTmpResult} as sharedTransitionOptions)
        return value
    }
}
export class SheetTitleOptions_serializer {
    public static write(buffer: SerializerBase, value: SheetTitleOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForTitle  = value.title
        if (valueHolderForTitle instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForTitleForIdx0  = valueHolderForTitle as string
            valueSerializer.writeString(valueHolderForTitleForIdx0)
        } else if (valueHolderForTitle instanceof arkui_component_units_Resource) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForTitleForIdx1  = valueHolderForTitle as arkui_component_units_Resource
            global_resource_Resource_serializer.write(valueSerializer, valueHolderForTitleForIdx1)
        }
        const valueHolderForSubtitle  = value.subtitle
        if (valueHolderForSubtitle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForSubtitleTmpValue  = valueHolderForSubtitle!
            if (valueHolderForSubtitleTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForSubtitleTmpValueForIdx0  = valueHolderForSubtitleTmpValue as string
                valueSerializer.writeString(valueHolderForSubtitleTmpValueForIdx0)
            } else if (valueHolderForSubtitleTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForSubtitleTmpValueForIdx1  = valueHolderForSubtitleTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForSubtitleTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): SheetTitleOptions {
        let valueDeserializer : DeserializerBase = buffer
        const titleTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let titleTmpBuf : string | arkui_component_units_Resource | undefined
        if (titleTmpBufUnionSelector == (0).toByte()) {
            titleTmpBuf = (valueDeserializer.readString() as string)
        } else if (titleTmpBufUnionSelector == (1).toByte()) {
            titleTmpBuf = global_resource_Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error('One of the branches for titleTmpBuf has to be chosen through deserialisation.')
        }
        const titleTmpResult : arkui_component_units_ResourceStr = (titleTmpBuf as string | arkui_component_units_Resource)
        const subtitleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let subtitleTmpBuf : arkui_component_units_ResourceStr | undefined = undefined
        if ((subtitleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const subtitleTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let subtitleTmpBufOpt : string | arkui_component_units_Resource | undefined
            if (subtitleTmpBufOptUnionSelector == (0).toByte()) {
                subtitleTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (subtitleTmpBufOptUnionSelector == (1).toByte()) {
                subtitleTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for subtitleTmpBufOpt has to be chosen through deserialisation.')
            }
            subtitleTmpBuf = (subtitleTmpBufOpt as string | arkui_component_units_Resource)
        }
        const subtitleTmpResult : arkui_component_units_ResourceStr | undefined = subtitleTmpBuf
        let value : SheetTitleOptions = ({title: titleTmpResult, subtitle: subtitleTmpResult} as SheetTitleOptions)
        return value
    }
}
export class TextDecorationOptions_serializer {
    public static write(buffer: SerializerBase, value: TextDecorationOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForType  = value.type
        if (valueHolderForType !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTypeTmpValue  = (valueHolderForType as TextDecorationType)
            valueSerializer.writeInt32(valueHolderForTypeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForColor  = value.color
        if (valueHolderForColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForColorTmpValue  = valueHolderForColor!
            if (valueHolderForColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorTmpValueForIdx0  = valueHolderForColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForColorTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorTmpValueForIdx1  = valueHolderForColorTmpValue as int32
                valueSerializer.writeInt32(valueHolderForColorTmpValueForIdx1)
            } else if (valueHolderForColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorTmpValueForIdx2  = valueHolderForColorTmpValue as string
                valueSerializer.writeString(valueHolderForColorTmpValueForIdx2)
            } else if (valueHolderForColorTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorTmpValueForIdx3  = valueHolderForColorTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForStyle  = value.style
        if (valueHolderForStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForStyleTmpValue  = (valueHolderForStyle as TextDecorationStyle)
            valueSerializer.writeInt32(valueHolderForStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): TextDecorationOptions {
        let valueDeserializer : DeserializerBase = buffer
        const typeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let typeTmpBuf : TextDecorationType | undefined = undefined
        if ((typeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            typeTmpBuf = TextDecorationType.fromValue(valueDeserializer.readInt32())
        }
        const typeTmpResult : TextDecorationType | undefined = typeTmpBuf
        const colorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let colorTmpBuf : ResourceColor | undefined = undefined
        if ((colorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const colorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let colorTmpBufOpt : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (colorTmpBufOptUnionSelector == (0).toByte()) {
                colorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (colorTmpBufOptUnionSelector == (1).toByte()) {
                colorTmpBufOpt = valueDeserializer.readInt32()
            } else if (colorTmpBufOptUnionSelector == (2).toByte()) {
                colorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (colorTmpBufOptUnionSelector == (3).toByte()) {
                colorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for colorTmpBufOpt has to be chosen through deserialisation.')
            }
            colorTmpBuf = (colorTmpBufOpt as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
        }
        const colorTmpResult : ResourceColor | undefined = colorTmpBuf
        const styleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let styleTmpBuf : TextDecorationStyle | undefined = undefined
        if ((styleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            styleTmpBuf = TextDecorationStyle.fromValue(valueDeserializer.readInt32())
        }
        const styleTmpResult : TextDecorationStyle | undefined = styleTmpBuf
        let value : TextDecorationOptions = ({type: typeTmpResult, color: colorTmpResult, style: styleTmpResult} as TextDecorationOptions)
        return value
    }
}
export class Bindable_Length_serializer {
    public static write(buffer: SerializerBase, value: Bindable<Length>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        if (valueHolderForValue instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForValueForIdx0  = valueHolderForValue as string
            valueSerializer.writeString(valueHolderForValueForIdx0)
        } else if (valueHolderForValue instanceof double) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForValueForIdx1  = valueHolderForValue as double
            valueSerializer.writeFloat64(valueHolderForValueForIdx1)
        } else if (valueHolderForValue instanceof arkui_component_units_Resource) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForValueForIdx2  = valueHolderForValue as arkui_component_units_Resource
            global_resource_Resource_serializer.write(valueSerializer, valueHolderForValueForIdx2)
        }
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<Length> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let valueTmpBuf : string | double | arkui_component_units_Resource | undefined
        if (valueTmpBufUnionSelector == (0).toByte()) {
            valueTmpBuf = (valueDeserializer.readString() as string)
        } else if (valueTmpBufUnionSelector == (1).toByte()) {
            valueTmpBuf = valueDeserializer.readFloat64()
        } else if (valueTmpBufUnionSelector == (2).toByte()) {
            valueTmpBuf = global_resource_Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error('One of the branches for valueTmpBuf has to be chosen through deserialisation.')
        }
        const valueTmpResult : Length = (valueTmpBuf as string | double | arkui_component_units_Resource)
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufClosure  = (data: Length):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            if (data instanceof string) {
                onChangeTmpBufBufArgsSerializer.writeInt8((0).toByte());
                const dataForIdx0  = data as string;
                onChangeTmpBufBufArgsSerializer.writeString(dataForIdx0);
            } else if (data instanceof double) {
                onChangeTmpBufBufArgsSerializer.writeInt8((1).toByte());
                const dataForIdx1  = data as double;
                onChangeTmpBufBufArgsSerializer.writeFloat64(dataForIdx1);
            } else if (data instanceof arkui_component_units_Resource) {
                onChangeTmpBufBufArgsSerializer.writeInt8((2).toByte());
                const dataForIdx2  = data as arkui_component_units_Resource;
                global_resource_Resource_serializer.write(onChangeTmpBufBufArgsSerializer, dataForIdx2);
            }
            InteropNativeModule._CallCallbackSync(10, -1155493549, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(onChangeTmpBufClosure, onChangeTmpBufBufResource)
        const onChangeTmpResult : Callback<Length, void> = onChangeTmpBufClosure
        let value : Bindable<Length> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<Length>)
        return value
    }
}
export class DividerStyle_serializer {
    public static write(buffer: SerializerBase, value: DividerStyle): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForStrokeWidth  = value.strokeWidth
        if (valueHolderForStrokeWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForStrokeWidthTmpValue  = valueHolderForStrokeWidth!
            if (valueHolderForStrokeWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForStrokeWidthTmpValueForIdx0  = valueHolderForStrokeWidthTmpValue as string
                valueSerializer.writeString(valueHolderForStrokeWidthTmpValueForIdx0)
            } else if (valueHolderForStrokeWidthTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForStrokeWidthTmpValueForIdx1  = valueHolderForStrokeWidthTmpValue as double
                valueSerializer.writeFloat64(valueHolderForStrokeWidthTmpValueForIdx1)
            } else if (valueHolderForStrokeWidthTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForStrokeWidthTmpValueForIdx2  = valueHolderForStrokeWidthTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForStrokeWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForColor  = value.color
        if (valueHolderForColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForColorTmpValue  = valueHolderForColor!
            if (valueHolderForColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorTmpValueForIdx0  = valueHolderForColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForColorTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorTmpValueForIdx1  = valueHolderForColorTmpValue as int32
                valueSerializer.writeInt32(valueHolderForColorTmpValueForIdx1)
            } else if (valueHolderForColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorTmpValueForIdx2  = valueHolderForColorTmpValue as string
                valueSerializer.writeString(valueHolderForColorTmpValueForIdx2)
            } else if (valueHolderForColorTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorTmpValueForIdx3  = valueHolderForColorTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForStartMargin  = value.startMargin
        if (valueHolderForStartMargin !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForStartMarginTmpValue  = valueHolderForStartMargin!
            if (valueHolderForStartMarginTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForStartMarginTmpValueForIdx0  = valueHolderForStartMarginTmpValue as string
                valueSerializer.writeString(valueHolderForStartMarginTmpValueForIdx0)
            } else if (valueHolderForStartMarginTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForStartMarginTmpValueForIdx1  = valueHolderForStartMarginTmpValue as double
                valueSerializer.writeFloat64(valueHolderForStartMarginTmpValueForIdx1)
            } else if (valueHolderForStartMarginTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForStartMarginTmpValueForIdx2  = valueHolderForStartMarginTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForStartMarginTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEndMargin  = value.endMargin
        if (valueHolderForEndMargin !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEndMarginTmpValue  = valueHolderForEndMargin!
            if (valueHolderForEndMarginTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForEndMarginTmpValueForIdx0  = valueHolderForEndMarginTmpValue as string
                valueSerializer.writeString(valueHolderForEndMarginTmpValueForIdx0)
            } else if (valueHolderForEndMarginTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForEndMarginTmpValueForIdx1  = valueHolderForEndMarginTmpValue as double
                valueSerializer.writeFloat64(valueHolderForEndMarginTmpValueForIdx1)
            } else if (valueHolderForEndMarginTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForEndMarginTmpValueForIdx2  = valueHolderForEndMarginTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForEndMarginTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): DividerStyle {
        let valueDeserializer : DeserializerBase = buffer
        const strokeWidthTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let strokeWidthTmpBuf : Length | undefined = undefined
        if ((strokeWidthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const strokeWidthTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let strokeWidthTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (strokeWidthTmpBufOptUnionSelector == (0).toByte()) {
                strokeWidthTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (strokeWidthTmpBufOptUnionSelector == (1).toByte()) {
                strokeWidthTmpBufOpt = valueDeserializer.readFloat64()
            } else if (strokeWidthTmpBufOptUnionSelector == (2).toByte()) {
                strokeWidthTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for strokeWidthTmpBufOpt has to be chosen through deserialisation.')
            }
            strokeWidthTmpBuf = (strokeWidthTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const strokeWidthTmpResult : Length | undefined = strokeWidthTmpBuf
        const colorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let colorTmpBuf : ResourceColor | undefined = undefined
        if ((colorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const colorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let colorTmpBufOpt : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (colorTmpBufOptUnionSelector == (0).toByte()) {
                colorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (colorTmpBufOptUnionSelector == (1).toByte()) {
                colorTmpBufOpt = valueDeserializer.readInt32()
            } else if (colorTmpBufOptUnionSelector == (2).toByte()) {
                colorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (colorTmpBufOptUnionSelector == (3).toByte()) {
                colorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for colorTmpBufOpt has to be chosen through deserialisation.')
            }
            colorTmpBuf = (colorTmpBufOpt as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
        }
        const colorTmpResult : ResourceColor | undefined = colorTmpBuf
        const startMarginTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let startMarginTmpBuf : Length | undefined = undefined
        if ((startMarginTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const startMarginTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let startMarginTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (startMarginTmpBufOptUnionSelector == (0).toByte()) {
                startMarginTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (startMarginTmpBufOptUnionSelector == (1).toByte()) {
                startMarginTmpBufOpt = valueDeserializer.readFloat64()
            } else if (startMarginTmpBufOptUnionSelector == (2).toByte()) {
                startMarginTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for startMarginTmpBufOpt has to be chosen through deserialisation.')
            }
            startMarginTmpBuf = (startMarginTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const startMarginTmpResult : Length | undefined = startMarginTmpBuf
        const endMarginTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let endMarginTmpBuf : Length | undefined = undefined
        if ((endMarginTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const endMarginTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let endMarginTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (endMarginTmpBufOptUnionSelector == (0).toByte()) {
                endMarginTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (endMarginTmpBufOptUnionSelector == (1).toByte()) {
                endMarginTmpBufOpt = valueDeserializer.readFloat64()
            } else if (endMarginTmpBufOptUnionSelector == (2).toByte()) {
                endMarginTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for endMarginTmpBufOpt has to be chosen through deserialisation.')
            }
            endMarginTmpBuf = (endMarginTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const endMarginTmpResult : Length | undefined = endMarginTmpBuf
        let value : DividerStyle = ({strokeWidth: strokeWidthTmpResult, color: colorTmpResult, startMargin: startMarginTmpResult, endMargin: endMarginTmpResult} as DividerStyle)
        return value
    }
}
export class PixelStretchEffectOptions_serializer {
    public static write(buffer: SerializerBase, value: PixelStretchEffectOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForTop  = value.top
        if (valueHolderForTop !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTopTmpValue  = valueHolderForTop!
            if (valueHolderForTopTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForTopTmpValueForIdx0  = valueHolderForTopTmpValue as string
                valueSerializer.writeString(valueHolderForTopTmpValueForIdx0)
            } else if (valueHolderForTopTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForTopTmpValueForIdx1  = valueHolderForTopTmpValue as double
                valueSerializer.writeFloat64(valueHolderForTopTmpValueForIdx1)
            } else if (valueHolderForTopTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForTopTmpValueForIdx2  = valueHolderForTopTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForTopTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBottom  = value.bottom
        if (valueHolderForBottom !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBottomTmpValue  = valueHolderForBottom!
            if (valueHolderForBottomTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBottomTmpValueForIdx0  = valueHolderForBottomTmpValue as string
                valueSerializer.writeString(valueHolderForBottomTmpValueForIdx0)
            } else if (valueHolderForBottomTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBottomTmpValueForIdx1  = valueHolderForBottomTmpValue as double
                valueSerializer.writeFloat64(valueHolderForBottomTmpValueForIdx1)
            } else if (valueHolderForBottomTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBottomTmpValueForIdx2  = valueHolderForBottomTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForBottomTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForLeft  = value.left
        if (valueHolderForLeft !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForLeftTmpValue  = valueHolderForLeft!
            if (valueHolderForLeftTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForLeftTmpValueForIdx0  = valueHolderForLeftTmpValue as string
                valueSerializer.writeString(valueHolderForLeftTmpValueForIdx0)
            } else if (valueHolderForLeftTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForLeftTmpValueForIdx1  = valueHolderForLeftTmpValue as double
                valueSerializer.writeFloat64(valueHolderForLeftTmpValueForIdx1)
            } else if (valueHolderForLeftTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForLeftTmpValueForIdx2  = valueHolderForLeftTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForLeftTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRight  = value.right
        if (valueHolderForRight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRightTmpValue  = valueHolderForRight!
            if (valueHolderForRightTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForRightTmpValueForIdx0  = valueHolderForRightTmpValue as string
                valueSerializer.writeString(valueHolderForRightTmpValueForIdx0)
            } else if (valueHolderForRightTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForRightTmpValueForIdx1  = valueHolderForRightTmpValue as double
                valueSerializer.writeFloat64(valueHolderForRightTmpValueForIdx1)
            } else if (valueHolderForRightTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForRightTmpValueForIdx2  = valueHolderForRightTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForRightTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PixelStretchEffectOptions {
        let valueDeserializer : DeserializerBase = buffer
        const topTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let topTmpBuf : Length | undefined = undefined
        if ((topTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const topTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let topTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (topTmpBufOptUnionSelector == (0).toByte()) {
                topTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (topTmpBufOptUnionSelector == (1).toByte()) {
                topTmpBufOpt = valueDeserializer.readFloat64()
            } else if (topTmpBufOptUnionSelector == (2).toByte()) {
                topTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for topTmpBufOpt has to be chosen through deserialisation.')
            }
            topTmpBuf = (topTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const topTmpResult : Length | undefined = topTmpBuf
        const bottomTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let bottomTmpBuf : Length | undefined = undefined
        if ((bottomTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const bottomTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let bottomTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (bottomTmpBufOptUnionSelector == (0).toByte()) {
                bottomTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (bottomTmpBufOptUnionSelector == (1).toByte()) {
                bottomTmpBufOpt = valueDeserializer.readFloat64()
            } else if (bottomTmpBufOptUnionSelector == (2).toByte()) {
                bottomTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for bottomTmpBufOpt has to be chosen through deserialisation.')
            }
            bottomTmpBuf = (bottomTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const bottomTmpResult : Length | undefined = bottomTmpBuf
        const leftTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let leftTmpBuf : Length | undefined = undefined
        if ((leftTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const leftTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let leftTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (leftTmpBufOptUnionSelector == (0).toByte()) {
                leftTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (leftTmpBufOptUnionSelector == (1).toByte()) {
                leftTmpBufOpt = valueDeserializer.readFloat64()
            } else if (leftTmpBufOptUnionSelector == (2).toByte()) {
                leftTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for leftTmpBufOpt has to be chosen through deserialisation.')
            }
            leftTmpBuf = (leftTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const leftTmpResult : Length | undefined = leftTmpBuf
        const rightTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let rightTmpBuf : Length | undefined = undefined
        if ((rightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const rightTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let rightTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (rightTmpBufOptUnionSelector == (0).toByte()) {
                rightTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (rightTmpBufOptUnionSelector == (1).toByte()) {
                rightTmpBufOpt = valueDeserializer.readFloat64()
            } else if (rightTmpBufOptUnionSelector == (2).toByte()) {
                rightTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for rightTmpBufOpt has to be chosen through deserialisation.')
            }
            rightTmpBuf = (rightTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const rightTmpResult : Length | undefined = rightTmpBuf
        let value : PixelStretchEffectOptions = ({top: topTmpResult, bottom: bottomTmpResult, left: leftTmpResult, right: rightTmpResult} as PixelStretchEffectOptions)
        return value
    }
}
export class PointLightStyle_serializer {
    public static write(buffer: SerializerBase, value: PointLightStyle): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForLightSource  = value.lightSource
        if (valueHolderForLightSource !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForLightSourceTmpValue  = valueHolderForLightSource!
            LightSource_serializer.write(valueSerializer, valueHolderForLightSourceTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForIlluminated  = value.illuminated
        if (valueHolderForIlluminated !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForIlluminatedTmpValue  = (valueHolderForIlluminated as IlluminatedType)
            valueSerializer.writeInt32(valueHolderForIlluminatedTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBloom  = value.bloom
        if (valueHolderForBloom !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBloomTmpValue  = valueHolderForBloom!
            valueSerializer.writeFloat64(valueHolderForBloomTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PointLightStyle {
        let valueDeserializer : DeserializerBase = buffer
        const lightSourceTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let lightSourceTmpBuf : LightSource | undefined = undefined
        if ((lightSourceTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            lightSourceTmpBuf = LightSource_serializer.read(valueDeserializer)
        }
        const lightSourceTmpResult : LightSource | undefined = lightSourceTmpBuf
        const illuminatedTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let illuminatedTmpBuf : IlluminatedType | undefined = undefined
        if ((illuminatedTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            illuminatedTmpBuf = IlluminatedType.fromValue(valueDeserializer.readInt32())
        }
        const illuminatedTmpResult : IlluminatedType | undefined = illuminatedTmpBuf
        const bloomTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let bloomTmpBuf : double | undefined = undefined
        if ((bloomTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            bloomTmpBuf = valueDeserializer.readFloat64()
        }
        const bloomTmpResult : double | undefined = bloomTmpBuf
        let value : PointLightStyle = ({lightSource: lightSourceTmpResult, illuminated: illuminatedTmpResult, bloom: bloomTmpResult} as PointLightStyle)
        return value
    }
}
export class RadialGradientOptions_serializer {
    public static write(buffer: SerializerBase, value: RadialGradientOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForCenter  = value.center
        const valueHolderForCenter_0  = valueHolderForCenter[0]
        if (valueHolderForCenter_0 instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForCenter_0ForIdx0  = valueHolderForCenter_0 as string
            valueSerializer.writeString(valueHolderForCenter_0ForIdx0)
        } else if (valueHolderForCenter_0 instanceof double) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForCenter_0ForIdx1  = valueHolderForCenter_0 as double
            valueSerializer.writeFloat64(valueHolderForCenter_0ForIdx1)
        } else if (valueHolderForCenter_0 instanceof arkui_component_units_Resource) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForCenter_0ForIdx2  = valueHolderForCenter_0 as arkui_component_units_Resource
            global_resource_Resource_serializer.write(valueSerializer, valueHolderForCenter_0ForIdx2)
        }
        const valueHolderForCenter_1  = valueHolderForCenter[1]
        if (valueHolderForCenter_1 instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForCenter_1ForIdx0  = valueHolderForCenter_1 as string
            valueSerializer.writeString(valueHolderForCenter_1ForIdx0)
        } else if (valueHolderForCenter_1 instanceof double) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForCenter_1ForIdx1  = valueHolderForCenter_1 as double
            valueSerializer.writeFloat64(valueHolderForCenter_1ForIdx1)
        } else if (valueHolderForCenter_1 instanceof arkui_component_units_Resource) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForCenter_1ForIdx2  = valueHolderForCenter_1 as arkui_component_units_Resource
            global_resource_Resource_serializer.write(valueSerializer, valueHolderForCenter_1ForIdx2)
        }
        const valueHolderForRadius  = value.radius
        if (valueHolderForRadius instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForRadiusForIdx0  = valueHolderForRadius as string
            valueSerializer.writeString(valueHolderForRadiusForIdx0)
        } else if (valueHolderForRadius instanceof double) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForRadiusForIdx1  = valueHolderForRadius as double
            valueSerializer.writeFloat64(valueHolderForRadiusForIdx1)
        } else if (valueHolderForRadius instanceof arkui_component_units_Resource) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForRadiusForIdx2  = valueHolderForRadius as arkui_component_units_Resource
            global_resource_Resource_serializer.write(valueSerializer, valueHolderForRadiusForIdx2)
        }
        const valueHolderForColors  = value.colors
        valueSerializer.writeInt32((valueHolderForColors.length).toInt())
        for (let valueHolderForColorsCounterI = 0; valueHolderForColorsCounterI < valueHolderForColors.length; valueHolderForColorsCounterI++) {
            const valueHolderForColorsTmpElement : [ ResourceColor, double ] = valueHolderForColors[valueHolderForColorsCounterI]
            const valueHolderForColorsTmpElement_0  = valueHolderForColorsTmpElement[0]
            if (valueHolderForColorsTmpElement_0 instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorsTmpElement_0ForIdx0  = valueHolderForColorsTmpElement_0 as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForColorsTmpElement_0ForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForColorsTmpElement_0 instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorsTmpElement_0ForIdx1  = valueHolderForColorsTmpElement_0 as int32
                valueSerializer.writeInt32(valueHolderForColorsTmpElement_0ForIdx1)
            } else if (valueHolderForColorsTmpElement_0 instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorsTmpElement_0ForIdx2  = valueHolderForColorsTmpElement_0 as string
                valueSerializer.writeString(valueHolderForColorsTmpElement_0ForIdx2)
            } else if (valueHolderForColorsTmpElement_0 instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorsTmpElement_0ForIdx3  = valueHolderForColorsTmpElement_0 as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForColorsTmpElement_0ForIdx3)
            }
            const valueHolderForColorsTmpElement_1  = valueHolderForColorsTmpElement[1]
            valueSerializer.writeFloat64(valueHolderForColorsTmpElement_1)
        }
        const valueHolderForRepeating  = value.repeating
        if (valueHolderForRepeating !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRepeatingTmpValue  = valueHolderForRepeating!
            valueSerializer.writeBoolean(valueHolderForRepeatingTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): RadialGradientOptions {
        let valueDeserializer : DeserializerBase = buffer
        const centerTmpBufValue0TempBufUnionSelector : int32 = valueDeserializer.readInt8()
        let centerTmpBufValue0TempBuf : string | double | arkui_component_units_Resource | undefined
        if (centerTmpBufValue0TempBufUnionSelector == (0).toByte()) {
            centerTmpBufValue0TempBuf = (valueDeserializer.readString() as string)
        } else if (centerTmpBufValue0TempBufUnionSelector == (1).toByte()) {
            centerTmpBufValue0TempBuf = valueDeserializer.readFloat64()
        } else if (centerTmpBufValue0TempBufUnionSelector == (2).toByte()) {
            centerTmpBufValue0TempBuf = global_resource_Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error('One of the branches for centerTmpBufValue0TempBuf has to be chosen through deserialisation.')
        }
        const centerTmpBufValue0 : Length = (centerTmpBufValue0TempBuf as string | double | arkui_component_units_Resource)
        const centerTmpBufValue1TempBufUnionSelector : int32 = valueDeserializer.readInt8()
        let centerTmpBufValue1TempBuf : string | double | arkui_component_units_Resource | undefined
        if (centerTmpBufValue1TempBufUnionSelector == (0).toByte()) {
            centerTmpBufValue1TempBuf = (valueDeserializer.readString() as string)
        } else if (centerTmpBufValue1TempBufUnionSelector == (1).toByte()) {
            centerTmpBufValue1TempBuf = valueDeserializer.readFloat64()
        } else if (centerTmpBufValue1TempBufUnionSelector == (2).toByte()) {
            centerTmpBufValue1TempBuf = global_resource_Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error('One of the branches for centerTmpBufValue1TempBuf has to be chosen through deserialisation.')
        }
        const centerTmpBufValue1 : Length = (centerTmpBufValue1TempBuf as string | double | arkui_component_units_Resource)
        const centerTmpResult : [ Length, Length ] = ([centerTmpBufValue0, centerTmpBufValue1] as [ Length, Length ])
        const radiusTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let radiusTmpBuf : string | double | arkui_component_units_Resource | undefined
        if (radiusTmpBufUnionSelector == (0).toByte()) {
            radiusTmpBuf = (valueDeserializer.readString() as string)
        } else if (radiusTmpBufUnionSelector == (1).toByte()) {
            radiusTmpBuf = valueDeserializer.readFloat64()
        } else if (radiusTmpBufUnionSelector == (2).toByte()) {
            radiusTmpBuf = global_resource_Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error('One of the branches for radiusTmpBuf has to be chosen through deserialisation.')
        }
        const radiusTmpResult : Length = (radiusTmpBuf as string | double | arkui_component_units_Resource)
        const colorsTmpBufLength : int32 = valueDeserializer.readInt32()
        let colorsTmpBuf : Array<[ ResourceColor, double ]> = new Array<[ ResourceColor, double ]>(colorsTmpBufLength)
        for (let colorsTmpBufBufCounterI = 0; colorsTmpBufBufCounterI < colorsTmpBufLength; colorsTmpBufBufCounterI++) {
            const colorsTmpBufTempBufValue0TempBufUnionSelector : int32 = valueDeserializer.readInt8()
            let colorsTmpBufTempBufValue0TempBuf : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (colorsTmpBufTempBufValue0TempBufUnionSelector == (0).toByte()) {
                colorsTmpBufTempBufValue0TempBuf = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (1).toByte()) {
                colorsTmpBufTempBufValue0TempBuf = valueDeserializer.readInt32()
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (2).toByte()) {
                colorsTmpBufTempBufValue0TempBuf = (valueDeserializer.readString() as string)
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (3).toByte()) {
                colorsTmpBufTempBufValue0TempBuf = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for colorsTmpBufTempBufValue0TempBuf has to be chosen through deserialisation.')
            }
            const colorsTmpBufTempBufValue0 : ResourceColor = (colorsTmpBufTempBufValue0TempBuf as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
            const colorsTmpBufTempBufValue1 : double = valueDeserializer.readFloat64()
            colorsTmpBuf[colorsTmpBufBufCounterI] = ([colorsTmpBufTempBufValue0, colorsTmpBufTempBufValue1] as [ ResourceColor, double ])
        }
        const colorsTmpResult : Array<[ ResourceColor, double ]> = colorsTmpBuf
        const repeatingTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let repeatingTmpBuf : boolean | undefined = undefined
        if ((repeatingTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            repeatingTmpBuf = valueDeserializer.readBoolean()
        }
        const repeatingTmpResult : boolean | undefined = repeatingTmpBuf
        let value : RadialGradientOptions = ({center: centerTmpResult, radius: radiusTmpResult, colors: colorsTmpResult, repeating: repeatingTmpResult} as RadialGradientOptions)
        return value
    }
}
export class Rectangle_serializer {
    public static write(buffer: SerializerBase, value: Rectangle): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForX  = value.x
        if (valueHolderForX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForXTmpValue  = valueHolderForX!
            if (valueHolderForXTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForXTmpValueForIdx0  = valueHolderForXTmpValue as string
                valueSerializer.writeString(valueHolderForXTmpValueForIdx0)
            } else if (valueHolderForXTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForXTmpValueForIdx1  = valueHolderForXTmpValue as double
                valueSerializer.writeFloat64(valueHolderForXTmpValueForIdx1)
            } else if (valueHolderForXTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForXTmpValueForIdx2  = valueHolderForXTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForXTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForY  = value.y
        if (valueHolderForY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForYTmpValue  = valueHolderForY!
            if (valueHolderForYTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForYTmpValueForIdx0  = valueHolderForYTmpValue as string
                valueSerializer.writeString(valueHolderForYTmpValueForIdx0)
            } else if (valueHolderForYTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForYTmpValueForIdx1  = valueHolderForYTmpValue as double
                valueSerializer.writeFloat64(valueHolderForYTmpValueForIdx1)
            } else if (valueHolderForYTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForYTmpValueForIdx2  = valueHolderForYTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForYTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForWidth  = value.width
        if (valueHolderForWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForWidthTmpValue  = valueHolderForWidth!
            if (valueHolderForWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForWidthTmpValueForIdx0  = valueHolderForWidthTmpValue as string
                valueSerializer.writeString(valueHolderForWidthTmpValueForIdx0)
            } else if (valueHolderForWidthTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForWidthTmpValueForIdx1  = valueHolderForWidthTmpValue as double
                valueSerializer.writeFloat64(valueHolderForWidthTmpValueForIdx1)
            } else if (valueHolderForWidthTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForWidthTmpValueForIdx2  = valueHolderForWidthTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHeight  = value.height
        if (valueHolderForHeight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHeightTmpValue  = valueHolderForHeight!
            if (valueHolderForHeightTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForHeightTmpValueForIdx0  = valueHolderForHeightTmpValue as string
                valueSerializer.writeString(valueHolderForHeightTmpValueForIdx0)
            } else if (valueHolderForHeightTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForHeightTmpValueForIdx1  = valueHolderForHeightTmpValue as double
                valueSerializer.writeFloat64(valueHolderForHeightTmpValueForIdx1)
            } else if (valueHolderForHeightTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForHeightTmpValueForIdx2  = valueHolderForHeightTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForHeightTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): Rectangle {
        let valueDeserializer : DeserializerBase = buffer
        const xTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let xTmpBuf : Length | undefined = undefined
        if ((xTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const xTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let xTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (xTmpBufOptUnionSelector == (0).toByte()) {
                xTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (xTmpBufOptUnionSelector == (1).toByte()) {
                xTmpBufOpt = valueDeserializer.readFloat64()
            } else if (xTmpBufOptUnionSelector == (2).toByte()) {
                xTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for xTmpBufOpt has to be chosen through deserialisation.')
            }
            xTmpBuf = (xTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const xTmpResult : Length | undefined = xTmpBuf
        const yTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let yTmpBuf : Length | undefined = undefined
        if ((yTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const yTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let yTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (yTmpBufOptUnionSelector == (0).toByte()) {
                yTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (yTmpBufOptUnionSelector == (1).toByte()) {
                yTmpBufOpt = valueDeserializer.readFloat64()
            } else if (yTmpBufOptUnionSelector == (2).toByte()) {
                yTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for yTmpBufOpt has to be chosen through deserialisation.')
            }
            yTmpBuf = (yTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const yTmpResult : Length | undefined = yTmpBuf
        const widthTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let widthTmpBuf : Length | undefined = undefined
        if ((widthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const widthTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let widthTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (widthTmpBufOptUnionSelector == (0).toByte()) {
                widthTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (widthTmpBufOptUnionSelector == (1).toByte()) {
                widthTmpBufOpt = valueDeserializer.readFloat64()
            } else if (widthTmpBufOptUnionSelector == (2).toByte()) {
                widthTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for widthTmpBufOpt has to be chosen through deserialisation.')
            }
            widthTmpBuf = (widthTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const widthTmpResult : Length | undefined = widthTmpBuf
        const heightTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let heightTmpBuf : Length | undefined = undefined
        if ((heightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const heightTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let heightTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (heightTmpBufOptUnionSelector == (0).toByte()) {
                heightTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (heightTmpBufOptUnionSelector == (1).toByte()) {
                heightTmpBufOpt = valueDeserializer.readFloat64()
            } else if (heightTmpBufOptUnionSelector == (2).toByte()) {
                heightTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for heightTmpBufOpt has to be chosen through deserialisation.')
            }
            heightTmpBuf = (heightTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const heightTmpResult : Length | undefined = heightTmpBuf
        let value : Rectangle = ({x: xTmpResult, y: yTmpResult, width: widthTmpResult, height: heightTmpResult} as Rectangle)
        return value
    }
}
export class SweepGradientOptions_serializer {
    public static write(buffer: SerializerBase, value: SweepGradientOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForCenter  = value.center
        const valueHolderForCenter_0  = valueHolderForCenter[0]
        if (valueHolderForCenter_0 instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForCenter_0ForIdx0  = valueHolderForCenter_0 as string
            valueSerializer.writeString(valueHolderForCenter_0ForIdx0)
        } else if (valueHolderForCenter_0 instanceof double) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForCenter_0ForIdx1  = valueHolderForCenter_0 as double
            valueSerializer.writeFloat64(valueHolderForCenter_0ForIdx1)
        } else if (valueHolderForCenter_0 instanceof arkui_component_units_Resource) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForCenter_0ForIdx2  = valueHolderForCenter_0 as arkui_component_units_Resource
            global_resource_Resource_serializer.write(valueSerializer, valueHolderForCenter_0ForIdx2)
        }
        const valueHolderForCenter_1  = valueHolderForCenter[1]
        if (valueHolderForCenter_1 instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForCenter_1ForIdx0  = valueHolderForCenter_1 as string
            valueSerializer.writeString(valueHolderForCenter_1ForIdx0)
        } else if (valueHolderForCenter_1 instanceof double) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForCenter_1ForIdx1  = valueHolderForCenter_1 as double
            valueSerializer.writeFloat64(valueHolderForCenter_1ForIdx1)
        } else if (valueHolderForCenter_1 instanceof arkui_component_units_Resource) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForCenter_1ForIdx2  = valueHolderForCenter_1 as arkui_component_units_Resource
            global_resource_Resource_serializer.write(valueSerializer, valueHolderForCenter_1ForIdx2)
        }
        const valueHolderForStart  = value.start
        if (valueHolderForStart !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForStartTmpValue  = valueHolderForStart!
            if (valueHolderForStartTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForStartTmpValueForIdx0  = valueHolderForStartTmpValue as double
                valueSerializer.writeFloat64(valueHolderForStartTmpValueForIdx0)
            } else if (valueHolderForStartTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForStartTmpValueForIdx1  = valueHolderForStartTmpValue as string
                valueSerializer.writeString(valueHolderForStartTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnd  = value.end
        if (valueHolderForEnd !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEndTmpValue  = valueHolderForEnd!
            if (valueHolderForEndTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForEndTmpValueForIdx0  = valueHolderForEndTmpValue as double
                valueSerializer.writeFloat64(valueHolderForEndTmpValueForIdx0)
            } else if (valueHolderForEndTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForEndTmpValueForIdx1  = valueHolderForEndTmpValue as string
                valueSerializer.writeString(valueHolderForEndTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRotation  = value.rotation
        if (valueHolderForRotation !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRotationTmpValue  = valueHolderForRotation!
            if (valueHolderForRotationTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForRotationTmpValueForIdx0  = valueHolderForRotationTmpValue as double
                valueSerializer.writeFloat64(valueHolderForRotationTmpValueForIdx0)
            } else if (valueHolderForRotationTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForRotationTmpValueForIdx1  = valueHolderForRotationTmpValue as string
                valueSerializer.writeString(valueHolderForRotationTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForColors  = value.colors
        valueSerializer.writeInt32((valueHolderForColors.length).toInt())
        for (let valueHolderForColorsCounterI = 0; valueHolderForColorsCounterI < valueHolderForColors.length; valueHolderForColorsCounterI++) {
            const valueHolderForColorsTmpElement : [ ResourceColor, double ] = valueHolderForColors[valueHolderForColorsCounterI]
            const valueHolderForColorsTmpElement_0  = valueHolderForColorsTmpElement[0]
            if (valueHolderForColorsTmpElement_0 instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorsTmpElement_0ForIdx0  = valueHolderForColorsTmpElement_0 as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForColorsTmpElement_0ForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForColorsTmpElement_0 instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorsTmpElement_0ForIdx1  = valueHolderForColorsTmpElement_0 as int32
                valueSerializer.writeInt32(valueHolderForColorsTmpElement_0ForIdx1)
            } else if (valueHolderForColorsTmpElement_0 instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorsTmpElement_0ForIdx2  = valueHolderForColorsTmpElement_0 as string
                valueSerializer.writeString(valueHolderForColorsTmpElement_0ForIdx2)
            } else if (valueHolderForColorsTmpElement_0 instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorsTmpElement_0ForIdx3  = valueHolderForColorsTmpElement_0 as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForColorsTmpElement_0ForIdx3)
            }
            const valueHolderForColorsTmpElement_1  = valueHolderForColorsTmpElement[1]
            valueSerializer.writeFloat64(valueHolderForColorsTmpElement_1)
        }
        const valueHolderForRepeating  = value.repeating
        if (valueHolderForRepeating !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRepeatingTmpValue  = valueHolderForRepeating!
            valueSerializer.writeBoolean(valueHolderForRepeatingTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): SweepGradientOptions {
        let valueDeserializer : DeserializerBase = buffer
        const centerTmpBufValue0TempBufUnionSelector : int32 = valueDeserializer.readInt8()
        let centerTmpBufValue0TempBuf : string | double | arkui_component_units_Resource | undefined
        if (centerTmpBufValue0TempBufUnionSelector == (0).toByte()) {
            centerTmpBufValue0TempBuf = (valueDeserializer.readString() as string)
        } else if (centerTmpBufValue0TempBufUnionSelector == (1).toByte()) {
            centerTmpBufValue0TempBuf = valueDeserializer.readFloat64()
        } else if (centerTmpBufValue0TempBufUnionSelector == (2).toByte()) {
            centerTmpBufValue0TempBuf = global_resource_Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error('One of the branches for centerTmpBufValue0TempBuf has to be chosen through deserialisation.')
        }
        const centerTmpBufValue0 : Length = (centerTmpBufValue0TempBuf as string | double | arkui_component_units_Resource)
        const centerTmpBufValue1TempBufUnionSelector : int32 = valueDeserializer.readInt8()
        let centerTmpBufValue1TempBuf : string | double | arkui_component_units_Resource | undefined
        if (centerTmpBufValue1TempBufUnionSelector == (0).toByte()) {
            centerTmpBufValue1TempBuf = (valueDeserializer.readString() as string)
        } else if (centerTmpBufValue1TempBufUnionSelector == (1).toByte()) {
            centerTmpBufValue1TempBuf = valueDeserializer.readFloat64()
        } else if (centerTmpBufValue1TempBufUnionSelector == (2).toByte()) {
            centerTmpBufValue1TempBuf = global_resource_Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error('One of the branches for centerTmpBufValue1TempBuf has to be chosen through deserialisation.')
        }
        const centerTmpBufValue1 : Length = (centerTmpBufValue1TempBuf as string | double | arkui_component_units_Resource)
        const centerTmpResult : [ Length, Length ] = ([centerTmpBufValue0, centerTmpBufValue1] as [ Length, Length ])
        const startTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let startTmpBuf : double | string | undefined = undefined
        if ((startTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const startTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let startTmpBufOpt : double | string | undefined
            if (startTmpBufOptUnionSelector == (0).toByte()) {
                startTmpBufOpt = valueDeserializer.readFloat64()
            } else if (startTmpBufOptUnionSelector == (1).toByte()) {
                startTmpBufOpt = (valueDeserializer.readString() as string)
            } else {
                throw new Error('One of the branches for startTmpBufOpt has to be chosen through deserialisation.')
            }
            startTmpBuf = (startTmpBufOpt as double | string)
        }
        const startTmpResult : double | string | undefined = startTmpBuf
        const endTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let endTmpBuf : double | string | undefined = undefined
        if ((endTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const endTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let endTmpBufOpt : double | string | undefined
            if (endTmpBufOptUnionSelector == (0).toByte()) {
                endTmpBufOpt = valueDeserializer.readFloat64()
            } else if (endTmpBufOptUnionSelector == (1).toByte()) {
                endTmpBufOpt = (valueDeserializer.readString() as string)
            } else {
                throw new Error('One of the branches for endTmpBufOpt has to be chosen through deserialisation.')
            }
            endTmpBuf = (endTmpBufOpt as double | string)
        }
        const endTmpResult : double | string | undefined = endTmpBuf
        const rotationTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let rotationTmpBuf : double | string | undefined = undefined
        if ((rotationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const rotationTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let rotationTmpBufOpt : double | string | undefined
            if (rotationTmpBufOptUnionSelector == (0).toByte()) {
                rotationTmpBufOpt = valueDeserializer.readFloat64()
            } else if (rotationTmpBufOptUnionSelector == (1).toByte()) {
                rotationTmpBufOpt = (valueDeserializer.readString() as string)
            } else {
                throw new Error('One of the branches for rotationTmpBufOpt has to be chosen through deserialisation.')
            }
            rotationTmpBuf = (rotationTmpBufOpt as double | string)
        }
        const rotationTmpResult : double | string | undefined = rotationTmpBuf
        const colorsTmpBufLength : int32 = valueDeserializer.readInt32()
        let colorsTmpBuf : Array<[ ResourceColor, double ]> = new Array<[ ResourceColor, double ]>(colorsTmpBufLength)
        for (let colorsTmpBufBufCounterI = 0; colorsTmpBufBufCounterI < colorsTmpBufLength; colorsTmpBufBufCounterI++) {
            const colorsTmpBufTempBufValue0TempBufUnionSelector : int32 = valueDeserializer.readInt8()
            let colorsTmpBufTempBufValue0TempBuf : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (colorsTmpBufTempBufValue0TempBufUnionSelector == (0).toByte()) {
                colorsTmpBufTempBufValue0TempBuf = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (1).toByte()) {
                colorsTmpBufTempBufValue0TempBuf = valueDeserializer.readInt32()
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (2).toByte()) {
                colorsTmpBufTempBufValue0TempBuf = (valueDeserializer.readString() as string)
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (3).toByte()) {
                colorsTmpBufTempBufValue0TempBuf = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for colorsTmpBufTempBufValue0TempBuf has to be chosen through deserialisation.')
            }
            const colorsTmpBufTempBufValue0 : ResourceColor = (colorsTmpBufTempBufValue0TempBuf as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
            const colorsTmpBufTempBufValue1 : double = valueDeserializer.readFloat64()
            colorsTmpBuf[colorsTmpBufBufCounterI] = ([colorsTmpBufTempBufValue0, colorsTmpBufTempBufValue1] as [ ResourceColor, double ])
        }
        const colorsTmpResult : Array<[ ResourceColor, double ]> = colorsTmpBuf
        const repeatingTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let repeatingTmpBuf : boolean | undefined = undefined
        if ((repeatingTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            repeatingTmpBuf = valueDeserializer.readBoolean()
        }
        const repeatingTmpResult : boolean | undefined = repeatingTmpBuf
        let value : SweepGradientOptions = ({center: centerTmpResult, start: startTmpResult, end: endTmpResult, rotation: rotationTmpResult, colors: colorsTmpResult, repeating: repeatingTmpResult} as SweepGradientOptions)
        return value
    }
}
export class TipsOptions_serializer {
    public static write(buffer: SerializerBase, value: TipsOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAppearingTime  = value.appearingTime
        if (valueHolderForAppearingTime !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAppearingTimeTmpValue  = valueHolderForAppearingTime!
            valueSerializer.writeInt32(valueHolderForAppearingTimeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDisappearingTime  = value.disappearingTime
        if (valueHolderForDisappearingTime !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDisappearingTimeTmpValue  = valueHolderForDisappearingTime!
            valueSerializer.writeInt32(valueHolderForDisappearingTimeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAppearingTimeWithContinuousOperation  = value.appearingTimeWithContinuousOperation
        if (valueHolderForAppearingTimeWithContinuousOperation !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAppearingTimeWithContinuousOperationTmpValue  = valueHolderForAppearingTimeWithContinuousOperation!
            valueSerializer.writeInt32(valueHolderForAppearingTimeWithContinuousOperationTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDisappearingTimeWithContinuousOperation  = value.disappearingTimeWithContinuousOperation
        if (valueHolderForDisappearingTimeWithContinuousOperation !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDisappearingTimeWithContinuousOperationTmpValue  = valueHolderForDisappearingTimeWithContinuousOperation!
            valueSerializer.writeInt32(valueHolderForDisappearingTimeWithContinuousOperationTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableArrow  = value.enableArrow
        if (valueHolderForEnableArrow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableArrowTmpValue  = valueHolderForEnableArrow!
            valueSerializer.writeBoolean(valueHolderForEnableArrowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowPointPosition  = value.arrowPointPosition
        if (valueHolderForArrowPointPosition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowPointPositionTmpValue  = (valueHolderForArrowPointPosition as ArrowPointPosition)
            valueSerializer.writeInt32(valueHolderForArrowPointPositionTmpValue.getOrdinal())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowWidth  = value.arrowWidth
        if (valueHolderForArrowWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowWidthTmpValue  = valueHolderForArrowWidth!
            if (valueHolderForArrowWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowWidthTmpValueForIdx0  = valueHolderForArrowWidthTmpValue as string
                valueSerializer.writeString(valueHolderForArrowWidthTmpValueForIdx0)
            } else if (valueHolderForArrowWidthTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowWidthTmpValueForIdx1  = valueHolderForArrowWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowWidthTmpValueForIdx1)
            } else if (valueHolderForArrowWidthTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowWidthTmpValueForIdx2  = valueHolderForArrowWidthTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForArrowWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowHeight  = value.arrowHeight
        if (valueHolderForArrowHeight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowHeightTmpValue  = valueHolderForArrowHeight!
            if (valueHolderForArrowHeightTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowHeightTmpValueForIdx0  = valueHolderForArrowHeightTmpValue as string
                valueSerializer.writeString(valueHolderForArrowHeightTmpValueForIdx0)
            } else if (valueHolderForArrowHeightTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowHeightTmpValueForIdx1  = valueHolderForArrowHeightTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowHeightTmpValueForIdx1)
            } else if (valueHolderForArrowHeightTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowHeightTmpValueForIdx2  = valueHolderForArrowHeightTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForArrowHeightTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): TipsOptions {
        let valueDeserializer : DeserializerBase = buffer
        const appearingTimeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let appearingTimeTmpBuf : int32 | undefined = undefined
        if ((appearingTimeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            appearingTimeTmpBuf = valueDeserializer.readInt32()
        }
        const appearingTimeTmpResult : int32 | undefined = appearingTimeTmpBuf
        const disappearingTimeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let disappearingTimeTmpBuf : int32 | undefined = undefined
        if ((disappearingTimeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            disappearingTimeTmpBuf = valueDeserializer.readInt32()
        }
        const disappearingTimeTmpResult : int32 | undefined = disappearingTimeTmpBuf
        const appearingTimeWithContinuousOperationTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let appearingTimeWithContinuousOperationTmpBuf : int32 | undefined = undefined
        if ((appearingTimeWithContinuousOperationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            appearingTimeWithContinuousOperationTmpBuf = valueDeserializer.readInt32()
        }
        const appearingTimeWithContinuousOperationTmpResult : int32 | undefined = appearingTimeWithContinuousOperationTmpBuf
        const disappearingTimeWithContinuousOperationTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let disappearingTimeWithContinuousOperationTmpBuf : int32 | undefined = undefined
        if ((disappearingTimeWithContinuousOperationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            disappearingTimeWithContinuousOperationTmpBuf = valueDeserializer.readInt32()
        }
        const disappearingTimeWithContinuousOperationTmpResult : int32 | undefined = disappearingTimeWithContinuousOperationTmpBuf
        const enableArrowTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let enableArrowTmpBuf : boolean | undefined = undefined
        if ((enableArrowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableArrowTmpBuf = valueDeserializer.readBoolean()
        }
        const enableArrowTmpResult : boolean | undefined = enableArrowTmpBuf
        const arrowPointPositionTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let arrowPointPositionTmpBuf : ArrowPointPosition | undefined = undefined
        if ((arrowPointPositionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            arrowPointPositionTmpBuf = ArrowPointPosition.values()[valueDeserializer.readInt32()]
        }
        const arrowPointPositionTmpResult : ArrowPointPosition | undefined = arrowPointPositionTmpBuf
        const arrowWidthTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let arrowWidthTmpBuf : Dimension | undefined = undefined
        if ((arrowWidthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowWidthTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let arrowWidthTmpBufOpt : string | number | global_resource_Resource | undefined
            if (arrowWidthTmpBufOptUnionSelector == (0).toByte()) {
                arrowWidthTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (arrowWidthTmpBufOptUnionSelector == (1).toByte()) {
                arrowWidthTmpBufOpt = (valueDeserializer.readNumber() as number)
            } else if (arrowWidthTmpBufOptUnionSelector == (2).toByte()) {
                arrowWidthTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for arrowWidthTmpBufOpt has to be chosen through deserialisation.')
            }
            arrowWidthTmpBuf = (arrowWidthTmpBufOpt as string | number | global_resource_Resource)
        }
        const arrowWidthTmpResult : Dimension | undefined = arrowWidthTmpBuf
        const arrowHeightTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let arrowHeightTmpBuf : Dimension | undefined = undefined
        if ((arrowHeightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowHeightTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let arrowHeightTmpBufOpt : string | number | global_resource_Resource | undefined
            if (arrowHeightTmpBufOptUnionSelector == (0).toByte()) {
                arrowHeightTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (arrowHeightTmpBufOptUnionSelector == (1).toByte()) {
                arrowHeightTmpBufOpt = (valueDeserializer.readNumber() as number)
            } else if (arrowHeightTmpBufOptUnionSelector == (2).toByte()) {
                arrowHeightTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for arrowHeightTmpBufOpt has to be chosen through deserialisation.')
            }
            arrowHeightTmpBuf = (arrowHeightTmpBufOpt as string | number | global_resource_Resource)
        }
        const arrowHeightTmpResult : Dimension | undefined = arrowHeightTmpBuf
        let value : TipsOptions = ({appearingTime: appearingTimeTmpResult, disappearingTime: disappearingTimeTmpResult, appearingTimeWithContinuousOperation: appearingTimeWithContinuousOperationTmpResult, disappearingTimeWithContinuousOperation: disappearingTimeWithContinuousOperationTmpResult, enableArrow: enableArrowTmpResult, arrowPointPosition: arrowPointPositionTmpResult, arrowWidth: arrowWidthTmpResult, arrowHeight: arrowHeightTmpResult} as TipsOptions)
        return value
    }
}
export class BorderImageOption_serializer {
    public static write(buffer: SerializerBase, value: BorderImageOption): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForSlice  = value.slice
        if (valueHolderForSlice !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForSliceTmpValue  = valueHolderForSlice!
            if (valueHolderForSliceTmpValue instanceof Length) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForSliceTmpValueForIdx0  = valueHolderForSliceTmpValue as Length
                if (valueHolderForSliceTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForSliceTmpValueForIdx0ForIdx0  = valueHolderForSliceTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForSliceTmpValueForIdx0ForIdx0)
                } else if (valueHolderForSliceTmpValueForIdx0 instanceof double) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForSliceTmpValueForIdx0ForIdx1  = valueHolderForSliceTmpValueForIdx0 as double
                    valueSerializer.writeFloat64(valueHolderForSliceTmpValueForIdx0ForIdx1)
                } else if (valueHolderForSliceTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForSliceTmpValueForIdx0ForIdx2  = valueHolderForSliceTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(valueSerializer, valueHolderForSliceTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForSliceTmpValue instanceof EdgeWidths) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForSliceTmpValueForIdx1  = valueHolderForSliceTmpValue as EdgeWidths
                EdgeWidths_serializer.write(valueSerializer, valueHolderForSliceTmpValueForIdx1)
            } else if (valueHolderForSliceTmpValue instanceof LocalizedEdgeWidths) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForSliceTmpValueForIdx2  = valueHolderForSliceTmpValue as LocalizedEdgeWidths
                LocalizedEdgeWidths_serializer.write(valueSerializer, valueHolderForSliceTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRepeat  = value.repeat
        if (valueHolderForRepeat !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRepeatTmpValue  = (valueHolderForRepeat as RepeatMode)
            valueSerializer.writeInt32(valueHolderForRepeatTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForSource  = value.source
        if (valueHolderForSource !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForSourceTmpValue  = valueHolderForSource!
            if (valueHolderForSourceTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForSourceTmpValueForIdx0  = valueHolderForSourceTmpValue as string
                valueSerializer.writeString(valueHolderForSourceTmpValueForIdx0)
            } else if (valueHolderForSourceTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForSourceTmpValueForIdx1  = valueHolderForSourceTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForSourceTmpValueForIdx1)
            } else if (valueHolderForSourceTmpValue instanceof LinearGradientOptions) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForSourceTmpValueForIdx2  = valueHolderForSourceTmpValue as LinearGradientOptions
                LinearGradientOptions_serializer.write(valueSerializer, valueHolderForSourceTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForWidth  = value.width
        if (valueHolderForWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForWidthTmpValue  = valueHolderForWidth!
            if (valueHolderForWidthTmpValue instanceof Length) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForWidthTmpValueForIdx0  = valueHolderForWidthTmpValue as Length
                if (valueHolderForWidthTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForWidthTmpValueForIdx0ForIdx0  = valueHolderForWidthTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForWidthTmpValueForIdx0ForIdx0)
                } else if (valueHolderForWidthTmpValueForIdx0 instanceof double) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForWidthTmpValueForIdx0ForIdx1  = valueHolderForWidthTmpValueForIdx0 as double
                    valueSerializer.writeFloat64(valueHolderForWidthTmpValueForIdx0ForIdx1)
                } else if (valueHolderForWidthTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForWidthTmpValueForIdx0ForIdx2  = valueHolderForWidthTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(valueSerializer, valueHolderForWidthTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForWidthTmpValue instanceof EdgeWidths) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForWidthTmpValueForIdx1  = valueHolderForWidthTmpValue as EdgeWidths
                EdgeWidths_serializer.write(valueSerializer, valueHolderForWidthTmpValueForIdx1)
            } else if (valueHolderForWidthTmpValue instanceof LocalizedEdgeWidths) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForWidthTmpValueForIdx2  = valueHolderForWidthTmpValue as LocalizedEdgeWidths
                LocalizedEdgeWidths_serializer.write(valueSerializer, valueHolderForWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOutset  = value.outset
        if (valueHolderForOutset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOutsetTmpValue  = valueHolderForOutset!
            if (valueHolderForOutsetTmpValue instanceof Length) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOutsetTmpValueForIdx0  = valueHolderForOutsetTmpValue as Length
                if (valueHolderForOutsetTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForOutsetTmpValueForIdx0ForIdx0  = valueHolderForOutsetTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForOutsetTmpValueForIdx0ForIdx0)
                } else if (valueHolderForOutsetTmpValueForIdx0 instanceof double) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForOutsetTmpValueForIdx0ForIdx1  = valueHolderForOutsetTmpValueForIdx0 as double
                    valueSerializer.writeFloat64(valueHolderForOutsetTmpValueForIdx0ForIdx1)
                } else if (valueHolderForOutsetTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForOutsetTmpValueForIdx0ForIdx2  = valueHolderForOutsetTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(valueSerializer, valueHolderForOutsetTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForOutsetTmpValue instanceof EdgeWidths) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOutsetTmpValueForIdx1  = valueHolderForOutsetTmpValue as EdgeWidths
                EdgeWidths_serializer.write(valueSerializer, valueHolderForOutsetTmpValueForIdx1)
            } else if (valueHolderForOutsetTmpValue instanceof LocalizedEdgeWidths) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForOutsetTmpValueForIdx2  = valueHolderForOutsetTmpValue as LocalizedEdgeWidths
                LocalizedEdgeWidths_serializer.write(valueSerializer, valueHolderForOutsetTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFill  = value.fill
        if (valueHolderForFill !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFillTmpValue  = valueHolderForFill!
            valueSerializer.writeBoolean(valueHolderForFillTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): BorderImageOption {
        let valueDeserializer : DeserializerBase = buffer
        const sliceTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let sliceTmpBuf : Length | EdgeWidths | LocalizedEdgeWidths | undefined = undefined
        if ((sliceTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const sliceTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let sliceTmpBufOpt : Length | EdgeWidths | LocalizedEdgeWidths | undefined
            if (sliceTmpBufOptUnionSelector == (0).toByte()) {
                const sliceTmpBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                let sliceTmpBufOptBufU : string | double | arkui_component_units_Resource | undefined
                if (sliceTmpBufOptBufUUnionSelector == (0).toByte()) {
                    sliceTmpBufOptBufU = (valueDeserializer.readString() as string)
                } else if (sliceTmpBufOptBufUUnionSelector == (1).toByte()) {
                    sliceTmpBufOptBufU = valueDeserializer.readFloat64()
                } else if (sliceTmpBufOptBufUUnionSelector == (2).toByte()) {
                    sliceTmpBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error('One of the branches for sliceTmpBufOptBufU has to be chosen through deserialisation.')
                }
                sliceTmpBufOpt = (sliceTmpBufOptBufU as string | double | arkui_component_units_Resource)
            } else if (sliceTmpBufOptUnionSelector == (1).toByte()) {
                sliceTmpBufOpt = EdgeWidths_serializer.read(valueDeserializer)
            } else if (sliceTmpBufOptUnionSelector == (2).toByte()) {
                sliceTmpBufOpt = LocalizedEdgeWidths_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for sliceTmpBufOpt has to be chosen through deserialisation.')
            }
            sliceTmpBuf = (sliceTmpBufOpt as Length | EdgeWidths | LocalizedEdgeWidths)
        }
        const sliceTmpResult : Length | EdgeWidths | LocalizedEdgeWidths | undefined = sliceTmpBuf
        const repeatTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let repeatTmpBuf : RepeatMode | undefined = undefined
        if ((repeatTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            repeatTmpBuf = RepeatMode.fromValue(valueDeserializer.readInt32())
        }
        const repeatTmpResult : RepeatMode | undefined = repeatTmpBuf
        const sourceTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let sourceTmpBuf : string | global_resource_Resource | LinearGradientOptions | undefined = undefined
        if ((sourceTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const sourceTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let sourceTmpBufOpt : string | global_resource_Resource | LinearGradientOptions | undefined
            if (sourceTmpBufOptUnionSelector == (0).toByte()) {
                sourceTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (sourceTmpBufOptUnionSelector == (1).toByte()) {
                sourceTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else if (sourceTmpBufOptUnionSelector == (2).toByte()) {
                sourceTmpBufOpt = LinearGradientOptions_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for sourceTmpBufOpt has to be chosen through deserialisation.')
            }
            sourceTmpBuf = (sourceTmpBufOpt as string | global_resource_Resource | LinearGradientOptions)
        }
        const sourceTmpResult : string | global_resource_Resource | LinearGradientOptions | undefined = sourceTmpBuf
        const widthTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let widthTmpBuf : Length | EdgeWidths | LocalizedEdgeWidths | undefined = undefined
        if ((widthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const widthTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let widthTmpBufOpt : Length | EdgeWidths | LocalizedEdgeWidths | undefined
            if (widthTmpBufOptUnionSelector == (0).toByte()) {
                const widthTmpBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                let widthTmpBufOptBufU : string | double | arkui_component_units_Resource | undefined
                if (widthTmpBufOptBufUUnionSelector == (0).toByte()) {
                    widthTmpBufOptBufU = (valueDeserializer.readString() as string)
                } else if (widthTmpBufOptBufUUnionSelector == (1).toByte()) {
                    widthTmpBufOptBufU = valueDeserializer.readFloat64()
                } else if (widthTmpBufOptBufUUnionSelector == (2).toByte()) {
                    widthTmpBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error('One of the branches for widthTmpBufOptBufU has to be chosen through deserialisation.')
                }
                widthTmpBufOpt = (widthTmpBufOptBufU as string | double | arkui_component_units_Resource)
            } else if (widthTmpBufOptUnionSelector == (1).toByte()) {
                widthTmpBufOpt = EdgeWidths_serializer.read(valueDeserializer)
            } else if (widthTmpBufOptUnionSelector == (2).toByte()) {
                widthTmpBufOpt = LocalizedEdgeWidths_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for widthTmpBufOpt has to be chosen through deserialisation.')
            }
            widthTmpBuf = (widthTmpBufOpt as Length | EdgeWidths | LocalizedEdgeWidths)
        }
        const widthTmpResult : Length | EdgeWidths | LocalizedEdgeWidths | undefined = widthTmpBuf
        const outsetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let outsetTmpBuf : Length | EdgeWidths | LocalizedEdgeWidths | undefined = undefined
        if ((outsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const outsetTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let outsetTmpBufOpt : Length | EdgeWidths | LocalizedEdgeWidths | undefined
            if (outsetTmpBufOptUnionSelector == (0).toByte()) {
                const outsetTmpBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                let outsetTmpBufOptBufU : string | double | arkui_component_units_Resource | undefined
                if (outsetTmpBufOptBufUUnionSelector == (0).toByte()) {
                    outsetTmpBufOptBufU = (valueDeserializer.readString() as string)
                } else if (outsetTmpBufOptBufUUnionSelector == (1).toByte()) {
                    outsetTmpBufOptBufU = valueDeserializer.readFloat64()
                } else if (outsetTmpBufOptBufUUnionSelector == (2).toByte()) {
                    outsetTmpBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error('One of the branches for outsetTmpBufOptBufU has to be chosen through deserialisation.')
                }
                outsetTmpBufOpt = (outsetTmpBufOptBufU as string | double | arkui_component_units_Resource)
            } else if (outsetTmpBufOptUnionSelector == (1).toByte()) {
                outsetTmpBufOpt = EdgeWidths_serializer.read(valueDeserializer)
            } else if (outsetTmpBufOptUnionSelector == (2).toByte()) {
                outsetTmpBufOpt = LocalizedEdgeWidths_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for outsetTmpBufOpt has to be chosen through deserialisation.')
            }
            outsetTmpBuf = (outsetTmpBufOpt as Length | EdgeWidths | LocalizedEdgeWidths)
        }
        const outsetTmpResult : Length | EdgeWidths | LocalizedEdgeWidths | undefined = outsetTmpBuf
        const fillTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let fillTmpBuf : boolean | undefined = undefined
        if ((fillTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            fillTmpBuf = valueDeserializer.readBoolean()
        }
        const fillTmpResult : boolean | undefined = fillTmpBuf
        let value : BorderImageOption = ({slice: sliceTmpResult, repeat: repeatTmpResult, source: sourceTmpResult, width: widthTmpResult, outset: outsetTmpResult, fill: fillTmpResult} as BorderImageOption)
        return value
    }
}
export class ContextMenuOptions_serializer {
    public static write(buffer: SerializerBase, value: ContextMenuOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForOffset  = value.offset
        if (valueHolderForOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetTmpValue  = valueHolderForOffset!
            Position_serializer.write(valueSerializer, valueHolderForOffsetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPlacement  = value.placement
        if (valueHolderForPlacement !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPlacementTmpValue  = (valueHolderForPlacement as Placement)
            valueSerializer.writeInt32(valueHolderForPlacementTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableArrow  = value.enableArrow
        if (valueHolderForEnableArrow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableArrowTmpValue  = valueHolderForEnableArrow!
            valueSerializer.writeBoolean(valueHolderForEnableArrowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowOffset  = value.arrowOffset
        if (valueHolderForArrowOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowOffsetTmpValue  = valueHolderForArrowOffset!
            if (valueHolderForArrowOffsetTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx0  = valueHolderForArrowOffsetTmpValue as string
                valueSerializer.writeString(valueHolderForArrowOffsetTmpValueForIdx0)
            } else if (valueHolderForArrowOffsetTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx1  = valueHolderForArrowOffsetTmpValue as double
                valueSerializer.writeFloat64(valueHolderForArrowOffsetTmpValueForIdx1)
            } else if (valueHolderForArrowOffsetTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx2  = valueHolderForArrowOffsetTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForArrowOffsetTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPreview  = value.preview
        if (valueHolderForPreview !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPreviewTmpValue  = valueHolderForPreview!
            if (valueHolderForPreviewTmpValue instanceof MenuPreviewMode) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForPreviewTmpValueForIdx0  = valueHolderForPreviewTmpValue as MenuPreviewMode
                valueSerializer.writeInt32(valueHolderForPreviewTmpValueForIdx0.valueOf())
            } else if (valueHolderForPreviewTmpValue instanceof CustomBuilder) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForPreviewTmpValueForIdx1  = valueHolderForPreviewTmpValue as CustomBuilder
                valueSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(valueHolderForPreviewTmpValueForIdx1))
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPreviewBorderRadius  = value.previewBorderRadius
        if (valueHolderForPreviewBorderRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPreviewBorderRadiusTmpValue  = valueHolderForPreviewBorderRadius!
            if (valueHolderForPreviewBorderRadiusTmpValue instanceof Length) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForPreviewBorderRadiusTmpValueForIdx0  = valueHolderForPreviewBorderRadiusTmpValue as Length
                if (valueHolderForPreviewBorderRadiusTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx0  = valueHolderForPreviewBorderRadiusTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx0)
                } else if (valueHolderForPreviewBorderRadiusTmpValueForIdx0 instanceof double) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx1  = valueHolderForPreviewBorderRadiusTmpValueForIdx0 as double
                    valueSerializer.writeFloat64(valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx1)
                } else if (valueHolderForPreviewBorderRadiusTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx2  = valueHolderForPreviewBorderRadiusTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(valueSerializer, valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForPreviewBorderRadiusTmpValue instanceof BorderRadiuses) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForPreviewBorderRadiusTmpValueForIdx1  = valueHolderForPreviewBorderRadiusTmpValue as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, valueHolderForPreviewBorderRadiusTmpValueForIdx1)
            } else if (valueHolderForPreviewBorderRadiusTmpValue instanceof LocalizedBorderRadiuses) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForPreviewBorderRadiusTmpValueForIdx2  = valueHolderForPreviewBorderRadiusTmpValue as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(valueSerializer, valueHolderForPreviewBorderRadiusTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBorderRadius  = value.borderRadius
        if (valueHolderForBorderRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBorderRadiusTmpValue  = valueHolderForBorderRadius!
            if (valueHolderForBorderRadiusTmpValue instanceof Length) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBorderRadiusTmpValueForIdx0  = valueHolderForBorderRadiusTmpValue as Length
                if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx0  = valueHolderForBorderRadiusTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForBorderRadiusTmpValueForIdx0ForIdx0)
                } else if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof double) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx1  = valueHolderForBorderRadiusTmpValueForIdx0 as double
                    valueSerializer.writeFloat64(valueHolderForBorderRadiusTmpValueForIdx0ForIdx1)
                } else if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx2  = valueHolderForBorderRadiusTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(valueSerializer, valueHolderForBorderRadiusTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForBorderRadiusTmpValue instanceof BorderRadiuses) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBorderRadiusTmpValueForIdx1  = valueHolderForBorderRadiusTmpValue as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, valueHolderForBorderRadiusTmpValueForIdx1)
            } else if (valueHolderForBorderRadiusTmpValue instanceof LocalizedBorderRadiuses) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBorderRadiusTmpValueForIdx2  = valueHolderForBorderRadiusTmpValue as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(valueSerializer, valueHolderForBorderRadiusTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnAppear  = value.onAppear
        if (valueHolderForOnAppear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnAppearTmpValue  = valueHolderForOnAppear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnAppearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnDisappear  = value.onDisappear
        if (valueHolderForOnDisappear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnDisappearTmpValue  = valueHolderForOnDisappear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnDisappearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAboutToAppear  = value.aboutToAppear
        if (valueHolderForAboutToAppear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAboutToAppearTmpValue  = valueHolderForAboutToAppear!
            valueSerializer.holdAndWriteCallback(valueHolderForAboutToAppearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAboutToDisappear  = value.aboutToDisappear
        if (valueHolderForAboutToDisappear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAboutToDisappearTmpValue  = valueHolderForAboutToDisappear!
            valueSerializer.holdAndWriteCallback(valueHolderForAboutToDisappearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForLayoutRegionMargin  = value.layoutRegionMargin
        if (valueHolderForLayoutRegionMargin !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForLayoutRegionMarginTmpValue  = valueHolderForLayoutRegionMargin!
            Padding_serializer.write(valueSerializer, valueHolderForLayoutRegionMarginTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPreviewAnimationOptions  = value.previewAnimationOptions
        if (valueHolderForPreviewAnimationOptions !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPreviewAnimationOptionsTmpValue  = valueHolderForPreviewAnimationOptions!
            ContextMenuAnimationOptions_serializer.write(valueSerializer, valueHolderForPreviewAnimationOptionsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundColor  = value.backgroundColor
        if (valueHolderForBackgroundColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundColorTmpValue  = valueHolderForBackgroundColor!
            if (valueHolderForBackgroundColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx0  = valueHolderForBackgroundColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForBackgroundColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForBackgroundColorTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx1  = valueHolderForBackgroundColorTmpValue as int32
                valueSerializer.writeInt32(valueHolderForBackgroundColorTmpValueForIdx1)
            } else if (valueHolderForBackgroundColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx2  = valueHolderForBackgroundColorTmpValue as string
                valueSerializer.writeString(valueHolderForBackgroundColorTmpValueForIdx2)
            } else if (valueHolderForBackgroundColorTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx3  = valueHolderForBackgroundColorTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForBackgroundColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundBlurStyle  = value.backgroundBlurStyle
        if (valueHolderForBackgroundBlurStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundBlurStyleTmpValue  = (valueHolderForBackgroundBlurStyle as BlurStyle)
            valueSerializer.writeInt32(valueHolderForBackgroundBlurStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundBlurStyleOptions  = value.backgroundBlurStyleOptions
        if (valueHolderForBackgroundBlurStyleOptions !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundBlurStyleOptionsTmpValue  = valueHolderForBackgroundBlurStyleOptions!
            BackgroundBlurStyleOptions_serializer.write(valueSerializer, valueHolderForBackgroundBlurStyleOptionsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundEffect  = value.backgroundEffect
        if (valueHolderForBackgroundEffect !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundEffectTmpValue  = valueHolderForBackgroundEffect!
            BackgroundEffectOptions_serializer.write(valueSerializer, valueHolderForBackgroundEffectTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTransition  = value.transition
        if (valueHolderForTransition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTransitionTmpValue  = valueHolderForTransition!
            TransitionEffect_serializer.write(valueSerializer, valueHolderForTransitionTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableHoverMode  = value.enableHoverMode
        if (valueHolderForEnableHoverMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableHoverModeTmpValue  = valueHolderForEnableHoverMode!
            valueSerializer.writeBoolean(valueHolderForEnableHoverModeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOutlineColor  = value.outlineColor
        if (valueHolderForOutlineColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOutlineColorTmpValue  = valueHolderForOutlineColor!
            if (valueHolderForOutlineColorTmpValue instanceof ResourceColor) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOutlineColorTmpValueForIdx0  = valueHolderForOutlineColorTmpValue as ResourceColor
                if (valueHolderForOutlineColorTmpValueForIdx0 instanceof arkui_component_enums_Color) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForOutlineColorTmpValueForIdx0ForIdx0  = valueHolderForOutlineColorTmpValueForIdx0 as arkui_component_enums_Color
                    valueSerializer.writeInt32((valueHolderForOutlineColorTmpValueForIdx0ForIdx0.getOrdinal()) % (12))
                } else if (valueHolderForOutlineColorTmpValueForIdx0 instanceof int32) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForOutlineColorTmpValueForIdx0ForIdx1  = valueHolderForOutlineColorTmpValueForIdx0 as int32
                    valueSerializer.writeInt32(valueHolderForOutlineColorTmpValueForIdx0ForIdx1)
                } else if (valueHolderForOutlineColorTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForOutlineColorTmpValueForIdx0ForIdx2  = valueHolderForOutlineColorTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForOutlineColorTmpValueForIdx0ForIdx2)
                } else if (valueHolderForOutlineColorTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    valueSerializer.writeInt8((3).toByte())
                    const valueHolderForOutlineColorTmpValueForIdx0ForIdx3  = valueHolderForOutlineColorTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(valueSerializer, valueHolderForOutlineColorTmpValueForIdx0ForIdx3)
                }
            } else if (valueHolderForOutlineColorTmpValue instanceof EdgeColors) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOutlineColorTmpValueForIdx1  = valueHolderForOutlineColorTmpValue as EdgeColors
                EdgeColors_serializer.write(valueSerializer, valueHolderForOutlineColorTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOutlineWidth  = value.outlineWidth
        if (valueHolderForOutlineWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOutlineWidthTmpValue  = valueHolderForOutlineWidth!
            if (valueHolderForOutlineWidthTmpValue instanceof Dimension) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOutlineWidthTmpValueForIdx0  = valueHolderForOutlineWidthTmpValue as Dimension
                if (valueHolderForOutlineWidthTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForOutlineWidthTmpValueForIdx0ForIdx0  = valueHolderForOutlineWidthTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForOutlineWidthTmpValueForIdx0ForIdx0)
                } else if (valueHolderForOutlineWidthTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForOutlineWidthTmpValueForIdx0ForIdx1  = valueHolderForOutlineWidthTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForOutlineWidthTmpValueForIdx0ForIdx1)
                } else if (valueHolderForOutlineWidthTmpValueForIdx0 instanceof global_resource_Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForOutlineWidthTmpValueForIdx0ForIdx2  = valueHolderForOutlineWidthTmpValueForIdx0 as global_resource_Resource
                    global_resource_Resource_serializer.write(valueSerializer, valueHolderForOutlineWidthTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForOutlineWidthTmpValue instanceof EdgeOutlineWidths) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOutlineWidthTmpValueForIdx1  = valueHolderForOutlineWidthTmpValue as EdgeOutlineWidths
                EdgeOutlineWidths_serializer.write(valueSerializer, valueHolderForOutlineWidthTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHapticFeedbackMode  = value.hapticFeedbackMode
        if (valueHolderForHapticFeedbackMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHapticFeedbackModeTmpValue  = (valueHolderForHapticFeedbackMode as HapticFeedbackMode)
            valueSerializer.writeInt32(valueHolderForHapticFeedbackModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ContextMenuOptions {
        let valueDeserializer : DeserializerBase = buffer
        const offsetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let offsetTmpBuf : Position | undefined = undefined
        if ((offsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            offsetTmpBuf = Position_serializer.read(valueDeserializer)
        }
        const offsetTmpResult : Position | undefined = offsetTmpBuf
        const placementTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let placementTmpBuf : Placement | undefined = undefined
        if ((placementTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            placementTmpBuf = Placement.fromValue(valueDeserializer.readInt32())
        }
        const placementTmpResult : Placement | undefined = placementTmpBuf
        const enableArrowTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let enableArrowTmpBuf : boolean | undefined = undefined
        if ((enableArrowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableArrowTmpBuf = valueDeserializer.readBoolean()
        }
        const enableArrowTmpResult : boolean | undefined = enableArrowTmpBuf
        const arrowOffsetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let arrowOffsetTmpBuf : Length | undefined = undefined
        if ((arrowOffsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowOffsetTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let arrowOffsetTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (arrowOffsetTmpBufOptUnionSelector == (0).toByte()) {
                arrowOffsetTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (arrowOffsetTmpBufOptUnionSelector == (1).toByte()) {
                arrowOffsetTmpBufOpt = valueDeserializer.readFloat64()
            } else if (arrowOffsetTmpBufOptUnionSelector == (2).toByte()) {
                arrowOffsetTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for arrowOffsetTmpBufOpt has to be chosen through deserialisation.')
            }
            arrowOffsetTmpBuf = (arrowOffsetTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const arrowOffsetTmpResult : Length | undefined = arrowOffsetTmpBuf
        const previewTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let previewTmpBuf : MenuPreviewMode | CustomBuilder | undefined = undefined
        if ((previewTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const previewTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let previewTmpBufOpt : MenuPreviewMode | CustomBuilder | undefined
            if (previewTmpBufOptUnionSelector == (0).toByte()) {
                previewTmpBufOpt = MenuPreviewMode.fromValue(valueDeserializer.readInt32())
            } else if (previewTmpBufOptUnionSelector == (1).toByte()) {
                const previewTmpBufOptBufUBufResource : CallbackResource = valueDeserializer.readCallbackResource()
                const previewTmpBufOptBufUBufCall : KPointer = valueDeserializer.readPointer()
                const previewTmpBufOptBufUBufCallSync : KPointer = valueDeserializer.readPointer()
                const previewTmpBufOptBufUClosure  = ():void => {
                    const previewTmpBufOptBufUBufArgsSerializer : SerializerBase = SerializerBase.hold();
                    previewTmpBufOptBufUBufArgsSerializer.writeInt32(previewTmpBufOptBufUBufResource.resourceId);
                    previewTmpBufOptBufUBufArgsSerializer.writePointer(previewTmpBufOptBufUBufCall);
                    previewTmpBufOptBufUBufArgsSerializer.writePointer(previewTmpBufOptBufUBufCallSync);
                    InteropNativeModule._CallCallbackSync(10, -1834072896, previewTmpBufOptBufUBufArgsSerializer.asBuffer(), previewTmpBufOptBufUBufArgsSerializer.length());
                    previewTmpBufOptBufUBufArgsSerializer.release();
                    return;
                }
                resourceFinalizerRegister(previewTmpBufOptBufUClosure, previewTmpBufOptBufUBufResource)
                previewTmpBufOpt = previewTmpBufOptBufUClosure
            } else {
                throw new Error('One of the branches for previewTmpBufOpt has to be chosen through deserialisation.')
            }
            previewTmpBuf = (previewTmpBufOpt as MenuPreviewMode | CustomBuilder)
        }
        const previewTmpResult : MenuPreviewMode | CustomBuilder | undefined = previewTmpBuf
        const previewBorderRadiusTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let previewBorderRadiusTmpBuf : BorderRadiusType | undefined = undefined
        if ((previewBorderRadiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const previewBorderRadiusTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let previewBorderRadiusTmpBufOpt : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined
            if (previewBorderRadiusTmpBufOptUnionSelector == (0).toByte()) {
                const previewBorderRadiusTmpBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                let previewBorderRadiusTmpBufOptBufU : string | double | arkui_component_units_Resource | undefined
                if (previewBorderRadiusTmpBufOptBufUUnionSelector == (0).toByte()) {
                    previewBorderRadiusTmpBufOptBufU = (valueDeserializer.readString() as string)
                } else if (previewBorderRadiusTmpBufOptBufUUnionSelector == (1).toByte()) {
                    previewBorderRadiusTmpBufOptBufU = valueDeserializer.readFloat64()
                } else if (previewBorderRadiusTmpBufOptBufUUnionSelector == (2).toByte()) {
                    previewBorderRadiusTmpBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error('One of the branches for previewBorderRadiusTmpBufOptBufU has to be chosen through deserialisation.')
                }
                previewBorderRadiusTmpBufOpt = (previewBorderRadiusTmpBufOptBufU as string | double | arkui_component_units_Resource)
            } else if (previewBorderRadiusTmpBufOptUnionSelector == (1).toByte()) {
                previewBorderRadiusTmpBufOpt = BorderRadiuses_serializer.read(valueDeserializer)
            } else if (previewBorderRadiusTmpBufOptUnionSelector == (2).toByte()) {
                previewBorderRadiusTmpBufOpt = LocalizedBorderRadiuses_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for previewBorderRadiusTmpBufOpt has to be chosen through deserialisation.')
            }
            previewBorderRadiusTmpBuf = (previewBorderRadiusTmpBufOpt as Length | BorderRadiuses | LocalizedBorderRadiuses)
        }
        const previewBorderRadiusTmpResult : BorderRadiusType | undefined = previewBorderRadiusTmpBuf
        const borderRadiusTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let borderRadiusTmpBuf : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined = undefined
        if ((borderRadiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const borderRadiusTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let borderRadiusTmpBufOpt : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined
            if (borderRadiusTmpBufOptUnionSelector == (0).toByte()) {
                const borderRadiusTmpBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                let borderRadiusTmpBufOptBufU : string | double | arkui_component_units_Resource | undefined
                if (borderRadiusTmpBufOptBufUUnionSelector == (0).toByte()) {
                    borderRadiusTmpBufOptBufU = (valueDeserializer.readString() as string)
                } else if (borderRadiusTmpBufOptBufUUnionSelector == (1).toByte()) {
                    borderRadiusTmpBufOptBufU = valueDeserializer.readFloat64()
                } else if (borderRadiusTmpBufOptBufUUnionSelector == (2).toByte()) {
                    borderRadiusTmpBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error('One of the branches for borderRadiusTmpBufOptBufU has to be chosen through deserialisation.')
                }
                borderRadiusTmpBufOpt = (borderRadiusTmpBufOptBufU as string | double | arkui_component_units_Resource)
            } else if (borderRadiusTmpBufOptUnionSelector == (1).toByte()) {
                borderRadiusTmpBufOpt = BorderRadiuses_serializer.read(valueDeserializer)
            } else if (borderRadiusTmpBufOptUnionSelector == (2).toByte()) {
                borderRadiusTmpBufOpt = LocalizedBorderRadiuses_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for borderRadiusTmpBufOpt has to be chosen through deserialisation.')
            }
            borderRadiusTmpBuf = (borderRadiusTmpBufOpt as Length | BorderRadiuses | LocalizedBorderRadiuses)
        }
        const borderRadiusTmpResult : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined = borderRadiusTmpBuf
        const onAppearTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onAppearTmpBuf : (() => void) | undefined = undefined
        if ((onAppearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onAppearTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onAppearTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onAppearTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onAppearTmpBufOptClosure  = ():void => {
                const onAppearTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onAppearTmpBufOptBufArgsSerializer.writeInt32(onAppearTmpBufOptBufResource.resourceId);
                onAppearTmpBufOptBufArgsSerializer.writePointer(onAppearTmpBufOptBufCall);
                onAppearTmpBufOptBufArgsSerializer.writePointer(onAppearTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, onAppearTmpBufOptBufArgsSerializer.asBuffer(), onAppearTmpBufOptBufArgsSerializer.length());
                onAppearTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onAppearTmpBufOptClosure, onAppearTmpBufOptBufResource)
            onAppearTmpBuf = onAppearTmpBufOptClosure
        }
        const onAppearTmpResult : (() => void) | undefined = onAppearTmpBuf
        const onDisappearTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onDisappearTmpBuf : (() => void) | undefined = undefined
        if ((onDisappearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onDisappearTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDisappearTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onDisappearTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onDisappearTmpBufOptClosure  = ():void => {
                const onDisappearTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onDisappearTmpBufOptBufArgsSerializer.writeInt32(onDisappearTmpBufOptBufResource.resourceId);
                onDisappearTmpBufOptBufArgsSerializer.writePointer(onDisappearTmpBufOptBufCall);
                onDisappearTmpBufOptBufArgsSerializer.writePointer(onDisappearTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, onDisappearTmpBufOptBufArgsSerializer.asBuffer(), onDisappearTmpBufOptBufArgsSerializer.length());
                onDisappearTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onDisappearTmpBufOptClosure, onDisappearTmpBufOptBufResource)
            onDisappearTmpBuf = onDisappearTmpBufOptClosure
        }
        const onDisappearTmpResult : (() => void) | undefined = onDisappearTmpBuf
        const aboutToAppearTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let aboutToAppearTmpBuf : (() => void) | undefined = undefined
        if ((aboutToAppearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const aboutToAppearTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const aboutToAppearTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const aboutToAppearTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const aboutToAppearTmpBufOptClosure  = ():void => {
                const aboutToAppearTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                aboutToAppearTmpBufOptBufArgsSerializer.writeInt32(aboutToAppearTmpBufOptBufResource.resourceId);
                aboutToAppearTmpBufOptBufArgsSerializer.writePointer(aboutToAppearTmpBufOptBufCall);
                aboutToAppearTmpBufOptBufArgsSerializer.writePointer(aboutToAppearTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, aboutToAppearTmpBufOptBufArgsSerializer.asBuffer(), aboutToAppearTmpBufOptBufArgsSerializer.length());
                aboutToAppearTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(aboutToAppearTmpBufOptClosure, aboutToAppearTmpBufOptBufResource)
            aboutToAppearTmpBuf = aboutToAppearTmpBufOptClosure
        }
        const aboutToAppearTmpResult : (() => void) | undefined = aboutToAppearTmpBuf
        const aboutToDisappearTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let aboutToDisappearTmpBuf : (() => void) | undefined = undefined
        if ((aboutToDisappearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const aboutToDisappearTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const aboutToDisappearTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const aboutToDisappearTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const aboutToDisappearTmpBufOptClosure  = ():void => {
                const aboutToDisappearTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                aboutToDisappearTmpBufOptBufArgsSerializer.writeInt32(aboutToDisappearTmpBufOptBufResource.resourceId);
                aboutToDisappearTmpBufOptBufArgsSerializer.writePointer(aboutToDisappearTmpBufOptBufCall);
                aboutToDisappearTmpBufOptBufArgsSerializer.writePointer(aboutToDisappearTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, aboutToDisappearTmpBufOptBufArgsSerializer.asBuffer(), aboutToDisappearTmpBufOptBufArgsSerializer.length());
                aboutToDisappearTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(aboutToDisappearTmpBufOptClosure, aboutToDisappearTmpBufOptBufResource)
            aboutToDisappearTmpBuf = aboutToDisappearTmpBufOptClosure
        }
        const aboutToDisappearTmpResult : (() => void) | undefined = aboutToDisappearTmpBuf
        const layoutRegionMarginTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let layoutRegionMarginTmpBuf : Margin | undefined = undefined
        if ((layoutRegionMarginTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            layoutRegionMarginTmpBuf = Padding_serializer.read(valueDeserializer)
        }
        const layoutRegionMarginTmpResult : Margin | undefined = layoutRegionMarginTmpBuf
        const previewAnimationOptionsTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let previewAnimationOptionsTmpBuf : ContextMenuAnimationOptions | undefined = undefined
        if ((previewAnimationOptionsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            previewAnimationOptionsTmpBuf = ContextMenuAnimationOptions_serializer.read(valueDeserializer)
        }
        const previewAnimationOptionsTmpResult : ContextMenuAnimationOptions | undefined = previewAnimationOptionsTmpBuf
        const backgroundColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let backgroundColorTmpBuf : ResourceColor | undefined = undefined
        if ((backgroundColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const backgroundColorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let backgroundColorTmpBufOpt : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (backgroundColorTmpBufOptUnionSelector == (0).toByte()) {
                backgroundColorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (backgroundColorTmpBufOptUnionSelector == (1).toByte()) {
                backgroundColorTmpBufOpt = valueDeserializer.readInt32()
            } else if (backgroundColorTmpBufOptUnionSelector == (2).toByte()) {
                backgroundColorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (backgroundColorTmpBufOptUnionSelector == (3).toByte()) {
                backgroundColorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for backgroundColorTmpBufOpt has to be chosen through deserialisation.')
            }
            backgroundColorTmpBuf = (backgroundColorTmpBufOpt as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
        }
        const backgroundColorTmpResult : ResourceColor | undefined = backgroundColorTmpBuf
        const backgroundBlurStyleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let backgroundBlurStyleTmpBuf : BlurStyle | undefined = undefined
        if ((backgroundBlurStyleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundBlurStyleTmpBuf = BlurStyle.fromValue(valueDeserializer.readInt32())
        }
        const backgroundBlurStyleTmpResult : BlurStyle | undefined = backgroundBlurStyleTmpBuf
        const backgroundBlurStyleOptionsTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let backgroundBlurStyleOptionsTmpBuf : BackgroundBlurStyleOptions | undefined = undefined
        if ((backgroundBlurStyleOptionsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundBlurStyleOptionsTmpBuf = BackgroundBlurStyleOptions_serializer.read(valueDeserializer)
        }
        const backgroundBlurStyleOptionsTmpResult : BackgroundBlurStyleOptions | undefined = backgroundBlurStyleOptionsTmpBuf
        const backgroundEffectTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let backgroundEffectTmpBuf : BackgroundEffectOptions | undefined = undefined
        if ((backgroundEffectTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundEffectTmpBuf = BackgroundEffectOptions_serializer.read(valueDeserializer)
        }
        const backgroundEffectTmpResult : BackgroundEffectOptions | undefined = backgroundEffectTmpBuf
        const transitionTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let transitionTmpBuf : TransitionEffect | undefined = undefined
        if ((transitionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            transitionTmpBuf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transitionTmpResult : TransitionEffect | undefined = transitionTmpBuf
        const enableHoverModeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let enableHoverModeTmpBuf : boolean | undefined = undefined
        if ((enableHoverModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableHoverModeTmpBuf = valueDeserializer.readBoolean()
        }
        const enableHoverModeTmpResult : boolean | undefined = enableHoverModeTmpBuf
        const outlineColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let outlineColorTmpBuf : ResourceColor | EdgeColors | undefined = undefined
        if ((outlineColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const outlineColorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let outlineColorTmpBufOpt : ResourceColor | EdgeColors | undefined
            if (outlineColorTmpBufOptUnionSelector == (0).toByte()) {
                const outlineColorTmpBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                let outlineColorTmpBufOptBufU : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
                if (outlineColorTmpBufOptBufUUnionSelector == (0).toByte()) {
                    outlineColorTmpBufOptBufU = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
                } else if (outlineColorTmpBufOptBufUUnionSelector == (1).toByte()) {
                    outlineColorTmpBufOptBufU = valueDeserializer.readInt32()
                } else if (outlineColorTmpBufOptBufUUnionSelector == (2).toByte()) {
                    outlineColorTmpBufOptBufU = (valueDeserializer.readString() as string)
                } else if (outlineColorTmpBufOptBufUUnionSelector == (3).toByte()) {
                    outlineColorTmpBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error('One of the branches for outlineColorTmpBufOptBufU has to be chosen through deserialisation.')
                }
                outlineColorTmpBufOpt = (outlineColorTmpBufOptBufU as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
            } else if (outlineColorTmpBufOptUnionSelector == (1).toByte()) {
                outlineColorTmpBufOpt = EdgeColors_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for outlineColorTmpBufOpt has to be chosen through deserialisation.')
            }
            outlineColorTmpBuf = (outlineColorTmpBufOpt as ResourceColor | EdgeColors)
        }
        const outlineColorTmpResult : ResourceColor | EdgeColors | undefined = outlineColorTmpBuf
        const outlineWidthTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let outlineWidthTmpBuf : Dimension | EdgeOutlineWidths | undefined = undefined
        if ((outlineWidthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const outlineWidthTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let outlineWidthTmpBufOpt : Dimension | EdgeOutlineWidths | undefined
            if (outlineWidthTmpBufOptUnionSelector == (0).toByte()) {
                const outlineWidthTmpBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                let outlineWidthTmpBufOptBufU : string | number | global_resource_Resource | undefined
                if (outlineWidthTmpBufOptBufUUnionSelector == (0).toByte()) {
                    outlineWidthTmpBufOptBufU = (valueDeserializer.readString() as string)
                } else if (outlineWidthTmpBufOptBufUUnionSelector == (1).toByte()) {
                    outlineWidthTmpBufOptBufU = (valueDeserializer.readNumber() as number)
                } else if (outlineWidthTmpBufOptBufUUnionSelector == (2).toByte()) {
                    outlineWidthTmpBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error('One of the branches for outlineWidthTmpBufOptBufU has to be chosen through deserialisation.')
                }
                outlineWidthTmpBufOpt = (outlineWidthTmpBufOptBufU as string | number | global_resource_Resource)
            } else if (outlineWidthTmpBufOptUnionSelector == (1).toByte()) {
                outlineWidthTmpBufOpt = EdgeOutlineWidths_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for outlineWidthTmpBufOpt has to be chosen through deserialisation.')
            }
            outlineWidthTmpBuf = (outlineWidthTmpBufOpt as Dimension | EdgeOutlineWidths)
        }
        const outlineWidthTmpResult : Dimension | EdgeOutlineWidths | undefined = outlineWidthTmpBuf
        const hapticFeedbackModeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let hapticFeedbackModeTmpBuf : HapticFeedbackMode | undefined = undefined
        if ((hapticFeedbackModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            hapticFeedbackModeTmpBuf = HapticFeedbackMode.fromValue(valueDeserializer.readInt32())
        }
        const hapticFeedbackModeTmpResult : HapticFeedbackMode | undefined = hapticFeedbackModeTmpBuf
        let value : ContextMenuOptions = ({offset: offsetTmpResult, placement: placementTmpResult, enableArrow: enableArrowTmpResult, arrowOffset: arrowOffsetTmpResult, preview: previewTmpResult, previewBorderRadius: previewBorderRadiusTmpResult, borderRadius: borderRadiusTmpResult, onAppear: onAppearTmpResult, onDisappear: onDisappearTmpResult, aboutToAppear: aboutToAppearTmpResult, aboutToDisappear: aboutToDisappearTmpResult, layoutRegionMargin: layoutRegionMarginTmpResult, previewAnimationOptions: previewAnimationOptionsTmpResult, backgroundColor: backgroundColorTmpResult, backgroundBlurStyle: backgroundBlurStyleTmpResult, backgroundBlurStyleOptions: backgroundBlurStyleOptionsTmpResult, backgroundEffect: backgroundEffectTmpResult, transition: transitionTmpResult, enableHoverMode: enableHoverModeTmpResult, outlineColor: outlineColorTmpResult, outlineWidth: outlineWidthTmpResult, hapticFeedbackMode: hapticFeedbackModeTmpResult} as ContextMenuOptions)
        return value
    }
}
export class CustomPopupOptions_serializer {
    public static write(buffer: SerializerBase, value: CustomPopupOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForBuilder  = value.builder
        valueSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(valueHolderForBuilder))
        const valueHolderForPlacement  = value.placement
        if (valueHolderForPlacement !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPlacementTmpValue  = (valueHolderForPlacement as Placement)
            valueSerializer.writeInt32(valueHolderForPlacementTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPopupColor  = value.popupColor
        if (valueHolderForPopupColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPopupColorTmpValue  = valueHolderForPopupColor!
            if (valueHolderForPopupColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForPopupColorTmpValueForIdx0  = valueHolderForPopupColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForPopupColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForPopupColorTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForPopupColorTmpValueForIdx1  = valueHolderForPopupColorTmpValue as string
                valueSerializer.writeString(valueHolderForPopupColorTmpValueForIdx1)
            } else if (valueHolderForPopupColorTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForPopupColorTmpValueForIdx2  = valueHolderForPopupColorTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForPopupColorTmpValueForIdx2)
            } else if (valueHolderForPopupColorTmpValue instanceof int64) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForPopupColorTmpValueForIdx3  = valueHolderForPopupColorTmpValue as int64
                valueSerializer.writeInt64(valueHolderForPopupColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableArrow  = value.enableArrow
        if (valueHolderForEnableArrow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableArrowTmpValue  = valueHolderForEnableArrow!
            valueSerializer.writeBoolean(valueHolderForEnableArrowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAutoCancel  = value.autoCancel
        if (valueHolderForAutoCancel !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAutoCancelTmpValue  = valueHolderForAutoCancel!
            valueSerializer.writeBoolean(valueHolderForAutoCancelTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnStateChange  = value.onStateChange
        if (valueHolderForOnStateChange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnStateChangeTmpValue  = valueHolderForOnStateChange!
            valueSerializer.holdAndWriteCallback(valueHolderForOnStateChangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowOffset  = value.arrowOffset
        if (valueHolderForArrowOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowOffsetTmpValue  = valueHolderForArrowOffset!
            if (valueHolderForArrowOffsetTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx0  = valueHolderForArrowOffsetTmpValue as string
                valueSerializer.writeString(valueHolderForArrowOffsetTmpValueForIdx0)
            } else if (valueHolderForArrowOffsetTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx1  = valueHolderForArrowOffsetTmpValue as double
                valueSerializer.writeFloat64(valueHolderForArrowOffsetTmpValueForIdx1)
            } else if (valueHolderForArrowOffsetTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx2  = valueHolderForArrowOffsetTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForArrowOffsetTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShowInSubWindow  = value.showInSubWindow
        if (valueHolderForShowInSubWindow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShowInSubWindowTmpValue  = valueHolderForShowInSubWindow!
            valueSerializer.writeBoolean(valueHolderForShowInSubWindowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMask  = value.mask
        if (valueHolderForMask !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMaskTmpValue  = valueHolderForMask!
            if (valueHolderForMaskTmpValue instanceof boolean) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForMaskTmpValueForIdx0  = valueHolderForMaskTmpValue as boolean
                valueSerializer.writeBoolean(valueHolderForMaskTmpValueForIdx0)
            } else if (valueHolderForMaskTmpValue instanceof PopupMaskType) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForMaskTmpValueForIdx1  = valueHolderForMaskTmpValue as PopupMaskType
                PopupMaskType_serializer.write(valueSerializer, valueHolderForMaskTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTargetSpace  = value.targetSpace
        if (valueHolderForTargetSpace !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTargetSpaceTmpValue  = valueHolderForTargetSpace!
            if (valueHolderForTargetSpaceTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx0  = valueHolderForTargetSpaceTmpValue as string
                valueSerializer.writeString(valueHolderForTargetSpaceTmpValueForIdx0)
            } else if (valueHolderForTargetSpaceTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx1  = valueHolderForTargetSpaceTmpValue as double
                valueSerializer.writeFloat64(valueHolderForTargetSpaceTmpValueForIdx1)
            } else if (valueHolderForTargetSpaceTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx2  = valueHolderForTargetSpaceTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForTargetSpaceTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOffset  = value.offset
        if (valueHolderForOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetTmpValue  = valueHolderForOffset!
            Position_serializer.write(valueSerializer, valueHolderForOffsetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForWidth  = value.width
        if (valueHolderForWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForWidthTmpValue  = valueHolderForWidth!
            if (valueHolderForWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForWidthTmpValueForIdx0  = valueHolderForWidthTmpValue as string
                valueSerializer.writeString(valueHolderForWidthTmpValueForIdx0)
            } else if (valueHolderForWidthTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForWidthTmpValueForIdx1  = valueHolderForWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForWidthTmpValueForIdx1)
            } else if (valueHolderForWidthTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForWidthTmpValueForIdx2  = valueHolderForWidthTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowPointPosition  = value.arrowPointPosition
        if (valueHolderForArrowPointPosition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowPointPositionTmpValue  = (valueHolderForArrowPointPosition as ArrowPointPosition)
            valueSerializer.writeInt32(valueHolderForArrowPointPositionTmpValue.getOrdinal())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowWidth  = value.arrowWidth
        if (valueHolderForArrowWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowWidthTmpValue  = valueHolderForArrowWidth!
            if (valueHolderForArrowWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowWidthTmpValueForIdx0  = valueHolderForArrowWidthTmpValue as string
                valueSerializer.writeString(valueHolderForArrowWidthTmpValueForIdx0)
            } else if (valueHolderForArrowWidthTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowWidthTmpValueForIdx1  = valueHolderForArrowWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowWidthTmpValueForIdx1)
            } else if (valueHolderForArrowWidthTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowWidthTmpValueForIdx2  = valueHolderForArrowWidthTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForArrowWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowHeight  = value.arrowHeight
        if (valueHolderForArrowHeight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowHeightTmpValue  = valueHolderForArrowHeight!
            if (valueHolderForArrowHeightTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowHeightTmpValueForIdx0  = valueHolderForArrowHeightTmpValue as string
                valueSerializer.writeString(valueHolderForArrowHeightTmpValueForIdx0)
            } else if (valueHolderForArrowHeightTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowHeightTmpValueForIdx1  = valueHolderForArrowHeightTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowHeightTmpValueForIdx1)
            } else if (valueHolderForArrowHeightTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowHeightTmpValueForIdx2  = valueHolderForArrowHeightTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForArrowHeightTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRadius  = value.radius
        if (valueHolderForRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRadiusTmpValue  = valueHolderForRadius!
            if (valueHolderForRadiusTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForRadiusTmpValueForIdx0  = valueHolderForRadiusTmpValue as string
                valueSerializer.writeString(valueHolderForRadiusTmpValueForIdx0)
            } else if (valueHolderForRadiusTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForRadiusTmpValueForIdx1  = valueHolderForRadiusTmpValue as number
                valueSerializer.writeNumber(valueHolderForRadiusTmpValueForIdx1)
            } else if (valueHolderForRadiusTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForRadiusTmpValueForIdx2  = valueHolderForRadiusTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForRadiusTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShadow  = value.shadow
        if (valueHolderForShadow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShadowTmpValue  = valueHolderForShadow!
            if (valueHolderForShadowTmpValue instanceof ShadowOptions) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForShadowTmpValueForIdx0  = valueHolderForShadowTmpValue as ShadowOptions
                ShadowOptions_serializer.write(valueSerializer, valueHolderForShadowTmpValueForIdx0)
            } else if (valueHolderForShadowTmpValue instanceof ShadowStyle) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForShadowTmpValueForIdx1  = valueHolderForShadowTmpValue as ShadowStyle
                valueSerializer.writeInt32(valueHolderForShadowTmpValueForIdx1.valueOf())
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundBlurStyle  = value.backgroundBlurStyle
        if (valueHolderForBackgroundBlurStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundBlurStyleTmpValue  = (valueHolderForBackgroundBlurStyle as BlurStyle)
            valueSerializer.writeInt32(valueHolderForBackgroundBlurStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFocusable  = value.focusable
        if (valueHolderForFocusable !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFocusableTmpValue  = valueHolderForFocusable!
            valueSerializer.writeBoolean(valueHolderForFocusableTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTransition  = value.transition
        if (valueHolderForTransition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTransitionTmpValue  = valueHolderForTransition!
            TransitionEffect_serializer.write(valueSerializer, valueHolderForTransitionTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillDismiss  = value.onWillDismiss
        if (valueHolderForOnWillDismiss !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillDismissTmpValue  = valueHolderForOnWillDismiss!
            if (valueHolderForOnWillDismissTmpValue instanceof boolean) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOnWillDismissTmpValueForIdx0  = valueHolderForOnWillDismissTmpValue as boolean
                valueSerializer.writeBoolean(valueHolderForOnWillDismissTmpValueForIdx0)
            } else if (valueHolderForOnWillDismissTmpValue instanceof Callback<DismissPopupAction, void>) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOnWillDismissTmpValueForIdx1  = valueHolderForOnWillDismissTmpValue as Callback<DismissPopupAction, void>
                valueSerializer.holdAndWriteCallback(valueHolderForOnWillDismissTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableHoverMode  = value.enableHoverMode
        if (valueHolderForEnableHoverMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableHoverModeTmpValue  = valueHolderForEnableHoverMode!
            valueSerializer.writeBoolean(valueHolderForEnableHoverModeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFollowTransformOfTarget  = value.followTransformOfTarget
        if (valueHolderForFollowTransformOfTarget !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFollowTransformOfTargetTmpValue  = valueHolderForFollowTransformOfTarget!
            valueSerializer.writeBoolean(valueHolderForFollowTransformOfTargetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForKeyboardAvoidMode  = value.keyboardAvoidMode
        if (valueHolderForKeyboardAvoidMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForKeyboardAvoidModeTmpValue  = (valueHolderForKeyboardAvoidMode as KeyboardAvoidMode)
            valueSerializer.writeInt32(valueHolderForKeyboardAvoidModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): CustomPopupOptions {
        let valueDeserializer : DeserializerBase = buffer
        const builderTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const builderTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const builderTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const builderTmpBufClosure  = ():void => {
            const builderTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            builderTmpBufBufArgsSerializer.writeInt32(builderTmpBufBufResource.resourceId);
            builderTmpBufBufArgsSerializer.writePointer(builderTmpBufBufCall);
            builderTmpBufBufArgsSerializer.writePointer(builderTmpBufBufCallSync);
            InteropNativeModule._CallCallbackSync(10, -1834072896, builderTmpBufBufArgsSerializer.asBuffer(), builderTmpBufBufArgsSerializer.length());
            builderTmpBufBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(builderTmpBufClosure, builderTmpBufBufResource)
        const builderTmpResult : CustomBuilder = builderTmpBufClosure
        const placementTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let placementTmpBuf : Placement | undefined = undefined
        if ((placementTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            placementTmpBuf = Placement.fromValue(valueDeserializer.readInt32())
        }
        const placementTmpResult : Placement | undefined = placementTmpBuf
        const popupColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let popupColorTmpBuf : arkui_component_enums_Color | string | global_resource_Resource | int64 | undefined = undefined
        if ((popupColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const popupColorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let popupColorTmpBufOpt : arkui_component_enums_Color | string | global_resource_Resource | int64 | undefined
            if (popupColorTmpBufOptUnionSelector == (0).toByte()) {
                popupColorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (popupColorTmpBufOptUnionSelector == (1).toByte()) {
                popupColorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (popupColorTmpBufOptUnionSelector == (2).toByte()) {
                popupColorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else if (popupColorTmpBufOptUnionSelector == (3).toByte()) {
                popupColorTmpBufOpt = valueDeserializer.readInt64()
            } else {
                throw new Error('One of the branches for popupColorTmpBufOpt has to be chosen through deserialisation.')
            }
            popupColorTmpBuf = (popupColorTmpBufOpt as arkui_component_enums_Color | string | global_resource_Resource | int64)
        }
        const popupColorTmpResult : arkui_component_enums_Color | string | global_resource_Resource | int64 | undefined = popupColorTmpBuf
        const enableArrowTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let enableArrowTmpBuf : boolean | undefined = undefined
        if ((enableArrowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableArrowTmpBuf = valueDeserializer.readBoolean()
        }
        const enableArrowTmpResult : boolean | undefined = enableArrowTmpBuf
        const autoCancelTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let autoCancelTmpBuf : boolean | undefined = undefined
        if ((autoCancelTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            autoCancelTmpBuf = valueDeserializer.readBoolean()
        }
        const autoCancelTmpResult : boolean | undefined = autoCancelTmpBuf
        const onStateChangeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onStateChangeTmpBuf : PopupStateChangeCallback | undefined = undefined
        if ((onStateChangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onStateChangeTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onStateChangeTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onStateChangeTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onStateChangeTmpBufOptClosure  = (event: PopupStateChangeParam):void => {
                const onStateChangeTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onStateChangeTmpBufOptBufArgsSerializer.writeInt32(onStateChangeTmpBufOptBufResource.resourceId);
                onStateChangeTmpBufOptBufArgsSerializer.writePointer(onStateChangeTmpBufOptBufCall);
                onStateChangeTmpBufOptBufArgsSerializer.writePointer(onStateChangeTmpBufOptBufCallSync);
                PopupStateChangeParam_serializer.write(onStateChangeTmpBufOptBufArgsSerializer, event);
                InteropNativeModule._CallCallbackSync(10, 1789299488, onStateChangeTmpBufOptBufArgsSerializer.asBuffer(), onStateChangeTmpBufOptBufArgsSerializer.length());
                onStateChangeTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onStateChangeTmpBufOptClosure, onStateChangeTmpBufOptBufResource)
            onStateChangeTmpBuf = onStateChangeTmpBufOptClosure
        }
        const onStateChangeTmpResult : PopupStateChangeCallback | undefined = onStateChangeTmpBuf
        const arrowOffsetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let arrowOffsetTmpBuf : Length | undefined = undefined
        if ((arrowOffsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowOffsetTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let arrowOffsetTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (arrowOffsetTmpBufOptUnionSelector == (0).toByte()) {
                arrowOffsetTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (arrowOffsetTmpBufOptUnionSelector == (1).toByte()) {
                arrowOffsetTmpBufOpt = valueDeserializer.readFloat64()
            } else if (arrowOffsetTmpBufOptUnionSelector == (2).toByte()) {
                arrowOffsetTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for arrowOffsetTmpBufOpt has to be chosen through deserialisation.')
            }
            arrowOffsetTmpBuf = (arrowOffsetTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const arrowOffsetTmpResult : Length | undefined = arrowOffsetTmpBuf
        const showInSubWindowTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let showInSubWindowTmpBuf : boolean | undefined = undefined
        if ((showInSubWindowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            showInSubWindowTmpBuf = valueDeserializer.readBoolean()
        }
        const showInSubWindowTmpResult : boolean | undefined = showInSubWindowTmpBuf
        const maskTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let maskTmpBuf : boolean | PopupMaskType | undefined = undefined
        if ((maskTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const maskTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let maskTmpBufOpt : boolean | PopupMaskType | undefined
            if (maskTmpBufOptUnionSelector == (0).toByte()) {
                maskTmpBufOpt = valueDeserializer.readBoolean()
            } else if (maskTmpBufOptUnionSelector == (1).toByte()) {
                maskTmpBufOpt = PopupMaskType_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for maskTmpBufOpt has to be chosen through deserialisation.')
            }
            maskTmpBuf = (maskTmpBufOpt as boolean | PopupMaskType)
        }
        const maskTmpResult : boolean | PopupMaskType | undefined = maskTmpBuf
        const targetSpaceTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let targetSpaceTmpBuf : Length | undefined = undefined
        if ((targetSpaceTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const targetSpaceTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let targetSpaceTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (targetSpaceTmpBufOptUnionSelector == (0).toByte()) {
                targetSpaceTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (targetSpaceTmpBufOptUnionSelector == (1).toByte()) {
                targetSpaceTmpBufOpt = valueDeserializer.readFloat64()
            } else if (targetSpaceTmpBufOptUnionSelector == (2).toByte()) {
                targetSpaceTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for targetSpaceTmpBufOpt has to be chosen through deserialisation.')
            }
            targetSpaceTmpBuf = (targetSpaceTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const targetSpaceTmpResult : Length | undefined = targetSpaceTmpBuf
        const offsetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let offsetTmpBuf : Position | undefined = undefined
        if ((offsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            offsetTmpBuf = Position_serializer.read(valueDeserializer)
        }
        const offsetTmpResult : Position | undefined = offsetTmpBuf
        const widthTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let widthTmpBuf : Dimension | undefined = undefined
        if ((widthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const widthTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let widthTmpBufOpt : string | number | global_resource_Resource | undefined
            if (widthTmpBufOptUnionSelector == (0).toByte()) {
                widthTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (widthTmpBufOptUnionSelector == (1).toByte()) {
                widthTmpBufOpt = (valueDeserializer.readNumber() as number)
            } else if (widthTmpBufOptUnionSelector == (2).toByte()) {
                widthTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for widthTmpBufOpt has to be chosen through deserialisation.')
            }
            widthTmpBuf = (widthTmpBufOpt as string | number | global_resource_Resource)
        }
        const widthTmpResult : Dimension | undefined = widthTmpBuf
        const arrowPointPositionTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let arrowPointPositionTmpBuf : ArrowPointPosition | undefined = undefined
        if ((arrowPointPositionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            arrowPointPositionTmpBuf = ArrowPointPosition.values()[valueDeserializer.readInt32()]
        }
        const arrowPointPositionTmpResult : ArrowPointPosition | undefined = arrowPointPositionTmpBuf
        const arrowWidthTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let arrowWidthTmpBuf : Dimension | undefined = undefined
        if ((arrowWidthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowWidthTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let arrowWidthTmpBufOpt : string | number | global_resource_Resource | undefined
            if (arrowWidthTmpBufOptUnionSelector == (0).toByte()) {
                arrowWidthTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (arrowWidthTmpBufOptUnionSelector == (1).toByte()) {
                arrowWidthTmpBufOpt = (valueDeserializer.readNumber() as number)
            } else if (arrowWidthTmpBufOptUnionSelector == (2).toByte()) {
                arrowWidthTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for arrowWidthTmpBufOpt has to be chosen through deserialisation.')
            }
            arrowWidthTmpBuf = (arrowWidthTmpBufOpt as string | number | global_resource_Resource)
        }
        const arrowWidthTmpResult : Dimension | undefined = arrowWidthTmpBuf
        const arrowHeightTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let arrowHeightTmpBuf : Dimension | undefined = undefined
        if ((arrowHeightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowHeightTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let arrowHeightTmpBufOpt : string | number | global_resource_Resource | undefined
            if (arrowHeightTmpBufOptUnionSelector == (0).toByte()) {
                arrowHeightTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (arrowHeightTmpBufOptUnionSelector == (1).toByte()) {
                arrowHeightTmpBufOpt = (valueDeserializer.readNumber() as number)
            } else if (arrowHeightTmpBufOptUnionSelector == (2).toByte()) {
                arrowHeightTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for arrowHeightTmpBufOpt has to be chosen through deserialisation.')
            }
            arrowHeightTmpBuf = (arrowHeightTmpBufOpt as string | number | global_resource_Resource)
        }
        const arrowHeightTmpResult : Dimension | undefined = arrowHeightTmpBuf
        const radiusTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let radiusTmpBuf : Dimension | undefined = undefined
        if ((radiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const radiusTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let radiusTmpBufOpt : string | number | global_resource_Resource | undefined
            if (radiusTmpBufOptUnionSelector == (0).toByte()) {
                radiusTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (radiusTmpBufOptUnionSelector == (1).toByte()) {
                radiusTmpBufOpt = (valueDeserializer.readNumber() as number)
            } else if (radiusTmpBufOptUnionSelector == (2).toByte()) {
                radiusTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for radiusTmpBufOpt has to be chosen through deserialisation.')
            }
            radiusTmpBuf = (radiusTmpBufOpt as string | number | global_resource_Resource)
        }
        const radiusTmpResult : Dimension | undefined = radiusTmpBuf
        const shadowTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let shadowTmpBuf : ShadowOptions | ShadowStyle | undefined = undefined
        if ((shadowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const shadowTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let shadowTmpBufOpt : ShadowOptions | ShadowStyle | undefined
            if (shadowTmpBufOptUnionSelector == (0).toByte()) {
                shadowTmpBufOpt = ShadowOptions_serializer.read(valueDeserializer)
            } else if (shadowTmpBufOptUnionSelector == (1).toByte()) {
                shadowTmpBufOpt = ShadowStyle.fromValue(valueDeserializer.readInt32())
            } else {
                throw new Error('One of the branches for shadowTmpBufOpt has to be chosen through deserialisation.')
            }
            shadowTmpBuf = (shadowTmpBufOpt as ShadowOptions | ShadowStyle)
        }
        const shadowTmpResult : ShadowOptions | ShadowStyle | undefined = shadowTmpBuf
        const backgroundBlurStyleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let backgroundBlurStyleTmpBuf : BlurStyle | undefined = undefined
        if ((backgroundBlurStyleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundBlurStyleTmpBuf = BlurStyle.fromValue(valueDeserializer.readInt32())
        }
        const backgroundBlurStyleTmpResult : BlurStyle | undefined = backgroundBlurStyleTmpBuf
        const focusableTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let focusableTmpBuf : boolean | undefined = undefined
        if ((focusableTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            focusableTmpBuf = valueDeserializer.readBoolean()
        }
        const focusableTmpResult : boolean | undefined = focusableTmpBuf
        const transitionTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let transitionTmpBuf : TransitionEffect | undefined = undefined
        if ((transitionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            transitionTmpBuf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transitionTmpResult : TransitionEffect | undefined = transitionTmpBuf
        const onWillDismissTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onWillDismissTmpBuf : boolean | Callback<DismissPopupAction, void> | undefined = undefined
        if ((onWillDismissTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillDismissTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let onWillDismissTmpBufOpt : boolean | Callback<DismissPopupAction, void> | undefined
            if (onWillDismissTmpBufOptUnionSelector == (0).toByte()) {
                onWillDismissTmpBufOpt = valueDeserializer.readBoolean()
            } else if (onWillDismissTmpBufOptUnionSelector == (1).toByte()) {
                const onWillDismissTmpBufOptBufUBufResource : CallbackResource = valueDeserializer.readCallbackResource()
                const onWillDismissTmpBufOptBufUBufCall : KPointer = valueDeserializer.readPointer()
                const onWillDismissTmpBufOptBufUBufCallSync : KPointer = valueDeserializer.readPointer()
                const onWillDismissTmpBufOptBufUClosure  = (data: DismissPopupAction):void => {
                    const onWillDismissTmpBufOptBufUBufArgsSerializer : SerializerBase = SerializerBase.hold();
                    onWillDismissTmpBufOptBufUBufArgsSerializer.writeInt32(onWillDismissTmpBufOptBufUBufResource.resourceId);
                    onWillDismissTmpBufOptBufUBufArgsSerializer.writePointer(onWillDismissTmpBufOptBufUBufCall);
                    onWillDismissTmpBufOptBufUBufArgsSerializer.writePointer(onWillDismissTmpBufOptBufUBufCallSync);
                    DismissPopupAction_serializer.write(onWillDismissTmpBufOptBufUBufArgsSerializer, data);
                    InteropNativeModule._CallCallbackSync(10, 1691355745, onWillDismissTmpBufOptBufUBufArgsSerializer.asBuffer(), onWillDismissTmpBufOptBufUBufArgsSerializer.length());
                    onWillDismissTmpBufOptBufUBufArgsSerializer.release();
                    return;
                }
                resourceFinalizerRegister(onWillDismissTmpBufOptBufUClosure, onWillDismissTmpBufOptBufUBufResource)
                onWillDismissTmpBufOpt = onWillDismissTmpBufOptBufUClosure
            } else {
                throw new Error('One of the branches for onWillDismissTmpBufOpt has to be chosen through deserialisation.')
            }
            onWillDismissTmpBuf = (onWillDismissTmpBufOpt as boolean | Callback<DismissPopupAction, void>)
        }
        const onWillDismissTmpResult : boolean | Callback<DismissPopupAction, void> | undefined = onWillDismissTmpBuf
        const enableHoverModeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let enableHoverModeTmpBuf : boolean | undefined = undefined
        if ((enableHoverModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableHoverModeTmpBuf = valueDeserializer.readBoolean()
        }
        const enableHoverModeTmpResult : boolean | undefined = enableHoverModeTmpBuf
        const followTransformOfTargetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let followTransformOfTargetTmpBuf : boolean | undefined = undefined
        if ((followTransformOfTargetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            followTransformOfTargetTmpBuf = valueDeserializer.readBoolean()
        }
        const followTransformOfTargetTmpResult : boolean | undefined = followTransformOfTargetTmpBuf
        const keyboardAvoidModeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let keyboardAvoidModeTmpBuf : KeyboardAvoidMode | undefined = undefined
        if ((keyboardAvoidModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            keyboardAvoidModeTmpBuf = KeyboardAvoidMode.fromValue(valueDeserializer.readInt32())
        }
        const keyboardAvoidModeTmpResult : KeyboardAvoidMode | undefined = keyboardAvoidModeTmpBuf
        let value : CustomPopupOptions = ({builder: builderTmpResult, placement: placementTmpResult, popupColor: popupColorTmpResult, enableArrow: enableArrowTmpResult, autoCancel: autoCancelTmpResult, onStateChange: onStateChangeTmpResult, arrowOffset: arrowOffsetTmpResult, showInSubWindow: showInSubWindowTmpResult, mask: maskTmpResult, targetSpace: targetSpaceTmpResult, offset: offsetTmpResult, width: widthTmpResult, arrowPointPosition: arrowPointPositionTmpResult, arrowWidth: arrowWidthTmpResult, arrowHeight: arrowHeightTmpResult, radius: radiusTmpResult, shadow: shadowTmpResult, backgroundBlurStyle: backgroundBlurStyleTmpResult, focusable: focusableTmpResult, transition: transitionTmpResult, onWillDismiss: onWillDismissTmpResult, enableHoverMode: enableHoverModeTmpResult, followTransformOfTarget: followTransformOfTargetTmpResult, keyboardAvoidMode: keyboardAvoidModeTmpResult} as CustomPopupOptions)
        return value
    }
}
export class EventTarget_serializer {
    public static write(buffer: SerializerBase, value: EventTarget): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForArea  = value.area
        Area_serializer.write(valueSerializer, valueHolderForArea)
        const valueHolderForId  = value.id
        if (valueHolderForId !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForIdTmpValue  = valueHolderForId!
            valueSerializer.writeString(valueHolderForIdTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): EventTarget {
        let valueDeserializer : DeserializerBase = buffer
        const areaTmpResult : Area = Area_serializer.read(valueDeserializer)
        const idTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let idTmpBuf : string | undefined = undefined
        if ((idTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            idTmpBuf = (valueDeserializer.readString() as string)
        }
        const idTmpResult : string | undefined = idTmpBuf
        let value : EventTarget = ({area: areaTmpResult, id: idTmpResult} as EventTarget)
        return value
    }
}
export class GeometryInfo_serializer {
    public static write(buffer: SerializerBase, value: GeometryInfo): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForWidth  = value.width
        valueSerializer.writeFloat64(valueHolderForWidth)
        const valueHolderForHeight  = value.height
        valueSerializer.writeFloat64(valueHolderForHeight)
        const valueHolderForBorderWidth  = value.borderWidth
        EdgeWidths_serializer.write(valueSerializer, valueHolderForBorderWidth)
        const valueHolderForMargin  = value.margin
        Padding_serializer.write(valueSerializer, valueHolderForMargin)
        const valueHolderForPadding  = value.padding
        Padding_serializer.write(valueSerializer, valueHolderForPadding)
    }
    public static read(buffer: DeserializerBase): GeometryInfo {
        let valueDeserializer : DeserializerBase = buffer
        const widthTmpResult : double = valueDeserializer.readFloat64()
        const heightTmpResult : double = valueDeserializer.readFloat64()
        const borderWidthTmpResult : EdgeWidth = EdgeWidths_serializer.read(valueDeserializer)
        const marginTmpResult : Margin = Padding_serializer.read(valueDeserializer)
        const paddingTmpResult : Padding = Padding_serializer.read(valueDeserializer)
        let value : GeometryInfo = ({width: widthTmpResult, height: heightTmpResult, borderWidth: borderWidthTmpResult, margin: marginTmpResult, padding: paddingTmpResult} as GeometryInfo)
        return value
    }
}
export class MenuOptions_serializer {
    public static write(buffer: SerializerBase, value: MenuOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForOffset  = value.offset
        if (valueHolderForOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetTmpValue  = valueHolderForOffset!
            Position_serializer.write(valueSerializer, valueHolderForOffsetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPlacement  = value.placement
        if (valueHolderForPlacement !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPlacementTmpValue  = (valueHolderForPlacement as Placement)
            valueSerializer.writeInt32(valueHolderForPlacementTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableArrow  = value.enableArrow
        if (valueHolderForEnableArrow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableArrowTmpValue  = valueHolderForEnableArrow!
            valueSerializer.writeBoolean(valueHolderForEnableArrowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowOffset  = value.arrowOffset
        if (valueHolderForArrowOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowOffsetTmpValue  = valueHolderForArrowOffset!
            if (valueHolderForArrowOffsetTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx0  = valueHolderForArrowOffsetTmpValue as string
                valueSerializer.writeString(valueHolderForArrowOffsetTmpValueForIdx0)
            } else if (valueHolderForArrowOffsetTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx1  = valueHolderForArrowOffsetTmpValue as double
                valueSerializer.writeFloat64(valueHolderForArrowOffsetTmpValueForIdx1)
            } else if (valueHolderForArrowOffsetTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx2  = valueHolderForArrowOffsetTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForArrowOffsetTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPreview  = value.preview
        if (valueHolderForPreview !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPreviewTmpValue  = valueHolderForPreview!
            if (valueHolderForPreviewTmpValue instanceof MenuPreviewMode) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForPreviewTmpValueForIdx0  = valueHolderForPreviewTmpValue as MenuPreviewMode
                valueSerializer.writeInt32(valueHolderForPreviewTmpValueForIdx0.valueOf())
            } else if (valueHolderForPreviewTmpValue instanceof CustomBuilder) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForPreviewTmpValueForIdx1  = valueHolderForPreviewTmpValue as CustomBuilder
                valueSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(valueHolderForPreviewTmpValueForIdx1))
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPreviewBorderRadius  = value.previewBorderRadius
        if (valueHolderForPreviewBorderRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPreviewBorderRadiusTmpValue  = valueHolderForPreviewBorderRadius!
            if (valueHolderForPreviewBorderRadiusTmpValue instanceof Length) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForPreviewBorderRadiusTmpValueForIdx0  = valueHolderForPreviewBorderRadiusTmpValue as Length
                if (valueHolderForPreviewBorderRadiusTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx0  = valueHolderForPreviewBorderRadiusTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx0)
                } else if (valueHolderForPreviewBorderRadiusTmpValueForIdx0 instanceof double) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx1  = valueHolderForPreviewBorderRadiusTmpValueForIdx0 as double
                    valueSerializer.writeFloat64(valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx1)
                } else if (valueHolderForPreviewBorderRadiusTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx2  = valueHolderForPreviewBorderRadiusTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(valueSerializer, valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForPreviewBorderRadiusTmpValue instanceof BorderRadiuses) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForPreviewBorderRadiusTmpValueForIdx1  = valueHolderForPreviewBorderRadiusTmpValue as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, valueHolderForPreviewBorderRadiusTmpValueForIdx1)
            } else if (valueHolderForPreviewBorderRadiusTmpValue instanceof LocalizedBorderRadiuses) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForPreviewBorderRadiusTmpValueForIdx2  = valueHolderForPreviewBorderRadiusTmpValue as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(valueSerializer, valueHolderForPreviewBorderRadiusTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBorderRadius  = value.borderRadius
        if (valueHolderForBorderRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBorderRadiusTmpValue  = valueHolderForBorderRadius!
            if (valueHolderForBorderRadiusTmpValue instanceof Length) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBorderRadiusTmpValueForIdx0  = valueHolderForBorderRadiusTmpValue as Length
                if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx0  = valueHolderForBorderRadiusTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForBorderRadiusTmpValueForIdx0ForIdx0)
                } else if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof double) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx1  = valueHolderForBorderRadiusTmpValueForIdx0 as double
                    valueSerializer.writeFloat64(valueHolderForBorderRadiusTmpValueForIdx0ForIdx1)
                } else if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx2  = valueHolderForBorderRadiusTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(valueSerializer, valueHolderForBorderRadiusTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForBorderRadiusTmpValue instanceof BorderRadiuses) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBorderRadiusTmpValueForIdx1  = valueHolderForBorderRadiusTmpValue as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, valueHolderForBorderRadiusTmpValueForIdx1)
            } else if (valueHolderForBorderRadiusTmpValue instanceof LocalizedBorderRadiuses) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBorderRadiusTmpValueForIdx2  = valueHolderForBorderRadiusTmpValue as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(valueSerializer, valueHolderForBorderRadiusTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnAppear  = value.onAppear
        if (valueHolderForOnAppear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnAppearTmpValue  = valueHolderForOnAppear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnAppearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnDisappear  = value.onDisappear
        if (valueHolderForOnDisappear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnDisappearTmpValue  = valueHolderForOnDisappear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnDisappearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAboutToAppear  = value.aboutToAppear
        if (valueHolderForAboutToAppear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAboutToAppearTmpValue  = valueHolderForAboutToAppear!
            valueSerializer.holdAndWriteCallback(valueHolderForAboutToAppearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAboutToDisappear  = value.aboutToDisappear
        if (valueHolderForAboutToDisappear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAboutToDisappearTmpValue  = valueHolderForAboutToDisappear!
            valueSerializer.holdAndWriteCallback(valueHolderForAboutToDisappearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForLayoutRegionMargin  = value.layoutRegionMargin
        if (valueHolderForLayoutRegionMargin !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForLayoutRegionMarginTmpValue  = valueHolderForLayoutRegionMargin!
            Padding_serializer.write(valueSerializer, valueHolderForLayoutRegionMarginTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPreviewAnimationOptions  = value.previewAnimationOptions
        if (valueHolderForPreviewAnimationOptions !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPreviewAnimationOptionsTmpValue  = valueHolderForPreviewAnimationOptions!
            ContextMenuAnimationOptions_serializer.write(valueSerializer, valueHolderForPreviewAnimationOptionsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundColor  = value.backgroundColor
        if (valueHolderForBackgroundColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundColorTmpValue  = valueHolderForBackgroundColor!
            if (valueHolderForBackgroundColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx0  = valueHolderForBackgroundColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForBackgroundColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForBackgroundColorTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx1  = valueHolderForBackgroundColorTmpValue as int32
                valueSerializer.writeInt32(valueHolderForBackgroundColorTmpValueForIdx1)
            } else if (valueHolderForBackgroundColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx2  = valueHolderForBackgroundColorTmpValue as string
                valueSerializer.writeString(valueHolderForBackgroundColorTmpValueForIdx2)
            } else if (valueHolderForBackgroundColorTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx3  = valueHolderForBackgroundColorTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForBackgroundColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundBlurStyle  = value.backgroundBlurStyle
        if (valueHolderForBackgroundBlurStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundBlurStyleTmpValue  = (valueHolderForBackgroundBlurStyle as BlurStyle)
            valueSerializer.writeInt32(valueHolderForBackgroundBlurStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundBlurStyleOptions  = value.backgroundBlurStyleOptions
        if (valueHolderForBackgroundBlurStyleOptions !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundBlurStyleOptionsTmpValue  = valueHolderForBackgroundBlurStyleOptions!
            BackgroundBlurStyleOptions_serializer.write(valueSerializer, valueHolderForBackgroundBlurStyleOptionsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundEffect  = value.backgroundEffect
        if (valueHolderForBackgroundEffect !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundEffectTmpValue  = valueHolderForBackgroundEffect!
            BackgroundEffectOptions_serializer.write(valueSerializer, valueHolderForBackgroundEffectTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTransition  = value.transition
        if (valueHolderForTransition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTransitionTmpValue  = valueHolderForTransition!
            TransitionEffect_serializer.write(valueSerializer, valueHolderForTransitionTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableHoverMode  = value.enableHoverMode
        if (valueHolderForEnableHoverMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableHoverModeTmpValue  = valueHolderForEnableHoverMode!
            valueSerializer.writeBoolean(valueHolderForEnableHoverModeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOutlineColor  = value.outlineColor
        if (valueHolderForOutlineColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOutlineColorTmpValue  = valueHolderForOutlineColor!
            if (valueHolderForOutlineColorTmpValue instanceof ResourceColor) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOutlineColorTmpValueForIdx0  = valueHolderForOutlineColorTmpValue as ResourceColor
                if (valueHolderForOutlineColorTmpValueForIdx0 instanceof arkui_component_enums_Color) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForOutlineColorTmpValueForIdx0ForIdx0  = valueHolderForOutlineColorTmpValueForIdx0 as arkui_component_enums_Color
                    valueSerializer.writeInt32((valueHolderForOutlineColorTmpValueForIdx0ForIdx0.getOrdinal()) % (12))
                } else if (valueHolderForOutlineColorTmpValueForIdx0 instanceof int32) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForOutlineColorTmpValueForIdx0ForIdx1  = valueHolderForOutlineColorTmpValueForIdx0 as int32
                    valueSerializer.writeInt32(valueHolderForOutlineColorTmpValueForIdx0ForIdx1)
                } else if (valueHolderForOutlineColorTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForOutlineColorTmpValueForIdx0ForIdx2  = valueHolderForOutlineColorTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForOutlineColorTmpValueForIdx0ForIdx2)
                } else if (valueHolderForOutlineColorTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    valueSerializer.writeInt8((3).toByte())
                    const valueHolderForOutlineColorTmpValueForIdx0ForIdx3  = valueHolderForOutlineColorTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(valueSerializer, valueHolderForOutlineColorTmpValueForIdx0ForIdx3)
                }
            } else if (valueHolderForOutlineColorTmpValue instanceof EdgeColors) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOutlineColorTmpValueForIdx1  = valueHolderForOutlineColorTmpValue as EdgeColors
                EdgeColors_serializer.write(valueSerializer, valueHolderForOutlineColorTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOutlineWidth  = value.outlineWidth
        if (valueHolderForOutlineWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOutlineWidthTmpValue  = valueHolderForOutlineWidth!
            if (valueHolderForOutlineWidthTmpValue instanceof Dimension) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOutlineWidthTmpValueForIdx0  = valueHolderForOutlineWidthTmpValue as Dimension
                if (valueHolderForOutlineWidthTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForOutlineWidthTmpValueForIdx0ForIdx0  = valueHolderForOutlineWidthTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForOutlineWidthTmpValueForIdx0ForIdx0)
                } else if (valueHolderForOutlineWidthTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForOutlineWidthTmpValueForIdx0ForIdx1  = valueHolderForOutlineWidthTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForOutlineWidthTmpValueForIdx0ForIdx1)
                } else if (valueHolderForOutlineWidthTmpValueForIdx0 instanceof global_resource_Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForOutlineWidthTmpValueForIdx0ForIdx2  = valueHolderForOutlineWidthTmpValueForIdx0 as global_resource_Resource
                    global_resource_Resource_serializer.write(valueSerializer, valueHolderForOutlineWidthTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForOutlineWidthTmpValue instanceof EdgeOutlineWidths) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOutlineWidthTmpValueForIdx1  = valueHolderForOutlineWidthTmpValue as EdgeOutlineWidths
                EdgeOutlineWidths_serializer.write(valueSerializer, valueHolderForOutlineWidthTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHapticFeedbackMode  = value.hapticFeedbackMode
        if (valueHolderForHapticFeedbackMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHapticFeedbackModeTmpValue  = (valueHolderForHapticFeedbackMode as HapticFeedbackMode)
            valueSerializer.writeInt32(valueHolderForHapticFeedbackModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTitle  = value.title
        if (valueHolderForTitle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTitleTmpValue  = valueHolderForTitle!
            if (valueHolderForTitleTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForTitleTmpValueForIdx0  = valueHolderForTitleTmpValue as string
                valueSerializer.writeString(valueHolderForTitleTmpValueForIdx0)
            } else if (valueHolderForTitleTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForTitleTmpValueForIdx1  = valueHolderForTitleTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForTitleTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShowInSubWindow  = value.showInSubWindow
        if (valueHolderForShowInSubWindow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShowInSubWindowTmpValue  = valueHolderForShowInSubWindow!
            valueSerializer.writeBoolean(valueHolderForShowInSubWindowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): MenuOptions {
        let valueDeserializer : DeserializerBase = buffer
        const offsetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let offsetTmpBuf : Position | undefined = undefined
        if ((offsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            offsetTmpBuf = Position_serializer.read(valueDeserializer)
        }
        const offsetTmpResult : Position | undefined = offsetTmpBuf
        const placementTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let placementTmpBuf : Placement | undefined = undefined
        if ((placementTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            placementTmpBuf = Placement.fromValue(valueDeserializer.readInt32())
        }
        const placementTmpResult : Placement | undefined = placementTmpBuf
        const enableArrowTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let enableArrowTmpBuf : boolean | undefined = undefined
        if ((enableArrowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableArrowTmpBuf = valueDeserializer.readBoolean()
        }
        const enableArrowTmpResult : boolean | undefined = enableArrowTmpBuf
        const arrowOffsetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let arrowOffsetTmpBuf : Length | undefined = undefined
        if ((arrowOffsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowOffsetTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let arrowOffsetTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (arrowOffsetTmpBufOptUnionSelector == (0).toByte()) {
                arrowOffsetTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (arrowOffsetTmpBufOptUnionSelector == (1).toByte()) {
                arrowOffsetTmpBufOpt = valueDeserializer.readFloat64()
            } else if (arrowOffsetTmpBufOptUnionSelector == (2).toByte()) {
                arrowOffsetTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for arrowOffsetTmpBufOpt has to be chosen through deserialisation.')
            }
            arrowOffsetTmpBuf = (arrowOffsetTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const arrowOffsetTmpResult : Length | undefined = arrowOffsetTmpBuf
        const previewTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let previewTmpBuf : MenuPreviewMode | CustomBuilder | undefined = undefined
        if ((previewTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const previewTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let previewTmpBufOpt : MenuPreviewMode | CustomBuilder | undefined
            if (previewTmpBufOptUnionSelector == (0).toByte()) {
                previewTmpBufOpt = MenuPreviewMode.fromValue(valueDeserializer.readInt32())
            } else if (previewTmpBufOptUnionSelector == (1).toByte()) {
                const previewTmpBufOptBufUBufResource : CallbackResource = valueDeserializer.readCallbackResource()
                const previewTmpBufOptBufUBufCall : KPointer = valueDeserializer.readPointer()
                const previewTmpBufOptBufUBufCallSync : KPointer = valueDeserializer.readPointer()
                const previewTmpBufOptBufUClosure  = ():void => {
                    const previewTmpBufOptBufUBufArgsSerializer : SerializerBase = SerializerBase.hold();
                    previewTmpBufOptBufUBufArgsSerializer.writeInt32(previewTmpBufOptBufUBufResource.resourceId);
                    previewTmpBufOptBufUBufArgsSerializer.writePointer(previewTmpBufOptBufUBufCall);
                    previewTmpBufOptBufUBufArgsSerializer.writePointer(previewTmpBufOptBufUBufCallSync);
                    InteropNativeModule._CallCallbackSync(10, -1834072896, previewTmpBufOptBufUBufArgsSerializer.asBuffer(), previewTmpBufOptBufUBufArgsSerializer.length());
                    previewTmpBufOptBufUBufArgsSerializer.release();
                    return;
                }
                resourceFinalizerRegister(previewTmpBufOptBufUClosure, previewTmpBufOptBufUBufResource)
                previewTmpBufOpt = previewTmpBufOptBufUClosure
            } else {
                throw new Error('One of the branches for previewTmpBufOpt has to be chosen through deserialisation.')
            }
            previewTmpBuf = (previewTmpBufOpt as MenuPreviewMode | CustomBuilder)
        }
        const previewTmpResult : MenuPreviewMode | CustomBuilder | undefined = previewTmpBuf
        const previewBorderRadiusTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let previewBorderRadiusTmpBuf : BorderRadiusType | undefined = undefined
        if ((previewBorderRadiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const previewBorderRadiusTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let previewBorderRadiusTmpBufOpt : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined
            if (previewBorderRadiusTmpBufOptUnionSelector == (0).toByte()) {
                const previewBorderRadiusTmpBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                let previewBorderRadiusTmpBufOptBufU : string | double | arkui_component_units_Resource | undefined
                if (previewBorderRadiusTmpBufOptBufUUnionSelector == (0).toByte()) {
                    previewBorderRadiusTmpBufOptBufU = (valueDeserializer.readString() as string)
                } else if (previewBorderRadiusTmpBufOptBufUUnionSelector == (1).toByte()) {
                    previewBorderRadiusTmpBufOptBufU = valueDeserializer.readFloat64()
                } else if (previewBorderRadiusTmpBufOptBufUUnionSelector == (2).toByte()) {
                    previewBorderRadiusTmpBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error('One of the branches for previewBorderRadiusTmpBufOptBufU has to be chosen through deserialisation.')
                }
                previewBorderRadiusTmpBufOpt = (previewBorderRadiusTmpBufOptBufU as string | double | arkui_component_units_Resource)
            } else if (previewBorderRadiusTmpBufOptUnionSelector == (1).toByte()) {
                previewBorderRadiusTmpBufOpt = BorderRadiuses_serializer.read(valueDeserializer)
            } else if (previewBorderRadiusTmpBufOptUnionSelector == (2).toByte()) {
                previewBorderRadiusTmpBufOpt = LocalizedBorderRadiuses_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for previewBorderRadiusTmpBufOpt has to be chosen through deserialisation.')
            }
            previewBorderRadiusTmpBuf = (previewBorderRadiusTmpBufOpt as Length | BorderRadiuses | LocalizedBorderRadiuses)
        }
        const previewBorderRadiusTmpResult : BorderRadiusType | undefined = previewBorderRadiusTmpBuf
        const borderRadiusTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let borderRadiusTmpBuf : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined = undefined
        if ((borderRadiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const borderRadiusTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let borderRadiusTmpBufOpt : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined
            if (borderRadiusTmpBufOptUnionSelector == (0).toByte()) {
                const borderRadiusTmpBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                let borderRadiusTmpBufOptBufU : string | double | arkui_component_units_Resource | undefined
                if (borderRadiusTmpBufOptBufUUnionSelector == (0).toByte()) {
                    borderRadiusTmpBufOptBufU = (valueDeserializer.readString() as string)
                } else if (borderRadiusTmpBufOptBufUUnionSelector == (1).toByte()) {
                    borderRadiusTmpBufOptBufU = valueDeserializer.readFloat64()
                } else if (borderRadiusTmpBufOptBufUUnionSelector == (2).toByte()) {
                    borderRadiusTmpBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error('One of the branches for borderRadiusTmpBufOptBufU has to be chosen through deserialisation.')
                }
                borderRadiusTmpBufOpt = (borderRadiusTmpBufOptBufU as string | double | arkui_component_units_Resource)
            } else if (borderRadiusTmpBufOptUnionSelector == (1).toByte()) {
                borderRadiusTmpBufOpt = BorderRadiuses_serializer.read(valueDeserializer)
            } else if (borderRadiusTmpBufOptUnionSelector == (2).toByte()) {
                borderRadiusTmpBufOpt = LocalizedBorderRadiuses_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for borderRadiusTmpBufOpt has to be chosen through deserialisation.')
            }
            borderRadiusTmpBuf = (borderRadiusTmpBufOpt as Length | BorderRadiuses | LocalizedBorderRadiuses)
        }
        const borderRadiusTmpResult : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined = borderRadiusTmpBuf
        const onAppearTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onAppearTmpBuf : (() => void) | undefined = undefined
        if ((onAppearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onAppearTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onAppearTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onAppearTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onAppearTmpBufOptClosure  = ():void => {
                const onAppearTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onAppearTmpBufOptBufArgsSerializer.writeInt32(onAppearTmpBufOptBufResource.resourceId);
                onAppearTmpBufOptBufArgsSerializer.writePointer(onAppearTmpBufOptBufCall);
                onAppearTmpBufOptBufArgsSerializer.writePointer(onAppearTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, onAppearTmpBufOptBufArgsSerializer.asBuffer(), onAppearTmpBufOptBufArgsSerializer.length());
                onAppearTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onAppearTmpBufOptClosure, onAppearTmpBufOptBufResource)
            onAppearTmpBuf = onAppearTmpBufOptClosure
        }
        const onAppearTmpResult : (() => void) | undefined = onAppearTmpBuf
        const onDisappearTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onDisappearTmpBuf : (() => void) | undefined = undefined
        if ((onDisappearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onDisappearTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDisappearTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onDisappearTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onDisappearTmpBufOptClosure  = ():void => {
                const onDisappearTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onDisappearTmpBufOptBufArgsSerializer.writeInt32(onDisappearTmpBufOptBufResource.resourceId);
                onDisappearTmpBufOptBufArgsSerializer.writePointer(onDisappearTmpBufOptBufCall);
                onDisappearTmpBufOptBufArgsSerializer.writePointer(onDisappearTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, onDisappearTmpBufOptBufArgsSerializer.asBuffer(), onDisappearTmpBufOptBufArgsSerializer.length());
                onDisappearTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onDisappearTmpBufOptClosure, onDisappearTmpBufOptBufResource)
            onDisappearTmpBuf = onDisappearTmpBufOptClosure
        }
        const onDisappearTmpResult : (() => void) | undefined = onDisappearTmpBuf
        const aboutToAppearTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let aboutToAppearTmpBuf : (() => void) | undefined = undefined
        if ((aboutToAppearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const aboutToAppearTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const aboutToAppearTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const aboutToAppearTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const aboutToAppearTmpBufOptClosure  = ():void => {
                const aboutToAppearTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                aboutToAppearTmpBufOptBufArgsSerializer.writeInt32(aboutToAppearTmpBufOptBufResource.resourceId);
                aboutToAppearTmpBufOptBufArgsSerializer.writePointer(aboutToAppearTmpBufOptBufCall);
                aboutToAppearTmpBufOptBufArgsSerializer.writePointer(aboutToAppearTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, aboutToAppearTmpBufOptBufArgsSerializer.asBuffer(), aboutToAppearTmpBufOptBufArgsSerializer.length());
                aboutToAppearTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(aboutToAppearTmpBufOptClosure, aboutToAppearTmpBufOptBufResource)
            aboutToAppearTmpBuf = aboutToAppearTmpBufOptClosure
        }
        const aboutToAppearTmpResult : (() => void) | undefined = aboutToAppearTmpBuf
        const aboutToDisappearTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let aboutToDisappearTmpBuf : (() => void) | undefined = undefined
        if ((aboutToDisappearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const aboutToDisappearTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const aboutToDisappearTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const aboutToDisappearTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const aboutToDisappearTmpBufOptClosure  = ():void => {
                const aboutToDisappearTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                aboutToDisappearTmpBufOptBufArgsSerializer.writeInt32(aboutToDisappearTmpBufOptBufResource.resourceId);
                aboutToDisappearTmpBufOptBufArgsSerializer.writePointer(aboutToDisappearTmpBufOptBufCall);
                aboutToDisappearTmpBufOptBufArgsSerializer.writePointer(aboutToDisappearTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, aboutToDisappearTmpBufOptBufArgsSerializer.asBuffer(), aboutToDisappearTmpBufOptBufArgsSerializer.length());
                aboutToDisappearTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(aboutToDisappearTmpBufOptClosure, aboutToDisappearTmpBufOptBufResource)
            aboutToDisappearTmpBuf = aboutToDisappearTmpBufOptClosure
        }
        const aboutToDisappearTmpResult : (() => void) | undefined = aboutToDisappearTmpBuf
        const layoutRegionMarginTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let layoutRegionMarginTmpBuf : Margin | undefined = undefined
        if ((layoutRegionMarginTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            layoutRegionMarginTmpBuf = Padding_serializer.read(valueDeserializer)
        }
        const layoutRegionMarginTmpResult : Margin | undefined = layoutRegionMarginTmpBuf
        const previewAnimationOptionsTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let previewAnimationOptionsTmpBuf : ContextMenuAnimationOptions | undefined = undefined
        if ((previewAnimationOptionsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            previewAnimationOptionsTmpBuf = ContextMenuAnimationOptions_serializer.read(valueDeserializer)
        }
        const previewAnimationOptionsTmpResult : ContextMenuAnimationOptions | undefined = previewAnimationOptionsTmpBuf
        const backgroundColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let backgroundColorTmpBuf : ResourceColor | undefined = undefined
        if ((backgroundColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const backgroundColorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let backgroundColorTmpBufOpt : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (backgroundColorTmpBufOptUnionSelector == (0).toByte()) {
                backgroundColorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (backgroundColorTmpBufOptUnionSelector == (1).toByte()) {
                backgroundColorTmpBufOpt = valueDeserializer.readInt32()
            } else if (backgroundColorTmpBufOptUnionSelector == (2).toByte()) {
                backgroundColorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (backgroundColorTmpBufOptUnionSelector == (3).toByte()) {
                backgroundColorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for backgroundColorTmpBufOpt has to be chosen through deserialisation.')
            }
            backgroundColorTmpBuf = (backgroundColorTmpBufOpt as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
        }
        const backgroundColorTmpResult : ResourceColor | undefined = backgroundColorTmpBuf
        const backgroundBlurStyleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let backgroundBlurStyleTmpBuf : BlurStyle | undefined = undefined
        if ((backgroundBlurStyleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundBlurStyleTmpBuf = BlurStyle.fromValue(valueDeserializer.readInt32())
        }
        const backgroundBlurStyleTmpResult : BlurStyle | undefined = backgroundBlurStyleTmpBuf
        const backgroundBlurStyleOptionsTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let backgroundBlurStyleOptionsTmpBuf : BackgroundBlurStyleOptions | undefined = undefined
        if ((backgroundBlurStyleOptionsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundBlurStyleOptionsTmpBuf = BackgroundBlurStyleOptions_serializer.read(valueDeserializer)
        }
        const backgroundBlurStyleOptionsTmpResult : BackgroundBlurStyleOptions | undefined = backgroundBlurStyleOptionsTmpBuf
        const backgroundEffectTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let backgroundEffectTmpBuf : BackgroundEffectOptions | undefined = undefined
        if ((backgroundEffectTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundEffectTmpBuf = BackgroundEffectOptions_serializer.read(valueDeserializer)
        }
        const backgroundEffectTmpResult : BackgroundEffectOptions | undefined = backgroundEffectTmpBuf
        const transitionTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let transitionTmpBuf : TransitionEffect | undefined = undefined
        if ((transitionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            transitionTmpBuf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transitionTmpResult : TransitionEffect | undefined = transitionTmpBuf
        const enableHoverModeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let enableHoverModeTmpBuf : boolean | undefined = undefined
        if ((enableHoverModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableHoverModeTmpBuf = valueDeserializer.readBoolean()
        }
        const enableHoverModeTmpResult : boolean | undefined = enableHoverModeTmpBuf
        const outlineColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let outlineColorTmpBuf : ResourceColor | EdgeColors | undefined = undefined
        if ((outlineColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const outlineColorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let outlineColorTmpBufOpt : ResourceColor | EdgeColors | undefined
            if (outlineColorTmpBufOptUnionSelector == (0).toByte()) {
                const outlineColorTmpBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                let outlineColorTmpBufOptBufU : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
                if (outlineColorTmpBufOptBufUUnionSelector == (0).toByte()) {
                    outlineColorTmpBufOptBufU = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
                } else if (outlineColorTmpBufOptBufUUnionSelector == (1).toByte()) {
                    outlineColorTmpBufOptBufU = valueDeserializer.readInt32()
                } else if (outlineColorTmpBufOptBufUUnionSelector == (2).toByte()) {
                    outlineColorTmpBufOptBufU = (valueDeserializer.readString() as string)
                } else if (outlineColorTmpBufOptBufUUnionSelector == (3).toByte()) {
                    outlineColorTmpBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error('One of the branches for outlineColorTmpBufOptBufU has to be chosen through deserialisation.')
                }
                outlineColorTmpBufOpt = (outlineColorTmpBufOptBufU as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
            } else if (outlineColorTmpBufOptUnionSelector == (1).toByte()) {
                outlineColorTmpBufOpt = EdgeColors_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for outlineColorTmpBufOpt has to be chosen through deserialisation.')
            }
            outlineColorTmpBuf = (outlineColorTmpBufOpt as ResourceColor | EdgeColors)
        }
        const outlineColorTmpResult : ResourceColor | EdgeColors | undefined = outlineColorTmpBuf
        const outlineWidthTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let outlineWidthTmpBuf : Dimension | EdgeOutlineWidths | undefined = undefined
        if ((outlineWidthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const outlineWidthTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let outlineWidthTmpBufOpt : Dimension | EdgeOutlineWidths | undefined
            if (outlineWidthTmpBufOptUnionSelector == (0).toByte()) {
                const outlineWidthTmpBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                let outlineWidthTmpBufOptBufU : string | number | global_resource_Resource | undefined
                if (outlineWidthTmpBufOptBufUUnionSelector == (0).toByte()) {
                    outlineWidthTmpBufOptBufU = (valueDeserializer.readString() as string)
                } else if (outlineWidthTmpBufOptBufUUnionSelector == (1).toByte()) {
                    outlineWidthTmpBufOptBufU = (valueDeserializer.readNumber() as number)
                } else if (outlineWidthTmpBufOptBufUUnionSelector == (2).toByte()) {
                    outlineWidthTmpBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error('One of the branches for outlineWidthTmpBufOptBufU has to be chosen through deserialisation.')
                }
                outlineWidthTmpBufOpt = (outlineWidthTmpBufOptBufU as string | number | global_resource_Resource)
            } else if (outlineWidthTmpBufOptUnionSelector == (1).toByte()) {
                outlineWidthTmpBufOpt = EdgeOutlineWidths_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for outlineWidthTmpBufOpt has to be chosen through deserialisation.')
            }
            outlineWidthTmpBuf = (outlineWidthTmpBufOpt as Dimension | EdgeOutlineWidths)
        }
        const outlineWidthTmpResult : Dimension | EdgeOutlineWidths | undefined = outlineWidthTmpBuf
        const hapticFeedbackModeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let hapticFeedbackModeTmpBuf : HapticFeedbackMode | undefined = undefined
        if ((hapticFeedbackModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            hapticFeedbackModeTmpBuf = HapticFeedbackMode.fromValue(valueDeserializer.readInt32())
        }
        const hapticFeedbackModeTmpResult : HapticFeedbackMode | undefined = hapticFeedbackModeTmpBuf
        const titleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let titleTmpBuf : arkui_component_units_ResourceStr | undefined = undefined
        if ((titleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const titleTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let titleTmpBufOpt : string | arkui_component_units_Resource | undefined
            if (titleTmpBufOptUnionSelector == (0).toByte()) {
                titleTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (titleTmpBufOptUnionSelector == (1).toByte()) {
                titleTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for titleTmpBufOpt has to be chosen through deserialisation.')
            }
            titleTmpBuf = (titleTmpBufOpt as string | arkui_component_units_Resource)
        }
        const titleTmpResult : arkui_component_units_ResourceStr | undefined = titleTmpBuf
        const showInSubWindowTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let showInSubWindowTmpBuf : boolean | undefined = undefined
        if ((showInSubWindowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            showInSubWindowTmpBuf = valueDeserializer.readBoolean()
        }
        const showInSubWindowTmpResult : boolean | undefined = showInSubWindowTmpBuf
        let value : MenuOptions = ({offset: offsetTmpResult, placement: placementTmpResult, enableArrow: enableArrowTmpResult, arrowOffset: arrowOffsetTmpResult, preview: previewTmpResult, previewBorderRadius: previewBorderRadiusTmpResult, borderRadius: borderRadiusTmpResult, onAppear: onAppearTmpResult, onDisappear: onDisappearTmpResult, aboutToAppear: aboutToAppearTmpResult, aboutToDisappear: aboutToDisappearTmpResult, layoutRegionMargin: layoutRegionMarginTmpResult, previewAnimationOptions: previewAnimationOptionsTmpResult, backgroundColor: backgroundColorTmpResult, backgroundBlurStyle: backgroundBlurStyleTmpResult, backgroundBlurStyleOptions: backgroundBlurStyleOptionsTmpResult, backgroundEffect: backgroundEffectTmpResult, transition: transitionTmpResult, enableHoverMode: enableHoverModeTmpResult, outlineColor: outlineColorTmpResult, outlineWidth: outlineWidthTmpResult, hapticFeedbackMode: hapticFeedbackModeTmpResult, title: titleTmpResult, showInSubWindow: showInSubWindowTmpResult} as MenuOptions)
        return value
    }
}
export class PickerDialogButtonStyle_serializer {
    public static write(buffer: SerializerBase, value: PickerDialogButtonStyle): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForType  = value.type
        if (valueHolderForType !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTypeTmpValue  = (valueHolderForType as ButtonType)
            valueSerializer.writeInt32(valueHolderForTypeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForStyle  = value.style
        if (valueHolderForStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForStyleTmpValue  = (valueHolderForStyle as ButtonStyleMode)
            valueSerializer.writeInt32(valueHolderForStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRole  = value.role
        if (valueHolderForRole !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRoleTmpValue  = (valueHolderForRole as ButtonRole)
            valueSerializer.writeInt32(valueHolderForRoleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFontSize  = value.fontSize
        if (valueHolderForFontSize !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFontSizeTmpValue  = valueHolderForFontSize!
            if (valueHolderForFontSizeTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForFontSizeTmpValueForIdx0  = valueHolderForFontSizeTmpValue as string
                valueSerializer.writeString(valueHolderForFontSizeTmpValueForIdx0)
            } else if (valueHolderForFontSizeTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForFontSizeTmpValueForIdx1  = valueHolderForFontSizeTmpValue as double
                valueSerializer.writeFloat64(valueHolderForFontSizeTmpValueForIdx1)
            } else if (valueHolderForFontSizeTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForFontSizeTmpValueForIdx2  = valueHolderForFontSizeTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForFontSizeTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFontColor  = value.fontColor
        if (valueHolderForFontColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFontColorTmpValue  = valueHolderForFontColor!
            if (valueHolderForFontColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForFontColorTmpValueForIdx0  = valueHolderForFontColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForFontColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForFontColorTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForFontColorTmpValueForIdx1  = valueHolderForFontColorTmpValue as int32
                valueSerializer.writeInt32(valueHolderForFontColorTmpValueForIdx1)
            } else if (valueHolderForFontColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForFontColorTmpValueForIdx2  = valueHolderForFontColorTmpValue as string
                valueSerializer.writeString(valueHolderForFontColorTmpValueForIdx2)
            } else if (valueHolderForFontColorTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForFontColorTmpValueForIdx3  = valueHolderForFontColorTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForFontColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFontWeight  = value.fontWeight
        if (valueHolderForFontWeight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFontWeightTmpValue  = valueHolderForFontWeight!
            if (valueHolderForFontWeightTmpValue instanceof FontWeight) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForFontWeightTmpValueForIdx0  = valueHolderForFontWeightTmpValue as FontWeight
                valueSerializer.writeInt32(valueHolderForFontWeightTmpValueForIdx0.valueOf())
            } else if (valueHolderForFontWeightTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForFontWeightTmpValueForIdx1  = valueHolderForFontWeightTmpValue as int32
                valueSerializer.writeInt32(valueHolderForFontWeightTmpValueForIdx1)
            } else if (valueHolderForFontWeightTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForFontWeightTmpValueForIdx2  = valueHolderForFontWeightTmpValue as string
                valueSerializer.writeString(valueHolderForFontWeightTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFontStyle  = value.fontStyle
        if (valueHolderForFontStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFontStyleTmpValue  = (valueHolderForFontStyle as FontStyle)
            valueSerializer.writeInt32(valueHolderForFontStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFontFamily  = value.fontFamily
        if (valueHolderForFontFamily !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFontFamilyTmpValue  = valueHolderForFontFamily!
            if (valueHolderForFontFamilyTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForFontFamilyTmpValueForIdx0  = valueHolderForFontFamilyTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForFontFamilyTmpValueForIdx0)
            } else if (valueHolderForFontFamilyTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForFontFamilyTmpValueForIdx1  = valueHolderForFontFamilyTmpValue as string
                valueSerializer.writeString(valueHolderForFontFamilyTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundColor  = value.backgroundColor
        if (valueHolderForBackgroundColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundColorTmpValue  = valueHolderForBackgroundColor!
            if (valueHolderForBackgroundColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx0  = valueHolderForBackgroundColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForBackgroundColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForBackgroundColorTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx1  = valueHolderForBackgroundColorTmpValue as int32
                valueSerializer.writeInt32(valueHolderForBackgroundColorTmpValueForIdx1)
            } else if (valueHolderForBackgroundColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx2  = valueHolderForBackgroundColorTmpValue as string
                valueSerializer.writeString(valueHolderForBackgroundColorTmpValueForIdx2)
            } else if (valueHolderForBackgroundColorTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx3  = valueHolderForBackgroundColorTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForBackgroundColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBorderRadius  = value.borderRadius
        if (valueHolderForBorderRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBorderRadiusTmpValue  = valueHolderForBorderRadius!
            if (valueHolderForBorderRadiusTmpValue instanceof Length) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBorderRadiusTmpValueForIdx0  = valueHolderForBorderRadiusTmpValue as Length
                if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx0  = valueHolderForBorderRadiusTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForBorderRadiusTmpValueForIdx0ForIdx0)
                } else if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof double) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx1  = valueHolderForBorderRadiusTmpValueForIdx0 as double
                    valueSerializer.writeFloat64(valueHolderForBorderRadiusTmpValueForIdx0ForIdx1)
                } else if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx2  = valueHolderForBorderRadiusTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(valueSerializer, valueHolderForBorderRadiusTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForBorderRadiusTmpValue instanceof BorderRadiuses) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBorderRadiusTmpValueForIdx1  = valueHolderForBorderRadiusTmpValue as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, valueHolderForBorderRadiusTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPrimary  = value.primary
        if (valueHolderForPrimary !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPrimaryTmpValue  = valueHolderForPrimary!
            valueSerializer.writeBoolean(valueHolderForPrimaryTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PickerDialogButtonStyle {
        let valueDeserializer : DeserializerBase = buffer
        const typeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let typeTmpBuf : ButtonType | undefined = undefined
        if ((typeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            typeTmpBuf = ButtonType.fromValue(valueDeserializer.readInt32())
        }
        const typeTmpResult : ButtonType | undefined = typeTmpBuf
        const styleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let styleTmpBuf : ButtonStyleMode | undefined = undefined
        if ((styleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            styleTmpBuf = ButtonStyleMode.fromValue(valueDeserializer.readInt32())
        }
        const styleTmpResult : ButtonStyleMode | undefined = styleTmpBuf
        const roleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let roleTmpBuf : ButtonRole | undefined = undefined
        if ((roleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            roleTmpBuf = ButtonRole.fromValue(valueDeserializer.readInt32())
        }
        const roleTmpResult : ButtonRole | undefined = roleTmpBuf
        const fontSizeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let fontSizeTmpBuf : Length | undefined = undefined
        if ((fontSizeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const fontSizeTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let fontSizeTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (fontSizeTmpBufOptUnionSelector == (0).toByte()) {
                fontSizeTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (fontSizeTmpBufOptUnionSelector == (1).toByte()) {
                fontSizeTmpBufOpt = valueDeserializer.readFloat64()
            } else if (fontSizeTmpBufOptUnionSelector == (2).toByte()) {
                fontSizeTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for fontSizeTmpBufOpt has to be chosen through deserialisation.')
            }
            fontSizeTmpBuf = (fontSizeTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const fontSizeTmpResult : Length | undefined = fontSizeTmpBuf
        const fontColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let fontColorTmpBuf : ResourceColor | undefined = undefined
        if ((fontColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const fontColorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let fontColorTmpBufOpt : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (fontColorTmpBufOptUnionSelector == (0).toByte()) {
                fontColorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (fontColorTmpBufOptUnionSelector == (1).toByte()) {
                fontColorTmpBufOpt = valueDeserializer.readInt32()
            } else if (fontColorTmpBufOptUnionSelector == (2).toByte()) {
                fontColorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (fontColorTmpBufOptUnionSelector == (3).toByte()) {
                fontColorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for fontColorTmpBufOpt has to be chosen through deserialisation.')
            }
            fontColorTmpBuf = (fontColorTmpBufOpt as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
        }
        const fontColorTmpResult : ResourceColor | undefined = fontColorTmpBuf
        const fontWeightTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let fontWeightTmpBuf : FontWeight | int32 | string | undefined = undefined
        if ((fontWeightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const fontWeightTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let fontWeightTmpBufOpt : FontWeight | int32 | string | undefined
            if (fontWeightTmpBufOptUnionSelector == (0).toByte()) {
                fontWeightTmpBufOpt = FontWeight.fromValue(valueDeserializer.readInt32())
            } else if (fontWeightTmpBufOptUnionSelector == (1).toByte()) {
                fontWeightTmpBufOpt = valueDeserializer.readInt32()
            } else if (fontWeightTmpBufOptUnionSelector == (2).toByte()) {
                fontWeightTmpBufOpt = (valueDeserializer.readString() as string)
            } else {
                throw new Error('One of the branches for fontWeightTmpBufOpt has to be chosen through deserialisation.')
            }
            fontWeightTmpBuf = (fontWeightTmpBufOpt as FontWeight | int32 | string)
        }
        const fontWeightTmpResult : FontWeight | int32 | string | undefined = fontWeightTmpBuf
        const fontStyleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let fontStyleTmpBuf : FontStyle | undefined = undefined
        if ((fontStyleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            fontStyleTmpBuf = FontStyle.fromValue(valueDeserializer.readInt32())
        }
        const fontStyleTmpResult : FontStyle | undefined = fontStyleTmpBuf
        const fontFamilyTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let fontFamilyTmpBuf : global_resource_Resource | string | undefined = undefined
        if ((fontFamilyTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const fontFamilyTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let fontFamilyTmpBufOpt : global_resource_Resource | string | undefined
            if (fontFamilyTmpBufOptUnionSelector == (0).toByte()) {
                fontFamilyTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else if (fontFamilyTmpBufOptUnionSelector == (1).toByte()) {
                fontFamilyTmpBufOpt = (valueDeserializer.readString() as string)
            } else {
                throw new Error('One of the branches for fontFamilyTmpBufOpt has to be chosen through deserialisation.')
            }
            fontFamilyTmpBuf = (fontFamilyTmpBufOpt as global_resource_Resource | string)
        }
        const fontFamilyTmpResult : global_resource_Resource | string | undefined = fontFamilyTmpBuf
        const backgroundColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let backgroundColorTmpBuf : ResourceColor | undefined = undefined
        if ((backgroundColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const backgroundColorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let backgroundColorTmpBufOpt : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (backgroundColorTmpBufOptUnionSelector == (0).toByte()) {
                backgroundColorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (backgroundColorTmpBufOptUnionSelector == (1).toByte()) {
                backgroundColorTmpBufOpt = valueDeserializer.readInt32()
            } else if (backgroundColorTmpBufOptUnionSelector == (2).toByte()) {
                backgroundColorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (backgroundColorTmpBufOptUnionSelector == (3).toByte()) {
                backgroundColorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for backgroundColorTmpBufOpt has to be chosen through deserialisation.')
            }
            backgroundColorTmpBuf = (backgroundColorTmpBufOpt as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
        }
        const backgroundColorTmpResult : ResourceColor | undefined = backgroundColorTmpBuf
        const borderRadiusTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let borderRadiusTmpBuf : Length | BorderRadiuses | undefined = undefined
        if ((borderRadiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const borderRadiusTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let borderRadiusTmpBufOpt : Length | BorderRadiuses | undefined
            if (borderRadiusTmpBufOptUnionSelector == (0).toByte()) {
                const borderRadiusTmpBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                let borderRadiusTmpBufOptBufU : string | double | arkui_component_units_Resource | undefined
                if (borderRadiusTmpBufOptBufUUnionSelector == (0).toByte()) {
                    borderRadiusTmpBufOptBufU = (valueDeserializer.readString() as string)
                } else if (borderRadiusTmpBufOptBufUUnionSelector == (1).toByte()) {
                    borderRadiusTmpBufOptBufU = valueDeserializer.readFloat64()
                } else if (borderRadiusTmpBufOptBufUUnionSelector == (2).toByte()) {
                    borderRadiusTmpBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error('One of the branches for borderRadiusTmpBufOptBufU has to be chosen through deserialisation.')
                }
                borderRadiusTmpBufOpt = (borderRadiusTmpBufOptBufU as string | double | arkui_component_units_Resource)
            } else if (borderRadiusTmpBufOptUnionSelector == (1).toByte()) {
                borderRadiusTmpBufOpt = BorderRadiuses_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for borderRadiusTmpBufOpt has to be chosen through deserialisation.')
            }
            borderRadiusTmpBuf = (borderRadiusTmpBufOpt as Length | BorderRadiuses)
        }
        const borderRadiusTmpResult : Length | BorderRadiuses | undefined = borderRadiusTmpBuf
        const primaryTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let primaryTmpBuf : boolean | undefined = undefined
        if ((primaryTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            primaryTmpBuf = valueDeserializer.readBoolean()
        }
        const primaryTmpResult : boolean | undefined = primaryTmpBuf
        let value : PickerDialogButtonStyle = ({type: typeTmpResult, style: styleTmpResult, role: roleTmpResult, fontSize: fontSizeTmpResult, fontColor: fontColorTmpResult, fontWeight: fontWeightTmpResult, fontStyle: fontStyleTmpResult, fontFamily: fontFamilyTmpResult, backgroundColor: backgroundColorTmpResult, borderRadius: borderRadiusTmpResult, primary: primaryTmpResult} as PickerDialogButtonStyle)
        return value
    }
}
export class PickerTextStyle_serializer {
    public static write(buffer: SerializerBase, value: PickerTextStyle): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForColor  = value.color
        if (valueHolderForColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForColorTmpValue  = valueHolderForColor!
            if (valueHolderForColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorTmpValueForIdx0  = valueHolderForColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForColorTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorTmpValueForIdx1  = valueHolderForColorTmpValue as int32
                valueSerializer.writeInt32(valueHolderForColorTmpValueForIdx1)
            } else if (valueHolderForColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorTmpValueForIdx2  = valueHolderForColorTmpValue as string
                valueSerializer.writeString(valueHolderForColorTmpValueForIdx2)
            } else if (valueHolderForColorTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorTmpValueForIdx3  = valueHolderForColorTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFont  = value.font
        if (valueHolderForFont !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFontTmpValue  = valueHolderForFont!
            arkui_component_units_Font_serializer.write(valueSerializer, valueHolderForFontTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PickerTextStyle {
        let valueDeserializer : DeserializerBase = buffer
        const colorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let colorTmpBuf : ResourceColor | undefined = undefined
        if ((colorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const colorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let colorTmpBufOpt : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (colorTmpBufOptUnionSelector == (0).toByte()) {
                colorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (colorTmpBufOptUnionSelector == (1).toByte()) {
                colorTmpBufOpt = valueDeserializer.readInt32()
            } else if (colorTmpBufOptUnionSelector == (2).toByte()) {
                colorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (colorTmpBufOptUnionSelector == (3).toByte()) {
                colorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for colorTmpBufOpt has to be chosen through deserialisation.')
            }
            colorTmpBuf = (colorTmpBufOpt as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
        }
        const colorTmpResult : ResourceColor | undefined = colorTmpBuf
        const fontTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let fontTmpBuf : arkui_component_units_Font | undefined = undefined
        if ((fontTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            fontTmpBuf = arkui_component_units_Font_serializer.read(valueDeserializer)
        }
        const fontTmpResult : arkui_component_units_Font | undefined = fontTmpBuf
        let value : PickerTextStyle = ({color: colorTmpResult, font: fontTmpResult} as PickerTextStyle)
        return value
    }
}
export class PopupCommonOptions_serializer {
    public static write(buffer: SerializerBase, value: PopupCommonOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForPlacement  = value.placement
        if (valueHolderForPlacement !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPlacementTmpValue  = (valueHolderForPlacement as Placement)
            valueSerializer.writeInt32(valueHolderForPlacementTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPopupColor  = value.popupColor
        if (valueHolderForPopupColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPopupColorTmpValue  = valueHolderForPopupColor!
            if (valueHolderForPopupColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForPopupColorTmpValueForIdx0  = valueHolderForPopupColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForPopupColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForPopupColorTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForPopupColorTmpValueForIdx1  = valueHolderForPopupColorTmpValue as int32
                valueSerializer.writeInt32(valueHolderForPopupColorTmpValueForIdx1)
            } else if (valueHolderForPopupColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForPopupColorTmpValueForIdx2  = valueHolderForPopupColorTmpValue as string
                valueSerializer.writeString(valueHolderForPopupColorTmpValueForIdx2)
            } else if (valueHolderForPopupColorTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForPopupColorTmpValueForIdx3  = valueHolderForPopupColorTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForPopupColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableArrow  = value.enableArrow
        if (valueHolderForEnableArrow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableArrowTmpValue  = valueHolderForEnableArrow!
            valueSerializer.writeBoolean(valueHolderForEnableArrowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAutoCancel  = value.autoCancel
        if (valueHolderForAutoCancel !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAutoCancelTmpValue  = valueHolderForAutoCancel!
            valueSerializer.writeBoolean(valueHolderForAutoCancelTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnStateChange  = value.onStateChange
        if (valueHolderForOnStateChange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnStateChangeTmpValue  = valueHolderForOnStateChange!
            valueSerializer.holdAndWriteCallback(valueHolderForOnStateChangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowOffset  = value.arrowOffset
        if (valueHolderForArrowOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowOffsetTmpValue  = valueHolderForArrowOffset!
            if (valueHolderForArrowOffsetTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx0  = valueHolderForArrowOffsetTmpValue as string
                valueSerializer.writeString(valueHolderForArrowOffsetTmpValueForIdx0)
            } else if (valueHolderForArrowOffsetTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx1  = valueHolderForArrowOffsetTmpValue as double
                valueSerializer.writeFloat64(valueHolderForArrowOffsetTmpValueForIdx1)
            } else if (valueHolderForArrowOffsetTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx2  = valueHolderForArrowOffsetTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForArrowOffsetTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShowInSubWindow  = value.showInSubWindow
        if (valueHolderForShowInSubWindow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShowInSubWindowTmpValue  = valueHolderForShowInSubWindow!
            valueSerializer.writeBoolean(valueHolderForShowInSubWindowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMask  = value.mask
        if (valueHolderForMask !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMaskTmpValue  = valueHolderForMask!
            if (valueHolderForMaskTmpValue instanceof boolean) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForMaskTmpValueForIdx0  = valueHolderForMaskTmpValue as boolean
                valueSerializer.writeBoolean(valueHolderForMaskTmpValueForIdx0)
            } else if (valueHolderForMaskTmpValue instanceof PopupMaskType) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForMaskTmpValueForIdx1  = valueHolderForMaskTmpValue as PopupMaskType
                PopupMaskType_serializer.write(valueSerializer, valueHolderForMaskTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTargetSpace  = value.targetSpace
        if (valueHolderForTargetSpace !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTargetSpaceTmpValue  = valueHolderForTargetSpace!
            if (valueHolderForTargetSpaceTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx0  = valueHolderForTargetSpaceTmpValue as string
                valueSerializer.writeString(valueHolderForTargetSpaceTmpValueForIdx0)
            } else if (valueHolderForTargetSpaceTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx1  = valueHolderForTargetSpaceTmpValue as double
                valueSerializer.writeFloat64(valueHolderForTargetSpaceTmpValueForIdx1)
            } else if (valueHolderForTargetSpaceTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx2  = valueHolderForTargetSpaceTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForTargetSpaceTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOffset  = value.offset
        if (valueHolderForOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetTmpValue  = valueHolderForOffset!
            Position_serializer.write(valueSerializer, valueHolderForOffsetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForWidth  = value.width
        if (valueHolderForWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForWidthTmpValue  = valueHolderForWidth!
            if (valueHolderForWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForWidthTmpValueForIdx0  = valueHolderForWidthTmpValue as string
                valueSerializer.writeString(valueHolderForWidthTmpValueForIdx0)
            } else if (valueHolderForWidthTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForWidthTmpValueForIdx1  = valueHolderForWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForWidthTmpValueForIdx1)
            } else if (valueHolderForWidthTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForWidthTmpValueForIdx2  = valueHolderForWidthTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowPointPosition  = value.arrowPointPosition
        if (valueHolderForArrowPointPosition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowPointPositionTmpValue  = (valueHolderForArrowPointPosition as ArrowPointPosition)
            valueSerializer.writeInt32(valueHolderForArrowPointPositionTmpValue.getOrdinal())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowWidth  = value.arrowWidth
        if (valueHolderForArrowWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowWidthTmpValue  = valueHolderForArrowWidth!
            if (valueHolderForArrowWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowWidthTmpValueForIdx0  = valueHolderForArrowWidthTmpValue as string
                valueSerializer.writeString(valueHolderForArrowWidthTmpValueForIdx0)
            } else if (valueHolderForArrowWidthTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowWidthTmpValueForIdx1  = valueHolderForArrowWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowWidthTmpValueForIdx1)
            } else if (valueHolderForArrowWidthTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowWidthTmpValueForIdx2  = valueHolderForArrowWidthTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForArrowWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowHeight  = value.arrowHeight
        if (valueHolderForArrowHeight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowHeightTmpValue  = valueHolderForArrowHeight!
            if (valueHolderForArrowHeightTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowHeightTmpValueForIdx0  = valueHolderForArrowHeightTmpValue as string
                valueSerializer.writeString(valueHolderForArrowHeightTmpValueForIdx0)
            } else if (valueHolderForArrowHeightTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowHeightTmpValueForIdx1  = valueHolderForArrowHeightTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowHeightTmpValueForIdx1)
            } else if (valueHolderForArrowHeightTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowHeightTmpValueForIdx2  = valueHolderForArrowHeightTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForArrowHeightTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRadius  = value.radius
        if (valueHolderForRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRadiusTmpValue  = valueHolderForRadius!
            if (valueHolderForRadiusTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForRadiusTmpValueForIdx0  = valueHolderForRadiusTmpValue as string
                valueSerializer.writeString(valueHolderForRadiusTmpValueForIdx0)
            } else if (valueHolderForRadiusTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForRadiusTmpValueForIdx1  = valueHolderForRadiusTmpValue as number
                valueSerializer.writeNumber(valueHolderForRadiusTmpValueForIdx1)
            } else if (valueHolderForRadiusTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForRadiusTmpValueForIdx2  = valueHolderForRadiusTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForRadiusTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShadow  = value.shadow
        if (valueHolderForShadow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShadowTmpValue  = valueHolderForShadow!
            if (valueHolderForShadowTmpValue instanceof ShadowOptions) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForShadowTmpValueForIdx0  = valueHolderForShadowTmpValue as ShadowOptions
                ShadowOptions_serializer.write(valueSerializer, valueHolderForShadowTmpValueForIdx0)
            } else if (valueHolderForShadowTmpValue instanceof ShadowStyle) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForShadowTmpValueForIdx1  = valueHolderForShadowTmpValue as ShadowStyle
                valueSerializer.writeInt32(valueHolderForShadowTmpValueForIdx1.valueOf())
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundBlurStyle  = value.backgroundBlurStyle
        if (valueHolderForBackgroundBlurStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundBlurStyleTmpValue  = (valueHolderForBackgroundBlurStyle as BlurStyle)
            valueSerializer.writeInt32(valueHolderForBackgroundBlurStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFocusable  = value.focusable
        if (valueHolderForFocusable !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFocusableTmpValue  = valueHolderForFocusable!
            valueSerializer.writeBoolean(valueHolderForFocusableTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTransition  = value.transition
        if (valueHolderForTransition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTransitionTmpValue  = valueHolderForTransition!
            TransitionEffect_serializer.write(valueSerializer, valueHolderForTransitionTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillDismiss  = value.onWillDismiss
        if (valueHolderForOnWillDismiss !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillDismissTmpValue  = valueHolderForOnWillDismiss!
            if (valueHolderForOnWillDismissTmpValue instanceof boolean) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOnWillDismissTmpValueForIdx0  = valueHolderForOnWillDismissTmpValue as boolean
                valueSerializer.writeBoolean(valueHolderForOnWillDismissTmpValueForIdx0)
            } else if (valueHolderForOnWillDismissTmpValue instanceof Callback<DismissPopupAction, void>) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOnWillDismissTmpValueForIdx1  = valueHolderForOnWillDismissTmpValue as Callback<DismissPopupAction, void>
                valueSerializer.holdAndWriteCallback(valueHolderForOnWillDismissTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableHoverMode  = value.enableHoverMode
        if (valueHolderForEnableHoverMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableHoverModeTmpValue  = valueHolderForEnableHoverMode!
            valueSerializer.writeBoolean(valueHolderForEnableHoverModeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFollowTransformOfTarget  = value.followTransformOfTarget
        if (valueHolderForFollowTransformOfTarget !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFollowTransformOfTargetTmpValue  = valueHolderForFollowTransformOfTarget!
            valueSerializer.writeBoolean(valueHolderForFollowTransformOfTargetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PopupCommonOptions {
        let valueDeserializer : DeserializerBase = buffer
        const placementTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let placementTmpBuf : Placement | undefined = undefined
        if ((placementTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            placementTmpBuf = Placement.fromValue(valueDeserializer.readInt32())
        }
        const placementTmpResult : Placement | undefined = placementTmpBuf
        const popupColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let popupColorTmpBuf : ResourceColor | undefined = undefined
        if ((popupColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const popupColorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let popupColorTmpBufOpt : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (popupColorTmpBufOptUnionSelector == (0).toByte()) {
                popupColorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (popupColorTmpBufOptUnionSelector == (1).toByte()) {
                popupColorTmpBufOpt = valueDeserializer.readInt32()
            } else if (popupColorTmpBufOptUnionSelector == (2).toByte()) {
                popupColorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (popupColorTmpBufOptUnionSelector == (3).toByte()) {
                popupColorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for popupColorTmpBufOpt has to be chosen through deserialisation.')
            }
            popupColorTmpBuf = (popupColorTmpBufOpt as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
        }
        const popupColorTmpResult : ResourceColor | undefined = popupColorTmpBuf
        const enableArrowTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let enableArrowTmpBuf : boolean | undefined = undefined
        if ((enableArrowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableArrowTmpBuf = valueDeserializer.readBoolean()
        }
        const enableArrowTmpResult : boolean | undefined = enableArrowTmpBuf
        const autoCancelTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let autoCancelTmpBuf : boolean | undefined = undefined
        if ((autoCancelTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            autoCancelTmpBuf = valueDeserializer.readBoolean()
        }
        const autoCancelTmpResult : boolean | undefined = autoCancelTmpBuf
        const onStateChangeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onStateChangeTmpBuf : PopupStateChangeCallback | undefined = undefined
        if ((onStateChangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onStateChangeTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onStateChangeTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onStateChangeTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onStateChangeTmpBufOptClosure  = (event: PopupStateChangeParam):void => {
                const onStateChangeTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onStateChangeTmpBufOptBufArgsSerializer.writeInt32(onStateChangeTmpBufOptBufResource.resourceId);
                onStateChangeTmpBufOptBufArgsSerializer.writePointer(onStateChangeTmpBufOptBufCall);
                onStateChangeTmpBufOptBufArgsSerializer.writePointer(onStateChangeTmpBufOptBufCallSync);
                PopupStateChangeParam_serializer.write(onStateChangeTmpBufOptBufArgsSerializer, event);
                InteropNativeModule._CallCallbackSync(10, 1789299488, onStateChangeTmpBufOptBufArgsSerializer.asBuffer(), onStateChangeTmpBufOptBufArgsSerializer.length());
                onStateChangeTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onStateChangeTmpBufOptClosure, onStateChangeTmpBufOptBufResource)
            onStateChangeTmpBuf = onStateChangeTmpBufOptClosure
        }
        const onStateChangeTmpResult : PopupStateChangeCallback | undefined = onStateChangeTmpBuf
        const arrowOffsetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let arrowOffsetTmpBuf : Length | undefined = undefined
        if ((arrowOffsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowOffsetTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let arrowOffsetTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (arrowOffsetTmpBufOptUnionSelector == (0).toByte()) {
                arrowOffsetTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (arrowOffsetTmpBufOptUnionSelector == (1).toByte()) {
                arrowOffsetTmpBufOpt = valueDeserializer.readFloat64()
            } else if (arrowOffsetTmpBufOptUnionSelector == (2).toByte()) {
                arrowOffsetTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for arrowOffsetTmpBufOpt has to be chosen through deserialisation.')
            }
            arrowOffsetTmpBuf = (arrowOffsetTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const arrowOffsetTmpResult : Length | undefined = arrowOffsetTmpBuf
        const showInSubWindowTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let showInSubWindowTmpBuf : boolean | undefined = undefined
        if ((showInSubWindowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            showInSubWindowTmpBuf = valueDeserializer.readBoolean()
        }
        const showInSubWindowTmpResult : boolean | undefined = showInSubWindowTmpBuf
        const maskTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let maskTmpBuf : boolean | PopupMaskType | undefined = undefined
        if ((maskTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const maskTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let maskTmpBufOpt : boolean | PopupMaskType | undefined
            if (maskTmpBufOptUnionSelector == (0).toByte()) {
                maskTmpBufOpt = valueDeserializer.readBoolean()
            } else if (maskTmpBufOptUnionSelector == (1).toByte()) {
                maskTmpBufOpt = PopupMaskType_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for maskTmpBufOpt has to be chosen through deserialisation.')
            }
            maskTmpBuf = (maskTmpBufOpt as boolean | PopupMaskType)
        }
        const maskTmpResult : boolean | PopupMaskType | undefined = maskTmpBuf
        const targetSpaceTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let targetSpaceTmpBuf : Length | undefined = undefined
        if ((targetSpaceTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const targetSpaceTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let targetSpaceTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (targetSpaceTmpBufOptUnionSelector == (0).toByte()) {
                targetSpaceTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (targetSpaceTmpBufOptUnionSelector == (1).toByte()) {
                targetSpaceTmpBufOpt = valueDeserializer.readFloat64()
            } else if (targetSpaceTmpBufOptUnionSelector == (2).toByte()) {
                targetSpaceTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for targetSpaceTmpBufOpt has to be chosen through deserialisation.')
            }
            targetSpaceTmpBuf = (targetSpaceTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const targetSpaceTmpResult : Length | undefined = targetSpaceTmpBuf
        const offsetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let offsetTmpBuf : Position | undefined = undefined
        if ((offsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            offsetTmpBuf = Position_serializer.read(valueDeserializer)
        }
        const offsetTmpResult : Position | undefined = offsetTmpBuf
        const widthTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let widthTmpBuf : Dimension | undefined = undefined
        if ((widthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const widthTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let widthTmpBufOpt : string | number | global_resource_Resource | undefined
            if (widthTmpBufOptUnionSelector == (0).toByte()) {
                widthTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (widthTmpBufOptUnionSelector == (1).toByte()) {
                widthTmpBufOpt = (valueDeserializer.readNumber() as number)
            } else if (widthTmpBufOptUnionSelector == (2).toByte()) {
                widthTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for widthTmpBufOpt has to be chosen through deserialisation.')
            }
            widthTmpBuf = (widthTmpBufOpt as string | number | global_resource_Resource)
        }
        const widthTmpResult : Dimension | undefined = widthTmpBuf
        const arrowPointPositionTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let arrowPointPositionTmpBuf : ArrowPointPosition | undefined = undefined
        if ((arrowPointPositionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            arrowPointPositionTmpBuf = ArrowPointPosition.values()[valueDeserializer.readInt32()]
        }
        const arrowPointPositionTmpResult : ArrowPointPosition | undefined = arrowPointPositionTmpBuf
        const arrowWidthTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let arrowWidthTmpBuf : Dimension | undefined = undefined
        if ((arrowWidthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowWidthTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let arrowWidthTmpBufOpt : string | number | global_resource_Resource | undefined
            if (arrowWidthTmpBufOptUnionSelector == (0).toByte()) {
                arrowWidthTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (arrowWidthTmpBufOptUnionSelector == (1).toByte()) {
                arrowWidthTmpBufOpt = (valueDeserializer.readNumber() as number)
            } else if (arrowWidthTmpBufOptUnionSelector == (2).toByte()) {
                arrowWidthTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for arrowWidthTmpBufOpt has to be chosen through deserialisation.')
            }
            arrowWidthTmpBuf = (arrowWidthTmpBufOpt as string | number | global_resource_Resource)
        }
        const arrowWidthTmpResult : Dimension | undefined = arrowWidthTmpBuf
        const arrowHeightTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let arrowHeightTmpBuf : Dimension | undefined = undefined
        if ((arrowHeightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowHeightTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let arrowHeightTmpBufOpt : string | number | global_resource_Resource | undefined
            if (arrowHeightTmpBufOptUnionSelector == (0).toByte()) {
                arrowHeightTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (arrowHeightTmpBufOptUnionSelector == (1).toByte()) {
                arrowHeightTmpBufOpt = (valueDeserializer.readNumber() as number)
            } else if (arrowHeightTmpBufOptUnionSelector == (2).toByte()) {
                arrowHeightTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for arrowHeightTmpBufOpt has to be chosen through deserialisation.')
            }
            arrowHeightTmpBuf = (arrowHeightTmpBufOpt as string | number | global_resource_Resource)
        }
        const arrowHeightTmpResult : Dimension | undefined = arrowHeightTmpBuf
        const radiusTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let radiusTmpBuf : Dimension | undefined = undefined
        if ((radiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const radiusTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let radiusTmpBufOpt : string | number | global_resource_Resource | undefined
            if (radiusTmpBufOptUnionSelector == (0).toByte()) {
                radiusTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (radiusTmpBufOptUnionSelector == (1).toByte()) {
                radiusTmpBufOpt = (valueDeserializer.readNumber() as number)
            } else if (radiusTmpBufOptUnionSelector == (2).toByte()) {
                radiusTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for radiusTmpBufOpt has to be chosen through deserialisation.')
            }
            radiusTmpBuf = (radiusTmpBufOpt as string | number | global_resource_Resource)
        }
        const radiusTmpResult : Dimension | undefined = radiusTmpBuf
        const shadowTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let shadowTmpBuf : ShadowOptions | ShadowStyle | undefined = undefined
        if ((shadowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const shadowTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let shadowTmpBufOpt : ShadowOptions | ShadowStyle | undefined
            if (shadowTmpBufOptUnionSelector == (0).toByte()) {
                shadowTmpBufOpt = ShadowOptions_serializer.read(valueDeserializer)
            } else if (shadowTmpBufOptUnionSelector == (1).toByte()) {
                shadowTmpBufOpt = ShadowStyle.fromValue(valueDeserializer.readInt32())
            } else {
                throw new Error('One of the branches for shadowTmpBufOpt has to be chosen through deserialisation.')
            }
            shadowTmpBuf = (shadowTmpBufOpt as ShadowOptions | ShadowStyle)
        }
        const shadowTmpResult : ShadowOptions | ShadowStyle | undefined = shadowTmpBuf
        const backgroundBlurStyleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let backgroundBlurStyleTmpBuf : BlurStyle | undefined = undefined
        if ((backgroundBlurStyleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundBlurStyleTmpBuf = BlurStyle.fromValue(valueDeserializer.readInt32())
        }
        const backgroundBlurStyleTmpResult : BlurStyle | undefined = backgroundBlurStyleTmpBuf
        const focusableTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let focusableTmpBuf : boolean | undefined = undefined
        if ((focusableTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            focusableTmpBuf = valueDeserializer.readBoolean()
        }
        const focusableTmpResult : boolean | undefined = focusableTmpBuf
        const transitionTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let transitionTmpBuf : TransitionEffect | undefined = undefined
        if ((transitionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            transitionTmpBuf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transitionTmpResult : TransitionEffect | undefined = transitionTmpBuf
        const onWillDismissTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onWillDismissTmpBuf : boolean | Callback<DismissPopupAction, void> | undefined = undefined
        if ((onWillDismissTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillDismissTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let onWillDismissTmpBufOpt : boolean | Callback<DismissPopupAction, void> | undefined
            if (onWillDismissTmpBufOptUnionSelector == (0).toByte()) {
                onWillDismissTmpBufOpt = valueDeserializer.readBoolean()
            } else if (onWillDismissTmpBufOptUnionSelector == (1).toByte()) {
                const onWillDismissTmpBufOptBufUBufResource : CallbackResource = valueDeserializer.readCallbackResource()
                const onWillDismissTmpBufOptBufUBufCall : KPointer = valueDeserializer.readPointer()
                const onWillDismissTmpBufOptBufUBufCallSync : KPointer = valueDeserializer.readPointer()
                const onWillDismissTmpBufOptBufUClosure  = (data: DismissPopupAction):void => {
                    const onWillDismissTmpBufOptBufUBufArgsSerializer : SerializerBase = SerializerBase.hold();
                    onWillDismissTmpBufOptBufUBufArgsSerializer.writeInt32(onWillDismissTmpBufOptBufUBufResource.resourceId);
                    onWillDismissTmpBufOptBufUBufArgsSerializer.writePointer(onWillDismissTmpBufOptBufUBufCall);
                    onWillDismissTmpBufOptBufUBufArgsSerializer.writePointer(onWillDismissTmpBufOptBufUBufCallSync);
                    DismissPopupAction_serializer.write(onWillDismissTmpBufOptBufUBufArgsSerializer, data);
                    InteropNativeModule._CallCallbackSync(10, 1691355745, onWillDismissTmpBufOptBufUBufArgsSerializer.asBuffer(), onWillDismissTmpBufOptBufUBufArgsSerializer.length());
                    onWillDismissTmpBufOptBufUBufArgsSerializer.release();
                    return;
                }
                resourceFinalizerRegister(onWillDismissTmpBufOptBufUClosure, onWillDismissTmpBufOptBufUBufResource)
                onWillDismissTmpBufOpt = onWillDismissTmpBufOptBufUClosure
            } else {
                throw new Error('One of the branches for onWillDismissTmpBufOpt has to be chosen through deserialisation.')
            }
            onWillDismissTmpBuf = (onWillDismissTmpBufOpt as boolean | Callback<DismissPopupAction, void>)
        }
        const onWillDismissTmpResult : boolean | Callback<DismissPopupAction, void> | undefined = onWillDismissTmpBuf
        const enableHoverModeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let enableHoverModeTmpBuf : boolean | undefined = undefined
        if ((enableHoverModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableHoverModeTmpBuf = valueDeserializer.readBoolean()
        }
        const enableHoverModeTmpResult : boolean | undefined = enableHoverModeTmpBuf
        const followTransformOfTargetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let followTransformOfTargetTmpBuf : boolean | undefined = undefined
        if ((followTransformOfTargetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            followTransformOfTargetTmpBuf = valueDeserializer.readBoolean()
        }
        const followTransformOfTargetTmpResult : boolean | undefined = followTransformOfTargetTmpBuf
        let value : PopupCommonOptions = ({placement: placementTmpResult, popupColor: popupColorTmpResult, enableArrow: enableArrowTmpResult, autoCancel: autoCancelTmpResult, onStateChange: onStateChangeTmpResult, arrowOffset: arrowOffsetTmpResult, showInSubWindow: showInSubWindowTmpResult, mask: maskTmpResult, targetSpace: targetSpaceTmpResult, offset: offsetTmpResult, width: widthTmpResult, arrowPointPosition: arrowPointPositionTmpResult, arrowWidth: arrowWidthTmpResult, arrowHeight: arrowHeightTmpResult, radius: radiusTmpResult, shadow: shadowTmpResult, backgroundBlurStyle: backgroundBlurStyleTmpResult, focusable: focusableTmpResult, transition: transitionTmpResult, onWillDismiss: onWillDismissTmpResult, enableHoverMode: enableHoverModeTmpResult, followTransformOfTarget: followTransformOfTargetTmpResult} as PopupCommonOptions)
        return value
    }
}
export class PopupMessageOptions_serializer {
    public static write(buffer: SerializerBase, value: PopupMessageOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForTextColor  = value.textColor
        if (valueHolderForTextColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTextColorTmpValue  = valueHolderForTextColor!
            if (valueHolderForTextColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForTextColorTmpValueForIdx0  = valueHolderForTextColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForTextColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForTextColorTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForTextColorTmpValueForIdx1  = valueHolderForTextColorTmpValue as int32
                valueSerializer.writeInt32(valueHolderForTextColorTmpValueForIdx1)
            } else if (valueHolderForTextColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForTextColorTmpValueForIdx2  = valueHolderForTextColorTmpValue as string
                valueSerializer.writeString(valueHolderForTextColorTmpValueForIdx2)
            } else if (valueHolderForTextColorTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForTextColorTmpValueForIdx3  = valueHolderForTextColorTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForTextColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFont  = value.font
        if (valueHolderForFont !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFontTmpValue  = valueHolderForFont!
            arkui_component_units_Font_serializer.write(valueSerializer, valueHolderForFontTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PopupMessageOptions {
        let valueDeserializer : DeserializerBase = buffer
        const textColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let textColorTmpBuf : ResourceColor | undefined = undefined
        if ((textColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const textColorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let textColorTmpBufOpt : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (textColorTmpBufOptUnionSelector == (0).toByte()) {
                textColorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (textColorTmpBufOptUnionSelector == (1).toByte()) {
                textColorTmpBufOpt = valueDeserializer.readInt32()
            } else if (textColorTmpBufOptUnionSelector == (2).toByte()) {
                textColorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (textColorTmpBufOptUnionSelector == (3).toByte()) {
                textColorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for textColorTmpBufOpt has to be chosen through deserialisation.')
            }
            textColorTmpBuf = (textColorTmpBufOpt as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
        }
        const textColorTmpResult : ResourceColor | undefined = textColorTmpBuf
        const fontTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let fontTmpBuf : arkui_component_units_Font | undefined = undefined
        if ((fontTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            fontTmpBuf = arkui_component_units_Font_serializer.read(valueDeserializer)
        }
        const fontTmpResult : arkui_component_units_Font | undefined = fontTmpBuf
        let value : PopupMessageOptions = ({textColor: textColorTmpResult, font: fontTmpResult} as PopupMessageOptions)
        return value
    }
}
export class SheetOptions_serializer {
    public static write(buffer: SerializerBase, value: SheetOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForBackgroundColor  = value.backgroundColor
        if (valueHolderForBackgroundColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundColorTmpValue  = valueHolderForBackgroundColor!
            if (valueHolderForBackgroundColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx0  = valueHolderForBackgroundColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForBackgroundColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForBackgroundColorTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx1  = valueHolderForBackgroundColorTmpValue as int32
                valueSerializer.writeInt32(valueHolderForBackgroundColorTmpValueForIdx1)
            } else if (valueHolderForBackgroundColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx2  = valueHolderForBackgroundColorTmpValue as string
                valueSerializer.writeString(valueHolderForBackgroundColorTmpValueForIdx2)
            } else if (valueHolderForBackgroundColorTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx3  = valueHolderForBackgroundColorTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForBackgroundColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnAppear  = value.onAppear
        if (valueHolderForOnAppear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnAppearTmpValue  = valueHolderForOnAppear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnAppearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnDisappear  = value.onDisappear
        if (valueHolderForOnDisappear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnDisappearTmpValue  = valueHolderForOnDisappear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnDisappearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillAppear  = value.onWillAppear
        if (valueHolderForOnWillAppear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillAppearTmpValue  = valueHolderForOnWillAppear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnWillAppearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillDisappear  = value.onWillDisappear
        if (valueHolderForOnWillDisappear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillDisappearTmpValue  = valueHolderForOnWillDisappear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnWillDisappearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHeight  = value.height
        if (valueHolderForHeight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHeightTmpValue  = valueHolderForHeight!
            if (valueHolderForHeightTmpValue instanceof SheetSize) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForHeightTmpValueForIdx0  = valueHolderForHeightTmpValue as SheetSize
                valueSerializer.writeInt32(valueHolderForHeightTmpValueForIdx0.valueOf())
            } else if (valueHolderForHeightTmpValue instanceof Length) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForHeightTmpValueForIdx1  = valueHolderForHeightTmpValue as Length
                if (valueHolderForHeightTmpValueForIdx1 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForHeightTmpValueForIdx1ForIdx0  = valueHolderForHeightTmpValueForIdx1 as string
                    valueSerializer.writeString(valueHolderForHeightTmpValueForIdx1ForIdx0)
                } else if (valueHolderForHeightTmpValueForIdx1 instanceof double) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForHeightTmpValueForIdx1ForIdx1  = valueHolderForHeightTmpValueForIdx1 as double
                    valueSerializer.writeFloat64(valueHolderForHeightTmpValueForIdx1ForIdx1)
                } else if (valueHolderForHeightTmpValueForIdx1 instanceof arkui_component_units_Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForHeightTmpValueForIdx1ForIdx2  = valueHolderForHeightTmpValueForIdx1 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(valueSerializer, valueHolderForHeightTmpValueForIdx1ForIdx2)
                }
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDragBar  = value.dragBar
        if (valueHolderForDragBar !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDragBarTmpValue  = valueHolderForDragBar!
            valueSerializer.writeBoolean(valueHolderForDragBarTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMaskColor  = value.maskColor
        if (valueHolderForMaskColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMaskColorTmpValue  = valueHolderForMaskColor!
            if (valueHolderForMaskColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForMaskColorTmpValueForIdx0  = valueHolderForMaskColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForMaskColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForMaskColorTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForMaskColorTmpValueForIdx1  = valueHolderForMaskColorTmpValue as int32
                valueSerializer.writeInt32(valueHolderForMaskColorTmpValueForIdx1)
            } else if (valueHolderForMaskColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForMaskColorTmpValueForIdx2  = valueHolderForMaskColorTmpValue as string
                valueSerializer.writeString(valueHolderForMaskColorTmpValueForIdx2)
            } else if (valueHolderForMaskColorTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForMaskColorTmpValueForIdx3  = valueHolderForMaskColorTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForMaskColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDetents  = value.detents
        if (valueHolderForDetents !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDetentsTmpValue  = valueHolderForDetents!
            const valueHolderForDetentsTmpValue_0  = valueHolderForDetentsTmpValue[0]
            if (valueHolderForDetentsTmpValue_0 instanceof SheetSize) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForDetentsTmpValue_0ForIdx0  = valueHolderForDetentsTmpValue_0 as SheetSize
                valueSerializer.writeInt32(valueHolderForDetentsTmpValue_0ForIdx0.valueOf())
            } else if (valueHolderForDetentsTmpValue_0 instanceof Length) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForDetentsTmpValue_0ForIdx1  = valueHolderForDetentsTmpValue_0 as Length
                if (valueHolderForDetentsTmpValue_0ForIdx1 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForDetentsTmpValue_0ForIdx1ForIdx0  = valueHolderForDetentsTmpValue_0ForIdx1 as string
                    valueSerializer.writeString(valueHolderForDetentsTmpValue_0ForIdx1ForIdx0)
                } else if (valueHolderForDetentsTmpValue_0ForIdx1 instanceof double) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForDetentsTmpValue_0ForIdx1ForIdx1  = valueHolderForDetentsTmpValue_0ForIdx1 as double
                    valueSerializer.writeFloat64(valueHolderForDetentsTmpValue_0ForIdx1ForIdx1)
                } else if (valueHolderForDetentsTmpValue_0ForIdx1 instanceof arkui_component_units_Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForDetentsTmpValue_0ForIdx1ForIdx2  = valueHolderForDetentsTmpValue_0ForIdx1 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(valueSerializer, valueHolderForDetentsTmpValue_0ForIdx1ForIdx2)
                }
            }
            const valueHolderForDetentsTmpValue_1  = valueHolderForDetentsTmpValue[1]
            if (valueHolderForDetentsTmpValue_1 !== undefined) {
                valueSerializer.writeInt8(RuntimeType.OBJECT)
                const valueHolderForDetentsTmpValue_1TmpValue  = valueHolderForDetentsTmpValue_1!
                if (valueHolderForDetentsTmpValue_1TmpValue instanceof SheetSize) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForDetentsTmpValue_1TmpValueForIdx0  = valueHolderForDetentsTmpValue_1TmpValue as SheetSize
                    valueSerializer.writeInt32(valueHolderForDetentsTmpValue_1TmpValueForIdx0.valueOf())
                } else if (valueHolderForDetentsTmpValue_1TmpValue instanceof Length) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForDetentsTmpValue_1TmpValueForIdx1  = valueHolderForDetentsTmpValue_1TmpValue as Length
                    if (valueHolderForDetentsTmpValue_1TmpValueForIdx1 instanceof string) {
                        valueSerializer.writeInt8((0).toByte())
                        const valueHolderForDetentsTmpValue_1TmpValueForIdx1ForIdx0  = valueHolderForDetentsTmpValue_1TmpValueForIdx1 as string
                        valueSerializer.writeString(valueHolderForDetentsTmpValue_1TmpValueForIdx1ForIdx0)
                    } else if (valueHolderForDetentsTmpValue_1TmpValueForIdx1 instanceof double) {
                        valueSerializer.writeInt8((1).toByte())
                        const valueHolderForDetentsTmpValue_1TmpValueForIdx1ForIdx1  = valueHolderForDetentsTmpValue_1TmpValueForIdx1 as double
                        valueSerializer.writeFloat64(valueHolderForDetentsTmpValue_1TmpValueForIdx1ForIdx1)
                    } else if (valueHolderForDetentsTmpValue_1TmpValueForIdx1 instanceof arkui_component_units_Resource) {
                        valueSerializer.writeInt8((2).toByte())
                        const valueHolderForDetentsTmpValue_1TmpValueForIdx1ForIdx2  = valueHolderForDetentsTmpValue_1TmpValueForIdx1 as arkui_component_units_Resource
                        global_resource_Resource_serializer.write(valueSerializer, valueHolderForDetentsTmpValue_1TmpValueForIdx1ForIdx2)
                    }
                }
            } else {
                valueSerializer.writeInt8(RuntimeType.UNDEFINED)
            }
            const valueHolderForDetentsTmpValue_2  = valueHolderForDetentsTmpValue[2]
            if (valueHolderForDetentsTmpValue_2 !== undefined) {
                valueSerializer.writeInt8(RuntimeType.OBJECT)
                const valueHolderForDetentsTmpValue_2TmpValue  = valueHolderForDetentsTmpValue_2!
                if (valueHolderForDetentsTmpValue_2TmpValue instanceof SheetSize) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForDetentsTmpValue_2TmpValueForIdx0  = valueHolderForDetentsTmpValue_2TmpValue as SheetSize
                    valueSerializer.writeInt32(valueHolderForDetentsTmpValue_2TmpValueForIdx0.valueOf())
                } else if (valueHolderForDetentsTmpValue_2TmpValue instanceof Length) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForDetentsTmpValue_2TmpValueForIdx1  = valueHolderForDetentsTmpValue_2TmpValue as Length
                    if (valueHolderForDetentsTmpValue_2TmpValueForIdx1 instanceof string) {
                        valueSerializer.writeInt8((0).toByte())
                        const valueHolderForDetentsTmpValue_2TmpValueForIdx1ForIdx0  = valueHolderForDetentsTmpValue_2TmpValueForIdx1 as string
                        valueSerializer.writeString(valueHolderForDetentsTmpValue_2TmpValueForIdx1ForIdx0)
                    } else if (valueHolderForDetentsTmpValue_2TmpValueForIdx1 instanceof double) {
                        valueSerializer.writeInt8((1).toByte())
                        const valueHolderForDetentsTmpValue_2TmpValueForIdx1ForIdx1  = valueHolderForDetentsTmpValue_2TmpValueForIdx1 as double
                        valueSerializer.writeFloat64(valueHolderForDetentsTmpValue_2TmpValueForIdx1ForIdx1)
                    } else if (valueHolderForDetentsTmpValue_2TmpValueForIdx1 instanceof arkui_component_units_Resource) {
                        valueSerializer.writeInt8((2).toByte())
                        const valueHolderForDetentsTmpValue_2TmpValueForIdx1ForIdx2  = valueHolderForDetentsTmpValue_2TmpValueForIdx1 as arkui_component_units_Resource
                        global_resource_Resource_serializer.write(valueSerializer, valueHolderForDetentsTmpValue_2TmpValueForIdx1ForIdx2)
                    }
                }
            } else {
                valueSerializer.writeInt8(RuntimeType.UNDEFINED)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBlurStyle  = value.blurStyle
        if (valueHolderForBlurStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBlurStyleTmpValue  = (valueHolderForBlurStyle as BlurStyle)
            valueSerializer.writeInt32(valueHolderForBlurStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShowClose  = value.showClose
        if (valueHolderForShowClose !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShowCloseTmpValue  = valueHolderForShowClose!
            if (valueHolderForShowCloseTmpValue instanceof boolean) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForShowCloseTmpValueForIdx0  = valueHolderForShowCloseTmpValue as boolean
                valueSerializer.writeBoolean(valueHolderForShowCloseTmpValueForIdx0)
            } else if (valueHolderForShowCloseTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForShowCloseTmpValueForIdx1  = valueHolderForShowCloseTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForShowCloseTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPreferType  = value.preferType
        if (valueHolderForPreferType !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPreferTypeTmpValue  = (valueHolderForPreferType as SheetType)
            valueSerializer.writeInt32(valueHolderForPreferTypeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTitle  = value.title
        if (valueHolderForTitle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTitleTmpValue  = valueHolderForTitle!
            if (valueHolderForTitleTmpValue instanceof SheetTitleOptions) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForTitleTmpValueForIdx0  = valueHolderForTitleTmpValue as SheetTitleOptions
                SheetTitleOptions_serializer.write(valueSerializer, valueHolderForTitleTmpValueForIdx0)
            } else if (valueHolderForTitleTmpValue instanceof CustomBuilder) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForTitleTmpValueForIdx1  = valueHolderForTitleTmpValue as CustomBuilder
                valueSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(valueHolderForTitleTmpValueForIdx1))
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShouldDismiss  = value.shouldDismiss
        if (valueHolderForShouldDismiss !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShouldDismissTmpValue  = valueHolderForShouldDismiss!
            valueSerializer.holdAndWriteCallback(valueHolderForShouldDismissTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillDismiss  = value.onWillDismiss
        if (valueHolderForOnWillDismiss !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillDismissTmpValue  = valueHolderForOnWillDismiss!
            valueSerializer.holdAndWriteCallback(valueHolderForOnWillDismissTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillSpringBackWhenDismiss  = value.onWillSpringBackWhenDismiss
        if (valueHolderForOnWillSpringBackWhenDismiss !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillSpringBackWhenDismissTmpValue  = valueHolderForOnWillSpringBackWhenDismiss!
            valueSerializer.holdAndWriteCallback(valueHolderForOnWillSpringBackWhenDismissTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableOutsideInteractive  = value.enableOutsideInteractive
        if (valueHolderForEnableOutsideInteractive !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableOutsideInteractiveTmpValue  = valueHolderForEnableOutsideInteractive!
            valueSerializer.writeBoolean(valueHolderForEnableOutsideInteractiveTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForWidth  = value.width
        if (valueHolderForWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForWidthTmpValue  = valueHolderForWidth!
            if (valueHolderForWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForWidthTmpValueForIdx0  = valueHolderForWidthTmpValue as string
                valueSerializer.writeString(valueHolderForWidthTmpValueForIdx0)
            } else if (valueHolderForWidthTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForWidthTmpValueForIdx1  = valueHolderForWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForWidthTmpValueForIdx1)
            } else if (valueHolderForWidthTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForWidthTmpValueForIdx2  = valueHolderForWidthTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBorderWidth  = value.borderWidth
        if (valueHolderForBorderWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBorderWidthTmpValue  = valueHolderForBorderWidth!
            if (valueHolderForBorderWidthTmpValue instanceof Dimension) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBorderWidthTmpValueForIdx0  = valueHolderForBorderWidthTmpValue as Dimension
                if (valueHolderForBorderWidthTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForBorderWidthTmpValueForIdx0ForIdx0  = valueHolderForBorderWidthTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForBorderWidthTmpValueForIdx0ForIdx0)
                } else if (valueHolderForBorderWidthTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForBorderWidthTmpValueForIdx0ForIdx1  = valueHolderForBorderWidthTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForBorderWidthTmpValueForIdx0ForIdx1)
                } else if (valueHolderForBorderWidthTmpValueForIdx0 instanceof global_resource_Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForBorderWidthTmpValueForIdx0ForIdx2  = valueHolderForBorderWidthTmpValueForIdx0 as global_resource_Resource
                    global_resource_Resource_serializer.write(valueSerializer, valueHolderForBorderWidthTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForBorderWidthTmpValue instanceof EdgeWidths) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBorderWidthTmpValueForIdx1  = valueHolderForBorderWidthTmpValue as EdgeWidths
                EdgeWidths_serializer.write(valueSerializer, valueHolderForBorderWidthTmpValueForIdx1)
            } else if (valueHolderForBorderWidthTmpValue instanceof LocalizedEdgeWidths) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBorderWidthTmpValueForIdx2  = valueHolderForBorderWidthTmpValue as LocalizedEdgeWidths
                LocalizedEdgeWidths_serializer.write(valueSerializer, valueHolderForBorderWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBorderColor  = value.borderColor
        if (valueHolderForBorderColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBorderColorTmpValue  = valueHolderForBorderColor!
            if (valueHolderForBorderColorTmpValue instanceof ResourceColor) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBorderColorTmpValueForIdx0  = valueHolderForBorderColorTmpValue as ResourceColor
                if (valueHolderForBorderColorTmpValueForIdx0 instanceof arkui_component_enums_Color) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForBorderColorTmpValueForIdx0ForIdx0  = valueHolderForBorderColorTmpValueForIdx0 as arkui_component_enums_Color
                    valueSerializer.writeInt32((valueHolderForBorderColorTmpValueForIdx0ForIdx0.getOrdinal()) % (12))
                } else if (valueHolderForBorderColorTmpValueForIdx0 instanceof int32) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForBorderColorTmpValueForIdx0ForIdx1  = valueHolderForBorderColorTmpValueForIdx0 as int32
                    valueSerializer.writeInt32(valueHolderForBorderColorTmpValueForIdx0ForIdx1)
                } else if (valueHolderForBorderColorTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForBorderColorTmpValueForIdx0ForIdx2  = valueHolderForBorderColorTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForBorderColorTmpValueForIdx0ForIdx2)
                } else if (valueHolderForBorderColorTmpValueForIdx0 instanceof arkui_component_units_Resource) {
                    valueSerializer.writeInt8((3).toByte())
                    const valueHolderForBorderColorTmpValueForIdx0ForIdx3  = valueHolderForBorderColorTmpValueForIdx0 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(valueSerializer, valueHolderForBorderColorTmpValueForIdx0ForIdx3)
                }
            } else if (valueHolderForBorderColorTmpValue instanceof EdgeColors) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBorderColorTmpValueForIdx1  = valueHolderForBorderColorTmpValue as EdgeColors
                EdgeColors_serializer.write(valueSerializer, valueHolderForBorderColorTmpValueForIdx1)
            } else if (valueHolderForBorderColorTmpValue instanceof LocalizedEdgeColors) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBorderColorTmpValueForIdx2  = valueHolderForBorderColorTmpValue as LocalizedEdgeColors
                LocalizedEdgeColors_serializer.write(valueSerializer, valueHolderForBorderColorTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBorderStyle  = value.borderStyle
        if (valueHolderForBorderStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBorderStyleTmpValue  = valueHolderForBorderStyle!
            if (valueHolderForBorderStyleTmpValue instanceof BorderStyle) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBorderStyleTmpValueForIdx0  = valueHolderForBorderStyleTmpValue as BorderStyle
                valueSerializer.writeInt32(valueHolderForBorderStyleTmpValueForIdx0.valueOf())
            } else if (valueHolderForBorderStyleTmpValue instanceof EdgeStyles) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBorderStyleTmpValueForIdx1  = valueHolderForBorderStyleTmpValue as EdgeStyles
                EdgeStyles_serializer.write(valueSerializer, valueHolderForBorderStyleTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShadow  = value.shadow
        if (valueHolderForShadow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShadowTmpValue  = valueHolderForShadow!
            if (valueHolderForShadowTmpValue instanceof ShadowOptions) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForShadowTmpValueForIdx0  = valueHolderForShadowTmpValue as ShadowOptions
                ShadowOptions_serializer.write(valueSerializer, valueHolderForShadowTmpValueForIdx0)
            } else if (valueHolderForShadowTmpValue instanceof ShadowStyle) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForShadowTmpValueForIdx1  = valueHolderForShadowTmpValue as ShadowStyle
                valueSerializer.writeInt32(valueHolderForShadowTmpValueForIdx1.valueOf())
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnHeightDidChange  = value.onHeightDidChange
        if (valueHolderForOnHeightDidChange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnHeightDidChangeTmpValue  = valueHolderForOnHeightDidChange!
            valueSerializer.holdAndWriteCallback(valueHolderForOnHeightDidChangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMode  = value.mode
        if (valueHolderForMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForModeTmpValue  = (valueHolderForMode as SheetMode)
            valueSerializer.writeInt32(valueHolderForModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForScrollSizeMode  = value.scrollSizeMode
        if (valueHolderForScrollSizeMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForScrollSizeModeTmpValue  = (valueHolderForScrollSizeMode as ScrollSizeMode)
            valueSerializer.writeInt32(valueHolderForScrollSizeModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnDetentsDidChange  = value.onDetentsDidChange
        if (valueHolderForOnDetentsDidChange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnDetentsDidChangeTmpValue  = valueHolderForOnDetentsDidChange!
            valueSerializer.holdAndWriteCallback(valueHolderForOnDetentsDidChangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWidthDidChange  = value.onWidthDidChange
        if (valueHolderForOnWidthDidChange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWidthDidChangeTmpValue  = valueHolderForOnWidthDidChange!
            valueSerializer.holdAndWriteCallback(valueHolderForOnWidthDidChangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnTypeDidChange  = value.onTypeDidChange
        if (valueHolderForOnTypeDidChange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnTypeDidChangeTmpValue  = valueHolderForOnTypeDidChange!
            valueSerializer.holdAndWriteCallback(valueHolderForOnTypeDidChangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForUiContext  = value.uiContext
        if (valueHolderForUiContext !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForUiContextTmpValue  = valueHolderForUiContext!
            ohos_arkui_UIContext_UIContext_serializer.write(valueSerializer, valueHolderForUiContextTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForKeyboardAvoidMode  = value.keyboardAvoidMode
        if (valueHolderForKeyboardAvoidMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForKeyboardAvoidModeTmpValue  = (valueHolderForKeyboardAvoidMode as SheetKeyboardAvoidMode)
            valueSerializer.writeInt32(valueHolderForKeyboardAvoidModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableHoverMode  = value.enableHoverMode
        if (valueHolderForEnableHoverMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableHoverModeTmpValue  = valueHolderForEnableHoverMode!
            valueSerializer.writeBoolean(valueHolderForEnableHoverModeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHoverModeArea  = value.hoverModeArea
        if (valueHolderForHoverModeArea !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHoverModeAreaTmpValue  = (valueHolderForHoverModeArea as HoverModeAreaType)
            valueSerializer.writeInt32(valueHolderForHoverModeAreaTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOffset  = value.offset
        if (valueHolderForOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetTmpValue  = valueHolderForOffset!
            Position_serializer.write(valueSerializer, valueHolderForOffsetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEffectEdge  = value.effectEdge
        if (valueHolderForEffectEdge !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEffectEdgeTmpValue  = valueHolderForEffectEdge!
            valueSerializer.writeInt32(valueHolderForEffectEdgeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRadius  = value.radius
        if (valueHolderForRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRadiusTmpValue  = valueHolderForRadius!
            if (valueHolderForRadiusTmpValue instanceof arkui_Graphics_LengthMetrics) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForRadiusTmpValueForIdx0  = valueHolderForRadiusTmpValue as arkui_Graphics_LengthMetrics
                arkui_Graphics_LengthMetrics_serializer.write(valueSerializer, valueHolderForRadiusTmpValueForIdx0)
            } else if (valueHolderForRadiusTmpValue instanceof BorderRadiuses) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForRadiusTmpValueForIdx1  = valueHolderForRadiusTmpValue as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, valueHolderForRadiusTmpValueForIdx1)
            } else if (valueHolderForRadiusTmpValue instanceof LocalizedBorderRadiuses) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForRadiusTmpValueForIdx2  = valueHolderForRadiusTmpValue as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(valueSerializer, valueHolderForRadiusTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDetentSelection  = value.detentSelection
        if (valueHolderForDetentSelection !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDetentSelectionTmpValue  = valueHolderForDetentSelection!
            if (valueHolderForDetentSelectionTmpValue instanceof SheetSize) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForDetentSelectionTmpValueForIdx0  = valueHolderForDetentSelectionTmpValue as SheetSize
                valueSerializer.writeInt32(valueHolderForDetentSelectionTmpValueForIdx0.valueOf())
            } else if (valueHolderForDetentSelectionTmpValue instanceof Length) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForDetentSelectionTmpValueForIdx1  = valueHolderForDetentSelectionTmpValue as Length
                if (valueHolderForDetentSelectionTmpValueForIdx1 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForDetentSelectionTmpValueForIdx1ForIdx0  = valueHolderForDetentSelectionTmpValueForIdx1 as string
                    valueSerializer.writeString(valueHolderForDetentSelectionTmpValueForIdx1ForIdx0)
                } else if (valueHolderForDetentSelectionTmpValueForIdx1 instanceof double) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForDetentSelectionTmpValueForIdx1ForIdx1  = valueHolderForDetentSelectionTmpValueForIdx1 as double
                    valueSerializer.writeFloat64(valueHolderForDetentSelectionTmpValueForIdx1ForIdx1)
                } else if (valueHolderForDetentSelectionTmpValueForIdx1 instanceof arkui_component_units_Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForDetentSelectionTmpValueForIdx1ForIdx2  = valueHolderForDetentSelectionTmpValueForIdx1 as arkui_component_units_Resource
                    global_resource_Resource_serializer.write(valueSerializer, valueHolderForDetentSelectionTmpValueForIdx1ForIdx2)
                }
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShowInSubWindow  = value.showInSubWindow
        if (valueHolderForShowInSubWindow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShowInSubWindowTmpValue  = valueHolderForShowInSubWindow!
            valueSerializer.writeBoolean(valueHolderForShowInSubWindowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPlacement  = value.placement
        if (valueHolderForPlacement !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPlacementTmpValue  = (valueHolderForPlacement as Placement)
            valueSerializer.writeInt32(valueHolderForPlacementTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPlacementOnTarget  = value.placementOnTarget
        if (valueHolderForPlacementOnTarget !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPlacementOnTargetTmpValue  = valueHolderForPlacementOnTarget!
            valueSerializer.writeBoolean(valueHolderForPlacementOnTargetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): SheetOptions {
        let valueDeserializer : DeserializerBase = buffer
        const backgroundColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let backgroundColorTmpBuf : ResourceColor | undefined = undefined
        if ((backgroundColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const backgroundColorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let backgroundColorTmpBufOpt : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (backgroundColorTmpBufOptUnionSelector == (0).toByte()) {
                backgroundColorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (backgroundColorTmpBufOptUnionSelector == (1).toByte()) {
                backgroundColorTmpBufOpt = valueDeserializer.readInt32()
            } else if (backgroundColorTmpBufOptUnionSelector == (2).toByte()) {
                backgroundColorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (backgroundColorTmpBufOptUnionSelector == (3).toByte()) {
                backgroundColorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for backgroundColorTmpBufOpt has to be chosen through deserialisation.')
            }
            backgroundColorTmpBuf = (backgroundColorTmpBufOpt as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
        }
        const backgroundColorTmpResult : ResourceColor | undefined = backgroundColorTmpBuf
        const onAppearTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onAppearTmpBuf : (() => void) | undefined = undefined
        if ((onAppearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onAppearTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onAppearTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onAppearTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onAppearTmpBufOptClosure  = ():void => {
                const onAppearTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onAppearTmpBufOptBufArgsSerializer.writeInt32(onAppearTmpBufOptBufResource.resourceId);
                onAppearTmpBufOptBufArgsSerializer.writePointer(onAppearTmpBufOptBufCall);
                onAppearTmpBufOptBufArgsSerializer.writePointer(onAppearTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, onAppearTmpBufOptBufArgsSerializer.asBuffer(), onAppearTmpBufOptBufArgsSerializer.length());
                onAppearTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onAppearTmpBufOptClosure, onAppearTmpBufOptBufResource)
            onAppearTmpBuf = onAppearTmpBufOptClosure
        }
        const onAppearTmpResult : (() => void) | undefined = onAppearTmpBuf
        const onDisappearTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onDisappearTmpBuf : (() => void) | undefined = undefined
        if ((onDisappearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onDisappearTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDisappearTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onDisappearTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onDisappearTmpBufOptClosure  = ():void => {
                const onDisappearTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onDisappearTmpBufOptBufArgsSerializer.writeInt32(onDisappearTmpBufOptBufResource.resourceId);
                onDisappearTmpBufOptBufArgsSerializer.writePointer(onDisappearTmpBufOptBufCall);
                onDisappearTmpBufOptBufArgsSerializer.writePointer(onDisappearTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, onDisappearTmpBufOptBufArgsSerializer.asBuffer(), onDisappearTmpBufOptBufArgsSerializer.length());
                onDisappearTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onDisappearTmpBufOptClosure, onDisappearTmpBufOptBufResource)
            onDisappearTmpBuf = onDisappearTmpBufOptClosure
        }
        const onDisappearTmpResult : (() => void) | undefined = onDisappearTmpBuf
        const onWillAppearTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onWillAppearTmpBuf : (() => void) | undefined = undefined
        if ((onWillAppearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillAppearTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillAppearTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onWillAppearTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onWillAppearTmpBufOptClosure  = ():void => {
                const onWillAppearTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onWillAppearTmpBufOptBufArgsSerializer.writeInt32(onWillAppearTmpBufOptBufResource.resourceId);
                onWillAppearTmpBufOptBufArgsSerializer.writePointer(onWillAppearTmpBufOptBufCall);
                onWillAppearTmpBufOptBufArgsSerializer.writePointer(onWillAppearTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, onWillAppearTmpBufOptBufArgsSerializer.asBuffer(), onWillAppearTmpBufOptBufArgsSerializer.length());
                onWillAppearTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onWillAppearTmpBufOptClosure, onWillAppearTmpBufOptBufResource)
            onWillAppearTmpBuf = onWillAppearTmpBufOptClosure
        }
        const onWillAppearTmpResult : (() => void) | undefined = onWillAppearTmpBuf
        const onWillDisappearTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onWillDisappearTmpBuf : (() => void) | undefined = undefined
        if ((onWillDisappearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillDisappearTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillDisappearTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onWillDisappearTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onWillDisappearTmpBufOptClosure  = ():void => {
                const onWillDisappearTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onWillDisappearTmpBufOptBufArgsSerializer.writeInt32(onWillDisappearTmpBufOptBufResource.resourceId);
                onWillDisappearTmpBufOptBufArgsSerializer.writePointer(onWillDisappearTmpBufOptBufCall);
                onWillDisappearTmpBufOptBufArgsSerializer.writePointer(onWillDisappearTmpBufOptBufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1225416436, onWillDisappearTmpBufOptBufArgsSerializer.asBuffer(), onWillDisappearTmpBufOptBufArgsSerializer.length());
                onWillDisappearTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onWillDisappearTmpBufOptClosure, onWillDisappearTmpBufOptBufResource)
            onWillDisappearTmpBuf = onWillDisappearTmpBufOptClosure
        }
        const onWillDisappearTmpResult : (() => void) | undefined = onWillDisappearTmpBuf
        const heightTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let heightTmpBuf : SheetSize | Length | undefined = undefined
        if ((heightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const heightTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let heightTmpBufOpt : SheetSize | Length | undefined
            if (heightTmpBufOptUnionSelector == (0).toByte()) {
                heightTmpBufOpt = SheetSize.fromValue(valueDeserializer.readInt32())
            } else if (heightTmpBufOptUnionSelector == (1).toByte()) {
                const heightTmpBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                let heightTmpBufOptBufU : string | double | arkui_component_units_Resource | undefined
                if (heightTmpBufOptBufUUnionSelector == (0).toByte()) {
                    heightTmpBufOptBufU = (valueDeserializer.readString() as string)
                } else if (heightTmpBufOptBufUUnionSelector == (1).toByte()) {
                    heightTmpBufOptBufU = valueDeserializer.readFloat64()
                } else if (heightTmpBufOptBufUUnionSelector == (2).toByte()) {
                    heightTmpBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error('One of the branches for heightTmpBufOptBufU has to be chosen through deserialisation.')
                }
                heightTmpBufOpt = (heightTmpBufOptBufU as string | double | arkui_component_units_Resource)
            } else {
                throw new Error('One of the branches for heightTmpBufOpt has to be chosen through deserialisation.')
            }
            heightTmpBuf = (heightTmpBufOpt as SheetSize | Length)
        }
        const heightTmpResult : SheetSize | Length | undefined = heightTmpBuf
        const dragBarTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let dragBarTmpBuf : boolean | undefined = undefined
        if ((dragBarTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            dragBarTmpBuf = valueDeserializer.readBoolean()
        }
        const dragBarTmpResult : boolean | undefined = dragBarTmpBuf
        const maskColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let maskColorTmpBuf : ResourceColor | undefined = undefined
        if ((maskColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const maskColorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let maskColorTmpBufOpt : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
            if (maskColorTmpBufOptUnionSelector == (0).toByte()) {
                maskColorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (maskColorTmpBufOptUnionSelector == (1).toByte()) {
                maskColorTmpBufOpt = valueDeserializer.readInt32()
            } else if (maskColorTmpBufOptUnionSelector == (2).toByte()) {
                maskColorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (maskColorTmpBufOptUnionSelector == (3).toByte()) {
                maskColorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for maskColorTmpBufOpt has to be chosen through deserialisation.')
            }
            maskColorTmpBuf = (maskColorTmpBufOpt as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
        }
        const maskColorTmpResult : ResourceColor | undefined = maskColorTmpBuf
        const detentsTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let detentsTmpBuf : TripleLengthDetents | undefined = undefined
        if ((detentsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const detentsTmpBufOptValue0TempBufUnionSelector : int32 = valueDeserializer.readInt8()
            let detentsTmpBufOptValue0TempBuf : SheetSize | Length | undefined
            if (detentsTmpBufOptValue0TempBufUnionSelector == (0).toByte()) {
                detentsTmpBufOptValue0TempBuf = SheetSize.fromValue(valueDeserializer.readInt32())
            } else if (detentsTmpBufOptValue0TempBufUnionSelector == (1).toByte()) {
                const detentsTmpBufOptValue0TempBufBufUUnionSelector : int32 = valueDeserializer.readInt8()
                let detentsTmpBufOptValue0TempBufBufU : string | double | arkui_component_units_Resource | undefined
                if (detentsTmpBufOptValue0TempBufBufUUnionSelector == (0).toByte()) {
                    detentsTmpBufOptValue0TempBufBufU = (valueDeserializer.readString() as string)
                } else if (detentsTmpBufOptValue0TempBufBufUUnionSelector == (1).toByte()) {
                    detentsTmpBufOptValue0TempBufBufU = valueDeserializer.readFloat64()
                } else if (detentsTmpBufOptValue0TempBufBufUUnionSelector == (2).toByte()) {
                    detentsTmpBufOptValue0TempBufBufU = global_resource_Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error('One of the branches for detentsTmpBufOptValue0TempBufBufU has to be chosen through deserialisation.')
                }
                detentsTmpBufOptValue0TempBuf = (detentsTmpBufOptValue0TempBufBufU as string | double | arkui_component_units_Resource)
            } else {
                throw new Error('One of the branches for detentsTmpBufOptValue0TempBuf has to be chosen through deserialisation.')
            }
            const detentsTmpBufOptValue0 : SheetSize | Length = (detentsTmpBufOptValue0TempBuf as SheetSize | Length)
            const detentsTmpBufOptValue1TempBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
            let detentsTmpBufOptValue1TempBuf : SheetSize | Length | undefined = undefined
            if ((detentsTmpBufOptValue1TempBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
                const detentsTmpBufOptValue1TempBufOptUnionSelector : int32 = valueDeserializer.readInt8()
                let detentsTmpBufOptValue1TempBufOpt : SheetSize | Length | undefined
                if (detentsTmpBufOptValue1TempBufOptUnionSelector == (0).toByte()) {
                    detentsTmpBufOptValue1TempBufOpt = SheetSize.fromValue(valueDeserializer.readInt32())
                } else if (detentsTmpBufOptValue1TempBufOptUnionSelector == (1).toByte()) {
                    const detentsTmpBufOptValue1TempBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                    let detentsTmpBufOptValue1TempBufOptBufU : string | double | arkui_component_units_Resource | undefined
                    if (detentsTmpBufOptValue1TempBufOptBufUUnionSelector == (0).toByte()) {
                        detentsTmpBufOptValue1TempBufOptBufU = (valueDeserializer.readString() as string)
                    } else if (detentsTmpBufOptValue1TempBufOptBufUUnionSelector == (1).toByte()) {
                        detentsTmpBufOptValue1TempBufOptBufU = valueDeserializer.readFloat64()
                    } else if (detentsTmpBufOptValue1TempBufOptBufUUnionSelector == (2).toByte()) {
                        detentsTmpBufOptValue1TempBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                    } else {
                        throw new Error('One of the branches for detentsTmpBufOptValue1TempBufOptBufU has to be chosen through deserialisation.')
                    }
                    detentsTmpBufOptValue1TempBufOpt = (detentsTmpBufOptValue1TempBufOptBufU as string | double | arkui_component_units_Resource)
                } else {
                    throw new Error('One of the branches for detentsTmpBufOptValue1TempBufOpt has to be chosen through deserialisation.')
                }
                detentsTmpBufOptValue1TempBuf = (detentsTmpBufOptValue1TempBufOpt as SheetSize | Length)
            }
            const detentsTmpBufOptValue1 : SheetSize | Length | undefined = detentsTmpBufOptValue1TempBuf
            const detentsTmpBufOptValue2TempBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
            let detentsTmpBufOptValue2TempBuf : SheetSize | Length | undefined = undefined
            if ((detentsTmpBufOptValue2TempBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
                const detentsTmpBufOptValue2TempBufOptUnionSelector : int32 = valueDeserializer.readInt8()
                let detentsTmpBufOptValue2TempBufOpt : SheetSize | Length | undefined
                if (detentsTmpBufOptValue2TempBufOptUnionSelector == (0).toByte()) {
                    detentsTmpBufOptValue2TempBufOpt = SheetSize.fromValue(valueDeserializer.readInt32())
                } else if (detentsTmpBufOptValue2TempBufOptUnionSelector == (1).toByte()) {
                    const detentsTmpBufOptValue2TempBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                    let detentsTmpBufOptValue2TempBufOptBufU : string | double | arkui_component_units_Resource | undefined
                    if (detentsTmpBufOptValue2TempBufOptBufUUnionSelector == (0).toByte()) {
                        detentsTmpBufOptValue2TempBufOptBufU = (valueDeserializer.readString() as string)
                    } else if (detentsTmpBufOptValue2TempBufOptBufUUnionSelector == (1).toByte()) {
                        detentsTmpBufOptValue2TempBufOptBufU = valueDeserializer.readFloat64()
                    } else if (detentsTmpBufOptValue2TempBufOptBufUUnionSelector == (2).toByte()) {
                        detentsTmpBufOptValue2TempBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                    } else {
                        throw new Error('One of the branches for detentsTmpBufOptValue2TempBufOptBufU has to be chosen through deserialisation.')
                    }
                    detentsTmpBufOptValue2TempBufOpt = (detentsTmpBufOptValue2TempBufOptBufU as string | double | arkui_component_units_Resource)
                } else {
                    throw new Error('One of the branches for detentsTmpBufOptValue2TempBufOpt has to be chosen through deserialisation.')
                }
                detentsTmpBufOptValue2TempBuf = (detentsTmpBufOptValue2TempBufOpt as SheetSize | Length)
            }
            const detentsTmpBufOptValue2 : SheetSize | Length | undefined = detentsTmpBufOptValue2TempBuf
            detentsTmpBuf = ([detentsTmpBufOptValue0, detentsTmpBufOptValue1, detentsTmpBufOptValue2] as TripleLengthDetents)
        }
        const detentsTmpResult : TripleLengthDetents | undefined = detentsTmpBuf
        const blurStyleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let blurStyleTmpBuf : BlurStyle | undefined = undefined
        if ((blurStyleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            blurStyleTmpBuf = BlurStyle.fromValue(valueDeserializer.readInt32())
        }
        const blurStyleTmpResult : BlurStyle | undefined = blurStyleTmpBuf
        const showCloseTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let showCloseTmpBuf : boolean | global_resource_Resource | undefined = undefined
        if ((showCloseTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const showCloseTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let showCloseTmpBufOpt : boolean | global_resource_Resource | undefined
            if (showCloseTmpBufOptUnionSelector == (0).toByte()) {
                showCloseTmpBufOpt = valueDeserializer.readBoolean()
            } else if (showCloseTmpBufOptUnionSelector == (1).toByte()) {
                showCloseTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for showCloseTmpBufOpt has to be chosen through deserialisation.')
            }
            showCloseTmpBuf = (showCloseTmpBufOpt as boolean | global_resource_Resource)
        }
        const showCloseTmpResult : boolean | global_resource_Resource | undefined = showCloseTmpBuf
        const preferTypeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let preferTypeTmpBuf : SheetType | undefined = undefined
        if ((preferTypeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            preferTypeTmpBuf = SheetType.fromValue(valueDeserializer.readInt32())
        }
        const preferTypeTmpResult : SheetType | undefined = preferTypeTmpBuf
        const titleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let titleTmpBuf : SheetTitleOptions | CustomBuilder | undefined = undefined
        if ((titleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const titleTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let titleTmpBufOpt : SheetTitleOptions | CustomBuilder | undefined
            if (titleTmpBufOptUnionSelector == (0).toByte()) {
                titleTmpBufOpt = SheetTitleOptions_serializer.read(valueDeserializer)
            } else if (titleTmpBufOptUnionSelector == (1).toByte()) {
                const titleTmpBufOptBufUBufResource : CallbackResource = valueDeserializer.readCallbackResource()
                const titleTmpBufOptBufUBufCall : KPointer = valueDeserializer.readPointer()
                const titleTmpBufOptBufUBufCallSync : KPointer = valueDeserializer.readPointer()
                const titleTmpBufOptBufUClosure  = ():void => {
                    const titleTmpBufOptBufUBufArgsSerializer : SerializerBase = SerializerBase.hold();
                    titleTmpBufOptBufUBufArgsSerializer.writeInt32(titleTmpBufOptBufUBufResource.resourceId);
                    titleTmpBufOptBufUBufArgsSerializer.writePointer(titleTmpBufOptBufUBufCall);
                    titleTmpBufOptBufUBufArgsSerializer.writePointer(titleTmpBufOptBufUBufCallSync);
                    InteropNativeModule._CallCallbackSync(10, -1834072896, titleTmpBufOptBufUBufArgsSerializer.asBuffer(), titleTmpBufOptBufUBufArgsSerializer.length());
                    titleTmpBufOptBufUBufArgsSerializer.release();
                    return;
                }
                resourceFinalizerRegister(titleTmpBufOptBufUClosure, titleTmpBufOptBufUBufResource)
                titleTmpBufOpt = titleTmpBufOptBufUClosure
            } else {
                throw new Error('One of the branches for titleTmpBufOpt has to be chosen through deserialisation.')
            }
            titleTmpBuf = (titleTmpBufOpt as SheetTitleOptions | CustomBuilder)
        }
        const titleTmpResult : SheetTitleOptions | CustomBuilder | undefined = titleTmpBuf
        const shouldDismissTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let shouldDismissTmpBuf : ((sheetDismiss: SheetDismiss) => void) | undefined = undefined
        if ((shouldDismissTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const shouldDismissTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const shouldDismissTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const shouldDismissTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const shouldDismissTmpBufOptClosure  = (sheetDismiss: SheetDismiss):void => {
                const shouldDismissTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                shouldDismissTmpBufOptBufArgsSerializer.writeInt32(shouldDismissTmpBufOptBufResource.resourceId);
                shouldDismissTmpBufOptBufArgsSerializer.writePointer(shouldDismissTmpBufOptBufCall);
                shouldDismissTmpBufOptBufArgsSerializer.writePointer(shouldDismissTmpBufOptBufCallSync);
                SheetDismiss_serializer.write(shouldDismissTmpBufOptBufArgsSerializer, sheetDismiss);
                InteropNativeModule._CallCallbackSync(10, -565675366, shouldDismissTmpBufOptBufArgsSerializer.asBuffer(), shouldDismissTmpBufOptBufArgsSerializer.length());
                shouldDismissTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(shouldDismissTmpBufOptClosure, shouldDismissTmpBufOptBufResource)
            shouldDismissTmpBuf = shouldDismissTmpBufOptClosure
        }
        const shouldDismissTmpResult : ((sheetDismiss: SheetDismiss) => void) | undefined = shouldDismissTmpBuf
        const onWillDismissTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onWillDismissTmpBuf : Callback<DismissSheetAction, void> | undefined = undefined
        if ((onWillDismissTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillDismissTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillDismissTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onWillDismissTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onWillDismissTmpBufOptClosure  = (data: DismissSheetAction):void => {
                const onWillDismissTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onWillDismissTmpBufOptBufArgsSerializer.writeInt32(onWillDismissTmpBufOptBufResource.resourceId);
                onWillDismissTmpBufOptBufArgsSerializer.writePointer(onWillDismissTmpBufOptBufCall);
                onWillDismissTmpBufOptBufArgsSerializer.writePointer(onWillDismissTmpBufOptBufCallSync);
                DismissSheetAction_serializer.write(onWillDismissTmpBufOptBufArgsSerializer, data);
                InteropNativeModule._CallCallbackSync(10, -220072348, onWillDismissTmpBufOptBufArgsSerializer.asBuffer(), onWillDismissTmpBufOptBufArgsSerializer.length());
                onWillDismissTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onWillDismissTmpBufOptClosure, onWillDismissTmpBufOptBufResource)
            onWillDismissTmpBuf = onWillDismissTmpBufOptClosure
        }
        const onWillDismissTmpResult : Callback<DismissSheetAction, void> | undefined = onWillDismissTmpBuf
        const onWillSpringBackWhenDismissTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onWillSpringBackWhenDismissTmpBuf : Callback<SpringBackAction, void> | undefined = undefined
        if ((onWillSpringBackWhenDismissTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillSpringBackWhenDismissTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillSpringBackWhenDismissTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onWillSpringBackWhenDismissTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onWillSpringBackWhenDismissTmpBufOptClosure  = (data: SpringBackAction):void => {
                const onWillSpringBackWhenDismissTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onWillSpringBackWhenDismissTmpBufOptBufArgsSerializer.writeInt32(onWillSpringBackWhenDismissTmpBufOptBufResource.resourceId);
                onWillSpringBackWhenDismissTmpBufOptBufArgsSerializer.writePointer(onWillSpringBackWhenDismissTmpBufOptBufCall);
                onWillSpringBackWhenDismissTmpBufOptBufArgsSerializer.writePointer(onWillSpringBackWhenDismissTmpBufOptBufCallSync);
                SpringBackAction_serializer.write(onWillSpringBackWhenDismissTmpBufOptBufArgsSerializer, data);
                InteropNativeModule._CallCallbackSync(10, -2101912629, onWillSpringBackWhenDismissTmpBufOptBufArgsSerializer.asBuffer(), onWillSpringBackWhenDismissTmpBufOptBufArgsSerializer.length());
                onWillSpringBackWhenDismissTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onWillSpringBackWhenDismissTmpBufOptClosure, onWillSpringBackWhenDismissTmpBufOptBufResource)
            onWillSpringBackWhenDismissTmpBuf = onWillSpringBackWhenDismissTmpBufOptClosure
        }
        const onWillSpringBackWhenDismissTmpResult : Callback<SpringBackAction, void> | undefined = onWillSpringBackWhenDismissTmpBuf
        const enableOutsideInteractiveTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let enableOutsideInteractiveTmpBuf : boolean | undefined = undefined
        if ((enableOutsideInteractiveTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableOutsideInteractiveTmpBuf = valueDeserializer.readBoolean()
        }
        const enableOutsideInteractiveTmpResult : boolean | undefined = enableOutsideInteractiveTmpBuf
        const widthTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let widthTmpBuf : Dimension | undefined = undefined
        if ((widthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const widthTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let widthTmpBufOpt : string | number | global_resource_Resource | undefined
            if (widthTmpBufOptUnionSelector == (0).toByte()) {
                widthTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (widthTmpBufOptUnionSelector == (1).toByte()) {
                widthTmpBufOpt = (valueDeserializer.readNumber() as number)
            } else if (widthTmpBufOptUnionSelector == (2).toByte()) {
                widthTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for widthTmpBufOpt has to be chosen through deserialisation.')
            }
            widthTmpBuf = (widthTmpBufOpt as string | number | global_resource_Resource)
        }
        const widthTmpResult : Dimension | undefined = widthTmpBuf
        const borderWidthTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let borderWidthTmpBuf : Dimension | EdgeWidths | LocalizedEdgeWidths | undefined = undefined
        if ((borderWidthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const borderWidthTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let borderWidthTmpBufOpt : Dimension | EdgeWidths | LocalizedEdgeWidths | undefined
            if (borderWidthTmpBufOptUnionSelector == (0).toByte()) {
                const borderWidthTmpBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                let borderWidthTmpBufOptBufU : string | number | global_resource_Resource | undefined
                if (borderWidthTmpBufOptBufUUnionSelector == (0).toByte()) {
                    borderWidthTmpBufOptBufU = (valueDeserializer.readString() as string)
                } else if (borderWidthTmpBufOptBufUUnionSelector == (1).toByte()) {
                    borderWidthTmpBufOptBufU = (valueDeserializer.readNumber() as number)
                } else if (borderWidthTmpBufOptBufUUnionSelector == (2).toByte()) {
                    borderWidthTmpBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error('One of the branches for borderWidthTmpBufOptBufU has to be chosen through deserialisation.')
                }
                borderWidthTmpBufOpt = (borderWidthTmpBufOptBufU as string | number | global_resource_Resource)
            } else if (borderWidthTmpBufOptUnionSelector == (1).toByte()) {
                borderWidthTmpBufOpt = EdgeWidths_serializer.read(valueDeserializer)
            } else if (borderWidthTmpBufOptUnionSelector == (2).toByte()) {
                borderWidthTmpBufOpt = LocalizedEdgeWidths_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for borderWidthTmpBufOpt has to be chosen through deserialisation.')
            }
            borderWidthTmpBuf = (borderWidthTmpBufOpt as Dimension | EdgeWidths | LocalizedEdgeWidths)
        }
        const borderWidthTmpResult : Dimension | EdgeWidths | LocalizedEdgeWidths | undefined = borderWidthTmpBuf
        const borderColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let borderColorTmpBuf : ResourceColor | EdgeColors | LocalizedEdgeColors | undefined = undefined
        if ((borderColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const borderColorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let borderColorTmpBufOpt : ResourceColor | EdgeColors | LocalizedEdgeColors | undefined
            if (borderColorTmpBufOptUnionSelector == (0).toByte()) {
                const borderColorTmpBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                let borderColorTmpBufOptBufU : arkui_component_enums_Color | int32 | string | arkui_component_units_Resource | undefined
                if (borderColorTmpBufOptBufUUnionSelector == (0).toByte()) {
                    borderColorTmpBufOptBufU = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
                } else if (borderColorTmpBufOptBufUUnionSelector == (1).toByte()) {
                    borderColorTmpBufOptBufU = valueDeserializer.readInt32()
                } else if (borderColorTmpBufOptBufUUnionSelector == (2).toByte()) {
                    borderColorTmpBufOptBufU = (valueDeserializer.readString() as string)
                } else if (borderColorTmpBufOptBufUUnionSelector == (3).toByte()) {
                    borderColorTmpBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error('One of the branches for borderColorTmpBufOptBufU has to be chosen through deserialisation.')
                }
                borderColorTmpBufOpt = (borderColorTmpBufOptBufU as arkui_component_enums_Color | int32 | string | arkui_component_units_Resource)
            } else if (borderColorTmpBufOptUnionSelector == (1).toByte()) {
                borderColorTmpBufOpt = EdgeColors_serializer.read(valueDeserializer)
            } else if (borderColorTmpBufOptUnionSelector == (2).toByte()) {
                borderColorTmpBufOpt = LocalizedEdgeColors_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for borderColorTmpBufOpt has to be chosen through deserialisation.')
            }
            borderColorTmpBuf = (borderColorTmpBufOpt as ResourceColor | EdgeColors | LocalizedEdgeColors)
        }
        const borderColorTmpResult : ResourceColor | EdgeColors | LocalizedEdgeColors | undefined = borderColorTmpBuf
        const borderStyleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let borderStyleTmpBuf : BorderStyle | EdgeStyles | undefined = undefined
        if ((borderStyleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const borderStyleTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let borderStyleTmpBufOpt : BorderStyle | EdgeStyles | undefined
            if (borderStyleTmpBufOptUnionSelector == (0).toByte()) {
                borderStyleTmpBufOpt = BorderStyle.fromValue(valueDeserializer.readInt32())
            } else if (borderStyleTmpBufOptUnionSelector == (1).toByte()) {
                borderStyleTmpBufOpt = EdgeStyles_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for borderStyleTmpBufOpt has to be chosen through deserialisation.')
            }
            borderStyleTmpBuf = (borderStyleTmpBufOpt as BorderStyle | EdgeStyles)
        }
        const borderStyleTmpResult : BorderStyle | EdgeStyles | undefined = borderStyleTmpBuf
        const shadowTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let shadowTmpBuf : ShadowOptions | ShadowStyle | undefined = undefined
        if ((shadowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const shadowTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let shadowTmpBufOpt : ShadowOptions | ShadowStyle | undefined
            if (shadowTmpBufOptUnionSelector == (0).toByte()) {
                shadowTmpBufOpt = ShadowOptions_serializer.read(valueDeserializer)
            } else if (shadowTmpBufOptUnionSelector == (1).toByte()) {
                shadowTmpBufOpt = ShadowStyle.fromValue(valueDeserializer.readInt32())
            } else {
                throw new Error('One of the branches for shadowTmpBufOpt has to be chosen through deserialisation.')
            }
            shadowTmpBuf = (shadowTmpBufOpt as ShadowOptions | ShadowStyle)
        }
        const shadowTmpResult : ShadowOptions | ShadowStyle | undefined = shadowTmpBuf
        const onHeightDidChangeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onHeightDidChangeTmpBuf : Callback<number, void> | undefined = undefined
        if ((onHeightDidChangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onHeightDidChangeTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onHeightDidChangeTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onHeightDidChangeTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onHeightDidChangeTmpBufOptClosure  = (data: number):void => {
                const onHeightDidChangeTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onHeightDidChangeTmpBufOptBufArgsSerializer.writeInt32(onHeightDidChangeTmpBufOptBufResource.resourceId);
                onHeightDidChangeTmpBufOptBufArgsSerializer.writePointer(onHeightDidChangeTmpBufOptBufCall);
                onHeightDidChangeTmpBufOptBufArgsSerializer.writePointer(onHeightDidChangeTmpBufOptBufCallSync);
                onHeightDidChangeTmpBufOptBufArgsSerializer.writeNumber(data);
                InteropNativeModule._CallCallbackSync(10, -1825275412, onHeightDidChangeTmpBufOptBufArgsSerializer.asBuffer(), onHeightDidChangeTmpBufOptBufArgsSerializer.length());
                onHeightDidChangeTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onHeightDidChangeTmpBufOptClosure, onHeightDidChangeTmpBufOptBufResource)
            onHeightDidChangeTmpBuf = onHeightDidChangeTmpBufOptClosure
        }
        const onHeightDidChangeTmpResult : Callback<number, void> | undefined = onHeightDidChangeTmpBuf
        const modeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let modeTmpBuf : SheetMode | undefined = undefined
        if ((modeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            modeTmpBuf = SheetMode.fromValue(valueDeserializer.readInt32())
        }
        const modeTmpResult : SheetMode | undefined = modeTmpBuf
        const scrollSizeModeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let scrollSizeModeTmpBuf : ScrollSizeMode | undefined = undefined
        if ((scrollSizeModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            scrollSizeModeTmpBuf = ScrollSizeMode.fromValue(valueDeserializer.readInt32())
        }
        const scrollSizeModeTmpResult : ScrollSizeMode | undefined = scrollSizeModeTmpBuf
        const onDetentsDidChangeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onDetentsDidChangeTmpBuf : Callback<int32, void> | undefined = undefined
        if ((onDetentsDidChangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onDetentsDidChangeTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDetentsDidChangeTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onDetentsDidChangeTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onDetentsDidChangeTmpBufOptClosure  = (data: int32):void => {
                const onDetentsDidChangeTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onDetentsDidChangeTmpBufOptBufArgsSerializer.writeInt32(onDetentsDidChangeTmpBufOptBufResource.resourceId);
                onDetentsDidChangeTmpBufOptBufArgsSerializer.writePointer(onDetentsDidChangeTmpBufOptBufCall);
                onDetentsDidChangeTmpBufOptBufArgsSerializer.writePointer(onDetentsDidChangeTmpBufOptBufCallSync);
                onDetentsDidChangeTmpBufOptBufArgsSerializer.writeInt32(data);
                InteropNativeModule._CallCallbackSync(10, 220612455, onDetentsDidChangeTmpBufOptBufArgsSerializer.asBuffer(), onDetentsDidChangeTmpBufOptBufArgsSerializer.length());
                onDetentsDidChangeTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onDetentsDidChangeTmpBufOptClosure, onDetentsDidChangeTmpBufOptBufResource)
            onDetentsDidChangeTmpBuf = onDetentsDidChangeTmpBufOptClosure
        }
        const onDetentsDidChangeTmpResult : Callback<int32, void> | undefined = onDetentsDidChangeTmpBuf
        const onWidthDidChangeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onWidthDidChangeTmpBuf : Callback<int32, void> | undefined = undefined
        if ((onWidthDidChangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWidthDidChangeTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWidthDidChangeTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onWidthDidChangeTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onWidthDidChangeTmpBufOptClosure  = (data: int32):void => {
                const onWidthDidChangeTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onWidthDidChangeTmpBufOptBufArgsSerializer.writeInt32(onWidthDidChangeTmpBufOptBufResource.resourceId);
                onWidthDidChangeTmpBufOptBufArgsSerializer.writePointer(onWidthDidChangeTmpBufOptBufCall);
                onWidthDidChangeTmpBufOptBufArgsSerializer.writePointer(onWidthDidChangeTmpBufOptBufCallSync);
                onWidthDidChangeTmpBufOptBufArgsSerializer.writeInt32(data);
                InteropNativeModule._CallCallbackSync(10, 220612455, onWidthDidChangeTmpBufOptBufArgsSerializer.asBuffer(), onWidthDidChangeTmpBufOptBufArgsSerializer.length());
                onWidthDidChangeTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onWidthDidChangeTmpBufOptClosure, onWidthDidChangeTmpBufOptBufResource)
            onWidthDidChangeTmpBuf = onWidthDidChangeTmpBufOptClosure
        }
        const onWidthDidChangeTmpResult : Callback<int32, void> | undefined = onWidthDidChangeTmpBuf
        const onTypeDidChangeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onTypeDidChangeTmpBuf : Callback<SheetType, void> | undefined = undefined
        if ((onTypeDidChangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onTypeDidChangeTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onTypeDidChangeTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onTypeDidChangeTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onTypeDidChangeTmpBufOptClosure  = (data: SheetType):void => {
                const onTypeDidChangeTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onTypeDidChangeTmpBufOptBufArgsSerializer.writeInt32(onTypeDidChangeTmpBufOptBufResource.resourceId);
                onTypeDidChangeTmpBufOptBufArgsSerializer.writePointer(onTypeDidChangeTmpBufOptBufCall);
                onTypeDidChangeTmpBufOptBufArgsSerializer.writePointer(onTypeDidChangeTmpBufOptBufCallSync);
                onTypeDidChangeTmpBufOptBufArgsSerializer.writeInt32(data.valueOf());
                InteropNativeModule._CallCallbackSync(10, 2029584216, onTypeDidChangeTmpBufOptBufArgsSerializer.asBuffer(), onTypeDidChangeTmpBufOptBufArgsSerializer.length());
                onTypeDidChangeTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onTypeDidChangeTmpBufOptClosure, onTypeDidChangeTmpBufOptBufResource)
            onTypeDidChangeTmpBuf = onTypeDidChangeTmpBufOptClosure
        }
        const onTypeDidChangeTmpResult : Callback<SheetType, void> | undefined = onTypeDidChangeTmpBuf
        const uiContextTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let uiContextTmpBuf : UIContext | undefined = undefined
        if ((uiContextTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            uiContextTmpBuf = (ohos_arkui_UIContext_UIContext_serializer.read(valueDeserializer) as ohos_arkui_UIContext_UIContext)
        }
        const uiContextTmpResult : UIContext | undefined = uiContextTmpBuf
        const keyboardAvoidModeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let keyboardAvoidModeTmpBuf : SheetKeyboardAvoidMode | undefined = undefined
        if ((keyboardAvoidModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            keyboardAvoidModeTmpBuf = SheetKeyboardAvoidMode.fromValue(valueDeserializer.readInt32())
        }
        const keyboardAvoidModeTmpResult : SheetKeyboardAvoidMode | undefined = keyboardAvoidModeTmpBuf
        const enableHoverModeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let enableHoverModeTmpBuf : boolean | undefined = undefined
        if ((enableHoverModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableHoverModeTmpBuf = valueDeserializer.readBoolean()
        }
        const enableHoverModeTmpResult : boolean | undefined = enableHoverModeTmpBuf
        const hoverModeAreaTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let hoverModeAreaTmpBuf : HoverModeAreaType | undefined = undefined
        if ((hoverModeAreaTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            hoverModeAreaTmpBuf = HoverModeAreaType.fromValue(valueDeserializer.readInt32())
        }
        const hoverModeAreaTmpResult : HoverModeAreaType | undefined = hoverModeAreaTmpBuf
        const offsetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let offsetTmpBuf : Position | undefined = undefined
        if ((offsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            offsetTmpBuf = Position_serializer.read(valueDeserializer)
        }
        const offsetTmpResult : Position | undefined = offsetTmpBuf
        const effectEdgeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let effectEdgeTmpBuf : int32 | undefined = undefined
        if ((effectEdgeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            effectEdgeTmpBuf = valueDeserializer.readInt32()
        }
        const effectEdgeTmpResult : int32 | undefined = effectEdgeTmpBuf
        const radiusTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let radiusTmpBuf : arkui_Graphics_LengthMetrics | BorderRadiuses | LocalizedBorderRadiuses | undefined = undefined
        if ((radiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const radiusTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let radiusTmpBufOpt : arkui_Graphics_LengthMetrics | BorderRadiuses | LocalizedBorderRadiuses | undefined
            if (radiusTmpBufOptUnionSelector == (0).toByte()) {
                radiusTmpBufOpt = arkui_Graphics_LengthMetrics_serializer.read(valueDeserializer)
            } else if (radiusTmpBufOptUnionSelector == (1).toByte()) {
                radiusTmpBufOpt = BorderRadiuses_serializer.read(valueDeserializer)
            } else if (radiusTmpBufOptUnionSelector == (2).toByte()) {
                radiusTmpBufOpt = LocalizedBorderRadiuses_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for radiusTmpBufOpt has to be chosen through deserialisation.')
            }
            radiusTmpBuf = (radiusTmpBufOpt as arkui_Graphics_LengthMetrics | BorderRadiuses | LocalizedBorderRadiuses)
        }
        const radiusTmpResult : arkui_Graphics_LengthMetrics | BorderRadiuses | LocalizedBorderRadiuses | undefined = radiusTmpBuf
        const detentSelectionTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let detentSelectionTmpBuf : SheetSize | Length | undefined = undefined
        if ((detentSelectionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const detentSelectionTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let detentSelectionTmpBufOpt : SheetSize | Length | undefined
            if (detentSelectionTmpBufOptUnionSelector == (0).toByte()) {
                detentSelectionTmpBufOpt = SheetSize.fromValue(valueDeserializer.readInt32())
            } else if (detentSelectionTmpBufOptUnionSelector == (1).toByte()) {
                const detentSelectionTmpBufOptBufUUnionSelector : int32 = valueDeserializer.readInt8()
                let detentSelectionTmpBufOptBufU : string | double | arkui_component_units_Resource | undefined
                if (detentSelectionTmpBufOptBufUUnionSelector == (0).toByte()) {
                    detentSelectionTmpBufOptBufU = (valueDeserializer.readString() as string)
                } else if (detentSelectionTmpBufOptBufUUnionSelector == (1).toByte()) {
                    detentSelectionTmpBufOptBufU = valueDeserializer.readFloat64()
                } else if (detentSelectionTmpBufOptBufUUnionSelector == (2).toByte()) {
                    detentSelectionTmpBufOptBufU = global_resource_Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error('One of the branches for detentSelectionTmpBufOptBufU has to be chosen through deserialisation.')
                }
                detentSelectionTmpBufOpt = (detentSelectionTmpBufOptBufU as string | double | arkui_component_units_Resource)
            } else {
                throw new Error('One of the branches for detentSelectionTmpBufOpt has to be chosen through deserialisation.')
            }
            detentSelectionTmpBuf = (detentSelectionTmpBufOpt as SheetSize | Length)
        }
        const detentSelectionTmpResult : SheetSize | Length | undefined = detentSelectionTmpBuf
        const showInSubWindowTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let showInSubWindowTmpBuf : boolean | undefined = undefined
        if ((showInSubWindowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            showInSubWindowTmpBuf = valueDeserializer.readBoolean()
        }
        const showInSubWindowTmpResult : boolean | undefined = showInSubWindowTmpBuf
        const placementTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let placementTmpBuf : Placement | undefined = undefined
        if ((placementTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            placementTmpBuf = Placement.fromValue(valueDeserializer.readInt32())
        }
        const placementTmpResult : Placement | undefined = placementTmpBuf
        const placementOnTargetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let placementOnTargetTmpBuf : boolean | undefined = undefined
        if ((placementOnTargetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            placementOnTargetTmpBuf = valueDeserializer.readBoolean()
        }
        const placementOnTargetTmpResult : boolean | undefined = placementOnTargetTmpBuf
        let value : SheetOptions = ({backgroundColor: backgroundColorTmpResult, onAppear: onAppearTmpResult, onDisappear: onDisappearTmpResult, onWillAppear: onWillAppearTmpResult, onWillDisappear: onWillDisappearTmpResult, height: heightTmpResult, dragBar: dragBarTmpResult, maskColor: maskColorTmpResult, detents: detentsTmpResult, blurStyle: blurStyleTmpResult, showClose: showCloseTmpResult, preferType: preferTypeTmpResult, title: titleTmpResult, shouldDismiss: shouldDismissTmpResult, onWillDismiss: onWillDismissTmpResult, onWillSpringBackWhenDismiss: onWillSpringBackWhenDismissTmpResult, enableOutsideInteractive: enableOutsideInteractiveTmpResult, width: widthTmpResult, borderWidth: borderWidthTmpResult, borderColor: borderColorTmpResult, borderStyle: borderStyleTmpResult, shadow: shadowTmpResult, onHeightDidChange: onHeightDidChangeTmpResult, mode: modeTmpResult, scrollSizeMode: scrollSizeModeTmpResult, onDetentsDidChange: onDetentsDidChangeTmpResult, onWidthDidChange: onWidthDidChangeTmpResult, onTypeDidChange: onTypeDidChangeTmpResult, uiContext: uiContextTmpResult, keyboardAvoidMode: keyboardAvoidModeTmpResult, enableHoverMode: enableHoverModeTmpResult, hoverModeArea: hoverModeAreaTmpResult, offset: offsetTmpResult, effectEdge: effectEdgeTmpResult, radius: radiusTmpResult, detentSelection: detentSelectionTmpResult, showInSubWindow: showInSubWindowTmpResult, placement: placementTmpResult, placementOnTarget: placementOnTargetTmpResult} as SheetOptions)
        return value
    }
}
export class PopupOptions_serializer {
    public static write(buffer: SerializerBase, value: PopupOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForMessage  = value.message
        valueSerializer.writeString(valueHolderForMessage)
        const valueHolderForPlacement  = value.placement
        if (valueHolderForPlacement !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPlacementTmpValue  = (valueHolderForPlacement as Placement)
            valueSerializer.writeInt32(valueHolderForPlacementTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPrimaryButton  = value.primaryButton
        if (valueHolderForPrimaryButton !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPrimaryButtonTmpValue  = valueHolderForPrimaryButton!
            PopupButton_serializer.write(valueSerializer, valueHolderForPrimaryButtonTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForSecondaryButton  = value.secondaryButton
        if (valueHolderForSecondaryButton !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForSecondaryButtonTmpValue  = valueHolderForSecondaryButton!
            PopupButton_serializer.write(valueSerializer, valueHolderForSecondaryButtonTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnStateChange  = value.onStateChange
        if (valueHolderForOnStateChange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnStateChangeTmpValue  = valueHolderForOnStateChange!
            valueSerializer.holdAndWriteCallback(valueHolderForOnStateChangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowOffset  = value.arrowOffset
        if (valueHolderForArrowOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowOffsetTmpValue  = valueHolderForArrowOffset!
            if (valueHolderForArrowOffsetTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx0  = valueHolderForArrowOffsetTmpValue as string
                valueSerializer.writeString(valueHolderForArrowOffsetTmpValueForIdx0)
            } else if (valueHolderForArrowOffsetTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx1  = valueHolderForArrowOffsetTmpValue as double
                valueSerializer.writeFloat64(valueHolderForArrowOffsetTmpValueForIdx1)
            } else if (valueHolderForArrowOffsetTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx2  = valueHolderForArrowOffsetTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForArrowOffsetTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShowInSubWindow  = value.showInSubWindow
        if (valueHolderForShowInSubWindow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShowInSubWindowTmpValue  = valueHolderForShowInSubWindow!
            valueSerializer.writeBoolean(valueHolderForShowInSubWindowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMask  = value.mask
        if (valueHolderForMask !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMaskTmpValue  = valueHolderForMask!
            if (valueHolderForMaskTmpValue instanceof boolean) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForMaskTmpValueForIdx0  = valueHolderForMaskTmpValue as boolean
                valueSerializer.writeBoolean(valueHolderForMaskTmpValueForIdx0)
            } else if (valueHolderForMaskTmpValue instanceof PopupMaskType) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForMaskTmpValueForIdx1  = valueHolderForMaskTmpValue as PopupMaskType
                PopupMaskType_serializer.write(valueSerializer, valueHolderForMaskTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMessageOptions  = value.messageOptions
        if (valueHolderForMessageOptions !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMessageOptionsTmpValue  = valueHolderForMessageOptions!
            PopupMessageOptions_serializer.write(valueSerializer, valueHolderForMessageOptionsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTargetSpace  = value.targetSpace
        if (valueHolderForTargetSpace !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTargetSpaceTmpValue  = valueHolderForTargetSpace!
            if (valueHolderForTargetSpaceTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx0  = valueHolderForTargetSpaceTmpValue as string
                valueSerializer.writeString(valueHolderForTargetSpaceTmpValueForIdx0)
            } else if (valueHolderForTargetSpaceTmpValue instanceof double) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx1  = valueHolderForTargetSpaceTmpValue as double
                valueSerializer.writeFloat64(valueHolderForTargetSpaceTmpValueForIdx1)
            } else if (valueHolderForTargetSpaceTmpValue instanceof arkui_component_units_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx2  = valueHolderForTargetSpaceTmpValue as arkui_component_units_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForTargetSpaceTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableArrow  = value.enableArrow
        if (valueHolderForEnableArrow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableArrowTmpValue  = valueHolderForEnableArrow!
            valueSerializer.writeBoolean(valueHolderForEnableArrowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOffset  = value.offset
        if (valueHolderForOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetTmpValue  = valueHolderForOffset!
            Position_serializer.write(valueSerializer, valueHolderForOffsetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPopupColor  = value.popupColor
        if (valueHolderForPopupColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPopupColorTmpValue  = valueHolderForPopupColor!
            if (valueHolderForPopupColorTmpValue instanceof arkui_component_enums_Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForPopupColorTmpValueForIdx0  = valueHolderForPopupColorTmpValue as arkui_component_enums_Color
                valueSerializer.writeInt32((valueHolderForPopupColorTmpValueForIdx0.getOrdinal()) % (12))
            } else if (valueHolderForPopupColorTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForPopupColorTmpValueForIdx1  = valueHolderForPopupColorTmpValue as string
                valueSerializer.writeString(valueHolderForPopupColorTmpValueForIdx1)
            } else if (valueHolderForPopupColorTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForPopupColorTmpValueForIdx2  = valueHolderForPopupColorTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForPopupColorTmpValueForIdx2)
            } else if (valueHolderForPopupColorTmpValue instanceof int64) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForPopupColorTmpValueForIdx3  = valueHolderForPopupColorTmpValue as int64
                valueSerializer.writeInt64(valueHolderForPopupColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAutoCancel  = value.autoCancel
        if (valueHolderForAutoCancel !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAutoCancelTmpValue  = valueHolderForAutoCancel!
            valueSerializer.writeBoolean(valueHolderForAutoCancelTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForWidth  = value.width
        if (valueHolderForWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForWidthTmpValue  = valueHolderForWidth!
            if (valueHolderForWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForWidthTmpValueForIdx0  = valueHolderForWidthTmpValue as string
                valueSerializer.writeString(valueHolderForWidthTmpValueForIdx0)
            } else if (valueHolderForWidthTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForWidthTmpValueForIdx1  = valueHolderForWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForWidthTmpValueForIdx1)
            } else if (valueHolderForWidthTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForWidthTmpValueForIdx2  = valueHolderForWidthTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowPointPosition  = value.arrowPointPosition
        if (valueHolderForArrowPointPosition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowPointPositionTmpValue  = (valueHolderForArrowPointPosition as ArrowPointPosition)
            valueSerializer.writeInt32(valueHolderForArrowPointPositionTmpValue.getOrdinal())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowWidth  = value.arrowWidth
        if (valueHolderForArrowWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowWidthTmpValue  = valueHolderForArrowWidth!
            if (valueHolderForArrowWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowWidthTmpValueForIdx0  = valueHolderForArrowWidthTmpValue as string
                valueSerializer.writeString(valueHolderForArrowWidthTmpValueForIdx0)
            } else if (valueHolderForArrowWidthTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowWidthTmpValueForIdx1  = valueHolderForArrowWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowWidthTmpValueForIdx1)
            } else if (valueHolderForArrowWidthTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowWidthTmpValueForIdx2  = valueHolderForArrowWidthTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForArrowWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowHeight  = value.arrowHeight
        if (valueHolderForArrowHeight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowHeightTmpValue  = valueHolderForArrowHeight!
            if (valueHolderForArrowHeightTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowHeightTmpValueForIdx0  = valueHolderForArrowHeightTmpValue as string
                valueSerializer.writeString(valueHolderForArrowHeightTmpValueForIdx0)
            } else if (valueHolderForArrowHeightTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowHeightTmpValueForIdx1  = valueHolderForArrowHeightTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowHeightTmpValueForIdx1)
            } else if (valueHolderForArrowHeightTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowHeightTmpValueForIdx2  = valueHolderForArrowHeightTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForArrowHeightTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRadius  = value.radius
        if (valueHolderForRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRadiusTmpValue  = valueHolderForRadius!
            if (valueHolderForRadiusTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForRadiusTmpValueForIdx0  = valueHolderForRadiusTmpValue as string
                valueSerializer.writeString(valueHolderForRadiusTmpValueForIdx0)
            } else if (valueHolderForRadiusTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForRadiusTmpValueForIdx1  = valueHolderForRadiusTmpValue as number
                valueSerializer.writeNumber(valueHolderForRadiusTmpValueForIdx1)
            } else if (valueHolderForRadiusTmpValue instanceof global_resource_Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForRadiusTmpValueForIdx2  = valueHolderForRadiusTmpValue as global_resource_Resource
                global_resource_Resource_serializer.write(valueSerializer, valueHolderForRadiusTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShadow  = value.shadow
        if (valueHolderForShadow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShadowTmpValue  = valueHolderForShadow!
            if (valueHolderForShadowTmpValue instanceof ShadowOptions) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForShadowTmpValueForIdx0  = valueHolderForShadowTmpValue as ShadowOptions
                ShadowOptions_serializer.write(valueSerializer, valueHolderForShadowTmpValueForIdx0)
            } else if (valueHolderForShadowTmpValue instanceof ShadowStyle) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForShadowTmpValueForIdx1  = valueHolderForShadowTmpValue as ShadowStyle
                valueSerializer.writeInt32(valueHolderForShadowTmpValueForIdx1.valueOf())
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundBlurStyle  = value.backgroundBlurStyle
        if (valueHolderForBackgroundBlurStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundBlurStyleTmpValue  = (valueHolderForBackgroundBlurStyle as BlurStyle)
            valueSerializer.writeInt32(valueHolderForBackgroundBlurStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTransition  = value.transition
        if (valueHolderForTransition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTransitionTmpValue  = valueHolderForTransition!
            TransitionEffect_serializer.write(valueSerializer, valueHolderForTransitionTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillDismiss  = value.onWillDismiss
        if (valueHolderForOnWillDismiss !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillDismissTmpValue  = valueHolderForOnWillDismiss!
            if (valueHolderForOnWillDismissTmpValue instanceof boolean) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOnWillDismissTmpValueForIdx0  = valueHolderForOnWillDismissTmpValue as boolean
                valueSerializer.writeBoolean(valueHolderForOnWillDismissTmpValueForIdx0)
            } else if (valueHolderForOnWillDismissTmpValue instanceof Callback<DismissPopupAction, void>) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOnWillDismissTmpValueForIdx1  = valueHolderForOnWillDismissTmpValue as Callback<DismissPopupAction, void>
                valueSerializer.holdAndWriteCallback(valueHolderForOnWillDismissTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableHoverMode  = value.enableHoverMode
        if (valueHolderForEnableHoverMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableHoverModeTmpValue  = valueHolderForEnableHoverMode!
            valueSerializer.writeBoolean(valueHolderForEnableHoverModeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFollowTransformOfTarget  = value.followTransformOfTarget
        if (valueHolderForFollowTransformOfTarget !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFollowTransformOfTargetTmpValue  = valueHolderForFollowTransformOfTarget!
            valueSerializer.writeBoolean(valueHolderForFollowTransformOfTargetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForKeyboardAvoidMode  = value.keyboardAvoidMode
        if (valueHolderForKeyboardAvoidMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForKeyboardAvoidModeTmpValue  = (valueHolderForKeyboardAvoidMode as KeyboardAvoidMode)
            valueSerializer.writeInt32(valueHolderForKeyboardAvoidModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PopupOptions {
        let valueDeserializer : DeserializerBase = buffer
        const messageTmpResult : string = (valueDeserializer.readString() as string)
        const placementTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let placementTmpBuf : Placement | undefined = undefined
        if ((placementTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            placementTmpBuf = Placement.fromValue(valueDeserializer.readInt32())
        }
        const placementTmpResult : Placement | undefined = placementTmpBuf
        const primaryButtonTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let primaryButtonTmpBuf : PopupButton | undefined = undefined
        if ((primaryButtonTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            primaryButtonTmpBuf = PopupButton_serializer.read(valueDeserializer)
        }
        const primaryButtonTmpResult : PopupButton | undefined = primaryButtonTmpBuf
        const secondaryButtonTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let secondaryButtonTmpBuf : PopupButton | undefined = undefined
        if ((secondaryButtonTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            secondaryButtonTmpBuf = PopupButton_serializer.read(valueDeserializer)
        }
        const secondaryButtonTmpResult : PopupButton | undefined = secondaryButtonTmpBuf
        const onStateChangeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onStateChangeTmpBuf : PopupStateChangeCallback | undefined = undefined
        if ((onStateChangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onStateChangeTmpBufOptBufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onStateChangeTmpBufOptBufCall : KPointer = valueDeserializer.readPointer()
            const onStateChangeTmpBufOptBufCallSync : KPointer = valueDeserializer.readPointer()
            const onStateChangeTmpBufOptClosure  = (event: PopupStateChangeParam):void => {
                const onStateChangeTmpBufOptBufArgsSerializer : SerializerBase = SerializerBase.hold();
                onStateChangeTmpBufOptBufArgsSerializer.writeInt32(onStateChangeTmpBufOptBufResource.resourceId);
                onStateChangeTmpBufOptBufArgsSerializer.writePointer(onStateChangeTmpBufOptBufCall);
                onStateChangeTmpBufOptBufArgsSerializer.writePointer(onStateChangeTmpBufOptBufCallSync);
                PopupStateChangeParam_serializer.write(onStateChangeTmpBufOptBufArgsSerializer, event);
                InteropNativeModule._CallCallbackSync(10, 1789299488, onStateChangeTmpBufOptBufArgsSerializer.asBuffer(), onStateChangeTmpBufOptBufArgsSerializer.length());
                onStateChangeTmpBufOptBufArgsSerializer.release();
                return;
            }
            resourceFinalizerRegister(onStateChangeTmpBufOptClosure, onStateChangeTmpBufOptBufResource)
            onStateChangeTmpBuf = onStateChangeTmpBufOptClosure
        }
        const onStateChangeTmpResult : PopupStateChangeCallback | undefined = onStateChangeTmpBuf
        const arrowOffsetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let arrowOffsetTmpBuf : Length | undefined = undefined
        if ((arrowOffsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowOffsetTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let arrowOffsetTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (arrowOffsetTmpBufOptUnionSelector == (0).toByte()) {
                arrowOffsetTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (arrowOffsetTmpBufOptUnionSelector == (1).toByte()) {
                arrowOffsetTmpBufOpt = valueDeserializer.readFloat64()
            } else if (arrowOffsetTmpBufOptUnionSelector == (2).toByte()) {
                arrowOffsetTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for arrowOffsetTmpBufOpt has to be chosen through deserialisation.')
            }
            arrowOffsetTmpBuf = (arrowOffsetTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const arrowOffsetTmpResult : Length | undefined = arrowOffsetTmpBuf
        const showInSubWindowTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let showInSubWindowTmpBuf : boolean | undefined = undefined
        if ((showInSubWindowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            showInSubWindowTmpBuf = valueDeserializer.readBoolean()
        }
        const showInSubWindowTmpResult : boolean | undefined = showInSubWindowTmpBuf
        const maskTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let maskTmpBuf : boolean | PopupMaskType | undefined = undefined
        if ((maskTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const maskTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let maskTmpBufOpt : boolean | PopupMaskType | undefined
            if (maskTmpBufOptUnionSelector == (0).toByte()) {
                maskTmpBufOpt = valueDeserializer.readBoolean()
            } else if (maskTmpBufOptUnionSelector == (1).toByte()) {
                maskTmpBufOpt = PopupMaskType_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for maskTmpBufOpt has to be chosen through deserialisation.')
            }
            maskTmpBuf = (maskTmpBufOpt as boolean | PopupMaskType)
        }
        const maskTmpResult : boolean | PopupMaskType | undefined = maskTmpBuf
        const messageOptionsTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let messageOptionsTmpBuf : PopupMessageOptions | undefined = undefined
        if ((messageOptionsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            messageOptionsTmpBuf = PopupMessageOptions_serializer.read(valueDeserializer)
        }
        const messageOptionsTmpResult : PopupMessageOptions | undefined = messageOptionsTmpBuf
        const targetSpaceTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let targetSpaceTmpBuf : Length | undefined = undefined
        if ((targetSpaceTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const targetSpaceTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let targetSpaceTmpBufOpt : string | double | arkui_component_units_Resource | undefined
            if (targetSpaceTmpBufOptUnionSelector == (0).toByte()) {
                targetSpaceTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (targetSpaceTmpBufOptUnionSelector == (1).toByte()) {
                targetSpaceTmpBufOpt = valueDeserializer.readFloat64()
            } else if (targetSpaceTmpBufOptUnionSelector == (2).toByte()) {
                targetSpaceTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for targetSpaceTmpBufOpt has to be chosen through deserialisation.')
            }
            targetSpaceTmpBuf = (targetSpaceTmpBufOpt as string | double | arkui_component_units_Resource)
        }
        const targetSpaceTmpResult : Length | undefined = targetSpaceTmpBuf
        const enableArrowTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let enableArrowTmpBuf : boolean | undefined = undefined
        if ((enableArrowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableArrowTmpBuf = valueDeserializer.readBoolean()
        }
        const enableArrowTmpResult : boolean | undefined = enableArrowTmpBuf
        const offsetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let offsetTmpBuf : Position | undefined = undefined
        if ((offsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            offsetTmpBuf = Position_serializer.read(valueDeserializer)
        }
        const offsetTmpResult : Position | undefined = offsetTmpBuf
        const popupColorTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let popupColorTmpBuf : arkui_component_enums_Color | string | global_resource_Resource | int64 | undefined = undefined
        if ((popupColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const popupColorTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let popupColorTmpBufOpt : arkui_component_enums_Color | string | global_resource_Resource | int64 | undefined
            if (popupColorTmpBufOptUnionSelector == (0).toByte()) {
                popupColorTmpBufOpt = arkui_component_enums_Color.values()[valueDeserializer.readInt32()]
            } else if (popupColorTmpBufOptUnionSelector == (1).toByte()) {
                popupColorTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (popupColorTmpBufOptUnionSelector == (2).toByte()) {
                popupColorTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else if (popupColorTmpBufOptUnionSelector == (3).toByte()) {
                popupColorTmpBufOpt = valueDeserializer.readInt64()
            } else {
                throw new Error('One of the branches for popupColorTmpBufOpt has to be chosen through deserialisation.')
            }
            popupColorTmpBuf = (popupColorTmpBufOpt as arkui_component_enums_Color | string | global_resource_Resource | int64)
        }
        const popupColorTmpResult : arkui_component_enums_Color | string | global_resource_Resource | int64 | undefined = popupColorTmpBuf
        const autoCancelTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let autoCancelTmpBuf : boolean | undefined = undefined
        if ((autoCancelTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            autoCancelTmpBuf = valueDeserializer.readBoolean()
        }
        const autoCancelTmpResult : boolean | undefined = autoCancelTmpBuf
        const widthTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let widthTmpBuf : Dimension | undefined = undefined
        if ((widthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const widthTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let widthTmpBufOpt : string | number | global_resource_Resource | undefined
            if (widthTmpBufOptUnionSelector == (0).toByte()) {
                widthTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (widthTmpBufOptUnionSelector == (1).toByte()) {
                widthTmpBufOpt = (valueDeserializer.readNumber() as number)
            } else if (widthTmpBufOptUnionSelector == (2).toByte()) {
                widthTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for widthTmpBufOpt has to be chosen through deserialisation.')
            }
            widthTmpBuf = (widthTmpBufOpt as string | number | global_resource_Resource)
        }
        const widthTmpResult : Dimension | undefined = widthTmpBuf
        const arrowPointPositionTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let arrowPointPositionTmpBuf : ArrowPointPosition | undefined = undefined
        if ((arrowPointPositionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            arrowPointPositionTmpBuf = ArrowPointPosition.values()[valueDeserializer.readInt32()]
        }
        const arrowPointPositionTmpResult : ArrowPointPosition | undefined = arrowPointPositionTmpBuf
        const arrowWidthTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let arrowWidthTmpBuf : Dimension | undefined = undefined
        if ((arrowWidthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowWidthTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let arrowWidthTmpBufOpt : string | number | global_resource_Resource | undefined
            if (arrowWidthTmpBufOptUnionSelector == (0).toByte()) {
                arrowWidthTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (arrowWidthTmpBufOptUnionSelector == (1).toByte()) {
                arrowWidthTmpBufOpt = (valueDeserializer.readNumber() as number)
            } else if (arrowWidthTmpBufOptUnionSelector == (2).toByte()) {
                arrowWidthTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for arrowWidthTmpBufOpt has to be chosen through deserialisation.')
            }
            arrowWidthTmpBuf = (arrowWidthTmpBufOpt as string | number | global_resource_Resource)
        }
        const arrowWidthTmpResult : Dimension | undefined = arrowWidthTmpBuf
        const arrowHeightTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let arrowHeightTmpBuf : Dimension | undefined = undefined
        if ((arrowHeightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowHeightTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let arrowHeightTmpBufOpt : string | number | global_resource_Resource | undefined
            if (arrowHeightTmpBufOptUnionSelector == (0).toByte()) {
                arrowHeightTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (arrowHeightTmpBufOptUnionSelector == (1).toByte()) {
                arrowHeightTmpBufOpt = (valueDeserializer.readNumber() as number)
            } else if (arrowHeightTmpBufOptUnionSelector == (2).toByte()) {
                arrowHeightTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for arrowHeightTmpBufOpt has to be chosen through deserialisation.')
            }
            arrowHeightTmpBuf = (arrowHeightTmpBufOpt as string | number | global_resource_Resource)
        }
        const arrowHeightTmpResult : Dimension | undefined = arrowHeightTmpBuf
        const radiusTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let radiusTmpBuf : Dimension | undefined = undefined
        if ((radiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const radiusTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let radiusTmpBufOpt : string | number | global_resource_Resource | undefined
            if (radiusTmpBufOptUnionSelector == (0).toByte()) {
                radiusTmpBufOpt = (valueDeserializer.readString() as string)
            } else if (radiusTmpBufOptUnionSelector == (1).toByte()) {
                radiusTmpBufOpt = (valueDeserializer.readNumber() as number)
            } else if (radiusTmpBufOptUnionSelector == (2).toByte()) {
                radiusTmpBufOpt = global_resource_Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error('One of the branches for radiusTmpBufOpt has to be chosen through deserialisation.')
            }
            radiusTmpBuf = (radiusTmpBufOpt as string | number | global_resource_Resource)
        }
        const radiusTmpResult : Dimension | undefined = radiusTmpBuf
        const shadowTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let shadowTmpBuf : ShadowOptions | ShadowStyle | undefined = undefined
        if ((shadowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const shadowTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let shadowTmpBufOpt : ShadowOptions | ShadowStyle | undefined
            if (shadowTmpBufOptUnionSelector == (0).toByte()) {
                shadowTmpBufOpt = ShadowOptions_serializer.read(valueDeserializer)
            } else if (shadowTmpBufOptUnionSelector == (1).toByte()) {
                shadowTmpBufOpt = ShadowStyle.fromValue(valueDeserializer.readInt32())
            } else {
                throw new Error('One of the branches for shadowTmpBufOpt has to be chosen through deserialisation.')
            }
            shadowTmpBuf = (shadowTmpBufOpt as ShadowOptions | ShadowStyle)
        }
        const shadowTmpResult : ShadowOptions | ShadowStyle | undefined = shadowTmpBuf
        const backgroundBlurStyleTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let backgroundBlurStyleTmpBuf : BlurStyle | undefined = undefined
        if ((backgroundBlurStyleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundBlurStyleTmpBuf = BlurStyle.fromValue(valueDeserializer.readInt32())
        }
        const backgroundBlurStyleTmpResult : BlurStyle | undefined = backgroundBlurStyleTmpBuf
        const transitionTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let transitionTmpBuf : TransitionEffect | undefined = undefined
        if ((transitionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            transitionTmpBuf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transitionTmpResult : TransitionEffect | undefined = transitionTmpBuf
        const onWillDismissTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let onWillDismissTmpBuf : boolean | Callback<DismissPopupAction, void> | undefined = undefined
        if ((onWillDismissTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillDismissTmpBufOptUnionSelector : int32 = valueDeserializer.readInt8()
            let onWillDismissTmpBufOpt : boolean | Callback<DismissPopupAction, void> | undefined
            if (onWillDismissTmpBufOptUnionSelector == (0).toByte()) {
                onWillDismissTmpBufOpt = valueDeserializer.readBoolean()
            } else if (onWillDismissTmpBufOptUnionSelector == (1).toByte()) {
                const onWillDismissTmpBufOptBufUBufResource : CallbackResource = valueDeserializer.readCallbackResource()
                const onWillDismissTmpBufOptBufUBufCall : KPointer = valueDeserializer.readPointer()
                const onWillDismissTmpBufOptBufUBufCallSync : KPointer = valueDeserializer.readPointer()
                const onWillDismissTmpBufOptBufUClosure  = (data: DismissPopupAction):void => {
                    const onWillDismissTmpBufOptBufUBufArgsSerializer : SerializerBase = SerializerBase.hold();
                    onWillDismissTmpBufOptBufUBufArgsSerializer.writeInt32(onWillDismissTmpBufOptBufUBufResource.resourceId);
                    onWillDismissTmpBufOptBufUBufArgsSerializer.writePointer(onWillDismissTmpBufOptBufUBufCall);
                    onWillDismissTmpBufOptBufUBufArgsSerializer.writePointer(onWillDismissTmpBufOptBufUBufCallSync);
                    DismissPopupAction_serializer.write(onWillDismissTmpBufOptBufUBufArgsSerializer, data);
                    InteropNativeModule._CallCallbackSync(10, 1691355745, onWillDismissTmpBufOptBufUBufArgsSerializer.asBuffer(), onWillDismissTmpBufOptBufUBufArgsSerializer.length());
                    onWillDismissTmpBufOptBufUBufArgsSerializer.release();
                    return;
                }
                resourceFinalizerRegister(onWillDismissTmpBufOptBufUClosure, onWillDismissTmpBufOptBufUBufResource)
                onWillDismissTmpBufOpt = onWillDismissTmpBufOptBufUClosure
            } else {
                throw new Error('One of the branches for onWillDismissTmpBufOpt has to be chosen through deserialisation.')
            }
            onWillDismissTmpBuf = (onWillDismissTmpBufOpt as boolean | Callback<DismissPopupAction, void>)
        }
        const onWillDismissTmpResult : boolean | Callback<DismissPopupAction, void> | undefined = onWillDismissTmpBuf
        const enableHoverModeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let enableHoverModeTmpBuf : boolean | undefined = undefined
        if ((enableHoverModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableHoverModeTmpBuf = valueDeserializer.readBoolean()
        }
        const enableHoverModeTmpResult : boolean | undefined = enableHoverModeTmpBuf
        const followTransformOfTargetTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let followTransformOfTargetTmpBuf : boolean | undefined = undefined
        if ((followTransformOfTargetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            followTransformOfTargetTmpBuf = valueDeserializer.readBoolean()
        }
        const followTransformOfTargetTmpResult : boolean | undefined = followTransformOfTargetTmpBuf
        const keyboardAvoidModeTmpBuf_runtimeType  = valueDeserializer.readInt8()!.toInt()
        let keyboardAvoidModeTmpBuf : KeyboardAvoidMode | undefined = undefined
        if ((keyboardAvoidModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            keyboardAvoidModeTmpBuf = KeyboardAvoidMode.fromValue(valueDeserializer.readInt32())
        }
        const keyboardAvoidModeTmpResult : KeyboardAvoidMode | undefined = keyboardAvoidModeTmpBuf
        let value : PopupOptions = ({message: messageTmpResult, placement: placementTmpResult, primaryButton: primaryButtonTmpResult, secondaryButton: secondaryButtonTmpResult, onStateChange: onStateChangeTmpResult, arrowOffset: arrowOffsetTmpResult, showInSubWindow: showInSubWindowTmpResult, mask: maskTmpResult, messageOptions: messageOptionsTmpResult, targetSpace: targetSpaceTmpResult, enableArrow: enableArrowTmpResult, offset: offsetTmpResult, popupColor: popupColorTmpResult, autoCancel: autoCancelTmpResult, width: widthTmpResult, arrowPointPosition: arrowPointPositionTmpResult, arrowWidth: arrowWidthTmpResult, arrowHeight: arrowHeightTmpResult, radius: radiusTmpResult, shadow: shadowTmpResult, backgroundBlurStyle: backgroundBlurStyleTmpResult, transition: transitionTmpResult, onWillDismiss: onWillDismissTmpResult, enableHoverMode: enableHoverModeTmpResult, followTransformOfTarget: followTransformOfTargetTmpResult, keyboardAvoidMode: keyboardAvoidModeTmpResult} as PopupOptions)
        return value
    }
}
export interface AccessibilityHoverEvent extends BaseEvent {
    type: AccessibilityHoverType
    x: double
    y: double
    displayX: double
    displayY: double
    windowX: double
    windowY: double
}
export class AccessibilityHoverEventInternal extends BaseEventInternal implements MaterializedBase,AccessibilityHoverEvent {
    public type: AccessibilityHoverType
    public x: double
    public y: double
    public displayX: double
    public displayY: double
    public windowX: double
    public windowY: double
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        super(tag, peerPtr)
        this.type = this.getType()
        this.x = this.getX()
        this.y = this.getY()
        this.displayX = this.getDisplayX()
        this.displayY = this.getDisplayY()
        this.windowX = this.getWindowX()
        this.windowY = this.getWindowY()
    }
    constructor() {
        this(MaterializedBaseTag.NOP, AccessibilityHoverEventInternal.construct())
        this.type = this.getType()
        this.x = this.getX()
        this.y = this.getY()
        this.displayX = this.getDisplayX()
        this.displayY = this.getDisplayY()
        this.windowX = this.getWindowX()
        this.windowY = this.getWindowY()
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): AccessibilityHoverEventInternal {
        return new AccessibilityHoverEventInternal(MaterializedBaseTag.NOP, ptr)
    }
    private getType(): AccessibilityHoverType {
        return this.getType_serialize()
    }
    private setType(type: AccessibilityHoverType): void {
        const type_casted = type as (AccessibilityHoverType)
        this.setType_serialize(type_casted)
        return
    }
    private getX(): double {
        return this.getX_serialize()
    }
    private setX(x: double): void {
        const x_casted = x as (double)
        this.setX_serialize(x_casted)
        return
    }
    private getY(): double {
        return this.getY_serialize()
    }
    private setY(y: double): void {
        const y_casted = y as (double)
        this.setY_serialize(y_casted)
        return
    }
    private getDisplayX(): double {
        return this.getDisplayX_serialize()
    }
    private setDisplayX(displayX: double): void {
        const displayX_casted = displayX as (double)
        this.setDisplayX_serialize(displayX_casted)
        return
    }
    private getDisplayY(): double {
        return this.getDisplayY_serialize()
    }
    private setDisplayY(displayY: double): void {
        const displayY_casted = displayY as (double)
        this.setDisplayY_serialize(displayY_casted)
        return
    }
    private getWindowX(): double {
        return this.getWindowX_serialize()
    }
    private setWindowX(windowX: double): void {
        const windowX_casted = windowX as (double)
        this.setWindowX_serialize(windowX_casted)
        return
    }
    private getWindowY(): double {
        return this.getWindowY_serialize()
    }
    private setWindowY(windowY: double): void {
        const windowY_casted = windowY as (double)
        this.setWindowY_serialize(windowY_casted)
        return
    }
    private getType_serialize(): AccessibilityHoverType {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getType(this.peer!.ptr)
        return AccessibilityHoverType.fromValue(retval)
    }
    private setType_serialize(type: AccessibilityHoverType): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setType(this.peer!.ptr, type.valueOf())
    }
    private getX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getX(this.peer!.ptr)
        return retval
    }
    private setX_serialize(x: double): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setX(this.peer!.ptr, x)
    }
    private getY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getY(this.peer!.ptr)
        return retval
    }
    private setY_serialize(y: double): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setY(this.peer!.ptr, y)
    }
    private getDisplayX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getDisplayX(this.peer!.ptr)
        return retval
    }
    private setDisplayX_serialize(displayX: double): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setDisplayX(this.peer!.ptr, displayX)
    }
    private getDisplayY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getDisplayY(this.peer!.ptr)
        return retval
    }
    private setDisplayY_serialize(displayY: double): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setDisplayY(this.peer!.ptr, displayY)
    }
    private getWindowX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getWindowX(this.peer!.ptr)
        return retval
    }
    private setWindowX_serialize(windowX: double): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setWindowX(this.peer!.ptr, windowX)
    }
    private getWindowY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getWindowY(this.peer!.ptr)
        return retval
    }
    private setWindowY_serialize(windowY: double): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setWindowY(this.peer!.ptr, windowY)
    }
}
export interface AxisEvent extends BaseEvent {
    action: AxisAction
    displayX: double
    displayY: double
    windowX: double
    windowY: double
    x: double
    y: double
    scrollStep?: int32 | undefined
    propagation(): void
    getHorizontalAxisValue(): double
    getVerticalAxisValue(): double
    getPinchAxisScaleValue(): double
}
export class AxisEventInternal extends BaseEventInternal implements MaterializedBase,AxisEvent {
    public action: AxisAction
    public displayX: double
    public displayY: double
    public windowX: double
    public windowY: double
    public x: double
    public y: double
    public scrollStep?: int32 | undefined
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        super(tag, peerPtr)
        this.action = this.getAction()
        this.displayX = this.getDisplayX()
        this.displayY = this.getDisplayY()
        this.windowX = this.getWindowX()
        this.windowY = this.getWindowY()
        this.x = this.getX()
        this.y = this.getY()
        this.scrollStep = this.getScrollStep()
    }
    constructor() {
        this(MaterializedBaseTag.NOP, AxisEventInternal.construct())
        this.action = this.getAction()
        this.displayX = this.getDisplayX()
        this.displayY = this.getDisplayY()
        this.windowX = this.getWindowX()
        this.windowY = this.getWindowY()
        this.x = this.getX()
        this.y = this.getY()
        this.scrollStep = this.getScrollStep()
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._AxisEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): AxisEventInternal {
        return new AxisEventInternal(MaterializedBaseTag.NOP, ptr)
    }
    public propagation(): void {
        this.propagation_serialize()
        return
    }
    public getHorizontalAxisValue(): double {
        return this.getHorizontalAxisValue_serialize()
    }
    public getVerticalAxisValue(): double {
        return this.getVerticalAxisValue_serialize()
    }
    public getPinchAxisScaleValue(): double {
        return this.getPinchAxisScaleValue_serialize()
    }
    private getAction(): AxisAction {
        return this.getAction_serialize()
    }
    private setAction(action: AxisAction): void {
        const action_casted = action as (AxisAction)
        this.setAction_serialize(action_casted)
        return
    }
    private getDisplayX(): double {
        return this.getDisplayX_serialize()
    }
    private setDisplayX(displayX: double): void {
        const displayX_casted = displayX as (double)
        this.setDisplayX_serialize(displayX_casted)
        return
    }
    private getDisplayY(): double {
        return this.getDisplayY_serialize()
    }
    private setDisplayY(displayY: double): void {
        const displayY_casted = displayY as (double)
        this.setDisplayY_serialize(displayY_casted)
        return
    }
    private getWindowX(): double {
        return this.getWindowX_serialize()
    }
    private setWindowX(windowX: double): void {
        const windowX_casted = windowX as (double)
        this.setWindowX_serialize(windowX_casted)
        return
    }
    private getWindowY(): double {
        return this.getWindowY_serialize()
    }
    private setWindowY(windowY: double): void {
        const windowY_casted = windowY as (double)
        this.setWindowY_serialize(windowY_casted)
        return
    }
    private getX(): double {
        return this.getX_serialize()
    }
    private setX(x: double): void {
        const x_casted = x as (double)
        this.setX_serialize(x_casted)
        return
    }
    private getY(): double {
        return this.getY_serialize()
    }
    private setY(y: double): void {
        const y_casted = y as (double)
        this.setY_serialize(y_casted)
        return
    }
    private getScrollStep(): int32 | undefined {
        return this.getScrollStep_serialize()
    }
    private setScrollStep(scrollStep: int32 | undefined): void {
        const scrollStep_casted = scrollStep as (int32 | undefined)
        this.setScrollStep_serialize(scrollStep_casted)
        return
    }
    private propagation_serialize(): void {
        ArkUIGeneratedNativeModule._AxisEvent_propagation(this.peer!.ptr)
    }
    private getHorizontalAxisValue_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getHorizontalAxisValue(this.peer!.ptr)
        return retval
    }
    private getVerticalAxisValue_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getVerticalAxisValue(this.peer!.ptr)
        return retval
    }
    private getPinchAxisScaleValue_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getPinchAxisScaleValue(this.peer!.ptr)
        return retval
    }
    private getAction_serialize(): AxisAction {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getAction(this.peer!.ptr)
        return AxisAction.fromValue(retval)
    }
    private setAction_serialize(action: AxisAction): void {
        ArkUIGeneratedNativeModule._AxisEvent_setAction(this.peer!.ptr, action.valueOf())
    }
    private getDisplayX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getDisplayX(this.peer!.ptr)
        return retval
    }
    private setDisplayX_serialize(displayX: double): void {
        ArkUIGeneratedNativeModule._AxisEvent_setDisplayX(this.peer!.ptr, displayX)
    }
    private getDisplayY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getDisplayY(this.peer!.ptr)
        return retval
    }
    private setDisplayY_serialize(displayY: double): void {
        ArkUIGeneratedNativeModule._AxisEvent_setDisplayY(this.peer!.ptr, displayY)
    }
    private getWindowX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getWindowX(this.peer!.ptr)
        return retval
    }
    private setWindowX_serialize(windowX: double): void {
        ArkUIGeneratedNativeModule._AxisEvent_setWindowX(this.peer!.ptr, windowX)
    }
    private getWindowY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getWindowY(this.peer!.ptr)
        return retval
    }
    private setWindowY_serialize(windowY: double): void {
        ArkUIGeneratedNativeModule._AxisEvent_setWindowY(this.peer!.ptr, windowY)
    }
    private getX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getX(this.peer!.ptr)
        return retval
    }
    private setX_serialize(x: double): void {
        ArkUIGeneratedNativeModule._AxisEvent_setX(this.peer!.ptr, x)
    }
    private getY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getY(this.peer!.ptr)
        return retval
    }
    private setY_serialize(y: double): void {
        ArkUIGeneratedNativeModule._AxisEvent_setY(this.peer!.ptr, y)
    }
    private getScrollStep_serialize(): int32 | undefined {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getScrollStep(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : int32 | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readInt32()
        }
        const returnResult : int32 | undefined = buffer
        return returnResult
    }
    private setScrollStep_serialize(scrollStep: int32 | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (scrollStep !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const scrollStepTmpValue  = scrollStep!
            thisSerializer.writeInt32(scrollStepTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._AxisEvent_setScrollStep(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface ClickEvent extends BaseEvent {
    displayX: double
    displayY: double
    windowX: double
    windowY: double
    x: double
    y: double
    hand?: InteractionHand | undefined
    preventDefault(): void
}
export class ClickEventInternal extends BaseEventInternal implements MaterializedBase,ClickEvent {
    public displayX: double
    public displayY: double
    public windowX: double
    public windowY: double
    public x: double
    public y: double
    public hand?: InteractionHand | undefined
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        super(tag, peerPtr)
        this.displayX = this.getDisplayX()
        this.displayY = this.getDisplayY()
        this.windowX = this.getWindowX()
        this.windowY = this.getWindowY()
        this.x = this.getX()
        this.y = this.getY()
        this.hand = this.getHand()
    }
    constructor() {
        this(MaterializedBaseTag.NOP, ClickEventInternal.construct())
        this.displayX = this.getDisplayX()
        this.displayY = this.getDisplayY()
        this.windowX = this.getWindowX()
        this.windowY = this.getWindowY()
        this.x = this.getX()
        this.y = this.getY()
        this.hand = this.getHand()
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._ClickEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): ClickEventInternal {
        return new ClickEventInternal(MaterializedBaseTag.NOP, ptr)
    }
    public preventDefault(): void {
        // instructive change start
        ArkUIAniModule._ClickEvent_preventDefault(this!.peer!.ptr);
        // instructive change end
        return
    }
    private getDisplayX(): double {
        return this.getDisplayX_serialize()
    }
    private setDisplayX(displayX: double): void {
        const displayX_casted = displayX as (double)
        this.setDisplayX_serialize(displayX_casted)
        return
    }
    private getDisplayY(): double {
        return this.getDisplayY_serialize()
    }
    private setDisplayY(displayY: double): void {
        const displayY_casted = displayY as (double)
        this.setDisplayY_serialize(displayY_casted)
        return
    }
    private getWindowX(): double {
        return this.getWindowX_serialize()
    }
    private setWindowX(windowX: double): void {
        const windowX_casted = windowX as (double)
        this.setWindowX_serialize(windowX_casted)
        return
    }
    private getWindowY(): double {
        return this.getWindowY_serialize()
    }
    private setWindowY(windowY: double): void {
        const windowY_casted = windowY as (double)
        this.setWindowY_serialize(windowY_casted)
        return
    }
    private getX(): double {
        return this.getX_serialize()
    }
    private setX(x: double): void {
        const x_casted = x as (double)
        this.setX_serialize(x_casted)
        return
    }
    private getY(): double {
        return this.getY_serialize()
    }
    private setY(y: double): void {
        const y_casted = y as (double)
        this.setY_serialize(y_casted)
        return
    }
    private getHand(): InteractionHand | undefined {
        return this.getHand_serialize()
    }
    private setHand(hand: InteractionHand | undefined): void {
        const hand_casted = hand as (InteractionHand | undefined)
        this.setHand_serialize(hand_casted)
        return
    }
    private preventDefault_serialize(): void {
        ArkUIGeneratedNativeModule._ClickEvent_preventDefault(this.peer!.ptr)
    }
    private getDisplayX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getDisplayX(this.peer!.ptr)
        return retval
    }
    private setDisplayX_serialize(displayX: double): void {
        ArkUIGeneratedNativeModule._ClickEvent_setDisplayX(this.peer!.ptr, displayX)
    }
    private getDisplayY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getDisplayY(this.peer!.ptr)
        return retval
    }
    private setDisplayY_serialize(displayY: double): void {
        ArkUIGeneratedNativeModule._ClickEvent_setDisplayY(this.peer!.ptr, displayY)
    }
    private getWindowX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getWindowX(this.peer!.ptr)
        return retval
    }
    private setWindowX_serialize(windowX: double): void {
        ArkUIGeneratedNativeModule._ClickEvent_setWindowX(this.peer!.ptr, windowX)
    }
    private getWindowY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getWindowY(this.peer!.ptr)
        return retval
    }
    private setWindowY_serialize(windowY: double): void {
        ArkUIGeneratedNativeModule._ClickEvent_setWindowY(this.peer!.ptr, windowY)
    }
    private getX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getX(this.peer!.ptr)
        return retval
    }
    private setX_serialize(x: double): void {
        ArkUIGeneratedNativeModule._ClickEvent_setX(this.peer!.ptr, x)
    }
    private getY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getY(this.peer!.ptr)
        return retval
    }
    private setY_serialize(y: double): void {
        ArkUIGeneratedNativeModule._ClickEvent_setY(this.peer!.ptr, y)
    }
    private getHand_serialize(): InteractionHand | undefined {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getHand(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : InteractionHand | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = InteractionHand.fromValue(retvalDeserializer.readInt32())
        }
        const returnResult : InteractionHand | undefined = buffer
        return returnResult
    }
    private setHand_serialize(hand: InteractionHand | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (hand !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const handTmpValue  = (hand as InteractionHand)
            thisSerializer.writeInt32(handTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ClickEvent_setHand(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface FocusAxisEvent extends BaseEvent {
    axisMap: Map<AxisModel, double>
    stopPropagation(): void
}
export class FocusAxisEventInternal extends BaseEventInternal implements MaterializedBase,FocusAxisEvent {
    public axisMap: Map<AxisModel, double>
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        super(tag, peerPtr)
        this.axisMap = this.getAxisMap()
    }
    constructor() {
        this(MaterializedBaseTag.NOP, FocusAxisEventInternal.construct())
        this.axisMap = this.getAxisMap()
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._FocusAxisEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._FocusAxisEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): FocusAxisEventInternal {
        return new FocusAxisEventInternal(MaterializedBaseTag.NOP, ptr)
    }
    public stopPropagation(): void {
        this.stopPropagation_serialize()
        return
    }
    private getAxisMap(): Map<AxisModel, double> {
        return this.getAxisMap_serialize()
    }
    private setAxisMap(axisMap: Map<AxisModel, double>): void {
        const axisMap_casted = axisMap as (Map<AxisModel, double>)
        this.setAxisMap_serialize(axisMap_casted)
        return
    }
    private stopPropagation_serialize(): void {
        ArkUIGeneratedNativeModule._FocusAxisEvent_stopPropagation(this.peer!.ptr)
    }
    private getAxisMap_serialize(): Map<AxisModel, double> {
        const retval  = ArkUIGeneratedNativeModule._FocusAxisEvent_getAxisMap(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const bufferSizeVar : int32 = retvalDeserializer.readInt32()
        let buffer : Map<AxisModel, double> = new Map<AxisModel, double>()
        // TODO: TS map resize
        for (let bufferIVar = 0; bufferIVar < bufferSizeVar; bufferIVar++) {
            const bufferKeyVar : AxisModel = AxisModel.fromValue(retvalDeserializer.readInt32())
            const bufferValueVar : double = retvalDeserializer.readFloat64()
            buffer.set(bufferKeyVar, bufferValueVar)
        }
        const returnResult : Map<AxisModel, double> = buffer
        return returnResult
    }
    private setAxisMap_serialize(axisMap: Map<AxisModel, double>): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.writeInt32((axisMap.size).toInt())
        for (const pair of axisMap) {
            const axisMapKeyVar = pair[0]
            const axisMapValueVar = pair[1]
            thisSerializer.writeInt32(axisMapKeyVar.valueOf())
            thisSerializer.writeFloat64(axisMapValueVar)
        }
        ArkUIGeneratedNativeModule._FocusAxisEvent_setAxisMap(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface HoverEvent extends BaseEvent {
    x?: double | undefined
    y?: double | undefined
    windowX?: double | undefined
    windowY?: double | undefined
    displayX?: double | undefined
    displayY?: double | undefined
    stopPropagation(): void
}
export class HoverEventInternal extends BaseEventInternal implements MaterializedBase,HoverEvent {
    public x?: double | undefined
    public y?: double | undefined
    public windowX?: double | undefined
    public windowY?: double | undefined
    public displayX?: double | undefined
    public displayY?: double | undefined
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        super(tag, peerPtr)
        this.x = this.getX()
        this.y = this.getY()
        this.windowX = this.getWindowX()
        this.windowY = this.getWindowY()
        this.displayX = this.getDisplayX()
        this.displayY = this.getDisplayY()
    }
    constructor() {
        this(MaterializedBaseTag.NOP, HoverEventInternal.construct())
        this.x = this.getX()
        this.y = this.getY()
        this.windowX = this.getWindowX()
        this.windowY = this.getWindowY()
        this.displayX = this.getDisplayX()
        this.displayY = this.getDisplayY()
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._HoverEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): HoverEventInternal {
        return new HoverEventInternal(MaterializedBaseTag.NOP, ptr)
    }
    public stopPropagation(): void {
        this.stopPropagation_serialize()
        return
    }
    private getX(): double | undefined {
        return this.getX_serialize()
    }
    private setX(x: double | undefined): void {
        const x_casted = x as (double | undefined)
        this.setX_serialize(x_casted)
        return
    }
    private getY(): double | undefined {
        return this.getY_serialize()
    }
    private setY(y: double | undefined): void {
        const y_casted = y as (double | undefined)
        this.setY_serialize(y_casted)
        return
    }
    private getWindowX(): double | undefined {
        return this.getWindowX_serialize()
    }
    private setWindowX(windowX: double | undefined): void {
        const windowX_casted = windowX as (double | undefined)
        this.setWindowX_serialize(windowX_casted)
        return
    }
    private getWindowY(): double | undefined {
        return this.getWindowY_serialize()
    }
    private setWindowY(windowY: double | undefined): void {
        const windowY_casted = windowY as (double | undefined)
        this.setWindowY_serialize(windowY_casted)
        return
    }
    private getDisplayX(): double | undefined {
        return this.getDisplayX_serialize()
    }
    private setDisplayX(displayX: double | undefined): void {
        const displayX_casted = displayX as (double | undefined)
        this.setDisplayX_serialize(displayX_casted)
        return
    }
    private getDisplayY(): double | undefined {
        return this.getDisplayY_serialize()
    }
    private setDisplayY(displayY: double | undefined): void {
        const displayY_casted = displayY as (double | undefined)
        this.setDisplayY_serialize(displayY_casted)
        return
    }
    private stopPropagation_serialize(): void {
        ArkUIGeneratedNativeModule._HoverEvent_stopPropagation(this.peer!.ptr)
    }
    private getX_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getX(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setX_serialize(x: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (x !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const xTmpValue  = x!
            thisSerializer.writeFloat64(xTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setX(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getY_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getY(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setY_serialize(y: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (y !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const yTmpValue  = y!
            thisSerializer.writeFloat64(yTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setY(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getWindowX_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getWindowX(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setWindowX_serialize(windowX: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (windowX !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const windowXTmpValue  = windowX!
            thisSerializer.writeFloat64(windowXTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setWindowX(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getWindowY_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getWindowY(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setWindowY_serialize(windowY: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (windowY !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const windowYTmpValue  = windowY!
            thisSerializer.writeFloat64(windowYTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setWindowY(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getDisplayX_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getDisplayX(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setDisplayX_serialize(displayX: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (displayX !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const displayXTmpValue  = displayX!
            thisSerializer.writeFloat64(displayXTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setDisplayX(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getDisplayY_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getDisplayY(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setDisplayY_serialize(displayY: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (displayY !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const displayYTmpValue  = displayY!
            thisSerializer.writeFloat64(displayYTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setDisplayY(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface MouseEvent extends BaseEvent {
    button: MouseButton
    action: MouseAction
    displayX: double
    displayY: double
    windowX: double
    windowY: double
    x: double
    y: double
    stopPropagation: (() => void)
    rawDeltaX?: double | undefined
    rawDeltaY?: double | undefined
    pressedButtons?: Array<MouseButton> | undefined
}
export class MouseEventInternal extends BaseEventInternal implements MaterializedBase,MouseEvent {
    public button: MouseButton
    public action: MouseAction
    public displayX: double
    public displayY: double
    public windowX: double
    public windowY: double
    public x: double
    public y: double
    public stopPropagation: (() => void)
    public rawDeltaX?: double | undefined
    public rawDeltaY?: double | undefined
    public pressedButtons?: Array<MouseButton> | undefined
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        super(tag, peerPtr)
        this.button = this.getButton()
        this.action = this.getAction()
        this.displayX = this.getDisplayX()
        this.displayY = this.getDisplayY()
        this.windowX = this.getWindowX()
        this.windowY = this.getWindowY()
        this.x = this.getX()
        this.y = this.getY()
        this.stopPropagation = this.getStopPropagation()
        this.rawDeltaX = this.getRawDeltaX()
        this.rawDeltaY = this.getRawDeltaY()
        this.pressedButtons = this.getPressedButtons()
    }
    constructor() {
        this(MaterializedBaseTag.NOP, MouseEventInternal.construct())
        this.button = this.getButton()
        this.action = this.getAction()
        this.displayX = this.getDisplayX()
        this.displayY = this.getDisplayY()
        this.windowX = this.getWindowX()
        this.windowY = this.getWindowY()
        this.x = this.getX()
        this.y = this.getY()
        this.stopPropagation = this.getStopPropagation()
        this.rawDeltaX = this.getRawDeltaX()
        this.rawDeltaY = this.getRawDeltaY()
        this.pressedButtons = this.getPressedButtons()
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._MouseEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): MouseEventInternal {
        return new MouseEventInternal(MaterializedBaseTag.NOP, ptr)
    }
    private getButton(): MouseButton {
        return this.getButton_serialize()
    }
    private setButton(button: MouseButton): void {
        const button_casted = button as (MouseButton)
        this.setButton_serialize(button_casted)
        return
    }
    private getAction(): MouseAction {
        return this.getAction_serialize()
    }
    private setAction(action: MouseAction): void {
        const action_casted = action as (MouseAction)
        this.setAction_serialize(action_casted)
        return
    }
    private getDisplayX(): double {
        return this.getDisplayX_serialize()
    }
    private setDisplayX(displayX: double): void {
        const displayX_casted = displayX as (double)
        this.setDisplayX_serialize(displayX_casted)
        return
    }
    private getDisplayY(): double {
        return this.getDisplayY_serialize()
    }
    private setDisplayY(displayY: double): void {
        const displayY_casted = displayY as (double)
        this.setDisplayY_serialize(displayY_casted)
        return
    }
    private getWindowX(): double {
        return this.getWindowX_serialize()
    }
    private setWindowX(windowX: double): void {
        const windowX_casted = windowX as (double)
        this.setWindowX_serialize(windowX_casted)
        return
    }
    private getWindowY(): double {
        return this.getWindowY_serialize()
    }
    private setWindowY(windowY: double): void {
        const windowY_casted = windowY as (double)
        this.setWindowY_serialize(windowY_casted)
        return
    }
    private getX(): double {
        return this.getX_serialize()
    }
    private setX(x: double): void {
        const x_casted = x as (double)
        this.setX_serialize(x_casted)
        return
    }
    private getY(): double {
        return this.getY_serialize()
    }
    private setY(y: double): void {
        const y_casted = y as (double)
        this.setY_serialize(y_casted)
        return
    }
    private getStopPropagation(): (() => void) {
        return this.getStopPropagation_serialize()
    }
    private setStopPropagation(stopPropagation: (() => void)): void {
        const stopPropagation_casted = stopPropagation as ((() => void))
        this.setStopPropagation_serialize(stopPropagation_casted)
        return
    }
    private getRawDeltaX(): double | undefined {
        return this.getRawDeltaX_serialize()
    }
    private setRawDeltaX(rawDeltaX: double | undefined): void {
        const rawDeltaX_casted = rawDeltaX as (double | undefined)
        this.setRawDeltaX_serialize(rawDeltaX_casted)
        return
    }
    private getRawDeltaY(): double | undefined {
        return this.getRawDeltaY_serialize()
    }
    private setRawDeltaY(rawDeltaY: double | undefined): void {
        const rawDeltaY_casted = rawDeltaY as (double | undefined)
        this.setRawDeltaY_serialize(rawDeltaY_casted)
        return
    }
    private getPressedButtons(): Array<MouseButton> | undefined {
        return this.getPressedButtons_serialize()
    }
    private setPressedButtons(pressedButtons: Array<MouseButton> | undefined): void {
        const pressedButtons_casted = pressedButtons as (Array<MouseButton> | undefined)
        this.setPressedButtons_serialize(pressedButtons_casted)
        return
    }
    private getButton_serialize(): MouseButton {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getButton(this.peer!.ptr)
        return MouseButton.fromValue(retval)
    }
    private setButton_serialize(button: MouseButton): void {
        ArkUIGeneratedNativeModule._MouseEvent_setButton(this.peer!.ptr, button.valueOf())
    }
    private getAction_serialize(): MouseAction {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getAction(this.peer!.ptr)
        return MouseAction.fromValue(retval)
    }
    private setAction_serialize(action: MouseAction): void {
        ArkUIGeneratedNativeModule._MouseEvent_setAction(this.peer!.ptr, action.valueOf())
    }
    private getDisplayX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getDisplayX(this.peer!.ptr)
        return retval
    }
    private setDisplayX_serialize(displayX: double): void {
        ArkUIGeneratedNativeModule._MouseEvent_setDisplayX(this.peer!.ptr, displayX)
    }
    private getDisplayY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getDisplayY(this.peer!.ptr)
        return retval
    }
    private setDisplayY_serialize(displayY: double): void {
        ArkUIGeneratedNativeModule._MouseEvent_setDisplayY(this.peer!.ptr, displayY)
    }
    private getWindowX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getWindowX(this.peer!.ptr)
        return retval
    }
    private setWindowX_serialize(windowX: double): void {
        ArkUIGeneratedNativeModule._MouseEvent_setWindowX(this.peer!.ptr, windowX)
    }
    private getWindowY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getWindowY(this.peer!.ptr)
        return retval
    }
    private setWindowY_serialize(windowY: double): void {
        ArkUIGeneratedNativeModule._MouseEvent_setWindowY(this.peer!.ptr, windowY)
    }
    private getX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getX(this.peer!.ptr)
        return retval
    }
    private setX_serialize(x: double): void {
        ArkUIGeneratedNativeModule._MouseEvent_setX(this.peer!.ptr, x)
    }
    private getY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getY(this.peer!.ptr)
        return retval
    }
    private setY_serialize(y: double): void {
        ArkUIGeneratedNativeModule._MouseEvent_setY(this.peer!.ptr, y)
    }
    private getStopPropagation_serialize(): (() => void) {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getStopPropagation(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const bufferBufResource : CallbackResource = retvalDeserializer.readCallbackResource()
        const bufferBufCall : KPointer = retvalDeserializer.readPointer()
        const bufferBufCallSync : KPointer = retvalDeserializer.readPointer()
        const bufferClosure  = ():void => {
            const bufferBufArgsSerializer : SerializerBase = SerializerBase.hold();
            bufferBufArgsSerializer.writeInt32(bufferBufResource.resourceId);
            bufferBufArgsSerializer.writePointer(bufferBufCall);
            bufferBufArgsSerializer.writePointer(bufferBufCallSync);
            InteropNativeModule._CallCallbackSync(10, -1225416436, bufferBufArgsSerializer.asBuffer(), bufferBufArgsSerializer.length());
            bufferBufArgsSerializer.release();
            return;
        }
        resourceFinalizerRegister(bufferClosure, bufferBufResource)
        const returnResult : (() => void) = bufferClosure
        return returnResult
    }
    private setStopPropagation_serialize(stopPropagation: (() => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.holdAndWriteCallback(stopPropagation)
        ArkUIGeneratedNativeModule._MouseEvent_setStopPropagation(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getRawDeltaX_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getRawDeltaX(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setRawDeltaX_serialize(rawDeltaX: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (rawDeltaX !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const rawDeltaXTmpValue  = rawDeltaX!
            thisSerializer.writeFloat64(rawDeltaXTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._MouseEvent_setRawDeltaX(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getRawDeltaY_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getRawDeltaY(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setRawDeltaY_serialize(rawDeltaY: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (rawDeltaY !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const rawDeltaYTmpValue  = rawDeltaY!
            thisSerializer.writeFloat64(rawDeltaYTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._MouseEvent_setRawDeltaY(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getPressedButtons_serialize(): Array<MouseButton> | undefined {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getPressedButtons(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : Array<MouseButton> | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            const bufferOptLength : int32 = retvalDeserializer.readInt32()
            let bufferOpt : Array<MouseButton> = new Array<MouseButton>(bufferOptLength)
            for (let bufferOptBufCounterI = 0; bufferOptBufCounterI < bufferOptLength; bufferOptBufCounterI++) {
                bufferOpt[bufferOptBufCounterI] = MouseButton.fromValue(retvalDeserializer.readInt32())
            }
            buffer = bufferOpt
        }
        const returnResult : Array<MouseButton> | undefined = buffer
        return returnResult
    }
    private setPressedButtons_serialize(pressedButtons: Array<MouseButton> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (pressedButtons !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const pressedButtonsTmpValue  = pressedButtons!
            thisSerializer.writeInt32((pressedButtonsTmpValue.length).toInt())
            for (let pressedButtonsTmpValueCounterI = 0; pressedButtonsTmpValueCounterI < pressedButtonsTmpValue.length; pressedButtonsTmpValueCounterI++) {
                const pressedButtonsTmpValueTmpElement : MouseButton = pressedButtonsTmpValue[pressedButtonsTmpValueCounterI]
                thisSerializer.writeInt32(pressedButtonsTmpValueTmpElement.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._MouseEvent_setPressedButtons(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface TouchEvent extends BaseEvent {
    type: TouchType
    touches: Array<TouchObject>
    changedTouches: Array<TouchObject>
    stopPropagation(): void
    getHistoricalPoints(): Array<HistoricalPoint> | undefined
    preventDefault(): void
}
export class TouchEventInternal extends BaseEventInternal implements MaterializedBase,TouchEvent {
    public type: TouchType
    public touches: Array<TouchObject>
    public changedTouches: Array<TouchObject>
    constructor(tag: MaterializedBaseTag, peerPtr: KPointer) {
        super(tag, peerPtr)
        this.type = this.getType()
        this.touches = this.getTouches()
        this.changedTouches = this.getChangedTouches()
    }
    constructor() {
        this(MaterializedBaseTag.NOP, TouchEventInternal.construct())
        this.type = this.getType()
        this.touches = this.getTouches()
        this.changedTouches = this.getChangedTouches()
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._TouchEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._TouchEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): TouchEventInternal {
        return new TouchEventInternal(MaterializedBaseTag.NOP, ptr)
    }
    public stopPropagation(): void {
        this.stopPropagation_serialize()
        return
    }
    public getHistoricalPoints(): Array<HistoricalPoint> | undefined {
        return this.getHistoricalPoints_serialize()
    }
    public preventDefault(): void {
        // instructive change start
        ArkUIAniModule._TouchEvent_preventDefault(this!.peer!.ptr);
        // instructive change end
        return
    }
    private getType(): TouchType {
        return this.getType_serialize()
    }
    private setType(type: TouchType): void {
        const type_casted = type as (TouchType)
        this.setType_serialize(type_casted)
        return
    }
    private getTouches(): Array<TouchObject> {
        return this.getTouches_serialize()
    }
    private setTouches(touches: Array<TouchObject>): void {
        const touches_casted = touches as (Array<TouchObject>)
        this.setTouches_serialize(touches_casted)
        return
    }
    private getChangedTouches(): Array<TouchObject> {
        return this.getChangedTouches_serialize()
    }
    private setChangedTouches(changedTouches: Array<TouchObject>): void {
        const changedTouches_casted = changedTouches as (Array<TouchObject>)
        this.setChangedTouches_serialize(changedTouches_casted)
        return
    }
    private stopPropagation_serialize(): void {
        ArkUIGeneratedNativeModule._TouchEvent_stopPropagation(this.peer!.ptr)
    }
    private getHistoricalPoints_serialize(): Array<HistoricalPoint> | undefined {
        const retval  = ArkUIGeneratedNativeModule._TouchEvent_getHistoricalPoints(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8()!.toInt()
        let buffer : Array<HistoricalPoint> | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            const bufferOptLength : int32 = retvalDeserializer.readInt32()
            let bufferOpt : Array<HistoricalPoint> = new Array<HistoricalPoint>(bufferOptLength)
            for (let bufferOptBufCounterI = 0; bufferOptBufCounterI < bufferOptLength; bufferOptBufCounterI++) {
                bufferOpt[bufferOptBufCounterI] = HistoricalPoint_serializer.read(retvalDeserializer)
            }
            buffer = bufferOpt
        }
        const returnResult : Array<HistoricalPoint> | undefined = buffer
        return returnResult
    }
    private preventDefault_serialize(): void {
        ArkUIGeneratedNativeModule._TouchEvent_preventDefault(this.peer!.ptr)
    }
    private getType_serialize(): TouchType {
        const retval  = ArkUIGeneratedNativeModule._TouchEvent_getType(this.peer!.ptr)
        return TouchType.fromValue(retval)
    }
    private setType_serialize(type: TouchType): void {
        ArkUIGeneratedNativeModule._TouchEvent_setType(this.peer!.ptr, type.valueOf())
    }
    private getTouches_serialize(): Array<TouchObject> {
        const retval  = ArkUIGeneratedNativeModule._TouchEvent_getTouches(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const bufferLength : int32 = retvalDeserializer.readInt32()
        let buffer : Array<TouchObject> = new Array<TouchObject>(bufferLength)
        for (let bufferBufCounterI = 0; bufferBufCounterI < bufferLength; bufferBufCounterI++) {
            buffer[bufferBufCounterI] = TouchObject_serializer.read(retvalDeserializer)
        }
        const returnResult : Array<TouchObject> = buffer
        return returnResult
    }
    private setTouches_serialize(touches: Array<TouchObject>): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.writeInt32((touches.length).toInt())
        for (let touchesCounterI = 0; touchesCounterI < touches.length; touchesCounterI++) {
            const touchesTmpElement : TouchObject = touches[touchesCounterI]
            TouchObject_serializer.write(thisSerializer, touchesTmpElement)
        }
        ArkUIGeneratedNativeModule._TouchEvent_setTouches(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getChangedTouches_serialize(): Array<TouchObject> {
        const retval  = ArkUIGeneratedNativeModule._TouchEvent_getChangedTouches(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const bufferLength : int32 = retvalDeserializer.readInt32()
        let buffer : Array<TouchObject> = new Array<TouchObject>(bufferLength)
        for (let bufferBufCounterI = 0; bufferBufCounterI < bufferLength; bufferBufCounterI++) {
            buffer[bufferBufCounterI] = TouchObject_serializer.read(retvalDeserializer)
        }
        const returnResult : Array<TouchObject> = buffer
        return returnResult
    }
    private setChangedTouches_serialize(changedTouches: Array<TouchObject>): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.writeInt32((changedTouches.length).toInt())
        for (let changedTouchesCounterI = 0; changedTouchesCounterI < changedTouches.length; changedTouchesCounterI++) {
            const changedTouchesTmpElement : TouchObject = changedTouches[changedTouchesCounterI]
            TouchObject_serializer.write(thisSerializer, changedTouchesTmpElement)
        }
        ArkUIGeneratedNativeModule._TouchEvent_setChangedTouches(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export namespace cursorControl {
    export function setCursor(value: PointerStyle): void {
        GlobalScope.cursorControl_setCursor(value)
    }
    export function restoreDefault(): void {
        GlobalScope.cursorControl_restoreDefault()
    }
}
export namespace focusControl {
    export function requestFocus(value: string): boolean {
        return GlobalScope.focusControl_requestFocus(value)
    }
}
