/*
 * Copyright (c) 2024-2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


// WARNING! THIS FILE IS AUTO-GENERATED, DO NOT MAKE CHANGES, THEY WILL BE LOST ON NEXT GENERATION!

import { SerializerBase, DeserializerBase, Finalizable, runtimeType, RuntimeType, toPeerPtr, KPointer, MaterializedBase, NativeBuffer, nullptr, KInt, KBoolean, KStringPtr, CallbackResource, InteropNativeModule, Tags, KSerializerBuffer, KUint8ArrayPtr } from "@koalaui/interop"
import { TypeChecker, ArkUIGeneratedNativeModule } from "#components"
import { unsafeCast, int32, int64, float32 } from "@koalaui/common"
import { CallbackTransformer } from "./../CallbackTransformer"
import { extractors, DrawModifier, GestureModifier, WrappedBuilder, hookId, hookStateStyleImpl, hookGesture, hookPriorityGesture, hookParallelGesture, hookGestureModifier, hookCustomPropertyImpl, hookDrawModifier, CustomStyles, ContentModifier, hookCommonMethodAttributeModifier, AttributeModifier, AttributeUpdater, hookCommonShapeMethodAttributeModifier, hookScrollableCommonMethodAttributeModifier, hookAllowDrop, hookDragPreviewOptions, hookDragEventStartDataLoading, hookDragEventGetSummary } from "#handwritten"
import { default as unifiedDataChannel } from "@ohos.data.unifiedDataChannel"
import { DrawContext, LengthMetrics, ColorMetrics } from "arkui.Graphics"
import { KeyType, KeySource, Color, HitTestMode, ImageSize, Alignment, BorderStyle, ColoringStrategy, HoverEffect, Visibility, ItemAlign, Direction, ObscuredReasons, RenderFit, FocusDrawLevel, ImageRepeat, Axis, ResponseType, FunctionKey, ModifierKey, InteractionHand, GradientDirection, SharedTransitionEffectType, ArrowPointPosition, Placement, LineCapStyle, LineJoinStyle, BarState, CrownSensitivity, EdgeEffect, TextDecorationType, TextDecorationStyle, PlayMode, VerticalAlign, HorizontalAlign, FontWeight, FontStyle, TouchType, CrownAction, ClickEffectLevel, NestedScrollMode, ResponseRegionSupportedTool, PixelRoundCalcPolicy, ScrollSource, IlluminatedType, AccessibilityHoverType, AxisAction, AxisType, AxisModel, MouseButton, MouseAction } from "./enums"
import { IntentionCode } from "@ohos.multimodalInput.intentionCode"
import { Position_serializer, DirectionalEdgesT_serializer, Position, DirectionalEdgesT, ConstraintSizeOptions_serializer, ConstraintSizeOptions, ResourceColor, SizeOptions, SizeOptions_serializer, ChainWeightOptions_serializer, Padding_serializer, LocalizedPadding_serializer, BorderOptions_serializer, EdgeStyles_serializer, EdgeWidths_serializer, LocalizedEdgeWidths_serializer, EdgeColors_serializer, LocalizedEdgeColors_serializer, BorderRadiuses_serializer, LocalizedBorderRadiuses_serializer, OutlineOptions_serializer, EdgeOutlineStyles_serializer, EdgeOutlineWidths_serializer, OutlineRadiuses_serializer, Edges_serializer, LocalizedEdges_serializer, LocalizedPosition_serializer, AccessibilityOptions_serializer, Length, ChainWeightOptions, Padding, LocalizedPadding, BorderOptions, EdgeStyles, EdgeWidths, LocalizedEdgeWidths, EdgeColors, LocalizedEdgeColors, BorderRadiuses, LocalizedBorderRadiuses, OutlineOptions, EdgeOutlineStyles, Dimension, EdgeOutlineWidths, OutlineRadiuses, VoidCallback, Area, Edges, LocalizedEdges, LocalizedPosition, ResourceStr, AccessibilityOptions, Bias, Font, Bias_serializer, Area_serializer, Font_serializer } from "./units"
import { Resource_serializer } from "./../framework/resource"
import { Resource } from "global.resource"
import { TextRange_serializer, TextRange } from "./textCommon"
import { LengthMetrics_serializer, ColorMetrics_serializer } from "./../Graphics"
import { ResizableOptions_serializer, ResizableOptions } from "./image"
import { uiEffect_VisualEffect_serializer, uiEffect_Filter_serializer, uiEffect_BrightnessBlender_serializer } from "./../framework/ohos.graphics.uiEffect"
import { FocusBoxStyle_serializer, FocusBoxStyle, FocusPriority } from "./focus"
import { matrix4_Matrix4Transit_serializer } from "./../framework/ohos.matrix4"
import { CircleShape_serializer, EllipseShape_serializer, PathShape_serializer, RectShape_serializer } from "./../framework/ohos.arkui.shape"
import { image_PixelMap_serializer } from "./../framework/ohos.multimedia.image"
import { StyledString_serializer, StyledString, ImageAttachment, CustomSpan, StyleOptions, StyledStringKey, SpanStyle, StyledStringMarshallCallback, UserDataSpan, StyledStringUnmarshallCallback } from "./styledString"
import { ComponentBase } from "./../ComponentBase"
import { PeerNode } from "./../PeerNode"
import { default as uiEffect } from "@ohos.graphics.uiEffect"
import { default as matrix4 } from "@ohos.matrix4"
import { CustomBuilder, CustomBuilderT } from "./builder"
import { default as uniformTypeDescriptor } from "@ohos.data.uniformTypeDescriptor"
import { CircleShape, EllipseShape, PathShape, RectShape } from "@ohos.arkui.shape"
import { GestureInfo, BaseGestureEvent, GestureJudgeResult, GestureRecognizer, GestureType, GestureMask, FingerInfo, GestureControl, GestureRecognizerState, EventTargetInfo } from "./gesture"
import { default as image } from "@ohos.multimedia.image"
import { ComponentContent, ComponentContentBase } from "arkui.ComponentContent"
import { AsyncCallback, BusinessError } from "@ohos.base"
import { default as colorSpaceManager } from "@ohos.graphics.colorSpaceManager"
import { default as rpc } from "@ohos.rpc"
import { default as curves } from "@ohos.curves"
import { UIContext } from "@ohos.arkui.UIContext"
import { BuildOptions } from "arkui.BuilderNode"
import { ImageModifier } from "./../ImageModifier"
import { ImageModifier_serializer } from "./../ImageModifier"
import { SymbolGlyphModifier } from "arkui.SymbolGlyphModifier"
import { CallbackKind } from "./../framework/peers/CallbackKind"
import { memo, memo_stable } from "@koalaui/runtime/annotations"
import { ComponentBuilder, Builder } from "@koalaui/builderLambda"
import { default as Context } from "application.Context"
import { default as pointer } from "@ohos.multimodalInput.pointer"
import { ButtonType, ButtonStyleMode, ButtonRole } from "./button"
import { default as uiObserver } from "@ohos.arkui.observer"
import { default as promptAction } from "@ohos.promptAction"
import { ScrollState } from "./list"
import { default as Want } from "@ohos.app.ability.Want"
import { default as intl } from "@ohos.intl"
import { CommonMethodModifier } from "./../CommonMethodModifier"
import { NodeAttach, remember } from "@koalaui/runtime"
import { CommonShapeMethodModifier } from "./../CommonShapeMethodModifier"
import { ScrollableCommonMethodModifier } from "./../ScrollableCommonMethodModifier"
import { GlobalScope } from "./../framework/GlobalScope"
import { curves_ICurve_serializer } from "./../framework/ohos.curves"
import { SymbolGlyphModifier_serializer } from "./../SymbolGlyphModifier"
import { Want_serializer } from "./../framework/ohos.app.ability.Want"
import { UIContext_serializer } from "./../framework/ohos.arkui.UIContext"
import { unifiedDataChannel_UnifiedData_serializer, unifiedDataChannel_Summary_serializer } from "./../framework/ohos.data.unifiedDataChannel"
// instructive change start
import { _animateTo, _animationStart, _animationStop } from "arkui/base/ArkAnimation"
import { AnimationExtender } from '#generated';
import { ArkUIAniModule } from "arkui.ani"
// instructive change end
export interface BaseEvent {
    target: EventTarget
    timestamp: int64
    source: SourceType
    axisHorizontal?: double | undefined
    axisVertical?: double | undefined
    pressure: double
    tiltX: double
    tiltY: double
    rollAngle?: double | undefined
    sourceTool: SourceTool
    getModifierKeyState?: ModifierKeyStateGetter | undefined
    deviceId?: int32 | undefined
    targetDisplayId?: int32 | undefined
}
export class BaseEventInternal implements MaterializedBase,BaseEvent {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get target(): EventTarget {
        return this.getTarget()
    }
    set target(target: EventTarget) {
        this.setTarget(target)
    }
    get timestamp(): int64 {
        return this.getTimestamp()
    }
    set timestamp(timestamp: int64) {
        this.setTimestamp(timestamp)
    }
    get source(): SourceType {
        return this.getSource()
    }
    set source(source: SourceType) {
        this.setSource(source)
    }
    get axisHorizontal(): double | undefined {
        return this.getAxisHorizontal()
    }
    set axisHorizontal(axisHorizontal: double | undefined) {
        const axisHorizontal_NonNull  = (axisHorizontal as double)
        this.setAxisHorizontal(axisHorizontal_NonNull)
    }
    get axisVertical(): double | undefined {
        return this.getAxisVertical()
    }
    set axisVertical(axisVertical: double | undefined) {
        const axisVertical_NonNull  = (axisVertical as double)
        this.setAxisVertical(axisVertical_NonNull)
    }
    get pressure(): double {
        return this.getPressure()
    }
    set pressure(pressure: double) {
        this.setPressure(pressure)
    }
    get tiltX(): double {
        return this.getTiltX()
    }
    set tiltX(tiltX: double) {
        this.setTiltX(tiltX)
    }
    get tiltY(): double {
        return this.getTiltY()
    }
    set tiltY(tiltY: double) {
        this.setTiltY(tiltY)
    }
    get rollAngle(): double | undefined {
        return this.getRollAngle()
    }
    set rollAngle(rollAngle: double | undefined) {
        const rollAngle_NonNull = (rollAngle as double)
        this.setRollAngle(rollAngle_NonNull)
    }
    get sourceTool(): SourceTool {
        return this.getSourceTool()
    }
    set sourceTool(sourceTool: SourceTool) {
        this.setSourceTool(sourceTool)
    }
    get getModifierKeyState(): ModifierKeyStateGetter | undefined {
        return this.getGetModifierKeyState()
    }
    set getModifierKeyState(getModifierKeyState: ModifierKeyStateGetter | undefined) {
        const getModifierKeyState_NonNull  = (getModifierKeyState as ModifierKeyStateGetter)
        this.setGetModifierKeyState(getModifierKeyState_NonNull)
    }
    get deviceId(): int32 | undefined {
        return this.getDeviceId()
    }
    set deviceId(deviceId: int32 | undefined) {
        const deviceId_NonNull  = (deviceId as int32)
        this.setDeviceId(deviceId_NonNull)
    }
    get targetDisplayId(): int32 | undefined {
        return this.getTargetDisplayId()
    }
    set targetDisplayId(targetDisplayId: int32 | undefined) {
        const targetDisplayId_NonNull  = (targetDisplayId as int32)
        this.setTargetDisplayId(targetDisplayId_NonNull)
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, BaseEventInternal.getFinalizer())
    }
    constructor() {
        this(BaseEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._BaseEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): BaseEventInternal {
        return new BaseEventInternal(ptr)
    }
    private getTarget(): EventTarget {
        return this.getTarget_serialize()
    }
    private setTarget(target: EventTarget): void {
        const target_casted = target as (EventTarget)
        this.setTarget_serialize(target_casted)
        return
    }
    private getTimestamp(): int64 {
        return this.getTimestamp_serialize()
    }
    private setTimestamp(timestamp: int64): void {
        const timestamp_casted = timestamp as (int64)
        this.setTimestamp_serialize(timestamp_casted)
        return
    }
    private getSource(): SourceType {
        return this.getSource_serialize()
    }
    private setSource(source: SourceType): void {
        const source_casted = source as (SourceType)
        this.setSource_serialize(source_casted)
        return
    }
    private getAxisHorizontal(): double | undefined {
        return this.getAxisHorizontal_serialize()
    }
    private setAxisHorizontal(axisHorizontal: double | undefined): void {
        const axisHorizontal_casted = axisHorizontal as (double | undefined)
        this.setAxisHorizontal_serialize(axisHorizontal_casted)
        return
    }
    private getAxisVertical(): double | undefined {
        return this.getAxisVertical_serialize()
    }
    private setAxisVertical(axisVertical: double | undefined): void {
        const axisVertical_casted = axisVertical as (double | undefined)
        this.setAxisVertical_serialize(axisVertical_casted)
        return
    }
    private getPressure(): double {
        return this.getPressure_serialize()
    }
    private setPressure(pressure: double): void {
        const pressure_casted = pressure as (double)
        this.setPressure_serialize(pressure_casted)
        return
    }
    private getTiltX(): double {
        return this.getTiltX_serialize()
    }
    private setTiltX(tiltX: double): void {
        const tiltX_casted = tiltX as (double)
        this.setTiltX_serialize(tiltX_casted)
        return
    }
    private getTiltY(): double {
        return this.getTiltY_serialize()
    }
    private setTiltY(tiltY: double): void {
        const tiltY_casted = tiltY as (double)
        this.setTiltY_serialize(tiltY_casted)
        return
    }
    private getRollAngle(): double | undefined {
        return this.getRollAngle_serialize()
    }
    private setRollAngle(rollAngle: double | undefined): void {
        const rollAngle_casted = rollAngle as (double | undefined)
        this.setRollAngle_serialize(rollAngle_casted)
        return
    }
    private getSourceTool(): SourceTool {
        return this.getSourceTool_serialize()
    }
    private setSourceTool(sourceTool: SourceTool): void {
        const sourceTool_casted = sourceTool as (SourceTool)
        this.setSourceTool_serialize(sourceTool_casted)
        return
    }
    private getGetModifierKeyState(): ModifierKeyStateGetter | undefined {
        return this.getGetModifierKeyState_serialize()
    }
    private setGetModifierKeyState(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const getModifierKeyState_casted = getModifierKeyState as (ModifierKeyStateGetter | undefined)
        this.setGetModifierKeyState_serialize(getModifierKeyState_casted)
        return
    }
    private getDeviceId(): int32 | undefined {
        return this.getDeviceId_serialize()
    }
    private setDeviceId(deviceId: int32 | undefined): void {
        const deviceId_casted = deviceId as (int32 | undefined)
        this.setDeviceId_serialize(deviceId_casted)
        return
    }
    private getTargetDisplayId(): int32 | undefined {
        return this.getTargetDisplayId_serialize()
    }
    private setTargetDisplayId(targetDisplayId: int32 | undefined): void {
        const targetDisplayId_casted = targetDisplayId as (int32 | undefined)
        this.setTargetDisplayId_serialize(targetDisplayId_casted)
        return
    }
    private getTarget_serialize(): EventTarget {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getTarget(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : EventTarget = EventTarget_serializer.read(retvalDeserializer)
        return returnResult
    }
    private setTarget_serialize(target: EventTarget): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        EventTarget_serializer.write(thisSerializer, target)
        ArkUIGeneratedNativeModule._BaseEvent_setTarget(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getTimestamp_serialize(): int64 {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getTimestamp(this.peer!.ptr)
        return retval
    }
    private setTimestamp_serialize(timestamp: int64): void {
        ArkUIGeneratedNativeModule._BaseEvent_setTimestamp(this.peer!.ptr, timestamp)
    }
    private getSource_serialize(): SourceType {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getSource(this.peer!.ptr)
        return SourceType.fromValue(retval)
    }
    private setSource_serialize(source: SourceType): void {
        ArkUIGeneratedNativeModule._BaseEvent_setSource(this.peer!.ptr, source.valueOf())
    }
    private getAxisHorizontal_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getAxisHorizontal(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setAxisHorizontal_serialize(axisHorizontal: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (axisHorizontal !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const axisHorizontalTmpValue  = axisHorizontal!
            thisSerializer.writeFloat64(axisHorizontalTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setAxisHorizontal(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getAxisVertical_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getAxisVertical(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setAxisVertical_serialize(axisVertical: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (axisVertical !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const axisVerticalTmpValue  = axisVertical!
            thisSerializer.writeFloat64(axisVerticalTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setAxisVertical(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getPressure_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getPressure(this.peer!.ptr)
        return retval
    }
    private setPressure_serialize(pressure: double): void {
        ArkUIGeneratedNativeModule._BaseEvent_setPressure(this.peer!.ptr, pressure)
    }
    private getTiltX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getTiltX(this.peer!.ptr)
        return retval
    }
    private setTiltX_serialize(tiltX: double): void {
        ArkUIGeneratedNativeModule._BaseEvent_setTiltX(this.peer!.ptr, tiltX)
    }
    private getTiltY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getTiltY(this.peer!.ptr)
        return retval
    }
    private setTiltY_serialize(tiltY: double): void {
        ArkUIGeneratedNativeModule._BaseEvent_setTiltY(this.peer!.ptr, tiltY)
    }
    private getRollAngle_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getRollAngle(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setRollAngle_serialize(rollAngle: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (rollAngle !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const rollAngleTmpValue  = rollAngle!
            thisSerializer.writeFloat64(rollAngleTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setRollAngle(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getSourceTool_serialize(): SourceTool {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getSourceTool(this.peer!.ptr)
        return SourceTool.fromValue(retval)
    }
    private setSourceTool_serialize(sourceTool: SourceTool): void {
        ArkUIGeneratedNativeModule._BaseEvent_setSourceTool(this.peer!.ptr, sourceTool.valueOf())
    }
    private getGetModifierKeyState_serialize(): ModifierKeyStateGetter | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getGetModifierKeyState(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : ModifierKeyStateGetter | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            const buffer_BufResource : CallbackResource = retvalDeserializer.readCallbackResource()
            const buffer_BufCall : KPointer = retvalDeserializer.readPointer()
            const buffer_BufCallSync : KPointer = retvalDeserializer.readPointer()
            buffer = (keys: Array<string>):boolean => {
                const buffer_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                buffer_BufArgsSerializer.writeInt32(buffer_BufResource.resourceId);
                buffer_BufArgsSerializer.writePointer(buffer_BufCall);
                buffer_BufArgsSerializer.writePointer(buffer_BufCallSync);
                buffer_BufArgsSerializer.writeInt32((keys.length).toInt());
                for (let keysCounterI = 0; keysCounterI < keys.length; keysCounterI++) {
                    const keysTmpElement : string = keys[keysCounterI];
                    buffer_BufArgsSerializer.writeString(keysTmpElement);
                }
                let buffer_BufContinuationValue : boolean | undefined;
                const buffer_BufContinuationCallback : ((value0: boolean) => void) = (value: boolean):void => {
                buffer_BufContinuationValue = value;
            }
                buffer_BufArgsSerializer.holdAndWriteCallback(buffer_BufContinuationCallback);
                InteropNativeModule._CallCallbackSync(10, -1026503952, buffer_BufArgsSerializer.asBuffer(), buffer_BufArgsSerializer.length());
                buffer_BufArgsSerializer.release();
                return (buffer_BufContinuationValue as boolean);
            }
        }
        const returnResult : ModifierKeyStateGetter | undefined = buffer
        return returnResult
    }
    private setGetModifierKeyState_serialize(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (getModifierKeyState !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const getModifierKeyStateTmpValue  = getModifierKeyState!
            thisSerializer.holdAndWriteCallback(getModifierKeyStateTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setGetModifierKeyState(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getDeviceId_serialize(): int32 | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getDeviceId(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : int32 | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readInt32()
        }
        const returnResult : int32 | undefined = buffer
        return returnResult
    }
    private setDeviceId_serialize(deviceId: int32 | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (deviceId !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const deviceIdTmpValue  = deviceId!
            thisSerializer.writeInt32(deviceIdTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setDeviceId(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getTargetDisplayId_serialize(): int32 | undefined {
        const retval  = ArkUIGeneratedNativeModule._BaseEvent_getTargetDisplayId(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : int32 | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readInt32()
        }
        const returnResult : int32 | undefined = buffer
        return returnResult
    }
    private setTargetDisplayId_serialize(targetDisplayId: int32 | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (targetDisplayId !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const targetDisplayIdTmpValue  = targetDisplayId!
            thisSerializer.writeInt32(targetDisplayIdTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._BaseEvent_setTargetDisplayId(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface DismissPopupAction {
    reason: DismissReason
    dismiss(): void
}
export class DismissPopupActionInternal implements MaterializedBase,DismissPopupAction {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get reason(): DismissReason {
        return this.getReason()
    }
    set reason(reason: DismissReason) {
        this.setReason(reason)
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, DismissPopupActionInternal.getFinalizer())
    }
    constructor() {
        this(DismissPopupActionInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._DismissPopupAction_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._DismissPopupAction_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): DismissPopupActionInternal {
        return new DismissPopupActionInternal(ptr)
    }
    public dismiss(): void {
        this.dismiss_serialize()
        return
    }
    private getReason(): DismissReason {
        return this.getReason_serialize()
    }
    private setReason(reason: DismissReason): void {
        const reason_casted = reason as (DismissReason)
        this.setReason_serialize(reason_casted)
        return
    }
    dismiss_serialize(): void {
        ArkUIGeneratedNativeModule._DismissPopupAction_dismiss(this.peer!.ptr)
    }
    private getReason_serialize(): DismissReason {
        const retval  = ArkUIGeneratedNativeModule._DismissPopupAction_getReason(this.peer!.ptr)
        return DismissReason.fromValue(retval)
    }
    private setReason_serialize(reason: DismissReason): void {
        ArkUIGeneratedNativeModule._DismissPopupAction_setReason(this.peer!.ptr, reason.valueOf())
    }
}
export interface DragEvent {
    dragBehavior: DragBehavior
    useCustomDropAnimation: boolean
    getModifierKeyState?: ModifierKeyStateGetter | undefined
    getDisplayX(): double
    getDisplayY(): double
    getWindowX(): double
    getWindowY(): double
    setData(unifiedData: unifiedDataChannel.UnifiedData): void
    getData(): unifiedDataChannel.UnifiedData | undefined
    getSummary(): unifiedDataChannel.Summary | undefined
    setResult(dragResult: DragResult): void
    getResult(): DragResult
    getPreviewRect(): Rectangle
    getVelocityX(): double
    getVelocityY(): double
    getVelocity(): double
    executeDropAnimation(customDropAnimation: (() => void)): void
    startDataLoading(options: unifiedDataChannel.GetDataParams): string | undefined
    enableInternalDropAnimation(configuration: string): void
}
export class DragEventInternal implements MaterializedBase,DragEvent {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get dragBehavior(): DragBehavior {
        return this.getDragBehavior()
    }
    set dragBehavior(dragBehavior: DragBehavior) {
        this.setDragBehavior(dragBehavior)
    }
    get useCustomDropAnimation(): boolean {
        return this.getUseCustomDropAnimation()
    }
    set useCustomDropAnimation(useCustomDropAnimation: boolean) {
        this.setUseCustomDropAnimation(useCustomDropAnimation)
    }
    get getModifierKeyState(): ModifierKeyStateGetter | undefined {
        return this.getGetModifierKeyState()
    }
    set getModifierKeyState(getModifierKeyState: ModifierKeyStateGetter | undefined) {
        const getModifierKeyState_NonNull  = (getModifierKeyState as ModifierKeyStateGetter)
        this.setGetModifierKeyState(getModifierKeyState_NonNull)
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, DragEventInternal.getFinalizer())
    }
    constructor() {
        this(DragEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._DragEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): DragEventInternal {
        return new DragEventInternal(ptr)
    }
    public getDisplayX(): double {
        return this.getDisplayX_serialize()
    }
    public getDisplayY(): double {
        return this.getDisplayY_serialize()
    }
    public getWindowX(): double {
        return this.getWindowX_serialize()
    }
    public getWindowY(): double {
        return this.getWindowY_serialize()
    }
    public setData(unifiedData: unifiedDataChannel.UnifiedData): void {
        const unifiedData_casted = unifiedData as (unifiedDataChannel.UnifiedData)
        this.setData_serialize(unifiedData_casted)
        return
    }
    public getData(): unifiedDataChannel.UnifiedData | undefined {
        return this.getData_serialize()
    }
    public getSummary(): unifiedDataChannel.Summary | undefined {
        return hookDragEventGetSummary(this)
    }
    public setResult(dragResult: DragResult): void {
        const dragResult_casted = dragResult as (DragResult)
        this.setResult_serialize(dragResult_casted)
        return
    }
    public getResult(): DragResult {
        return this.getResult_serialize()
    }
    public getPreviewRect(): Rectangle {
        return this.getPreviewRect_serialize()
    }
    public getVelocityX(): double {
        return this.getVelocityX_serialize()
    }
    public getVelocityY(): double {
        return this.getVelocityY_serialize()
    }
    public getVelocity(): double {
        return this.getVelocity_serialize()
    }
    public executeDropAnimation(customDropAnimation: (() => void)): void {
        const customDropAnimation_casted = customDropAnimation as ((() => void))
        this.executeDropAnimation_serialize(customDropAnimation_casted)
        return
    }
    public startDataLoading(options: unifiedDataChannel.GetDataParams): string | undefined {
        return hookDragEventStartDataLoading(this, options)
    }
    public enableInternalDropAnimation(configuration: string): void {
        const configuration_casted = configuration as (string)
        this.enableInternalDropAnimation_serialize(configuration_casted)
        return
    }
    private getDragBehavior(): DragBehavior {
        return this.getDragBehavior_serialize()
    }
    private setDragBehavior(dragBehavior: DragBehavior): void {
        const dragBehavior_casted = dragBehavior as (DragBehavior)
        this.setDragBehavior_serialize(dragBehavior_casted)
        return
    }
    private getUseCustomDropAnimation(): boolean {
        return this.getUseCustomDropAnimation_serialize()
    }
    private setUseCustomDropAnimation(useCustomDropAnimation: boolean): void {
        const useCustomDropAnimation_casted = useCustomDropAnimation as (boolean)
        this.setUseCustomDropAnimation_serialize(useCustomDropAnimation_casted)
        return
    }
    private getGetModifierKeyState(): ModifierKeyStateGetter | undefined {
        return this.getGetModifierKeyState_serialize()
    }
    private setGetModifierKeyState(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const getModifierKeyState_casted = getModifierKeyState as (ModifierKeyStateGetter | undefined)
        this.setGetModifierKeyState_serialize(getModifierKeyState_casted)
        return
    }
    getDisplayX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getDisplayX(this.peer!.ptr)
        return retval
    }
    getDisplayY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getDisplayY(this.peer!.ptr)
        return retval
    }
    getWindowX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getWindowX(this.peer!.ptr)
        return retval
    }
    getWindowY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getWindowY(this.peer!.ptr)
        return retval
    }
    setData_serialize(unifiedData: unifiedDataChannel.UnifiedData): void {
        ArkUIGeneratedNativeModule._DragEvent_setData(this.peer!.ptr, extractors.toUnifiedDataChannelUnifiedDataPtr(unifiedData))
    }
    getData_serialize(): unifiedDataChannel.UnifiedData | undefined {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getData(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : unifiedDataChannel.UnifiedData | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = (unifiedDataChannel_UnifiedData_serializer.read(retvalDeserializer) as unifiedDataChannel.UnifiedData)
        }
        const returnResult : unifiedDataChannel.UnifiedData | undefined = buffer
        return returnResult
    }
    setResult_serialize(dragResult: DragResult): void {
        ArkUIGeneratedNativeModule._DragEvent_setResult(this.peer!.ptr, dragResult.valueOf())
    }
    getResult_serialize(): DragResult {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getResult(this.peer!.ptr)
        return DragResult.fromValue(retval)
    }
    getPreviewRect_serialize(): Rectangle {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getPreviewRect(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : Rectangle = Rectangle_serializer.read(retvalDeserializer)
        return returnResult
    }
    getVelocityX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getVelocityX(this.peer!.ptr)
        return retval
    }
    getVelocityY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getVelocityY(this.peer!.ptr)
        return retval
    }
    getVelocity_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getVelocity(this.peer!.ptr)
        return retval
    }
    executeDropAnimation_serialize(customDropAnimation: (() => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.holdAndWriteCallback(customDropAnimation)
        ArkUIGeneratedNativeModule._DragEvent_executeDropAnimation(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    enableInternalDropAnimation_serialize(configuration: string): void {
        ArkUIGeneratedNativeModule._DragEvent_enableInternalDropAnimation(this.peer!.ptr, configuration)
    }
    private getDragBehavior_serialize(): DragBehavior {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getDragBehavior(this.peer!.ptr)
        return DragBehavior.fromValue(retval)
    }
    private setDragBehavior_serialize(dragBehavior: DragBehavior): void {
        ArkUIGeneratedNativeModule._DragEvent_setDragBehavior(this.peer!.ptr, dragBehavior.valueOf())
    }
    private getUseCustomDropAnimation_serialize(): boolean {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getUseCustomDropAnimation(this.peer!.ptr)
        return retval
    }
    private setUseCustomDropAnimation_serialize(useCustomDropAnimation: boolean): void {
        ArkUIGeneratedNativeModule._DragEvent_setUseCustomDropAnimation(this.peer!.ptr, useCustomDropAnimation ? 1 : 0)
    }
    private getGetModifierKeyState_serialize(): ModifierKeyStateGetter | undefined {
        const retval  = ArkUIGeneratedNativeModule._DragEvent_getGetModifierKeyState(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : ModifierKeyStateGetter | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            const buffer_BufResource : CallbackResource = retvalDeserializer.readCallbackResource()
            const buffer_BufCall : KPointer = retvalDeserializer.readPointer()
            const buffer_BufCallSync : KPointer = retvalDeserializer.readPointer()
            buffer = (keys: Array<string>):boolean => {
                const buffer_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                buffer_BufArgsSerializer.writeInt32(buffer_BufResource.resourceId);
                buffer_BufArgsSerializer.writePointer(buffer_BufCall);
                buffer_BufArgsSerializer.writePointer(buffer_BufCallSync);
                buffer_BufArgsSerializer.writeInt32((keys.length).toInt());
                for (let keysCounterI = 0; keysCounterI < keys.length; keysCounterI++) {
                    const keysTmpElement : string = keys[keysCounterI];
                    buffer_BufArgsSerializer.writeString(keysTmpElement);
                }
                let buffer_BufContinuationValue : boolean | undefined;
                const buffer_BufContinuationCallback : ((value0: boolean) => void) = (value: boolean):void => {
                buffer_BufContinuationValue = value;
            }
                buffer_BufArgsSerializer.holdAndWriteCallback(buffer_BufContinuationCallback);
                InteropNativeModule._CallCallbackSync(10, -1026503952, buffer_BufArgsSerializer.asBuffer(), buffer_BufArgsSerializer.length());
                buffer_BufArgsSerializer.release();
                return (buffer_BufContinuationValue as boolean);
            }
        }
        const returnResult : ModifierKeyStateGetter | undefined = buffer
        return returnResult
    }
    private setGetModifierKeyState_serialize(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (getModifierKeyState !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const getModifierKeyStateTmpValue  = getModifierKeyState!
            thisSerializer.holdAndWriteCallback(getModifierKeyStateTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._DragEvent_setGetModifierKeyState(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}

export interface KeyEvent {
    type: KeyType
    keyCode: int32
    keyText: string
    keySource: KeySource
    deviceId: int32
    metaKey: int32
    timestamp: int64
    stopPropagation: (() => void)
    intentionCode: IntentionCode
    getModifierKeyState?: ModifierKeyStateGetter | undefined
    unicode?: int64 | undefined
}
export class KeyEventInternal implements MaterializedBase,KeyEvent {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get type(): KeyType {
        return this.getType()
    }
    set type(type: KeyType) {
        this.setType(type)
    }
    get keyCode(): int32 {
        return this.getKeyCode()
    }
    set keyCode(keyCode: int32) {
        this.setKeyCode(keyCode)
    }
    get keyText(): string {
        return this.getKeyText()
    }
    set keyText(keyText: string) {
        this.setKeyText(keyText)
    }
    get keySource(): KeySource {
        return this.getKeySource()
    }
    set keySource(keySource: KeySource) {
        this.setKeySource(keySource)
    }
    get deviceId(): int32 {
        return this.getDeviceId()
    }
    set deviceId(deviceId: int32) {
        this.setDeviceId(deviceId)
    }
    get metaKey(): int32 {
        return this.getMetaKey()
    }
    set metaKey(metaKey: int32) {
        this.setMetaKey(metaKey)
    }
    get timestamp(): int64 {
        return this.getTimestamp()
    }
    set timestamp(timestamp: int64) {
        this.setTimestamp(timestamp)
    }
    get stopPropagation(): (() => void) {
        return this.getStopPropagation()
    }
    set stopPropagation(stopPropagation: (() => void)) {
        this.setStopPropagation(stopPropagation)
    }
    get intentionCode(): IntentionCode {
        return this.getIntentionCode()
    }
    set intentionCode(intentionCode: IntentionCode) {
        this.setIntentionCode(intentionCode)
    }
    get getModifierKeyState(): ModifierKeyStateGetter | undefined {
        return this.getGetModifierKeyState()
    }
    set getModifierKeyState(getModifierKeyState: ModifierKeyStateGetter | undefined) {
        const getModifierKeyState_NonNull  = (getModifierKeyState as ModifierKeyStateGetter)
        this.setGetModifierKeyState(getModifierKeyState_NonNull)
    }
    get unicode(): int64 | undefined {
        return this.getUnicode()
    }
    set unicode(unicode: int64 | undefined) {
        const unicode_NonNull  = (unicode as int64)
        this.setUnicode(unicode_NonNull)
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, KeyEventInternal.getFinalizer())
    }
    constructor() {
        this(KeyEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._KeyEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): KeyEventInternal {
        return new KeyEventInternal(ptr)
    }
    private getType(): KeyType {
        return this.getType_serialize()
    }
    private setType(type: KeyType): void {
        const type_casted = type as (KeyType)
        this.setType_serialize(type_casted)
        return
    }
    private getKeyCode(): int32 {
        return this.getKeyCode_serialize()
    }
    private setKeyCode(keyCode: int32): void {
        const keyCode_casted = keyCode as (int32)
        this.setKeyCode_serialize(keyCode_casted)
        return
    }
    private getKeyText(): string {
        return this.getKeyText_serialize()
    }
    private setKeyText(keyText: string): void {
        const keyText_casted = keyText as (string)
        this.setKeyText_serialize(keyText_casted)
        return
    }
    private getKeySource(): KeySource {
        return this.getKeySource_serialize()
    }
    private setKeySource(keySource: KeySource): void {
        const keySource_casted = keySource as (KeySource)
        this.setKeySource_serialize(keySource_casted)
        return
    }
    private getDeviceId(): int32 {
        return this.getDeviceId_serialize()
    }
    private setDeviceId(deviceId: int32): void {
        const deviceId_casted = deviceId as (int32)
        this.setDeviceId_serialize(deviceId_casted)
        return
    }
    private getMetaKey(): int32 {
        return this.getMetaKey_serialize()
    }
    private setMetaKey(metaKey: int32): void {
        const metaKey_casted = metaKey as (int32)
        this.setMetaKey_serialize(metaKey_casted)
        return
    }
    private getTimestamp(): int64 {
        return this.getTimestamp_serialize()
    }
    private setTimestamp(timestamp: int64): void {
        const timestamp_casted = timestamp as (int64)
        this.setTimestamp_serialize(timestamp_casted)
        return
    }
    private getStopPropagation(): (() => void) {
        return this.getStopPropagation_serialize()
    }
    private setStopPropagation(stopPropagation: (() => void)): void {
        const stopPropagation_casted = stopPropagation as ((() => void))
        this.setStopPropagation_serialize(stopPropagation_casted)
        return
    }
    private getIntentionCode(): IntentionCode {
        return this.getIntentionCode_serialize()
    }
    private setIntentionCode(intentionCode: IntentionCode): void {
        const intentionCode_casted = intentionCode as (IntentionCode)
        this.setIntentionCode_serialize(intentionCode_casted)
        return
    }
    private getGetModifierKeyState(): ModifierKeyStateGetter | undefined {
        return this.getGetModifierKeyState_serialize()
    }
    private setGetModifierKeyState(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const getModifierKeyState_casted = getModifierKeyState as (ModifierKeyStateGetter | undefined)
        this.setGetModifierKeyState_serialize(getModifierKeyState_casted)
        return
    }
    private getUnicode(): int64 | undefined {
        return this.getUnicode_serialize()
    }
    private setUnicode(unicode: int64 | undefined): void {
        const unicode_casted = unicode as (int64 | undefined)
        this.setUnicode_serialize(unicode_casted)
        return
    }
    private getType_serialize(): KeyType {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getType(this.peer!.ptr)
        return KeyType.fromValue(retval)
    }
    private setType_serialize(type: KeyType): void {
        ArkUIGeneratedNativeModule._KeyEvent_setType(this.peer!.ptr, type.valueOf())
    }
    private getKeyCode_serialize(): int32 {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getKeyCode(this.peer!.ptr)
        return retval
    }
    private setKeyCode_serialize(keyCode: int32): void {
        ArkUIGeneratedNativeModule._KeyEvent_setKeyCode(this.peer!.ptr, keyCode)
    }
    private getKeyText_serialize(): string {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getKeyText(this.peer!.ptr)
        return retval
    }
    private setKeyText_serialize(keyText: string): void {
        ArkUIGeneratedNativeModule._KeyEvent_setKeyText(this.peer!.ptr, keyText)
    }
    private getKeySource_serialize(): KeySource {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getKeySource(this.peer!.ptr)
        return KeySource.fromValue(retval)
    }
    private setKeySource_serialize(keySource: KeySource): void {
        ArkUIGeneratedNativeModule._KeyEvent_setKeySource(this.peer!.ptr, keySource.valueOf())
    }
    private getDeviceId_serialize(): int32 {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getDeviceId(this.peer!.ptr)
        return retval
    }
    private setDeviceId_serialize(deviceId: int32): void {
        ArkUIGeneratedNativeModule._KeyEvent_setDeviceId(this.peer!.ptr, deviceId)
    }
    private getMetaKey_serialize(): int32 {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getMetaKey(this.peer!.ptr)
        return retval
    }
    private setMetaKey_serialize(metaKey: int32): void {
        ArkUIGeneratedNativeModule._KeyEvent_setMetaKey(this.peer!.ptr, metaKey)
    }
    private getTimestamp_serialize(): int64 {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getTimestamp(this.peer!.ptr)
        return retval
    }
    private setTimestamp_serialize(timestamp: int64): void {
        ArkUIGeneratedNativeModule._KeyEvent_setTimestamp(this.peer!.ptr, timestamp)
    }
    private getStopPropagation_serialize(): (() => void) {
        const retval = ArkUIGeneratedNativeModule._KeyEvent_getStopPropagation(this.peer!.ptr)
        let retvalDeserializer: DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType = retvalDeserializer.readInt8().toInt()
        let buffer: (() => void) | undefined = undefined
        
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            const buffer_BufResource: CallbackResource = retvalDeserializer.readCallbackResource()
            const buffer_BufCall: KPointer = retvalDeserializer.readPointer()
            const buffer_BufCallSync: KPointer = retvalDeserializer.readPointer()
            
            buffer = (): void => {
                const buffer_BufArgsSerializer: SerializerBase = SerializerBase.hold();
                buffer_BufArgsSerializer.writeInt32(buffer_BufResource.resourceId);
                buffer_BufArgsSerializer.writePointer(buffer_BufCall);
                buffer_BufArgsSerializer.writePointer(buffer_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, buffer_BufArgsSerializer.asBuffer(), buffer_BufArgsSerializer.length());
                buffer_BufArgsSerializer.release();
                return;
            }
        }
        
        const returnResult: (() => void) = (buffer || (() => {})) as (() => void);
        return returnResult;
    }
    private setStopPropagation_serialize(stopPropagation: (() => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.holdAndWriteCallback(stopPropagation)
        ArkUIGeneratedNativeModule._KeyEvent_setStopPropagation(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getIntentionCode_serialize(): IntentionCode {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getIntentionCode(this.peer!.ptr)
        return IntentionCode.fromValue(retval)
    }
    private setIntentionCode_serialize(intentionCode: IntentionCode): void {
        ArkUIGeneratedNativeModule._KeyEvent_setIntentionCode(this.peer!.ptr, intentionCode.valueOf())
    }
    private getGetModifierKeyState_serialize(): ModifierKeyStateGetter | undefined {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getGetModifierKeyState(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : ModifierKeyStateGetter | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            const buffer_BufResource : CallbackResource = retvalDeserializer.readCallbackResource()
            const buffer_BufCall : KPointer = retvalDeserializer.readPointer()
            const buffer_BufCallSync : KPointer = retvalDeserializer.readPointer()
            buffer = (keys: Array<string>):boolean => {
                const buffer_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                buffer_BufArgsSerializer.writeInt32(buffer_BufResource.resourceId);
                buffer_BufArgsSerializer.writePointer(buffer_BufCall);
                buffer_BufArgsSerializer.writePointer(buffer_BufCallSync);
                buffer_BufArgsSerializer.writeInt32((keys.length).toInt());
                for (let keysCounterI = 0; keysCounterI < keys.length; keysCounterI++) {
                    const keysTmpElement : string = keys[keysCounterI];
                    buffer_BufArgsSerializer.writeString(keysTmpElement);
                }
                let buffer_BufContinuationValue : boolean | undefined;
                const buffer_BufContinuationCallback : ((value0: boolean) => void) = (value: boolean):void => {
                buffer_BufContinuationValue = value;
            }
                buffer_BufArgsSerializer.holdAndWriteCallback(buffer_BufContinuationCallback);
                InteropNativeModule._CallCallbackSync(10, -1026503952, buffer_BufArgsSerializer.asBuffer(), buffer_BufArgsSerializer.length());
                buffer_BufArgsSerializer.release();
                return (buffer_BufContinuationValue as boolean);
            }
        }
        const returnResult : ModifierKeyStateGetter | undefined = buffer
        return returnResult
    }
    private setGetModifierKeyState_serialize(getModifierKeyState: ModifierKeyStateGetter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (getModifierKeyState !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const getModifierKeyStateTmpValue  = getModifierKeyState!
            thisSerializer.holdAndWriteCallback(getModifierKeyStateTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._KeyEvent_setGetModifierKeyState(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getUnicode_serialize(): int64 | undefined {
        const retval  = ArkUIGeneratedNativeModule._KeyEvent_getUnicode(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : int64 | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readInt64()
        }
        const returnResult : int64 | undefined = buffer
        return returnResult
    }
    private setUnicode_serialize(unicode: int64 | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (unicode !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const unicodeTmpValue  = unicode!
            thisSerializer.writeInt64(unicodeTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._KeyEvent_setUnicode(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface Layoutable {
    measureResult: MeasureResult
    uniqueId?: number | undefined
    layout(position: Position): void
    getMargin(): DirectionalEdgesT<number>
    getPadding(): DirectionalEdgesT<number>
    getBorderWidth(): DirectionalEdgesT<number>
}
export class LayoutableInternal implements MaterializedBase,Layoutable {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get measureResult(): MeasureResult {
        return this.getMeasureResult()
    }
    set measureResult(measureResult: MeasureResult) {
        this.setMeasureResult(measureResult)
    }
    get uniqueId(): number | undefined {
        return this.getUniqueId()
    }
    set uniqueId(uniqueId: number | undefined) {
        const uniqueId_NonNull  = (uniqueId as number)
        this.setUniqueId(uniqueId_NonNull)
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, LayoutableInternal.getFinalizer())
    }
    constructor() {
        this(LayoutableInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._Layoutable_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): LayoutableInternal {
        return new LayoutableInternal(ptr)
    }
    public layout(position: Position): void {
        const position_casted = position as (Position)
        this.layout_serialize(position_casted)
        return
    }
    public getMargin(): DirectionalEdgesT<number> {
        return this.getMargin_serialize()
    }
    public getPadding(): DirectionalEdgesT<number> {
        return this.getPadding_serialize()
    }
    public getBorderWidth(): DirectionalEdgesT<number> {
        return this.getBorderWidth_serialize()
    }
    private getMeasureResult(): MeasureResult {
        return this.getMeasureResult_serialize()
    }
    private setMeasureResult(measureResult: MeasureResult): void {
        const measureResult_casted = measureResult as (MeasureResult)
        this.setMeasureResult_serialize(measureResult_casted)
        return
    }
    private getUniqueId(): number | undefined {
        return this.getUniqueId_serialize()
    }
    private setUniqueId(uniqueId: number | undefined): void {
        const uniqueId_casted = uniqueId as (number | undefined)
        this.setUniqueId_serialize(uniqueId_casted)
        return
    }
    layout_serialize(position: Position): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        Position_serializer.write(thisSerializer, position)
        ArkUIGeneratedNativeModule._Layoutable_layout(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    getMargin_serialize(): DirectionalEdgesT<number> {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_getMargin(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : DirectionalEdgesT<number> = DirectionalEdgesT_serializer.read(retvalDeserializer)
        return returnResult
    }
    getPadding_serialize(): DirectionalEdgesT<number> {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_getPadding(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : DirectionalEdgesT<number> = DirectionalEdgesT_serializer.read(retvalDeserializer)
        return returnResult
    }
    getBorderWidth_serialize(): DirectionalEdgesT<number> {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_getBorderWidth(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : DirectionalEdgesT<number> = DirectionalEdgesT_serializer.read(retvalDeserializer)
        return returnResult
    }
    private getMeasureResult_serialize(): MeasureResult {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_getMeasureResult(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : MeasureResult = MeasureResult_serializer.read(retvalDeserializer)
        return returnResult
    }
    private setMeasureResult_serialize(measureResult: MeasureResult): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        MeasureResult_serializer.write(thisSerializer, measureResult)
        ArkUIGeneratedNativeModule._Layoutable_setMeasureResult(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getUniqueId_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._Layoutable_getUniqueId(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setUniqueId_serialize(uniqueId: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (uniqueId !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const uniqueIdTmpValue  = uniqueId!
            thisSerializer.writeNumber(uniqueIdTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._Layoutable_setUniqueId(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export class LayoutPolicyInternal {
    public static fromPtr(ptr: KPointer): LayoutPolicy {
        return new LayoutPolicy(ptr)
    }
}
export class LayoutPolicy implements MaterializedBase {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    static readonly matchParent: LayoutPolicy = LayoutPolicy.getMatchParent()
    static readonly wrapContent: LayoutPolicy = LayoutPolicy.getWrapContent()
    static readonly fixAtIdealSize: LayoutPolicy = LayoutPolicy.getFixAtIdealSize()
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, LayoutPolicy.getFinalizer())
    }
    constructor() {
        this(LayoutPolicy.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._LayoutPolicy_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._LayoutPolicy_getFinalizer()
    }
    private static getMatchParent_serialize(): LayoutPolicy {
        const retval  = ArkUIGeneratedNativeModule._LayoutPolicy_getMatchParent()
        const obj : LayoutPolicy = LayoutPolicyInternal.fromPtr(retval)
        return obj
    }
    private static getWrapContent_serialize(): LayoutPolicy {
        const retval  = ArkUIGeneratedNativeModule._LayoutPolicy_getWrapContent()
        const obj : LayoutPolicy = LayoutPolicyInternal.fromPtr(retval)
        return obj
    }
    private static getFixAtIdealSize_serialize(): LayoutPolicy {
        const retval  = ArkUIGeneratedNativeModule._LayoutPolicy_getFixAtIdealSize()
        const obj : LayoutPolicy = LayoutPolicyInternal.fromPtr(retval)
        return obj
    }
    private static getMatchParent(): LayoutPolicy {
        return LayoutPolicy.getMatchParent_serialize()
    }
    private static getWrapContent(): LayoutPolicy {
        return LayoutPolicy.getWrapContent_serialize()
    }
    private static getFixAtIdealSize(): LayoutPolicy {
        return LayoutPolicy.getFixAtIdealSize_serialize()
    }
}
export interface Measurable {
    uniqueId?: number | undefined
    measure(constraint: ConstraintSizeOptions): MeasureResult
    getMargin(): DirectionalEdgesT<number>
    getPadding(): DirectionalEdgesT<number>
    getBorderWidth(): DirectionalEdgesT<number>
}
export class MeasurableInternal implements MaterializedBase,Measurable {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get uniqueId(): number | undefined {
        return this.getUniqueId()
    }
    set uniqueId(uniqueId: number | undefined) {
        const uniqueId_NonNull  = (uniqueId as number)
        this.setUniqueId(uniqueId_NonNull)
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, MeasurableInternal.getFinalizer())
    }
    constructor() {
        this(MeasurableInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._Measurable_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._Measurable_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): MeasurableInternal {
        return new MeasurableInternal(ptr)
    }
    public measure(constraint: ConstraintSizeOptions): MeasureResult {
        const constraint_casted = constraint as (ConstraintSizeOptions)
        return this.measure_serialize(constraint_casted)
    }
    public getMargin(): DirectionalEdgesT<number> {
        return this.getMargin_serialize()
    }
    public getPadding(): DirectionalEdgesT<number> {
        return this.getPadding_serialize()
    }
    public getBorderWidth(): DirectionalEdgesT<number> {
        return this.getBorderWidth_serialize()
    }
    private getUniqueId(): number | undefined {
        return this.getUniqueId_serialize()
    }
    private setUniqueId(uniqueId: number | undefined): void {
        const uniqueId_casted = uniqueId as (number | undefined)
        this.setUniqueId_serialize(uniqueId_casted)
        return
    }
    measure_serialize(constraint: ConstraintSizeOptions): MeasureResult {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        ConstraintSizeOptions_serializer.write(thisSerializer, constraint)
        const retval  = ArkUIGeneratedNativeModule._Measurable_measure(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : MeasureResult = MeasureResult_serializer.read(retvalDeserializer)
        return returnResult
    }
    getMargin_serialize(): DirectionalEdgesT<number> {
        const retval  = ArkUIGeneratedNativeModule._Measurable_getMargin(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : DirectionalEdgesT<number> = DirectionalEdgesT_serializer.read(retvalDeserializer)
        return returnResult
    }
    getPadding_serialize(): DirectionalEdgesT<number> {
        const retval  = ArkUIGeneratedNativeModule._Measurable_getPadding(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : DirectionalEdgesT<number> = DirectionalEdgesT_serializer.read(retvalDeserializer)
        return returnResult
    }
    getBorderWidth_serialize(): DirectionalEdgesT<number> {
        const retval  = ArkUIGeneratedNativeModule._Measurable_getBorderWidth(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : DirectionalEdgesT<number> = DirectionalEdgesT_serializer.read(retvalDeserializer)
        return returnResult
    }
    private getUniqueId_serialize(): number | undefined {
        const retval  = ArkUIGeneratedNativeModule._Measurable_getUniqueId(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : number | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = (retvalDeserializer.readNumber() as number)
        }
        const returnResult : number | undefined = buffer
        return returnResult
    }
    private setUniqueId_serialize(uniqueId: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (uniqueId !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const uniqueIdTmpValue  = uniqueId!
            thisSerializer.writeNumber(uniqueIdTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._Measurable_setUniqueId(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface PixelMapMock {
    release(): void
}
export class PixelMapMockInternal implements MaterializedBase,PixelMapMock {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, PixelMapMockInternal.getFinalizer())
    }
    constructor() {
        this(PixelMapMockInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._PixelMapMock_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._PixelMapMock_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): PixelMapMockInternal {
        return new PixelMapMockInternal(ptr)
    }
    public release(): void {
        this.release_serialize()
        return
    }
    release_serialize(): void {
        ArkUIGeneratedNativeModule._PixelMapMock_release(this.peer!.ptr)
    }
}
export class ProgressMaskInternal {
    public static fromPtr(ptr: KPointer): ProgressMask {
        return new ProgressMask(false, false, false, ptr)
    }
}
export class ProgressMask implements MaterializedBase {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    constructor(_0: boolean, _1: boolean, _2: boolean, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, ProgressMask.getFinalizer())
    }
    constructor(value: double, total: double, color: ResourceColor) {
        this(false, false, false, ProgressMask.construct(value, total, color))
    }
    static construct(value: double, total: double, color: ResourceColor): KPointer {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (color instanceof Color) {
            thisSerializer.writeInt8((0).toByte())
            const colorForIdx0  = color as Color
            thisSerializer.writeInt32(colorForIdx0.getOrdinal())
        } else if (color instanceof number) {
            thisSerializer.writeInt8((1).toByte())
            const colorForIdx1  = color as number
            thisSerializer.writeNumber(colorForIdx1)
        } else if (color instanceof string) {
            thisSerializer.writeInt8((2).toByte())
            const colorForIdx2  = color as string
            thisSerializer.writeString(colorForIdx2)
        } else if (color instanceof Resource) {
            thisSerializer.writeInt8((3).toByte())
            const colorForIdx3  = color as Resource
            Resource_serializer.write(thisSerializer, colorForIdx3)
        }
        const retval  = ArkUIGeneratedNativeModule._ProgressMask_construct(value, total, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._ProgressMask_getFinalizer()
    }
    public updateProgress(value: double): void {
        const value_casted = value as (double)
        this.updateProgress_serialize(value_casted)
        return
    }
    public updateColor(value: ResourceColor): void {
        const value_casted = value as (ResourceColor)
        this.updateColor_serialize(value_casted)
        return
    }
    public enableBreathingAnimation(value: boolean): void {
        const value_casted = value as (boolean)
        this.enableBreathingAnimation_serialize(value_casted)
        return
    }
    updateProgress_serialize(value: double): void {
        ArkUIGeneratedNativeModule._ProgressMask_updateProgress(this.peer!.ptr, value)
    }
    updateColor_serialize(value: ResourceColor): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value instanceof Color) {
            thisSerializer.writeInt8((0).toByte())
            const valueForIdx0  = value as Color
            thisSerializer.writeInt32(valueForIdx0.getOrdinal())
        } else if (value instanceof number) {
            thisSerializer.writeInt8((1).toByte())
            const valueForIdx1  = value as number
            thisSerializer.writeNumber(valueForIdx1)
        } else if (value instanceof string) {
            thisSerializer.writeInt8((2).toByte())
            const valueForIdx2  = value as string
            thisSerializer.writeString(valueForIdx2)
        } else if (value instanceof Resource) {
            thisSerializer.writeInt8((3).toByte())
            const valueForIdx3  = value as Resource
            Resource_serializer.write(thisSerializer, valueForIdx3)
        }
        ArkUIGeneratedNativeModule._ProgressMask_updateColor(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    enableBreathingAnimation_serialize(value: boolean): void {
        ArkUIGeneratedNativeModule._ProgressMask_enableBreathingAnimation(this.peer!.ptr, value ? 1 : 0)
    }
}
export class ScrollResultInternal {
    public static fromPtr(ptr: KPointer): ScrollResult {
        return new ScrollResult(ptr)
    }
}
export class ScrollResult implements MaterializedBase {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    get offsetRemain(): double {
        return this.getOffsetRemain()
    }
    set offsetRemain(offsetRemain: double) {
        this.setOffsetRemain(offsetRemain)
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, ScrollResult.getFinalizer())
    }
    constructor() {
        this(ScrollResult.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._ScrollResult_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._ScrollResult_getFinalizer()
    }
    private getOffsetRemain(): double {
        return this.getOffsetRemain_serialize()
    }
    private setOffsetRemain(offsetRemain: double): void {
        const offsetRemain_casted = offsetRemain as (double)
        this.setOffsetRemain_serialize(offsetRemain_casted)
        return
    }
    private getOffsetRemain_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._ScrollResult_getOffsetRemain(this.peer!.ptr)
        return retval
    }
    private setOffsetRemain_serialize(offsetRemain: double): void {
        ArkUIGeneratedNativeModule._ScrollResult_setOffsetRemain(this.peer!.ptr, offsetRemain)
    }
}
export class TextContentControllerBaseInternal {
    public static fromPtr(ptr: KPointer): TextContentControllerBase {
        return new TextContentControllerBase(ptr)
    }
}
export class TextContentControllerBase implements MaterializedBase {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, TextContentControllerBase.getFinalizer())
    }
    constructor() {
        this(TextContentControllerBase.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._TextContentControllerBase_getFinalizer()
    }
    public getCaretOffset(): CaretOffset {
        return this.getCaretOffset_serialize()
    }
    public getTextContentRect(): RectResult {
        return this.getTextContentRect_serialize()
    }
    public getTextContentLineCount(): int32 {
        return this.getTextContentLineCount_serialize()
    }
    public addText(text: string, textOperationOptions?: TextContentControllerOptions): int32 {
        const text_casted = text as (string)
        const textOperationOptions_casted = textOperationOptions as (TextContentControllerOptions | undefined)
        return this.addText_serialize(text_casted, textOperationOptions_casted)
    }
    public deleteText(range?: TextRange): void {
        const range_casted = range as (TextRange | undefined)
        this.deleteText_serialize(range_casted)
        return
    }
    public getSelection(): TextRange {
        return this.getSelection_serialize()
    }
    public clearPreviewText(): void {
        this.clearPreviewText_serialize()
        return
    }
    public getText(range?: TextRange): string {
        const range_casted = range as (TextRange | undefined)
        return this.getText_serialize(range_casted)
    }
    public deleteBackward(): void {
        this.deleteBackward_serialize()
        return
    }
    getCaretOffset_serialize(): CaretOffset {
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_getCaretOffset(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : CaretOffset = CaretOffset_serializer.read(retvalDeserializer)
        return returnResult
    }
    getTextContentRect_serialize(): RectResult {
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_getTextContentRect(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : RectResult = RectResult_serializer.read(retvalDeserializer)
        return returnResult
    }
    getTextContentLineCount_serialize(): int32 {
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_getTextContentLineCount(this.peer!.ptr)
        return retval
    }
    addText_serialize(text: string, textOperationOptions?: TextContentControllerOptions): int32 {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (textOperationOptions !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const textOperationOptionsTmpValue  = textOperationOptions!
            TextContentControllerOptions_serializer.write(thisSerializer, textOperationOptionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_addText(this.peer!.ptr, text, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    deleteText_serialize(range?: TextRange): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (range !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const rangeTmpValue  = range!
            TextRange_serializer.write(thisSerializer, rangeTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._TextContentControllerBase_deleteText(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    getSelection_serialize(): TextRange {
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_getSelection(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const returnResult : TextRange = TextRange_serializer.read(retvalDeserializer)
        return returnResult
    }
    clearPreviewText_serialize(): void {
        ArkUIGeneratedNativeModule._TextContentControllerBase_clearPreviewText(this.peer!.ptr)
    }
    getText_serialize(range?: TextRange): string {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (range !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const rangeTmpValue  = range!
            TextRange_serializer.write(thisSerializer, rangeTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const retval  = ArkUIGeneratedNativeModule._TextContentControllerBase_getText(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    deleteBackward_serialize(): void {
        ArkUIGeneratedNativeModule._TextContentControllerBase_deleteBackward(this.peer!.ptr)
    }
}
export class TransitionEffectInternal {
    public static fromPtr(ptr: KPointer): TransitionEffect {
        return new TransitionEffect(false, ptr)
    }
}
export class TransitionEffect implements MaterializedBase {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    static get IDENTITY(): TransitionEffect {
        return TransitionEffect.getIDENTITY()
    }
    static set IDENTITY(IDENTITY: TransitionEffect) {
        TransitionEffect.setIDENTITY(IDENTITY)
    }
    static get OPACITY(): TransitionEffect {
        return TransitionEffect.getOPACITY()
    }
    static set OPACITY(OPACITY: TransitionEffect) {
        TransitionEffect.setOPACITY(OPACITY)
    }
    static get SLIDE(): TransitionEffect {
        return TransitionEffect.getSLIDE()
    }
    static set SLIDE(SLIDE: TransitionEffect) {
        TransitionEffect.setSLIDE(SLIDE)
    }
    static get SLIDE_SWITCH(): TransitionEffect {
        return TransitionEffect.getSLIDE_SWITCH()
    }
    static set SLIDE_SWITCH(SLIDE_SWITCH: TransitionEffect) {
        TransitionEffect.setSLIDE_SWITCH(SLIDE_SWITCH)
    }
    constructor(_0: boolean, peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, TransitionEffect.getFinalizer())
    }
    constructor(type: string) {
        this(false, TransitionEffect.construct0(type))
    }
    constructor(effect: double) {
        this(false, TransitionEffect.construct1(effect))
    }
    constructor(effect: TransitionEdge) {
        this(false, TransitionEffect.construct2(effect))
    }
    constructor(effect: TranslateOptions) {
        this(false, TransitionEffect.construct3(effect))
    }
    constructor(effect: RotateOptions) {
        this(false, TransitionEffect.construct4(effect))
    }
    constructor(effect: ScaleOptions) {
        this(false, TransitionEffect.construct5(effect))
    }
    constructor(effect: AsymmetricTransitionOption) {
        this(false, TransitionEffect.construct6(effect))
    }
    static construct0(type: string): KPointer {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct0(type)
        return retval
    }
    static construct1(effect: double): KPointer {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct1(effect)
        return retval
    }
    static construct2(effect: TransitionEdge): KPointer {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct2(effect.valueOf())
        return retval
    }
    static construct3(effect: TranslateOptions): KPointer {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        TranslateOptions_serializer.write(thisSerializer, effect)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct3(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    static construct4(effect: RotateOptions): KPointer {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        RotateOptions_serializer.write(thisSerializer, effect)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct4(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    static construct5(effect: ScaleOptions): KPointer {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        ScaleOptions_serializer.write(thisSerializer, effect)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct5(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    static construct6(effect: AsymmetricTransitionOption): KPointer {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        AsymmetricTransitionOption_serializer.write(thisSerializer, effect)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_construct6(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._TransitionEffect_getFinalizer()
    }
    static translate_serialize(options: TranslateOptions): TransitionEffect {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        TranslateOptions_serializer.write(thisSerializer, options)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_translate(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    static rotate_serialize(options: RotateOptions): TransitionEffect {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        RotateOptions_serializer.write(thisSerializer, options)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_rotate(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    static scale_serialize(options: ScaleOptions): TransitionEffect {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        ScaleOptions_serializer.write(thisSerializer, options)
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_scale(thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    static opacity_serialize(alpha: double): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_opacity(alpha)
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    static move_serialize(edge: TransitionEdge): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_move(edge.valueOf())
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    static asymmetric_serialize(appear: TransitionEffect, disappear: TransitionEffect): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_asymmetric(toPeerPtr(appear), toPeerPtr(disappear))
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static getIDENTITY_serialize(): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_getIDENTITY()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static setIDENTITY_serialize(IDENTITY: TransitionEffect): void {
        ArkUIGeneratedNativeModule._TransitionEffect_setIDENTITY(toPeerPtr(IDENTITY))
    }
    private static getOPACITY_serialize(): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_getOPACITY()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static setOPACITY_serialize(OPACITY: TransitionEffect): void {
        ArkUIGeneratedNativeModule._TransitionEffect_setOPACITY(toPeerPtr(OPACITY))
    }
    private static getSLIDE_serialize(): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_getSLIDE()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static setSLIDE_serialize(SLIDE: TransitionEffect): void {
        ArkUIGeneratedNativeModule._TransitionEffect_setSLIDE(toPeerPtr(SLIDE))
    }
    private static getSLIDE_SWITCH_serialize(): TransitionEffect {
        const retval  = ArkUIGeneratedNativeModule._TransitionEffect_getSLIDE_SWITCH()
        const obj : TransitionEffect = TransitionEffectInternal.fromPtr(retval)
        return obj
    }
    private static setSLIDE_SWITCH_serialize(SLIDE_SWITCH: TransitionEffect): void {
        ArkUIGeneratedNativeModule._TransitionEffect_setSLIDE_SWITCH(toPeerPtr(SLIDE_SWITCH))
    }
    public static translate(options: TranslateOptions): TransitionEffect {
        const options_casted = options as (TranslateOptions)
        return TransitionEffect.translate_serialize(options_casted)
    }
    public static rotate(options: RotateOptions): TransitionEffect {
        const options_casted = options as (RotateOptions)
        return TransitionEffect.rotate_serialize(options_casted)
    }
    public static scale(options: ScaleOptions): TransitionEffect {
        const options_casted = options as (ScaleOptions)
        return TransitionEffect.scale_serialize(options_casted)
    }
    public static opacity(alpha: double): TransitionEffect {
        const alpha_casted = alpha as (double)
        return TransitionEffect.opacity_serialize(alpha_casted)
    }
    public static move(edge: TransitionEdge): TransitionEffect {
        const edge_casted = edge as (TransitionEdge)
        return TransitionEffect.move_serialize(edge_casted)
    }
    public static asymmetric(appear: TransitionEffect, disappear: TransitionEffect): TransitionEffect {
        const appear_casted = appear as (TransitionEffect)
        const disappear_casted = disappear as (TransitionEffect)
        return TransitionEffect.asymmetric_serialize(appear_casted, disappear_casted)
    }
    public animation(value: AnimateParam): TransitionEffect {
        const value_casted = value as (AnimateParam)
        return this.animation_serialize(value_casted)
    }
    public combine(transitionEffect: TransitionEffect): TransitionEffect {
        const transitionEffect_casted = transitionEffect as (TransitionEffect)
        return this.combine_serialize(transitionEffect_casted)
    }
    private static getIDENTITY(): TransitionEffect {
        return TransitionEffect.getIDENTITY_serialize()
    }
    private static setIDENTITY(IDENTITY: TransitionEffect): void {
        const IDENTITY_casted = IDENTITY as (TransitionEffect)
        TransitionEffect.setIDENTITY_serialize(IDENTITY_casted)
        return
    }
    private static getOPACITY(): TransitionEffect {
        return TransitionEffect.getOPACITY_serialize()
    }
    private static setOPACITY(OPACITY: TransitionEffect): void {
        const OPACITY_casted = OPACITY as (TransitionEffect)
        TransitionEffect.setOPACITY_serialize(OPACITY_casted)
        return
    }
    private static getSLIDE(): TransitionEffect {
        return TransitionEffect.getSLIDE_serialize()
    }
    private static setSLIDE(SLIDE: TransitionEffect): void {
        const SLIDE_casted = SLIDE as (TransitionEffect)
        TransitionEffect.setSLIDE_serialize(SLIDE_casted)
        return
    }
    private static getSLIDE_SWITCH(): TransitionEffect {
        return TransitionEffect.getSLIDE_SWITCH_serialize()
    }
    private static setSLIDE_SWITCH(SLIDE_SWITCH: TransitionEffect): void {
        const SLIDE_SWITCH_casted = SLIDE_SWITCH as (TransitionEffect)
        TransitionEffect.setSLIDE_SWITCH_serialize(SLIDE_SWITCH_casted)
        return
    }
    animation_serialize(value: AnimateParam): TransitionEffect {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        AnimateParam_serializer.write(thisSerializer, value)
        // instructive change start
        ArkUIGeneratedNativeModule._TransitionEffect_animation(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
        return this
        // instructive change end
    }
    combine_serialize(transitionEffect: TransitionEffect): TransitionEffect {
        // instructive change start
        ArkUIGeneratedNativeModule._TransitionEffect_combine(this.peer!.ptr, toPeerPtr(transitionEffect))
        return this
        // instructive change end
    }
}
export interface UICommonEvent {
    setOnClick(callback_: ((event: ClickEvent) => void) | undefined): void
    setOnTouch(callback_: ((event: TouchEvent) => void) | undefined): void
    setOnAppear(callback_: (() => void) | undefined): void
    setOnDisappear(callback_: (() => void) | undefined): void
    setOnKeyEvent(callback_: ((event: KeyEvent) => void) | undefined): void
    setOnFocus(callback_: (() => void) | undefined): void
    setOnBlur(callback_: (() => void) | undefined): void
    setOnHover(callback_: HoverCallback | undefined): void
    setOnMouse(callback_: ((event: MouseEvent) => void) | undefined): void
    setOnSizeChange(callback_: SizeChangeCallback | undefined): void
    setOnVisibleAreaApproximateChange(options: VisibleAreaEventOptions, event: VisibleAreaChangeCallback | undefined): void
}
export class UICommonEventInternal implements MaterializedBase,UICommonEvent {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, UICommonEventInternal.getFinalizer())
    }
    constructor() {
        this(UICommonEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._UICommonEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._UICommonEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): UICommonEventInternal {
        return new UICommonEventInternal(ptr)
    }
    public setOnClick(callback_: ((event: ClickEvent) => void) | undefined): void {
        const callback__casted = callback_ as (((event: ClickEvent) => void) | undefined)
        this.setOnClick_serialize(callback__casted)
        return
    }
    public setOnTouch(callback_: ((event: TouchEvent) => void) | undefined): void {
        const callback__casted = callback_ as (((event: TouchEvent) => void) | undefined)
        this.setOnTouch_serialize(callback__casted)
        return
    }
    public setOnAppear(callback_: (() => void) | undefined): void {
        const callback__casted = callback_ as ((() => void) | undefined)
        this.setOnAppear_serialize(callback__casted)
        return
    }
    public setOnDisappear(callback_: (() => void) | undefined): void {
        const callback__casted = callback_ as ((() => void) | undefined)
        this.setOnDisappear_serialize(callback__casted)
        return
    }
    public setOnKeyEvent(callback_: ((event: KeyEvent) => void) | undefined): void {
        const callback__casted = callback_ as (((event: KeyEvent) => void) | undefined)
        this.setOnKeyEvent_serialize(callback__casted)
        return
    }
    public setOnFocus(callback_: (() => void) | undefined): void {
        const callback__casted = callback_ as ((() => void) | undefined)
        this.setOnFocus_serialize(callback__casted)
        return
    }
    public setOnBlur(callback_: (() => void) | undefined): void {
        const callback__casted = callback_ as ((() => void) | undefined)
        this.setOnBlur_serialize(callback__casted)
        return
    }
    public setOnHover(callback_: HoverCallback | undefined): void {
        const callback__casted = callback_ as (HoverCallback | undefined)
        this.setOnHover_serialize(callback__casted)
        return
    }
    public setOnMouse(callback_: ((event: MouseEvent) => void) | undefined): void {
        const callback__casted = callback_ as (((event: MouseEvent) => void) | undefined)
        this.setOnMouse_serialize(callback__casted)
        return
    }
    public setOnSizeChange(callback_: SizeChangeCallback | undefined): void {
        const callback__casted = callback_ as (SizeChangeCallback | undefined)
        this.setOnSizeChange_serialize(callback__casted)
        return
    }
    public setOnVisibleAreaApproximateChange(options: VisibleAreaEventOptions, event: VisibleAreaChangeCallback | undefined): void {
        const options_casted = options as (VisibleAreaEventOptions)
        const event_casted = event as (VisibleAreaChangeCallback | undefined)
        this.setOnVisibleAreaApproximateChange_serialize(options_casted, event_casted)
        return
    }
    setOnClick_serialize(callback_: ((event: ClickEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnClick(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnTouch_serialize(callback_: ((event: TouchEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnTouch(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAppear_serialize(callback_: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnAppear(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDisappear_serialize(callback_: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnDisappear(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnKeyEvent_serialize(callback_: ((event: KeyEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnKeyEvent(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnFocus_serialize(callback_: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnFocus(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnBlur_serialize(callback_: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnBlur(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnHover_serialize(callback_: HoverCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnHover(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnMouse_serialize(callback_: ((event: MouseEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnMouse(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnSizeChange_serialize(callback_: SizeChangeCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnSizeChange(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnVisibleAreaApproximateChange_serialize(options: VisibleAreaEventOptions, event: VisibleAreaChangeCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        VisibleAreaEventOptions_serializer.write(thisSerializer, options)
        if (event !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const eventTmpValue  = event!
            thisSerializer.holdAndWriteCallback(eventTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._UICommonEvent_setOnVisibleAreaApproximateChange(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export class ArkCommonMethodPeer extends PeerNode {
    attributeSet?: CommonMethodModifier;
    public constructor(peerPtr: KPointer, id: int32, name: string = "", flags: int32 = 0) {
        super(peerPtr, id, name, flags)
    }
    public static create(component?: ComponentBase, flags: int32 = 0): ArkCommonMethodPeer {
        const peerId  = PeerNode.nextId()
        const _peerPtr  = ArkUIGeneratedNativeModule._CommonMethod_construct(peerId, flags)
        const _peer  = new ArkCommonMethodPeer(_peerPtr, peerId, 'CommonMethod', flags)
        component?.setPeer(_peer)
        return _peer
    }
    setWidthAttribute(value: Length | LayoutPolicy | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Length) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Length
                if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx0)
                } else if (valueTmpValueForIdx0 instanceof number) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as number
                    thisSerializer.writeNumber(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as Resource
                    Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx2)
                }
            } else if (valueTmpValue instanceof LayoutPolicy) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as LayoutPolicy
                LayoutPolicy_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setWidth(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setHeightAttribute(value: Length | LayoutPolicy | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Length) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Length
                if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx0)
                } else if (valueTmpValueForIdx0 instanceof number) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as number
                    thisSerializer.writeNumber(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as Resource
                    Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx2)
                }
            } else if (valueTmpValue instanceof LayoutPolicy) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as LayoutPolicy
                LayoutPolicy_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setHeight(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setResponseRegionAttribute(value: Array<Rectangle> | Rectangle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (TypeChecker.isArray_Rectangle(valueTmpValue)) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Array<Rectangle>
                thisSerializer.writeInt32((valueTmpValueForIdx0.length).toInt())
                for (let valueTmpValueForIdx0CounterI = 0; valueTmpValueForIdx0CounterI < valueTmpValueForIdx0.length; valueTmpValueForIdx0CounterI++) {
                    const valueTmpValueForIdx0TmpElement : Rectangle = valueTmpValueForIdx0[valueTmpValueForIdx0CounterI]
                    Rectangle_serializer.write(thisSerializer, valueTmpValueForIdx0TmpElement)
                }
            } else if (valueTmpValue instanceof Rectangle) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as Rectangle
                Rectangle_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setResponseRegion(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMouseResponseRegionAttribute(value: Array<Rectangle> | Rectangle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (TypeChecker.isArray_Rectangle(valueTmpValue)) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Array<Rectangle>
                thisSerializer.writeInt32((valueTmpValueForIdx0.length).toInt())
                for (let valueTmpValueForIdx0CounterI = 0; valueTmpValueForIdx0CounterI < valueTmpValueForIdx0.length; valueTmpValueForIdx0CounterI++) {
                    const valueTmpValueForIdx0TmpElement : Rectangle = valueTmpValueForIdx0[valueTmpValueForIdx0CounterI]
                    Rectangle_serializer.write(thisSerializer, valueTmpValueForIdx0TmpElement)
                }
            } else if (valueTmpValue instanceof Rectangle) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as Rectangle
                Rectangle_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMouseResponseRegion(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setResponseRegionListAttribute(value: Array<ResponseRegion> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeInt32((valueTmpValue.length).toInt())
            for (let valueTmpValueCounterI = 0; valueTmpValueCounterI < valueTmpValue.length; valueTmpValueCounterI++) {
                const valueTmpValueTmpElement : ResponseRegion = valueTmpValue[valueTmpValueCounterI]
                ResponseRegion_serializer.write(thisSerializer, valueTmpValueTmpElement)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setResponseRegionList(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSizeAttribute(value: SizeOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            SizeOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSize(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setConstraintSizeAttribute(value: ConstraintSizeOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            ConstraintSizeOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setConstraintSize(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setHitTestBehaviorAttribute(value: HitTestMode | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as HitTestMode)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setHitTestBehavior(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnChildTouchTestAttribute(value: ((value: Array<TouchTestInfo>) => TouchResult) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnChildTouchTest(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setLayoutWeightAttribute(value: number | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof number) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as number
                thisSerializer.writeNumber(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setLayoutWeight(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setChainWeightAttribute(value: ChainWeightOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            ChainWeightOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setChainWeight(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setPaddingAttribute(value: Padding | Length | LocalizedPadding | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Padding) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Padding
                Padding_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof Length) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as Length
                if (valueTmpValueForIdx1 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx1ForIdx0  = valueTmpValueForIdx1 as string
                    thisSerializer.writeString(valueTmpValueForIdx1ForIdx0)
                } else if (valueTmpValueForIdx1 instanceof number) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx1ForIdx1  = valueTmpValueForIdx1 as number
                    thisSerializer.writeNumber(valueTmpValueForIdx1ForIdx1)
                } else if (valueTmpValueForIdx1 instanceof Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx1ForIdx2  = valueTmpValueForIdx1 as Resource
                    Resource_serializer.write(thisSerializer, valueTmpValueForIdx1ForIdx2)
                }
            } else if (valueTmpValue instanceof LocalizedPadding) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedPadding
                LocalizedPadding_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setPadding(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSafeAreaPaddingAttribute(value: Padding | LengthMetrics | LocalizedPadding | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Padding) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Padding
                Padding_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof LengthMetrics) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as LengthMetrics
                LengthMetrics_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof LocalizedPadding) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedPadding
                LocalizedPadding_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSafeAreaPadding(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMarginAttribute(value: Padding | Length | LocalizedPadding | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Padding) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Padding
                Padding_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof Length) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as Length
                if (valueTmpValueForIdx1 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx1ForIdx0  = valueTmpValueForIdx1 as string
                    thisSerializer.writeString(valueTmpValueForIdx1ForIdx0)
                } else if (valueTmpValueForIdx1 instanceof number) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx1ForIdx1  = valueTmpValueForIdx1 as number
                    thisSerializer.writeNumber(valueTmpValueForIdx1ForIdx1)
                } else if (valueTmpValueForIdx1 instanceof Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx1ForIdx2  = valueTmpValueForIdx1 as Resource
                    Resource_serializer.write(thisSerializer, valueTmpValueForIdx1ForIdx2)
                }
            } else if (valueTmpValue instanceof LocalizedPadding) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedPadding
                LocalizedPadding_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMargin(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundColorAttribute(value: ResourceColor | ColorMetrics | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof ResourceColor) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as ResourceColor
                if (valueTmpValueForIdx0 instanceof Color) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as Color
                    thisSerializer.writeInt32(valueTmpValueForIdx0ForIdx0.getOrdinal())
                } else if (valueTmpValueForIdx0 instanceof number) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as number
                    thisSerializer.writeNumber(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx2)
                } else if (valueTmpValueForIdx0 instanceof Resource) {
                    thisSerializer.writeInt8((3).toByte())
                    const valueTmpValueForIdx0ForIdx3  = valueTmpValueForIdx0 as Resource
                    Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx3)
                }
            } else if (valueTmpValue instanceof ColorMetrics) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as ColorMetrics
                ColorMetrics_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
             thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundColor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setPixelRoundAttribute(value: PixelRoundPolicy | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            PixelRoundPolicy_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setPixelRound(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundImageSizeAttribute(value: SizeOptions | ImageSize | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof SizeOptions) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as SizeOptions
                SizeOptions_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof ImageSize) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as ImageSize
                thisSerializer.writeInt32(valueTmpValueForIdx1.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundImageSize(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundImagePositionAttribute(value: Position | Alignment | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Position) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Position
                Position_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof Alignment) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as Alignment
                thisSerializer.writeInt32(valueTmpValueForIdx1.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundImagePosition(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundEffect0Attribute(value: BackgroundEffectOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            BackgroundEffectOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundEffect0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundImageResizableAttribute(value: ResizableOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            ResizableOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundImageResizable(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setForegroundEffectAttribute(value: ForegroundEffectOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            ForegroundEffectOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setForegroundEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setVisualEffectAttribute(value: uiEffect.VisualEffect | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            uiEffect_VisualEffect_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setVisualEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundFilterAttribute(value: uiEffect.Filter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            uiEffect_Filter_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundFilter(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setForegroundFilterAttribute(value: uiEffect.Filter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            uiEffect_Filter_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setForegroundFilter(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setCompositingFilterAttribute(value: uiEffect.Filter | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            uiEffect_Filter_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setCompositingFilter(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOpacityAttribute(value: double | Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof double) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as double
                thisSerializer.writeFloat64(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof Resource) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as Resource
                Resource_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOpacity(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderAttribute(value: BorderOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            BorderOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorder(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderStyleAttribute(value: BorderStyle | EdgeStyles | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof BorderStyle) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as BorderStyle
                thisSerializer.writeInt32(valueTmpValueForIdx0.valueOf())
            } else if (valueTmpValue instanceof EdgeStyles) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as EdgeStyles
                EdgeStyles_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorderStyle(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderWidthAttribute(value: Length | EdgeWidths | LocalizedEdgeWidths | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Length) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Length
                if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx0)
                } else if (valueTmpValueForIdx0 instanceof number) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as number
                    thisSerializer.writeNumber(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as Resource
                    Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx2)
                }
            } else if (valueTmpValue instanceof EdgeWidths) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as EdgeWidths
                EdgeWidths_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof LocalizedEdgeWidths) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedEdgeWidths
                LocalizedEdgeWidths_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorderWidth(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderColorAttribute(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof ResourceColor) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as ResourceColor
                if (valueTmpValueForIdx0 instanceof Color) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as Color
                    thisSerializer.writeInt32(valueTmpValueForIdx0ForIdx0.getOrdinal())
                } else if (valueTmpValueForIdx0 instanceof number) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as number
                    thisSerializer.writeNumber(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx2)
                } else if (valueTmpValueForIdx0 instanceof Resource) {
                    thisSerializer.writeInt8((3).toByte())
                    const valueTmpValueForIdx0ForIdx3  = valueTmpValueForIdx0 as Resource
                    Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx3)
                }
            } else if (valueTmpValue instanceof EdgeColors) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as EdgeColors
                EdgeColors_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof LocalizedEdgeColors) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedEdgeColors
                LocalizedEdgeColors_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorderColor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderRadiusAttribute(value: Length | BorderRadiuses | LocalizedBorderRadiuses | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Length) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Length
                if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx0)
                } else if (valueTmpValueForIdx0 instanceof number) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as number
                    thisSerializer.writeNumber(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as Resource
                    Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx2)
                }
            } else if (valueTmpValue instanceof BorderRadiuses) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as BorderRadiuses
                BorderRadiuses_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof LocalizedBorderRadiuses) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorderRadius(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBorderImageAttribute(value: BorderImageOption | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            BorderImageOption_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBorderImage(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOutlineAttribute(value: OutlineOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            OutlineOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOutline(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOutlineStyleAttribute(value: OutlineStyle | EdgeOutlineStyles | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof OutlineStyle) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as OutlineStyle
                thisSerializer.writeInt32(valueTmpValueForIdx0.valueOf())
            } else if (valueTmpValue instanceof EdgeOutlineStyles) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as EdgeOutlineStyles
                EdgeOutlineStyles_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOutlineStyle(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOutlineWidthAttribute(value: Dimension | EdgeOutlineWidths | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Dimension) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Dimension
                if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx0)
                } else if (valueTmpValueForIdx0 instanceof number) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as number
                    thisSerializer.writeNumber(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as Resource
                    Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx2)
                }
            } else if (valueTmpValue instanceof EdgeOutlineWidths) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as EdgeOutlineWidths
                EdgeOutlineWidths_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOutlineWidth(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOutlineColorAttribute(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof ResourceColor) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as ResourceColor
                if (valueTmpValueForIdx0 instanceof Color) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as Color
                    thisSerializer.writeInt32(valueTmpValueForIdx0ForIdx0.getOrdinal())
                } else if (valueTmpValueForIdx0 instanceof number) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as number
                    thisSerializer.writeNumber(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx2)
                } else if (valueTmpValueForIdx0 instanceof Resource) {
                    thisSerializer.writeInt8((3).toByte())
                    const valueTmpValueForIdx0ForIdx3  = valueTmpValueForIdx0 as Resource
                    Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx3)
                }
            } else if (valueTmpValue instanceof EdgeColors) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as EdgeColors
                EdgeColors_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof LocalizedEdgeColors) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedEdgeColors
                LocalizedEdgeColors_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOutlineColor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOutlineRadiusAttribute(value: Dimension | OutlineRadiuses | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Dimension) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Dimension
                if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx0)
                } else if (valueTmpValueForIdx0 instanceof number) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as number
                    thisSerializer.writeNumber(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as Resource
                    Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx2)
                }
            } else if (valueTmpValue instanceof OutlineRadiuses) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as OutlineRadiuses
                OutlineRadiuses_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOutlineRadius(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setForegroundColorAttribute(value: ResourceColor | ColoringStrategy | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof ResourceColor) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as ResourceColor
                if (valueTmpValueForIdx0 instanceof Color) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueForIdx0ForIdx0  = valueTmpValueForIdx0 as Color
                    thisSerializer.writeInt32(valueTmpValueForIdx0ForIdx0.getOrdinal())
                } else if (valueTmpValueForIdx0 instanceof number) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueForIdx0ForIdx1  = valueTmpValueForIdx0 as number
                    thisSerializer.writeNumber(valueTmpValueForIdx0ForIdx1)
                } else if (valueTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueForIdx0ForIdx2  = valueTmpValueForIdx0 as string
                    thisSerializer.writeString(valueTmpValueForIdx0ForIdx2)
                } else if (valueTmpValueForIdx0 instanceof Resource) {
                    thisSerializer.writeInt8((3).toByte())
                    const valueTmpValueForIdx0ForIdx3  = valueTmpValueForIdx0 as Resource
                    Resource_serializer.write(thisSerializer, valueTmpValueForIdx0ForIdx3)
                }
            } else if (valueTmpValue instanceof ColoringStrategy) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as ColoringStrategy
                thisSerializer.writeInt32(valueTmpValueForIdx1.getOrdinal())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setForegroundColor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnClick0Attribute(value: ((event: ClickEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnClick0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnHoverAttribute(value: ((isHover: boolean,event: HoverEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnHover(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnHoverMoveAttribute(value: ((value0: HoverEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnHoverMove(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAccessibilityHoverAttribute(value: AccessibilityCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAccessibilityHover(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAccessibilityHoverTransparentAttribute(value: AccessibilityTransparentCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAccessibilityHoverTransparent(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setHoverEffectAttribute(value: HoverEffect | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as HoverEffect)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setHoverEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnMouseAttribute(value: ((event: MouseEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnMouse(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnTouchAttribute(value: ((event: TouchEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnTouch(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnKeyEventAttribute(value: ((event: KeyEvent) => boolean) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnKeyEvent(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDigitalCrownAttribute(value: ((value0: CrownEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDigitalCrown(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnKeyPreImeAttribute(value: ((value0: KeyEvent) => boolean) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnKeyPreIme(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnKeyEventDispatchAttribute(value: ((value0: KeyEvent) => boolean) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnKeyEventDispatch(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnFocusAxisEventAttribute(value: ((value0: FocusAxisEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnFocusAxisEvent(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAxisEventAttribute(value: ((value0: AxisEvent) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAxisEvent(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFocusableAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFocusable(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setNextFocusAttribute(value: FocusMovement | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            FocusMovement_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setNextFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTabStopAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTabStop(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnFocusAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnBlurAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnBlur(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTabIndexAttribute(value: int32 | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeInt32(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTabIndex(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDefaultFocusAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDefaultFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setGroupDefaultFocusAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setGroupDefaultFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFocusOnTouchAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFocusOnTouch(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFocusBoxAttribute(value: FocusBoxStyle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            FocusBoxStyle_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFocusBox(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAnimationAttribute(value: AnimateParam | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            AnimateParam_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAnimation(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTransition0Attribute(value: TransitionEffect | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            TransitionEffect_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTransition0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMotionBlurAttribute(value: MotionBlurOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            MotionBlurOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMotionBlur(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBrightnessAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBrightness(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setContrastAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setContrast(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setGrayscaleAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setGrayscale(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setColorBlendAttribute(value: Color | string | Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Color) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Color
                thisSerializer.writeInt32(valueTmpValueForIdx0.getOrdinal())
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof Resource) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as Resource
                Resource_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setColorBlend(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSaturateAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSaturate(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSepiaAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSepia(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setInvertAttribute(value: double | InvertOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof double) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as double
                thisSerializer.writeFloat64(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof InvertOptions) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as InvertOptions
                InvertOptions_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setInvert(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setHueRotateAttribute(value: double | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof double) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as double
                thisSerializer.writeFloat64(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setHueRotate(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setUseShadowBatchingAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setUseShadowBatching(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setUseEffect0Attribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setUseEffect0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setRenderGroupAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setRenderGroup(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFreezeAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFreeze(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTranslateAttribute(value: TranslateOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            TranslateOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTranslate(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setScaleAttribute(value: ScaleOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            ScaleOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setScale(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setRotateAttribute(value: RotateOptions | RotateAngleOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof RotateOptions) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as RotateOptions
                RotateOptions_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof RotateAngleOptions) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as RotateAngleOptions
                RotateAngleOptions_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setRotate(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTransformAttribute(value: matrix4.Matrix4Transit | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            matrix4_Matrix4Transit_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTransform(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTransform3DAttribute(value: matrix4.Matrix4Transit | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            matrix4_Matrix4Transit_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTransform3D(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAppearAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAppear(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDisAppearAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDisAppear(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAttachAttribute(value: VoidCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAttach(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDetachAttribute(value: VoidCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDetach(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAreaChangeAttribute(value: ((oldValue: Area,newValue: Area) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAreaChange(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setVisibilityAttribute(value: Visibility | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as Visibility)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setVisibility(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFlexGrowAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeNumber(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFlexGrow(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFlexShrinkAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeNumber(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFlexShrink(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFlexBasisAttribute(value: number | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof number) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as number
                thisSerializer.writeNumber(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFlexBasis(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAlignSelfAttribute(value: ItemAlign | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as ItemAlign)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAlignSelf(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDisplayPriorityAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeNumber(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDisplayPriority(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setZIndexAttribute(value: int32 | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeInt32(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setZIndex(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDirectionAttribute(value: Direction | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as Direction)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDirection(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAlignAttribute(value: Alignment | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as Alignment)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAlign(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setPositionAttribute(value: Position | Edges | LocalizedEdges | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Position) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Position
                Position_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof Edges) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as Edges
                Edges_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof LocalizedEdges) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedEdges
                LocalizedEdges_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setPosition(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMarkAnchorAttribute(value: Position | LocalizedPosition | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Position) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Position
                Position_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof LocalizedPosition) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as LocalizedPosition
                LocalizedPosition_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMarkAnchor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOffsetAttribute(value: Position | Edges | LocalizedEdges | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Position) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Position
                Position_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof Edges) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as Edges
                Edges_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof LocalizedEdges) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as LocalizedEdges
                LocalizedEdges_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOffset(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setEnabledAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setEnabled(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAlignRulesAttribute(value: AlignRuleOption | LocalizedAlignRuleOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof AlignRuleOption) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as AlignRuleOption
                AlignRuleOption_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof LocalizedAlignRuleOptions) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as LocalizedAlignRuleOptions
                LocalizedAlignRuleOptions_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAlignRules(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAspectRatioAttribute(value: number | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeNumber(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAspectRatio(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setClickEffectAttribute(value: ClickEffect | null | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined && value !== null) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            ClickEffect_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setClickEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDragStartAttribute(value: ((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDragStart(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDragEnterAttribute(value: ((event: DragEvent,extraParams?: string) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDragEnter(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDragMoveAttribute(value: ((event: DragEvent,extraParams?: string) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDragMove(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDragLeaveAttribute(value: ((event: DragEvent,extraParams?: string) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDragLeave(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDrop0Attribute(value: ((event: DragEvent,extraParams?: string) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDrop0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDragEndAttribute(value: ((event: DragEvent,extraParams?: string) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDragEnd(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDraggableAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDraggable(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDragPreview0Attribute(value: CustomBuilder | DragItemInfo | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof CustomBuilder) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as CustomBuilder
                thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(valueTmpValueForIdx0))
            } else if (valueTmpValue instanceof DragItemInfo) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as DragItemInfo
                DragItemInfo_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDragPreview0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnPreDragAttribute(value: ((value0: PreDragStatus) => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnPreDrag(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setLinearGradientAttribute(value: LinearGradientOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            LinearGradientOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setLinearGradient(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSweepGradientAttribute(value: SweepGradientOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            SweepGradientOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSweepGradient(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setRadialGradientAttribute(value: RadialGradientOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            RadialGradientOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setRadialGradient(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMotionPathAttribute(value: MotionPathOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            MotionPathOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMotionPath(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setShadowAttribute(value: ShadowOptions | ShadowStyle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof ShadowOptions) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as ShadowOptions
                ShadowOptions_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof ShadowStyle) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as ShadowStyle
                thisSerializer.writeInt32(valueTmpValueForIdx1.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setShadow(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setClipAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setClip(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setClipShapeAttribute(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof CircleShape) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as CircleShape
                CircleShape_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof EllipseShape) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as EllipseShape
                EllipseShape_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof PathShape) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as PathShape
                PathShape_serializer.write(thisSerializer, valueTmpValueForIdx2)
            } else if (valueTmpValue instanceof RectShape) {
                thisSerializer.writeInt8((3).toByte())
                const valueTmpValueForIdx3  = valueTmpValue as RectShape
                RectShape_serializer.write(thisSerializer, valueTmpValueForIdx3)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setClipShape(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMaskAttribute(value: ProgressMask | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            ProgressMask_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMask(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMaskShapeAttribute(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof CircleShape) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as CircleShape
                CircleShape_serializer.write(thisSerializer, valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof EllipseShape) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as EllipseShape
                EllipseShape_serializer.write(thisSerializer, valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof PathShape) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as PathShape
                PathShape_serializer.write(thisSerializer, valueTmpValueForIdx2)
            } else if (valueTmpValue instanceof RectShape) {
                thisSerializer.writeInt8((3).toByte())
                const valueTmpValueForIdx3  = valueTmpValue as RectShape
                RectShape_serializer.write(thisSerializer, valueTmpValueForIdx3)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMaskShape(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setKeyAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeString(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setKey(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setIdAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeString(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setId(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setGeometryTransition0Attribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeString(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setGeometryTransition0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setRestoreIdAttribute(value: int32 | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeInt32(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setRestoreId(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSphericalEffectAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSphericalEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setLightUpEffectAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setLightUpEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setPixelStretchEffectAttribute(value: PixelStretchEffectOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            PixelStretchEffectOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setPixelStretchEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityGroupWithValueAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityGroupWithValue(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityTextOfStringTypeAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeString(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityTextOfStringType(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityNextFocusIdAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeString(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityNextFocusId(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityDefaultFocusAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityDefaultFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityUseSamePageAttribute(value: AccessibilitySamePageMode | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as AccessibilitySamePageMode)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityUseSamePage(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityScrollTriggerableAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityScrollTriggerable(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityTextOfResourceTypeAttribute(value: Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            Resource_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityTextOfResourceType(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityRoleAttribute(value: AccessibilityRoleType | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as AccessibilityRoleType)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityRole(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAccessibilityFocusAttribute(value: AccessibilityFocusCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAccessibilityFocus(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnAccessibilityActionInterceptAttribute(value: AccessibilityActionInterceptCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnAccessibilityActionIntercept(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityTextHintAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeString(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityTextHint(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityDescriptionOfStringTypeAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeString(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityDescriptionOfStringType(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityDescriptionOfResourceTypeAttribute(value: Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            Resource_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityDescriptionOfResourceType(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityLevelAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeString(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityLevel(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityVirtualNodeAttribute(value: CustomBuilder | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(valueTmpValue))
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityVirtualNode(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityCheckedAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityChecked(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilitySelectedAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilitySelected(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setObscuredAttribute(value: Array<ObscuredReasons> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeInt32((valueTmpValue.length).toInt())
            for (let valueTmpValueCounterI = 0; valueTmpValueCounterI < valueTmpValue.length; valueTmpValueCounterI++) {
                const valueTmpValueTmpElement : ObscuredReasons = valueTmpValue[valueTmpValueCounterI]
                thisSerializer.writeInt32(valueTmpValueTmpElement.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setObscured(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setReuseIdAttribute(value: string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeString(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setReuseId(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setReuseAttribute(value: ReuseOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            ReuseOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setReuse(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setRenderFitAttribute(value: RenderFit | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as RenderFit)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setRenderFit(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundBrightnessAttribute(value: BackgroundBrightnessOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            BackgroundBrightnessOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundBrightness(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnGestureJudgeBeginAttribute(value: ((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnGestureJudgeBegin(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnGestureRecognizerJudgeBegin0Attribute(value: GestureRecognizerJudgeBeginCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnGestureRecognizerJudgeBegin0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setShouldBuiltInRecognizerParallelWithAttribute(value: ShouldBuiltInRecognizerParallelWithCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setShouldBuiltInRecognizerParallelWith(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setMonopolizeEventsAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setMonopolizeEvents(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnTouchInterceptAttribute(value: ((value0: TouchEvent) => HitTestMode) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnTouchIntercept(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnSizeChangeAttribute(value: SizeChangeCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnSizeChange(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityFocusDrawLevelAttribute(value: FocusDrawLevel | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as FocusDrawLevel)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityFocusDrawLevel(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setExpandSafeAreaAttribute(types?: Array<SafeAreaType>, edges?: Array<SafeAreaEdge>): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (types !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const typesTmpValue  = types!
            thisSerializer.writeInt32((typesTmpValue.length).toInt())
            for (let typesTmpValueCounterI = 0; typesTmpValueCounterI < typesTmpValue.length; typesTmpValueCounterI++) {
                const typesTmpValueTmpElement : SafeAreaType = typesTmpValue[typesTmpValueCounterI]
                thisSerializer.writeInt32(typesTmpValueTmpElement.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (edges !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const edgesTmpValue  = edges!
            thisSerializer.writeInt32((edgesTmpValue.length).toInt())
            for (let edgesTmpValueCounterI = 0; edgesTmpValueCounterI < edgesTmpValue.length; edgesTmpValueCounterI++) {
                const edgesTmpValueTmpElement : SafeAreaEdge = edgesTmpValue[edgesTmpValueCounterI]
                thisSerializer.writeInt32(edgesTmpValueTmpElement.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setExpandSafeArea(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setIgnoreLayoutSafeAreaAttribute(types?: Array<LayoutSafeAreaType>, edges?: Array<LayoutSafeAreaEdge>): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (types !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const typesTmpValue  = types!
            thisSerializer.writeInt32((typesTmpValue.length).toInt())
            for (let typesTmpValueCounterI = 0; typesTmpValueCounterI < typesTmpValue.length; typesTmpValueCounterI++) {
                const typesTmpValueTmpElement : LayoutSafeAreaType = typesTmpValue[typesTmpValueCounterI]
                thisSerializer.writeInt32(typesTmpValueTmpElement.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (edges !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const edgesTmpValue  = edges!
            thisSerializer.writeInt32((edgesTmpValue.length).toInt())
            for (let edgesTmpValueCounterI = 0; edgesTmpValueCounterI < edgesTmpValue.length; edgesTmpValueCounterI++) {
                const edgesTmpValueTmpElement : LayoutSafeAreaEdge = edgesTmpValue[edgesTmpValueCounterI]
                thisSerializer.writeInt32(edgesTmpValueTmpElement.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setIgnoreLayoutSafeArea(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundAttribute(builder: CustomBuilder | undefined, options?: BackgroundOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (builder !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const builderTmpValue  = builder!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(builderTmpValue))
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            BackgroundOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackground(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundImage0Attribute(src: ResourceStr | image.PixelMap | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (src !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const srcTmpValue  = src!
            if (srcTmpValue instanceof ResourceStr) {
                thisSerializer.writeInt8((0).toByte())
                const srcTmpValueForIdx0  = srcTmpValue as ResourceStr
                if (srcTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const srcTmpValueForIdx0ForIdx0  = srcTmpValueForIdx0 as string
                    thisSerializer.writeString(srcTmpValueForIdx0ForIdx0)
                } else if (srcTmpValueForIdx0 instanceof Resource) {
                    thisSerializer.writeInt8((1).toByte())
                    const srcTmpValueForIdx0ForIdx1  = srcTmpValueForIdx0 as Resource
                    Resource_serializer.write(thisSerializer, srcTmpValueForIdx0ForIdx1)
                }
            } else if (srcTmpValue instanceof image.PixelMap) {
                thisSerializer.writeInt8((1).toByte())
                const srcTmpValueForIdx1  = srcTmpValue as image.PixelMap
                image_PixelMap_serializer.write(thisSerializer, srcTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundImage0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundImage1Attribute(src: ResourceStr | image.PixelMap | undefined, options?: BackgroundImageOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (src !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const srcTmpValue  = src!
            if (srcTmpValue instanceof ResourceStr) {
                thisSerializer.writeInt8((0).toByte())
                const srcTmpValueForIdx0  = srcTmpValue as ResourceStr
                if (srcTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const srcTmpValueForIdx0ForIdx0  = srcTmpValueForIdx0 as string
                    thisSerializer.writeString(srcTmpValueForIdx0ForIdx0)
                } else if (srcTmpValueForIdx0 instanceof Resource) {
                    thisSerializer.writeInt8((1).toByte())
                    const srcTmpValueForIdx0ForIdx1  = srcTmpValueForIdx0 as Resource
                    Resource_serializer.write(thisSerializer, srcTmpValueForIdx0ForIdx1)
                }
            } else if (srcTmpValue instanceof image.PixelMap) {
                thisSerializer.writeInt8((1).toByte())
                const srcTmpValueForIdx1  = srcTmpValue as image.PixelMap
                image_PixelMap_serializer.write(thisSerializer, srcTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            BackgroundImageOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundImage1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundImage2Attribute(src: ResourceStr | image.PixelMap | undefined, repeat?: ImageRepeat): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (src !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const srcTmpValue  = src!
            if (srcTmpValue instanceof ResourceStr) {
                thisSerializer.writeInt8((0).toByte())
                const srcTmpValueForIdx0  = srcTmpValue as ResourceStr
                if (srcTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const srcTmpValueForIdx0ForIdx0  = srcTmpValueForIdx0 as string
                    thisSerializer.writeString(srcTmpValueForIdx0ForIdx0)
                } else if (srcTmpValueForIdx0 instanceof Resource) {
                    thisSerializer.writeInt8((1).toByte())
                    const srcTmpValueForIdx0ForIdx1  = srcTmpValueForIdx0 as Resource
                    Resource_serializer.write(thisSerializer, srcTmpValueForIdx0ForIdx1)
                }
            } else if (srcTmpValue instanceof image.PixelMap) {
                thisSerializer.writeInt8((1).toByte())
                const srcTmpValueForIdx1  = srcTmpValue as image.PixelMap
                image_PixelMap_serializer.write(thisSerializer, srcTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (repeat !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const repeatTmpValue  = (repeat as ImageRepeat)
            thisSerializer.writeInt32(repeatTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundImage2(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundBlurStyleAttribute(style: BlurStyle | undefined, options?: BackgroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (style !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const styleTmpValue  = (style as BlurStyle)
            thisSerializer.writeInt32(styleTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            BackgroundBlurStyleOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (sysOptions !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const sysOptionsTmpValue  = sysOptions!
            SystemAdaptiveOptions_serializer.write(thisSerializer, sysOptionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundBlurStyle(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackgroundEffect1Attribute(options: BackgroundEffectOptions | undefined, sysOptions?: SystemAdaptiveOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            BackgroundEffectOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (sysOptions !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const sysOptionsTmpValue  = sysOptions!
            SystemAdaptiveOptions_serializer.write(thisSerializer, sysOptionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackgroundEffect1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setForegroundBlurStyleAttribute(style: BlurStyle | undefined, options?: ForegroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (style !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const styleTmpValue  = (style as BlurStyle)
            thisSerializer.writeInt32(styleTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            ForegroundBlurStyleOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (sysOptions !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const sysOptionsTmpValue  = sysOptions!
            SystemAdaptiveOptions_serializer.write(thisSerializer, sysOptionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setForegroundBlurStyle(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnClick1Attribute(event: ((event: ClickEvent) => void) | undefined, distanceThreshold: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (event !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const eventTmpValue  = event!
            thisSerializer.holdAndWriteCallback(eventTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (distanceThreshold !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const distanceThresholdTmpValue  = distanceThreshold!
            thisSerializer.writeFloat64(distanceThresholdTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnClick1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFocusScopeIdAttribute(id: string | undefined, isGroup?: boolean, arrowStepOut?: boolean): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (id !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const idTmpValue  = id!
            thisSerializer.writeString(idTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (isGroup !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const isGroupTmpValue  = isGroup!
            thisSerializer.writeBoolean(isGroupTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (arrowStepOut !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const arrowStepOutTmpValue  = arrowStepOut!
            thisSerializer.writeBoolean(arrowStepOutTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFocusScopeId(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFocusScopePriorityAttribute(scopeId: string | undefined, priority?: FocusPriority): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (scopeId !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const scopeIdTmpValue  = scopeId!
            thisSerializer.writeString(scopeIdTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (priority !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const priorityTmpValue  = (priority as FocusPriority)
            thisSerializer.writeInt32(priorityTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setFocusScopePriority(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setTransition1Attribute(effect: TransitionEffect | undefined, onFinish: TransitionFinishCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (effect !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const effectTmpValue  = effect!
            TransitionEffect_serializer.write(thisSerializer, effectTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (onFinish !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const onFinishTmpValue  = onFinish!
            thisSerializer.holdAndWriteCallback(onFinishTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setTransition1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBlurAttribute(blurRadius: number | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (blurRadius !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const blurRadiusTmpValue  = blurRadius!
            thisSerializer.writeFloat64(blurRadiusTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            BlurOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (sysOptions !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const sysOptionsTmpValue  = sysOptions!
            SystemAdaptiveOptions_serializer.write(thisSerializer, sysOptionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBlur(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setLinearGradientBlurAttribute(value: double | undefined, options: LinearGradientBlurOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            LinearGradientBlurOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setLinearGradientBlur(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSystemBarEffectAttribute(): void {
        ArkUIGeneratedNativeModule._CommonMethod_setSystemBarEffect(this.peer.ptr)
    }
    setUseEffect1Attribute(useEffect: boolean | undefined, effectType: EffectType | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (useEffect !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const useEffectTmpValue  = useEffect!
            thisSerializer.writeBoolean(useEffectTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (effectType !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const effectTypeTmpValue  = (effectType as EffectType)
            thisSerializer.writeInt32(effectTypeTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setUseEffect1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackdropBlurAttribute(radius: double | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (radius !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const radiusTmpValue  = radius!
            thisSerializer.writeFloat64(radiusTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            BlurOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (sysOptions !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const sysOptionsTmpValue  = sysOptions!
            SystemAdaptiveOptions_serializer.write(thisSerializer, sysOptionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBackdropBlur(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setSharedTransitionAttribute(id: string | undefined, options?: sharedTransitionOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (id !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const idTmpValue  = id!
            thisSerializer.writeString(idTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            sharedTransitionOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setSharedTransition(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setChainModeAttribute(direction: Axis | undefined, style: ChainStyle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (direction !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const directionTmpValue  = (direction as Axis)
            thisSerializer.writeInt32(directionTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (style !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const styleTmpValue  = (style as ChainStyle)
            thisSerializer.writeInt32(styleTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setChainMode(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnDrop1Attribute(eventCallback: OnDragEventCallback | undefined, dropOptions?: DropOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (eventCallback !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const eventCallbackTmpValue  = eventCallback!
            thisSerializer.holdAndWriteCallback(eventCallbackTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (dropOptions !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const dropOptionsTmpValue  = dropOptions!
            DropOptions_serializer.write(thisSerializer, dropOptionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnDrop1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDragPreview1Attribute(preview: CustomBuilder | DragItemInfo | string | undefined, config?: PreviewConfiguration): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (preview !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const previewTmpValue  = preview!
            if (previewTmpValue instanceof CustomBuilder) {
                thisSerializer.writeInt8((0).toByte())
                const previewTmpValueForIdx0  = previewTmpValue as CustomBuilder
                thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(previewTmpValueForIdx0))
            } else if (previewTmpValue instanceof DragItemInfo) {
                thisSerializer.writeInt8((1).toByte())
                const previewTmpValueForIdx1  = previewTmpValue as DragItemInfo
                DragItemInfo_serializer.write(thisSerializer, previewTmpValueForIdx1)
            } else if (previewTmpValue instanceof string) {
                thisSerializer.writeInt8((2).toByte())
                const previewTmpValueForIdx2  = previewTmpValue as string
                thisSerializer.writeString(previewTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (config !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const configTmpValue  = config!
            PreviewConfiguration_serializer.write(thisSerializer, configTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setDragPreview1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOverlayAttribute(value: string | CustomBuilder | ComponentContent | undefined, options?: OverlayOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof CustomBuilder) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as CustomBuilder
                thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(valueTmpValueForIdx1))
            } else if (valueTmpValue instanceof ComponentContent) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as ComponentContent
                thisSerializer.holdAndWriteObject(valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            OverlayOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOverlay(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBlendModeAttribute(value: BlendMode | undefined, type?: BlendApplyType): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as BlendMode)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (type !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const typeTmpValue  = (type as BlendApplyType)
            thisSerializer.writeInt32(typeTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBlendMode(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAdvancedBlendModeAttribute(effect: BlendMode | uiEffect.Blender, type?: BlendApplyType): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (effect instanceof BlendMode) {
            thisSerializer.writeInt8((0).toByte())
            const effectForIdx0  = effect as BlendMode
            thisSerializer.writeInt32(effectForIdx0.valueOf())
        } else if (effect instanceof uiEffect.Blender) {
            thisSerializer.writeInt8((1).toByte())
            const effectForIdx1  = effect as uiEffect.Blender
            uiEffect_BrightnessBlender_serializer.write(thisSerializer, effectForIdx1)
        }
        if (type !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const typeTmpValue  = (type as BlendApplyType)
            thisSerializer.writeInt32(typeTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAdvancedBlendMode(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setGeometryTransition1Attribute(id: string | undefined, options?: GeometryTransitionOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (id !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const idTmpValue  = id!
            thisSerializer.writeString(idTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            GeometryTransitionOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setGeometryTransition1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindTipsAttribute(message: TipsMessageType | undefined, options?: TipsOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (message !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const messageTmpValue  = message!
            if (messageTmpValue instanceof ResourceStr) {
                thisSerializer.writeInt8((0).toByte())
                const messageTmpValueForIdx0  = messageTmpValue as ResourceStr
                if (messageTmpValueForIdx0 instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const messageTmpValueForIdx0ForIdx0  = messageTmpValueForIdx0 as string
                    thisSerializer.writeString(messageTmpValueForIdx0ForIdx0)
                } else if (messageTmpValueForIdx0 instanceof Resource) {
                    thisSerializer.writeInt8((1).toByte())
                    const messageTmpValueForIdx0ForIdx1  = messageTmpValueForIdx0 as Resource
                    Resource_serializer.write(thisSerializer, messageTmpValueForIdx0ForIdx1)
                }
            } else if (messageTmpValue instanceof StyledString) {
                thisSerializer.writeInt8((1).toByte())
                const messageTmpValueForIdx1  = messageTmpValue as StyledString
                StyledString_serializer.write(thisSerializer, messageTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            TipsOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindTips(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindPopupAttribute(show: boolean | undefined, popup: PopupOptions | CustomPopupOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (show !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const showTmpValue  = show!
            thisSerializer.writeBoolean(showTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (popup !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const popupTmpValue  = popup!
            if (popupTmpValue instanceof PopupOptions) {
                thisSerializer.writeInt8((0).toByte())
                const popupTmpValueForIdx0  = popupTmpValue as PopupOptions
                PopupOptions_serializer.write(thisSerializer, popupTmpValueForIdx0)
            } else if (popupTmpValue instanceof CustomPopupOptions) {
                thisSerializer.writeInt8((1).toByte())
                const popupTmpValueForIdx1  = popupTmpValue as CustomPopupOptions
                CustomPopupOptions_serializer.write(thisSerializer, popupTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindPopup(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindMenu0Attribute(content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (content !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const contentTmpValue  = content!
            if (TypeChecker.isArray_MenuElement(contentTmpValue)) {
                thisSerializer.writeInt8((0).toByte())
                const contentTmpValueForIdx0  = contentTmpValue as Array<MenuElement>
                thisSerializer.writeInt32((contentTmpValueForIdx0.length).toInt())
                for (let contentTmpValueForIdx0CounterI = 0; contentTmpValueForIdx0CounterI < contentTmpValueForIdx0.length; contentTmpValueForIdx0CounterI++) {
                    const contentTmpValueForIdx0TmpElement : MenuElement = contentTmpValueForIdx0[contentTmpValueForIdx0CounterI]
                    MenuElement_serializer.write(thisSerializer, contentTmpValueForIdx0TmpElement)
                }
            } else if (contentTmpValue instanceof CustomBuilder) {
                thisSerializer.writeInt8((1).toByte())
                const contentTmpValueForIdx1  = contentTmpValue as CustomBuilder
                thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(contentTmpValueForIdx1))
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            MenuOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindMenu0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindMenu1Attribute(isShow: boolean | undefined, content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (isShow !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const isShowTmpValue  = isShow!
            thisSerializer.writeBoolean(isShowTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (content !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const contentTmpValue  = content!
            if (TypeChecker.isArray_MenuElement(contentTmpValue)) {
                thisSerializer.writeInt8((0).toByte())
                const contentTmpValueForIdx0  = contentTmpValue as Array<MenuElement>
                thisSerializer.writeInt32((contentTmpValueForIdx0.length).toInt())
                for (let contentTmpValueForIdx0CounterI = 0; contentTmpValueForIdx0CounterI < contentTmpValueForIdx0.length; contentTmpValueForIdx0CounterI++) {
                    const contentTmpValueForIdx0TmpElement : MenuElement = contentTmpValueForIdx0[contentTmpValueForIdx0CounterI]
                    MenuElement_serializer.write(thisSerializer, contentTmpValueForIdx0TmpElement)
                }
            } else if (contentTmpValue instanceof CustomBuilder) {
                thisSerializer.writeInt8((1).toByte())
                const contentTmpValueForIdx1  = contentTmpValue as CustomBuilder
                thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(contentTmpValueForIdx1))
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            MenuOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindMenu1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindContextMenu0Attribute(content: CustomBuilder | undefined, responseType: ResponseType | undefined, options?: ContextMenuOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (content !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const contentTmpValue  = content!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(contentTmpValue))
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (responseType !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const responseTypeTmpValue  = (responseType as ResponseType)
            thisSerializer.writeInt32(responseTypeTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            ContextMenuOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindContextMenu0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindContextMenu1Attribute(isShown: boolean | undefined, content: CustomBuilder | undefined, options?: ContextMenuOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (isShown !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const isShownTmpValue  = isShown!
            thisSerializer.writeBoolean(isShownTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (content !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const contentTmpValue  = content!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(contentTmpValue))
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            ContextMenuOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindContextMenu1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindContentCover0Attribute(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, type?: ModalTransition): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (isShow !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const isShowTmpValue  = isShow!
            if (isShowTmpValue instanceof boolean) {
                thisSerializer.writeInt8((0).toByte())
                const isShowTmpValueForIdx0  = isShowTmpValue as boolean
                thisSerializer.writeBoolean(isShowTmpValueForIdx0)
            } else if (isShowTmpValue instanceof Bindable<boolean>) {
                thisSerializer.writeInt8((1).toByte())
                const isShowTmpValueForIdx1  = isShowTmpValue as Bindable<boolean>
                Bindable_Boolean_serializer.write(thisSerializer, isShowTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (builder !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const builderTmpValue  = builder!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(builderTmpValue))
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (type !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const typeTmpValue  = (type as ModalTransition)
            thisSerializer.writeInt32(typeTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindContentCover0(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindContentCover1Attribute(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, options?: ContentCoverOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (isShow !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const isShowTmpValue  = isShow!
            if (isShowTmpValue instanceof boolean) {
                thisSerializer.writeInt8((0).toByte())
                const isShowTmpValueForIdx0  = isShowTmpValue as boolean
                thisSerializer.writeBoolean(isShowTmpValueForIdx0)
            } else if (isShowTmpValue instanceof Bindable<boolean>) {
                thisSerializer.writeInt8((1).toByte())
                const isShowTmpValueForIdx1  = isShowTmpValue as Bindable<boolean>
                Bindable_Boolean_serializer.write(thisSerializer, isShowTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (builder !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const builderTmpValue  = builder!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(builderTmpValue))
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            ContentCoverOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindContentCover1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBindSheetAttribute(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, options?: SheetOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (isShow !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const isShowTmpValue  = isShow!
            if (isShowTmpValue instanceof boolean) {
                thisSerializer.writeInt8((0).toByte())
                const isShowTmpValueForIdx0  = isShowTmpValue as boolean
                thisSerializer.writeBoolean(isShowTmpValueForIdx0)
            } else if (isShowTmpValue instanceof Bindable<boolean>) {
                thisSerializer.writeInt8((1).toByte())
                const isShowTmpValueForIdx1  = isShowTmpValue as Bindable<boolean>
                Bindable_Boolean_serializer.write(thisSerializer, isShowTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (builder !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const builderTmpValue  = builder!
            thisSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(builderTmpValue))
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            SheetOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setBindSheet(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnVisibleAreaChangeAttribute(ratios: Array<double> | undefined, event: VisibleAreaChangeCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (ratios !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const ratiosTmpValue  = ratios!
            thisSerializer.writeInt32((ratiosTmpValue.length).toInt())
            for (let ratiosTmpValueCounterI = 0; ratiosTmpValueCounterI < ratiosTmpValue.length; ratiosTmpValueCounterI++) {
                const ratiosTmpValueTmpElement : double = ratiosTmpValue[ratiosTmpValueCounterI]
                thisSerializer.writeFloat64(ratiosTmpValueTmpElement)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (event !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const eventTmpValue  = event!
            thisSerializer.holdAndWriteCallback(eventTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnVisibleAreaChange(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnVisibleAreaApproximateChangeAttribute(options: VisibleAreaEventOptions | undefined, event: VisibleAreaChangeCallback | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            VisibleAreaEventOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (event !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const eventTmpValue  = event!
            thisSerializer.holdAndWriteCallback(eventTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnVisibleAreaApproximateChange(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setKeyboardShortcutAttribute(value: string | FunctionKey | undefined, keys: Array<ModifierKey> | undefined, action?: (() => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof FunctionKey) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as FunctionKey
                thisSerializer.writeInt32(valueTmpValueForIdx1.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (keys !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const keysTmpValue  = keys!
            thisSerializer.writeInt32((keysTmpValue.length).toInt())
            for (let keysTmpValueCounterI = 0; keysTmpValueCounterI < keysTmpValue.length; keysTmpValueCounterI++) {
                const keysTmpValueTmpElement : ModifierKey = keysTmpValue[keysTmpValueCounterI]
                thisSerializer.writeInt32(keysTmpValueTmpElement.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (action !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const actionTmpValue  = action!
            thisSerializer.holdAndWriteCallback(actionTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setKeyboardShortcut(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAccessibilityGroupWithConfigAttribute(isGroup: boolean | undefined, config: AccessibilityOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (isGroup !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const isGroupTmpValue  = isGroup!
            thisSerializer.writeBoolean(isGroupTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (config !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const configTmpValue  = config!
            AccessibilityOptions_serializer.write(thisSerializer, configTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setAccessibilityGroupWithConfig(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnGestureRecognizerJudgeBegin1Attribute(callback_: GestureRecognizerJudgeBeginCallback | undefined, exposeInnerGesture: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (callback_ !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const callback_TmpValue  = callback_!
            thisSerializer.holdAndWriteCallback(callback_TmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (exposeInnerGesture !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const exposeInnerGestureTmpValue  = exposeInnerGesture!
            thisSerializer.writeBoolean(exposeInnerGestureTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonMethod_setOnGestureRecognizerJudgeBegin1(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export class ArkCommonShapeMethodPeer extends ArkCommonMethodPeer {
    attributeSet?: CommonShapeMethodModifier;
    public constructor(peerPtr: KPointer, id: int32, name: string = "", flags: int32 = 0) {
        super(peerPtr, id, name, flags)
    }
    public static create(component?: ComponentBase, flags: int32 = 0): ArkCommonShapeMethodPeer {
        const peerId  = PeerNode.nextId()
        const _peerPtr  = ArkUIGeneratedNativeModule._CommonShapeMethod_construct(peerId, flags)
        const _peer  = new ArkCommonShapeMethodPeer(_peerPtr, peerId, 'CommonShapeMethod', flags)
        component?.setPeer(_peer)
        return _peer
    }
    setStrokeAttribute(value: ResourceColor | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Color) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Color
                thisSerializer.writeInt32(valueTmpValueForIdx0.getOrdinal())
            } else if (valueTmpValue instanceof number) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as number
                thisSerializer.writeNumber(valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx2)
            } else if (valueTmpValue instanceof Resource) {
                thisSerializer.writeInt8((3).toByte())
                const valueTmpValueForIdx3  = valueTmpValue as Resource
                Resource_serializer.write(thisSerializer, valueTmpValueForIdx3)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStroke(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFillAttribute(value: ResourceColor | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Color) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Color
                thisSerializer.writeInt32(valueTmpValueForIdx0.getOrdinal())
            } else if (valueTmpValue instanceof number) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as number
                thisSerializer.writeNumber(valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx2)
            } else if (valueTmpValue instanceof Resource) {
                thisSerializer.writeInt8((3).toByte())
                const valueTmpValueForIdx3  = valueTmpValue as Resource
                Resource_serializer.write(thisSerializer, valueTmpValueForIdx3)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setFill(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeDashOffsetAttribute(value: number | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof number) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as number
                thisSerializer.writeNumber(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeDashOffset(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeLineCapAttribute(value: LineCapStyle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as LineCapStyle)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeLineCap(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeLineJoinAttribute(value: LineJoinStyle | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as LineJoinStyle)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeLineJoin(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeMiterLimitAttribute(value: number | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof number) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as number
                thisSerializer.writeNumber(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeMiterLimit(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeOpacityAttribute(value: number | string | Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof number) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as number
                thisSerializer.writeNumber(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof Resource) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as Resource
                Resource_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeOpacity(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFillOpacityAttribute(value: number | string | Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof number) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as number
                thisSerializer.writeNumber(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof Resource) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as Resource
                Resource_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setFillOpacity(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeWidthAttribute(value: Length | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof number) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as number
                thisSerializer.writeNumber(valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof Resource) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as Resource
                Resource_serializer.write(thisSerializer, valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeWidth(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setAntiAliasAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setAntiAlias(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setStrokeDashArrayAttribute(value: Array<Length> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeInt32((valueTmpValue.length).toInt())
            for (let valueTmpValueCounterI = 0; valueTmpValueCounterI < valueTmpValue.length; valueTmpValueCounterI++) {
                const valueTmpValueTmpElement : Length = valueTmpValue[valueTmpValueCounterI]
                if (valueTmpValueTmpElement instanceof string) {
                    thisSerializer.writeInt8((0).toByte())
                    const valueTmpValueTmpElementForIdx0  = valueTmpValueTmpElement as string
                    thisSerializer.writeString(valueTmpValueTmpElementForIdx0)
                } else if (valueTmpValueTmpElement instanceof number) {
                    thisSerializer.writeInt8((1).toByte())
                    const valueTmpValueTmpElementForIdx1  = valueTmpValueTmpElement as number
                    thisSerializer.writeNumber(valueTmpValueTmpElementForIdx1)
                } else if (valueTmpValueTmpElement instanceof Resource) {
                    thisSerializer.writeInt8((2).toByte())
                    const valueTmpValueTmpElementForIdx2  = valueTmpValueTmpElement as Resource
                    Resource_serializer.write(thisSerializer, valueTmpValueTmpElementForIdx2)
                }
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._CommonShapeMethod_setStrokeDashArray(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export class ArkScrollableCommonMethodPeer extends ArkCommonMethodPeer {
    attributeSet?: ScrollableCommonMethodModifier;
    public constructor(peerPtr: KPointer, id: int32, name: string = "", flags: int32 = 0) {
        super(peerPtr, id, name, flags)
    }
    public static create(component?: ComponentBase, flags: int32 = 0): ArkScrollableCommonMethodPeer {
        const peerId  = PeerNode.nextId()
        const _peerPtr  = ArkUIGeneratedNativeModule._ScrollableCommonMethod_construct(peerId, flags)
        const _peer  = new ArkScrollableCommonMethodPeer(_peerPtr, peerId, 'ScrollableCommonMethod', flags)
        component?.setPeer(_peer)
        return _peer
    }
    setScrollBarAttribute(value: BarState | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as BarState)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setScrollBar(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setScrollBarColorAttribute(value: Color | int32 | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof Color) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as Color
                thisSerializer.writeInt32(valueTmpValueForIdx0.getOrdinal())
            } else if (valueTmpValue instanceof int32) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as int32
                thisSerializer.writeInt32(valueTmpValueForIdx1)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((2).toByte())
                const valueTmpValueForIdx2  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx2)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setScrollBarColor(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setScrollBarWidthAttribute(value: double | string | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof double) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as double
                thisSerializer.writeFloat64(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof string) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as string
                thisSerializer.writeString(valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setScrollBarWidth(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setNestedScrollAttribute(value: NestedScrollOptions | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            NestedScrollOptions_serializer.write(thisSerializer, valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setNestedScroll(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setEnableScrollInteractionAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setEnableScrollInteraction(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFrictionAttribute(value: double | Resource | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof double) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as double
                thisSerializer.writeFloat64(valueTmpValueForIdx0)
            } else if (valueTmpValue instanceof Resource) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as Resource
                Resource_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setFriction(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnReachStartAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setOnReachStart(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnReachEndAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setOnReachEnd(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnScrollStartAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setOnScrollStart(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setOnScrollStopAttribute(value: (() => void) | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.holdAndWriteCallback(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setOnScrollStop(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFlingSpeedLimitAttribute(value: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeFloat64(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setFlingSpeedLimit(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setClipContentAttribute(value: ContentClipMode | RectShape | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            if (valueTmpValue instanceof ContentClipMode) {
                thisSerializer.writeInt8((0).toByte())
                const valueTmpValueForIdx0  = valueTmpValue as ContentClipMode
                thisSerializer.writeInt32(valueTmpValueForIdx0.valueOf())
            } else if (valueTmpValue instanceof RectShape) {
                thisSerializer.writeInt8((1).toByte())
                const valueTmpValueForIdx1  = valueTmpValue as RectShape
                RectShape_serializer.write(thisSerializer, valueTmpValueForIdx1)
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setClipContent(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setDigitalCrownSensitivityAttribute(value: CrownSensitivity | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = (value as CrownSensitivity)
            thisSerializer.writeInt32(valueTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setDigitalCrownSensitivity(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setBackToTopAttribute(value: boolean | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (value !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const valueTmpValue  = value!
            thisSerializer.writeBoolean(valueTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setBackToTop(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setEdgeEffectAttribute(edgeEffect: EdgeEffect | undefined, options?: EdgeEffectOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (edgeEffect !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const edgeEffectTmpValue  = (edgeEffect as EdgeEffect)
            thisSerializer.writeInt32(edgeEffectTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            EdgeEffectOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setEdgeEffect(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    setFadingEdgeAttribute(enabled: boolean | undefined, options?: FadingEdgeOptions): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (enabled !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const enabledTmpValue  = enabled!
            thisSerializer.writeBoolean(enabledTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        if (options !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const optionsTmpValue  = options!
            FadingEdgeOptions_serializer.write(thisSerializer, optionsTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ScrollableCommonMethod_setFadingEdge(this.peer.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface InputCounterOptions {
    thresholdPercentage?: double;
    highlightBorder?: boolean;
}
export interface TextDecorationOptions {
    type: TextDecorationType | undefined;
    color?: ResourceColor;
    style?: TextDecorationStyle;
}
export interface DividerStyle {
    strokeWidth: Length | undefined;
    color?: ResourceColor;
    startMargin?: Length;
    endMargin?: Length;
}
export type ReuseIdCallback = () => string;
export interface ReuseOptions {
    reuseId?: ReuseIdCallback;
}
export { Context } from "application.Context"
export interface Configuration {
    readonly colorMode: string;
    readonly fontScale: double;
}
export interface Rectangle {
    x?: Length;
    y?: Length;
    width?: Length;
    height?: Length;
}
export interface ExpectedFrameRateRange {
    min: int32;
    max: int32;
    expected: int32;
}
export enum AccessibilitySamePageMode {
    SEMI_SILENT = 0,
    FULL_SILENT = 1
}
export enum AccessibilityRoleType {
    ACTION_SHEET = 0,
    ALERT_DIALOG = 1,
    INDEXER_COMPONENT = 2,
    BADGE_COMPONENT = 3,
    BLANK = 4,
    BUTTON = 5,
    BACK_BUTTON = 6,
    SHEET_DRAG_BAR = 7,
    CALENDAR_PICKER = 8,
    CALENDAR = 9,
    CANVAS = 10,
    CANVAS_GRADIENT = 11,
    CANVAS_PATTERN = 12,
    CHECKBOX = 13,
    CHECKBOX_GROUP = 14,
    CIRCLE = 15,
    COLUMN_SPLIT = 16,
    COLUMN = 17,
    CANVAS_RENDERING_CONTEXT_2D = 18,
    CHART = 19,
    COUNTER = 20,
    CONTAINER_MODAL = 21,
    DATA_PANEL = 22,
    DATE_PICKER = 23,
    DIALOG = 24,
    DIVIDER = 25,
    DRAG_BAR = 26,
    EFFECT_COMPONENT = 27,
    ELLIPSE = 28,
    FLEX = 29,
    FLOW_ITEM = 30,
    FORM_COMPONENT = 31,
    FORM_LINK = 32,
    GAUGE = 33,
    GRID = 34,
    GRID_COL = 35,
    GRID_CONTAINER = 36,
    GRID_ITEM = 37,
    GRID_ROW = 38,
    HYPERLINK = 39,
    IMAGE = 40,
    IMAGE_ANIMATOR = 41,
    IMAGE_BITMAP = 42,
    IMAGE_DATA = 43,
    IMAGE_SPAN = 44,
    LABEL = 45,
    LINE = 46,
    LIST = 47,
    LIST_ITEM = 48,
    LIST_ITEM_GROUP = 49,
    LOADING_PROGRESS = 50,
    MARQUEE = 51,
    MATRIX2D = 52,
    MENU = 53,
    MENU_ITEM = 54,
    MENU_ITEM_GROUP = 55,
    NAV_DESTINATION = 56,
    NAV_ROUTER = 57,
    NAVIGATION = 58,
    NAVIGATION_BAR = 59,
    NAVIGATION_MENU = 60,
    NAVIGATOR = 61,
    OFFSCREEN_CANVAS = 62,
    OFFSCREEN_CANVAS_RENDERING_CONTEXT2D = 63,
    OPTION = 64,
    PANEL = 65,
    PAPER_PAGE = 66,
    PATH = 67,
    PATH2D = 68,
    PATTERN_LOCK = 69,
    PICKER = 70,
    PICKER_VIEW = 71,
    PLUGIN_COMPONENT = 72,
    POLYGON = 73,
    POLYLINE = 74,
    POPUP = 75,
    PROGRESS = 76,
    QRCODE = 77,
    RADIO = 78,
    RATING = 79,
    RECT = 80,
    REFRESH = 81,
    RELATIVE_CONTAINER = 82,
    REMOTE_WINDOW = 83,
    RICH_EDITOR = 84,
    RICH_TEXT = 85,
    ROLE_PAGER = 86,
    ROW = 87,
    ROW_SPLIT = 88,
    SCROLL = 89,
    SCROLL_BAR = 90,
    SEARCH = 91,
    SEARCH_FIELD = 92,
    SELECT = 93,
    SHAPE = 94,
    SIDEBAR_CONTAINER = 95,
    SLIDER = 96,
    SPAN = 97,
    STACK = 98,
    STEPPER = 99,
    STEPPER_ITEM = 100,
    SWIPER = 101,
    SWIPER_INDICATOR = 102,
    SWITCH = 103,
    SYMBOL_GLYPH = 104,
    TAB_CONTENT = 105,
    TAB_BAR = 106,
    TABS = 107,
    TEXT = 108,
    TEXT_CLOCK = 109,
    TEXT_ENTRY = 110,
    TEXT_INPUT = 111,
    TEXT_PICKER = 112,
    TEXT_TIMER = 113,
    TEXT_AREA = 114,
    TEXT_FIELD = 115,
    TIME_PICKER = 116,
    TITLE_BAR = 117,
    TOGGLER = 118,
    UI_EXTENSION_COMPONENT = 119,
    VIDEO = 120,
    WATER_FLOW = 121,
    WEB = 122,
    XCOMPONENT = 123,
    ROLE_NONE = 124
}
export type AccessibilityFocusCallback = (isFocus: boolean) => void;
export enum AccessibilityAction {
    UNDEFINED_ACTION = 0,
    ACCESSIBILITY_CLICK = 1
}
export enum AccessibilityActionInterceptResult {
    ACTION_INTERCEPT = 0,
    ACTION_CONTINUE = 1,
    ACTION_RISE = 2
}
export type AccessibilityActionInterceptCallback = (action: AccessibilityAction) => AccessibilityActionInterceptResult;
export enum FinishCallbackType {
    REMOVED = 0,
    LOGICALLY = 1
}
export enum TouchTestStrategy {
    DEFAULT = 0,
    FORWARD_COMPETITION = 1,
    FORWARD = 2
}
export interface AnimateParam {
    duration?: int32;
    tempo?: double;
    curve?: curves.Curve | string | curves.ICurve;
    delay?: int32;
    iterations?: int32;
    playMode?: PlayMode;
    onFinish?: (() => void);
    finishCallbackType?: FinishCallbackType;
    expectedFrameRateRange?: ExpectedFrameRateRange;
}
export type ICurve = curves.ICurve;
export type Matrix4Transit = matrix4.Matrix4Transit;
export interface MotionPathOptions {
    path: string;
    from?: double;
    to?: double;
    rotatable?: boolean;
}
export interface sharedTransitionOptions {
    duration?: int32;
    curve?: curves.Curve | string | curves.ICurve;
    delay?: int32;
    motionPath?: MotionPathOptions;
    zIndex?: int32;
    type?: SharedTransitionEffectType;
}
export interface GeometryTransitionOptions {
    follow?: boolean;
    hierarchyStrategy?: TransitionHierarchyStrategy;
}
export interface LinearGradientOptions {
    angle?: double | string;
    direction?: GradientDirection;
    colors: Array<[ ResourceColor, double ]>;
    repeating?: boolean;
}
export enum TransitionHierarchyStrategy {
    NONE = 0,
    ADAPTIVE = 1
}
export interface SweepGradientOptions {
    center: [ Length, Length ];
    start?: double | string;
    end?: double | string;
    rotation?: double | string;
    colors: Array<[ ResourceColor, double ]>;
    repeating?: boolean;
}
export interface RadialGradientOptions {
    center: [ Length, Length ];
    radius: Length;
    colors: Array<[ ResourceColor, double ]>;
    repeating?: boolean;
}
export interface TranslateOptions {
    x?: double | string;
    y?: double | string;
    z?: double | string;
}
export interface ScaleOptions {
    x?: double;
    y?: double;
    z?: double;
    centerX?: double | string;
    centerY?: double | string;
}
export interface VerticalAlignParam {
    anchor: string;
    align: VerticalAlign;
}
export interface HorizontalAlignParam {
    anchor: string;
    align: HorizontalAlign;
}
export interface AlignRuleOption {
    left?: HorizontalAlignParam;
    right?: HorizontalAlignParam;
    middle?: HorizontalAlignParam;
    top?: VerticalAlignParam;
    bottom?: VerticalAlignParam;
    center?: VerticalAlignParam;
    bias?: Bias;
}
export interface LocalizedHorizontalAlignParam {
    anchor: string;
    align: HorizontalAlign;
}
export interface LocalizedVerticalAlignParam {
    anchor: string;
    align: VerticalAlign;
}
export interface LocalizedAlignRuleOptions {
    start?: LocalizedHorizontalAlignParam;
    end?: LocalizedHorizontalAlignParam;
    middle?: LocalizedHorizontalAlignParam;
    top?: LocalizedVerticalAlignParam;
    bottom?: LocalizedVerticalAlignParam;
    center?: LocalizedVerticalAlignParam;
    bias?: Bias;
}
export enum ChainStyle {
    SPREAD = 0,
    SPREAD_INSIDE = 1,
    PACKED = 2
}
export interface RotateOptions {
    x?: double;
    y?: double;
    z?: double;
    centerX?: double | string;
    centerY?: double | string;
    centerZ?: double;
    perspective?: double;
    angle: double | string;
}
export interface RotateAngleOptions {
    angleX?: number | string;
    angleY?: number | string;
    angleZ?: number | string;
    centerX?: number | string;
    centerY?: number | string;
    centerZ?: number;
    perspective?: number;
}
export enum TransitionEdge {
    TOP = 0,
    BOTTOM = 1,
    START = 2,
    END = 3
}
export interface AsymmetricTransitionOption {
    appear: TransitionEffect;
    disappear: TransitionEffect;
}
export interface ItemDragInfo {
    x: double;
    y: double;
}
export enum EffectType {
    DEFAULT = 0,
    WINDOW_EFFECT = 1
}
export enum PreDragStatus {
    ACTION_DETECTING_STATUS = 0,
    READY_TO_TRIGGER_DRAG_ACTION = 1,
    PREVIEW_LIFT_STARTED = 2,
    PREVIEW_LIFT_FINISHED = 3,
    PREVIEW_LANDING_STARTED = 4,
    PREVIEW_LANDING_FINISHED = 5,
    ACTION_CANCELED_BEFORE_DRAG = 6,
    PREPARING_FOR_DRAG_DETECTION = 7
}
export interface DragItemInfo {
    pixelMap?: image.PixelMap;
    builder?: CustomBuilder;
    extraInfo?: string;
}
export type PointerStyle = pointer.PointerStyle;
export interface EventTarget {
    area: Area;
    id?: string;
}
export enum SourceType {
    UNKNOWN = 0,
    Unknown = 0,
    MOUSE = 1,
    Mouse = 1,
    TOUCH_SCREEN = 2,
    TouchScreen = 2,
    KEY = 4,
    JOYSTICK = 5
}
export enum SourceTool {
    UNKNOWN = 0,
    Unknown = 0,
    FINGER = 1,
    Finger = 1,
    PEN = 2,
    Pen = 2,
    MOUSE = 7,
    TOUCHPAD = 9,
    JOYSTICK = 10
}
export enum RepeatMode {
    REPEAT = 0,
    Repeat = 0,
    STRETCH = 1,
    Stretch = 1,
    ROUND = 2,
    Round = 2,
    SPACE = 3,
    Space = 3
}
export enum BlurStyle {
    THIN = 0,
    Thin = 0,
    REGULAR = 1,
    Regular = 1,
    THICK = 2,
    Thick = 2,
    BACKGROUND_THIN = 3,
    BACKGROUND_REGULAR = 4,
    BACKGROUND_THICK = 5,
    BACKGROUND_ULTRA_THICK = 6,
    NONE = 7,
    COMPONENT_ULTRA_THIN = 8,
    COMPONENT_THIN = 9,
    COMPONENT_REGULAR = 10,
    COMPONENT_THICK = 11,
    COMPONENT_ULTRA_THICK = 12
}
export enum BlurStyleActivePolicy {
    FOLLOWS_WINDOW_ACTIVE_STATE = 0,
    ALWAYS_ACTIVE = 1,
    ALWAYS_INACTIVE = 2
}
export enum ThemeColorMode {
    SYSTEM = 0,
    LIGHT = 1,
    DARK = 2
}
export enum AdaptiveColor {
    DEFAULT = 0,
    AVERAGE = 1
}
export enum ModalTransition {
    DEFAULT = 0,
    NONE = 1,
    ALPHA = 2
}
export interface BackgroundBlurStyleOptions extends BlurStyleOptions {
    policy?: BlurStyleActivePolicy;
    inactiveColor?: ResourceColor;
}
export interface ForegroundBlurStyleOptions extends BlurStyleOptions {
}
export interface BlurOptions {
    grayscale: [ double, double ];
}
export interface SystemAdaptiveOptions {
    disableSystemAdaptation?: boolean;
}
export interface BlurStyleOptions {
    colorMode?: ThemeColorMode;
    adaptiveColor?: AdaptiveColor;
    scale?: double;
    blurOptions?: BlurOptions;
}
export interface BackgroundEffectOptions {
    radius: double;
    saturation?: double;
    brightness?: double;
    color?: ResourceColor;
    adaptiveColor?: AdaptiveColor;
    blurOptions?: BlurOptions;
    policy?: BlurStyleActivePolicy;
    inactiveColor?: ResourceColor;
}
export interface ForegroundEffectOptions {
    radius: double;
}
export interface PickerTextStyle {
    color?: ResourceColor;
    font?: Font;
}
export interface PickerDialogButtonStyle {
    type?: ButtonType;
    style?: ButtonStyleMode;
    role?: ButtonRole;
    fontSize?: Length;
    fontColor?: ResourceColor;
    fontWeight?: FontWeight | int32 | string;
    fontStyle?: FontStyle;
    fontFamily?: Resource | string;
    backgroundColor?: ResourceColor;
    borderRadius?: Length | BorderRadiuses;
    primary?: boolean;
}
export enum ShadowType {
    COLOR = 0,
    BLUR = 1
}
export interface ShadowOptions {
    radius: double | Resource;
    type?: ShadowType;
    color?: Color | string | Resource | ColoringStrategy;
    offsetX?: double | Resource;
    offsetY?: double | Resource;
    fill?: boolean;
}
export enum ShadowStyle {
    OUTER_DEFAULT_XS = 0,
    OUTER_DEFAULT_SM = 1,
    OUTER_DEFAULT_MD = 2,
    OUTER_DEFAULT_LG = 3,
    OUTER_FLOATING_SM = 4,
    OUTER_FLOATING_MD = 5
}
export interface MultiShadowOptions {
    radius?: double | Resource;
    offsetX?: double | Resource;
    offsetY?: double | Resource;
}
export enum SafeAreaType {
    SYSTEM = 0,
    CUTOUT = 1,
    KEYBOARD = 2
}
export enum SafeAreaEdge {
    TOP = 0,
    BOTTOM = 1,
    START = 2,
    END = 3
}
export enum LayoutSafeAreaType {
    SYSTEM = 0
}
export enum LayoutSafeAreaEdge {
    TOP = 0,
    BOTTOM = 1,
    START = 2,
    END = 3,
    VERTICAL = 4,
    HORIZONTAL = 5,
    ALL = 6
}
export enum SheetSize {
    MEDIUM = 0,
    LARGE = 1,
    FIT_CONTENT = 2
}
export type ModifierKeyStateGetter = (keys: Array<string>) => boolean;
export interface BorderImageOption {
    slice?: Length | EdgeWidths | LocalizedEdgeWidths;
    repeat?: RepeatMode;
    source?: string | Resource | LinearGradientOptions;
    width?: Length | EdgeWidths | LocalizedEdgeWidths;
    outset?: Length | EdgeWidths | LocalizedEdgeWidths;
    fill?: boolean;
}
export interface TouchObject {
    type: TouchType;
    id: int32;
    displayX: double;
    displayY: double;
    windowX: double;
    windowY: double;
    x: double;
    y: double;
    hand?: InteractionHand;
    pressedTime?: int64;
    pressure?: double;
    width?: double;
    height?: double;
}
export interface HistoricalPoint {
    touchObject: TouchObject;
    size: int32;
    force: double;
    timestamp: int64;
}
export type SizeChangeCallback = (oldValue: SizeOptions, newValue: SizeOptions) => void;
export type GestureRecognizerJudgeBeginCallback = (event: BaseGestureEvent, current: GestureRecognizer, recognizers: Array<GestureRecognizer>) => GestureJudgeResult;
export type ShouldBuiltInRecognizerParallelWithCallback = (current: GestureRecognizer, others: Array<GestureRecognizer>) => GestureRecognizer;
export type TransitionFinishCallback = (transitionIn: boolean) => void;
export type PixelMap = image.PixelMap;
export enum DragBehavior {
    COPY = 0,
    MOVE = 1
}
export type UnifiedData = unifiedDataChannel.UnifiedData;
export type Summary = unifiedDataChannel.Summary;
export type UniformDataType = uniformTypeDescriptor.UniformDataType;
export type DataSyncOptions = unifiedDataChannel.GetDataParams;
export enum DragResult {
    UNKNOWN = -1,
    DRAG_SUCCESSFUL = 0,
    DRAG_FAILED = 1,
    DRAG_CANCELED = 2,
    DROP_ENABLED = 3,
    DROP_DISABLED = 4
}
export enum BlendMode {
    NONE = 0,
    CLEAR = 1,
    SRC = 2,
    DST = 3,
    SRC_OVER = 4,
    DST_OVER = 5,
    SRC_IN = 6,
    DST_IN = 7,
    SRC_OUT = 8,
    DST_OUT = 9,
    SRC_ATOP = 10,
    DST_ATOP = 11,
    XOR = 12,
    PLUS = 13,
    MODULATE = 14,
    SCREEN = 15,
    OVERLAY = 16,
    DARKEN = 17,
    LIGHTEN = 18,
    COLOR_DODGE = 19,
    COLOR_BURN = 20,
    HARD_LIGHT = 21,
    SOFT_LIGHT = 22,
    DIFFERENCE = 23,
    EXCLUSION = 24,
    MULTIPLY = 25,
    HUE = 26,
    SATURATION = 27,
    COLOR = 28,
    LUMINOSITY = 29
}
export enum BlendApplyType {
    FAST = 0,
    OFFSCREEN = 1,
    OFFSCREEN_WITH_BACKGROUND = 2
}
export type OnDragEventCallback = (event: DragEvent, extraParams?: string) => void;
export interface DropOptions {
    disableDataPrefetch?: boolean;
}
export interface CrownEvent {
    timestamp: int64;
    angularVelocity: double;
    degree: double;
    action: CrownAction;
    stopPropagation: (() => void);
}
export interface BindOptions {
    backgroundColor?: ResourceColor;
    onAppear?: (() => void);
    onDisappear?: (() => void);
    onWillAppear?: (() => void);
    onWillDisappear?: (() => void);
}
export interface DismissContentCoverAction {
    dismiss: VoidCallback;
    reason: DismissReason;
}
export interface ContentCoverOptions extends BindOptions {
    modalTransition?: ModalTransition;
    onWillDismiss?: ((value0: DismissContentCoverAction) => void);
    transition?: TransitionEffect;
    enableSafeArea?: boolean;
}
export interface SheetTitleOptions {
    title: ResourceStr;
    subtitle?: ResourceStr;
}
export enum SheetType {
    BOTTOM = 0,
    CENTER = 1,
    POPUP = 2,
    SIDE = 3,
    CONTENT_COVER = 4
}
export enum SheetMode {
    OVERLAY = 0,
    EMBEDDED = 1
}
export enum ScrollSizeMode {
    FOLLOW_DETENT = 0,
    CONTINUOUS = 1
}
export enum SheetKeyboardAvoidMode {
    NONE = 0,
    TRANSLATE_AND_RESIZE = 1,
    RESIZE_ONLY = 2,
    TRANSLATE_AND_SCROLL = 3,
    POPUP_SHEET = 4
}
export interface SheetDismiss {
    dismiss: VoidCallback;
}
export interface DismissSheetAction {
    dismiss: VoidCallback;
    reason: DismissReason;
}
export interface SpringBackAction {
    springBack(): void
}
export class SpringBackActionInternal implements MaterializedBase,SpringBackAction {
    peer?: Finalizable | undefined = undefined
    public getPeer(): Finalizable | undefined {
        return this.peer
    }
    constructor(peerPtr: KPointer) {
        this.peer = new Finalizable(peerPtr, SpringBackActionInternal.getFinalizer())
    }
    constructor() {
        this(SpringBackActionInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._SpringBackAction_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._SpringBackAction_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): SpringBackActionInternal {
        return new SpringBackActionInternal(ptr)
    }
    public springBack(): void {
        this.springBack_serialize()
        return
    }
    springBack_serialize(): void {
        ArkUIGeneratedNativeModule._SpringBackAction_springBack(this.peer!.ptr)
    }
}
export type SingleLengthDetent = [
    SheetSize | Length
]
export type DoubleLengthDetents = [
    (SheetSize | Length),
    SheetSize | Length | undefined
]
export type TripleLengthDetents = [
    (SheetSize | Length),
    SheetSize | Length | undefined,
    SheetSize | Length | undefined
]
export interface SheetOptions extends BindOptions {
    height?: SheetSize | Length;
    dragBar?: boolean;
    enableFloatingDragBar?: boolean;
    modalTransition?: ModalTransition;
    maskColor?: ResourceColor;
    detents?: SingleLengthDetent | DoubleLengthDetents | TripleLengthDetents;
    blurStyle?: BlurStyle;
    showClose?: boolean | Resource;
    preferType?: SheetType;
    title?: SheetTitleOptions | CustomBuilder;
    shouldDismiss?: ((sheetDismiss: SheetDismiss) => void);
    onWillDismiss?: ((value0: DismissSheetAction) => void);
    onWillSpringBackWhenDismiss?: ((value0: SpringBackAction) => void);
    enableOutsideInteractive?: boolean;
    width?: Dimension;
    borderWidth?: Dimension | EdgeWidths | LocalizedEdgeWidths;
    borderColor?: ResourceColor | EdgeColors | LocalizedEdgeColors;
    borderStyle?: BorderStyle | EdgeStyles;
    shadow?: ShadowOptions | ShadowStyle;
    onHeightDidChange?: ((value0: int32) => void);
    mode?: SheetMode;
    scrollSizeMode?: ScrollSizeMode;
    onDetentsDidChange?: ((value0: int32) => void);
    onWidthDidChange?: ((value0: int32) => void);
    onTypeDidChange?: ((value0: SheetType) => void);
    uiContext?: UIContext;
    keyboardAvoidMode?: SheetKeyboardAvoidMode;
    enableHoverMode?: boolean;
    hoverModeArea?: HoverModeAreaType;
    offset?: Position;
    effectEdge?: int32;
    radius?: LengthMetrics | BorderRadiuses | LocalizedBorderRadiuses;
    detentSelection?: SheetSize | Length;
    showInSubWindow?: boolean;
    placement?: Placement;
    placementOnTarget?: boolean;
}
export interface StateStyles {
    normal?: CustomStyles;
    pressed?: CustomStyles;
    disabled?: CustomStyles;
    focused?: CustomStyles;
    clicked?: CustomStyles;
    selected?: CustomStyles;
}
export interface PopupMessageOptions {
    textColor?: ResourceColor;
    font?: Font;
}
export enum DismissReason {
    PRESS_BACK = 0,
    TOUCH_OUTSIDE = 1,
    CLOSE_BUTTON = 2,
    SLIDE_DOWN = 3,
    SLIDE = 4
}
export interface PopupStateChangeParam {
    isVisible: boolean;
}
export type PopupStateChangeCallback = (event: PopupStateChangeParam) => void;
export interface PopupMaskType {
    color: ResourceColor;
}
export interface PopupBorderLinearGradient {
    direction?: GradientDirection;
    colors: Array<[ ResourceColor, double ]>;
}
export interface PopupCommonOptions {
    placement?: Placement;
    popupColor?: ResourceColor;
    enableArrow?: boolean;
    autoCancel?: boolean;
    onStateChange?: PopupStateChangeCallback;
    arrowOffset?: Length;
    showInSubWindow?: boolean;
    mask?: boolean | PopupMaskType;
    targetSpace?: Length;
    offset?: Position;
    width?: Dimension;
    arrowPointPosition?: ArrowPointPosition;
    arrowWidth?: Dimension;
    arrowHeight?: Dimension;
    radius?: Dimension;
    shadow?: ShadowOptions | ShadowStyle;
    backgroundBlurStyle?: BlurStyle;
    focusable?: boolean;
    transition?: TransitionEffect;
    onWillDismiss?: boolean | ((value0: DismissPopupAction) => void);
    enableHoverMode?: boolean;
    followTransformOfTarget?: boolean;
}
export interface TipsOptions {
    appearingTime?: int32;
    disappearingTime?: int32;
    appearingTimeWithContinuousOperation?: int32;
    disappearingTimeWithContinuousOperation?: int32;
    enableArrow?: boolean;
    arrowPointPosition?: ArrowPointPosition;
    arrowWidth?: Dimension;
    arrowHeight?: Dimension;
}
export interface PopupButton {
    value: string;
    action: VoidCallback;
}
export interface PopupOptions {
    message: string;
    placement?: Placement;
    primaryButton?: PopupButton;
    secondaryButton?: PopupButton;
    onStateChange?: PopupStateChangeCallback;
    arrowOffset?: Length;
    showInSubWindow?: boolean;
    mask?: boolean | PopupMaskType;
    messageOptions?: PopupMessageOptions;
    targetSpace?: Length;
    enableArrow?: boolean;
    offset?: Position;
    popupColor?: Color | string | Resource | int64;
    autoCancel?: boolean;
    width?: Dimension;
    arrowPointPosition?: ArrowPointPosition;
    arrowWidth?: Dimension;
    arrowHeight?: Dimension;
    radius?: Dimension;
    shadow?: ShadowOptions | ShadowStyle;
    backgroundBlurStyle?: BlurStyle;
    transition?: TransitionEffect;
    onWillDismiss?: boolean | ((value0: DismissPopupAction) => void);
    enableHoverMode?: boolean;
    followTransformOfTarget?: boolean;
    keyboardAvoidMode?: KeyboardAvoidMode;
}
export interface CustomPopupOptions {
    builder: CustomBuilder;
    placement?: Placement;
    popupColor?: Color | string | Resource | int64;
    enableArrow?: boolean;
    autoCancel?: boolean;
    onStateChange?: PopupStateChangeCallback;
    arrowOffset?: Length;
    showInSubWindow?: boolean;
    mask?: boolean | PopupMaskType;
    targetSpace?: Length;
    offset?: Position;
    width?: Dimension;
    arrowPointPosition?: ArrowPointPosition;
    arrowWidth?: Dimension;
    arrowHeight?: Dimension;
    radius?: Dimension;
    shadow?: ShadowOptions | ShadowStyle;
    backgroundBlurStyle?: BlurStyle;
    focusable?: boolean;
    transition?: TransitionEffect;
    onWillDismiss?: boolean | ((value0: DismissPopupAction) => void);
    enableHoverMode?: boolean;
    followTransformOfTarget?: boolean;
    keyboardAvoidMode?: KeyboardAvoidMode;
}
export enum MenuPreviewMode {
    NONE = 0,
    IMAGE = 1
}
export type AnimationNumberRange = [
    double,
    double
]
export interface ContextMenuAnimationOptions {
    scale?: AnimationNumberRange;
    transition?: TransitionEffect;
    hoverScale?: AnimationNumberRange;
}
export type BorderRadiusType = Length | BorderRadiuses | LocalizedBorderRadiuses;
export enum HapticFeedbackMode {
    DISABLED = 0,
    ENABLED = 1,
    AUTO = 2
}
export interface ContextMenuOptions {
    offset?: Position;
    placement?: Placement;
    enableArrow?: boolean;
    arrowOffset?: Length;
    preview?: MenuPreviewMode | CustomBuilder;
    previewBorderRadius?: BorderRadiusType;
    borderRadius?: Length | BorderRadiuses | LocalizedBorderRadiuses;
    onAppear?: (() => void);
    onDisappear?: (() => void);
    aboutToAppear?: (() => void);
    aboutToDisappear?: (() => void);
    layoutRegionMargin?: Padding;
    previewAnimationOptions?: ContextMenuAnimationOptions;
    backgroundColor?: ResourceColor;
    backgroundBlurStyle?: BlurStyle;
    backgroundBlurStyleOptions?: BackgroundBlurStyleOptions;
    backgroundEffect?: BackgroundEffectOptions;
    transition?: TransitionEffect;
    enableHoverMode?: boolean;
    outlineColor?: ResourceColor | EdgeColors;
    outlineWidth?: Dimension | EdgeOutlineWidths;
    hapticFeedbackMode?: HapticFeedbackMode;
}
export interface MenuOptions extends ContextMenuOptions {
    title?: ResourceStr;
    showInSubWindow?: boolean;
}
export interface PixelStretchEffectOptions {
    top?: Length;
    bottom?: Length;
    left?: Length;
    right?: Length;
}
export interface ClickEffect {
    level: ClickEffectLevel;
    scale?: double;
}
export interface FadingEdgeOptions {
    fadingEdgeLength?: LengthMetrics;
}
export interface NestedScrollOptions {
    scrollForward: NestedScrollMode;
    scrollBackward: NestedScrollMode;
}
export interface MenuElement {
    value: ResourceStr;
    icon?: ResourceStr;
    symbolIcon?: SymbolGlyphModifier;
    enabled?: boolean;
    action: (() => void);
}
export interface CommonConfiguration<T = void> {
    enabled: boolean;
    contentModifier: ContentModifier<T>;
}
export enum OutlineStyle {
    SOLID = 0,
    DASHED = 1,
    DOTTED = 2
}
export enum DragPreviewMode {
    AUTO = 1,
    DISABLE_SCALE = 2,
    ENABLE_DEFAULT_SHADOW = 3,
    ENABLE_DEFAULT_RADIUS = 4,
    ENABLE_DRAG_ITEM_GRAY_EFFECT = 5,
    ENABLE_MULTI_TILE_EFFECT = 6,
    ENABLE_TOUCH_POINT_CALCULATION_BASED_ON_FINAL_PREVIEW = 7
}
export enum DraggingSizeChangeEffect {
    DEFAULT = 0,
    SIZE_TRANSITION = 1,
    SIZE_CONTENT_TRANSITION = 2
}
export enum MenuPolicy {
    DEFAULT = 0,
    HIDE = 1,
    SHOW = 2
}
export interface DragPreviewOptions {
    mode?: DragPreviewMode | Array<DragPreviewMode>;
    modifier?: ImageModifier;
    numberBadge?: boolean | int64;
    sizeChangeEffect?: DraggingSizeChangeEffect;
}
export interface DragInteractionOptions {
    isMultiSelectionEnabled?: boolean;
    defaultAnimationBeforeLifting?: boolean;
    enableEdgeAutoScroll?: boolean;
    enableHapticFeedback?: boolean;
    isLiftingDisabled?: boolean;
}
export interface PreviewConfiguration {
    onlyForLifting?: boolean;
    delayCreating?: boolean;
}
export interface InvertOptions {
    low: double;
    high: double;
    threshold: double;
    thresholdRange: double;
}
export type TipsMessageType = ResourceStr | StyledString;
export interface BackgroundImageOptions {
    syncLoad?: boolean;
    repeat?: ImageRepeat;
}
export interface BackgroundOptions {
    align?: Alignment;
}
export interface ResponseRegion {
    tool?: ResponseRegionSupportedTool;
    x?: LengthMetrics;
    y?: LengthMetrics;
    width?: LengthMetrics | string;
    height?: LengthMetrics | string;
}
// instructive change start
export type CustomProperty = undefined | null | Object | Record<string, CustomProperty> | Array<CustomProperty>;
// instructive change end
export interface CommonMethod {
    width(value: Length | LayoutPolicy | undefined): this {
        throw new Error("Unimplemented method width")
    }
    height(value: Length | LayoutPolicy | undefined): this {
        throw new Error("Unimplemented method height")
    }
    drawModifier(value: DrawModifier | undefined): this {
        throw new Error("Unimplemented method drawModifier")
    }
    responseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        throw new Error("Unimplemented method responseRegion")
    }
    mouseResponseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        throw new Error("Unimplemented method mouseResponseRegion")
    }
    responseRegionList(value: Array<ResponseRegion> | undefined): this {
        throw new Error("Unimplemented method responseRegionList")
    }
    size(value: SizeOptions | undefined): this {
        throw new Error("Unimplemented method size")
    }
    constraintSize(value: ConstraintSizeOptions | undefined): this {
        throw new Error("Unimplemented method constraintSize")
    }
    hitTestBehavior(value: HitTestMode | undefined): this {
        throw new Error("Unimplemented method hitTestBehavior")
    }
    onChildTouchTest(value: ((value: Array<TouchTestInfo>) => TouchResult) | undefined): this {
        throw new Error("Unimplemented method onChildTouchTest")
    }
    layoutWeight(value: number | string | undefined): this {
        throw new Error("Unimplemented method layoutWeight")
    }
    chainWeight(value: ChainWeightOptions | undefined): this {
        throw new Error("Unimplemented method chainWeight")
    }
    padding(value: Padding | Length | LocalizedPadding | undefined): this {
        throw new Error("Unimplemented method padding")
    }
    safeAreaPadding(value: Padding | LengthMetrics | LocalizedPadding | undefined): this {
        throw new Error("Unimplemented method safeAreaPadding")
    }
    margin(value: Padding | Length | LocalizedPadding | undefined): this {
        throw new Error("Unimplemented method margin")
    }
    backgroundColor(value: ResourceColor | ColorMetrics | undefined): this {
        throw new Error("Unimplemented method backgroundColor")
    }
    pixelRound(value: PixelRoundPolicy | undefined): this {
        throw new Error("Unimplemented method pixelRound")
    }
    backgroundImageSize(value: SizeOptions | ImageSize | undefined): this {
        throw new Error("Unimplemented method backgroundImageSize")
    }
    backgroundImagePosition(value: Position | Alignment | undefined): this {
        throw new Error("Unimplemented method backgroundImagePosition")
    }
    backgroundEffect(value: BackgroundEffectOptions | undefined): this {
        throw new Error("Unimplemented method backgroundEffect")
    }
    backgroundImageResizable(value: ResizableOptions | undefined): this {
        throw new Error("Unimplemented method backgroundImageResizable")
    }
    foregroundEffect(value: ForegroundEffectOptions | undefined): this {
        throw new Error("Unimplemented method foregroundEffect")
    }
    visualEffect(value: uiEffect.VisualEffect | undefined): this {
        throw new Error("Unimplemented method visualEffect")
    }
    backgroundFilter(value: uiEffect.Filter | undefined): this {
        throw new Error("Unimplemented method backgroundFilter")
    }
    foregroundFilter(value: uiEffect.Filter | undefined): this {
        throw new Error("Unimplemented method foregroundFilter")
    }
    compositingFilter(value: uiEffect.Filter | undefined): this {
        throw new Error("Unimplemented method compositingFilter")
    }
    opacity(value: double | Resource | undefined): this {
        throw new Error("Unimplemented method opacity")
    }
    border(value: BorderOptions | undefined): this {
        throw new Error("Unimplemented method border")
    }
    borderStyle(value: BorderStyle | EdgeStyles | undefined): this {
        throw new Error("Unimplemented method borderStyle")
    }
    borderWidth(value: Length | EdgeWidths | LocalizedEdgeWidths | undefined): this {
        throw new Error("Unimplemented method borderWidth")
    }
    borderColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        throw new Error("Unimplemented method borderColor")
    }
    borderRadius(value: Length | BorderRadiuses | LocalizedBorderRadiuses | undefined): this {
        throw new Error("Unimplemented method borderRadius")
    }
    borderImage(value: BorderImageOption | undefined): this {
        throw new Error("Unimplemented method borderImage")
    }
    outline(value: OutlineOptions | undefined): this {
        throw new Error("Unimplemented method outline")
    }
    outlineStyle(value: OutlineStyle | EdgeOutlineStyles | undefined): this {
        throw new Error("Unimplemented method outlineStyle")
    }
    outlineWidth(value: Dimension | EdgeOutlineWidths | undefined): this {
        throw new Error("Unimplemented method outlineWidth")
    }
    outlineColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        throw new Error("Unimplemented method outlineColor")
    }
    outlineRadius(value: Dimension | OutlineRadiuses | undefined): this {
        throw new Error("Unimplemented method outlineRadius")
    }
    foregroundColor(value: ResourceColor | ColoringStrategy | undefined): this {
        throw new Error("Unimplemented method foregroundColor")
    }
    onClick(value: ((event: ClickEvent) => void) | undefined): this {
        throw new Error("Unimplemented method onClick")
    }
    onHover(value: ((isHover: boolean,event: HoverEvent) => void) | undefined): this {
        throw new Error("Unimplemented method onHover")
    }
    onHoverMove(value: ((value0: HoverEvent) => void) | undefined): this {
        throw new Error("Unimplemented method onHoverMove")
    }
    onAccessibilityHover(value: AccessibilityCallback | undefined): this {
        throw new Error("Unimplemented method onAccessibilityHover")
    }
    onAccessibilityHoverTransparent(value: AccessibilityTransparentCallback | undefined): this {
        throw new Error("Unimplemented method onAccessibilityHoverTransparent")
    }
    hoverEffect(value: HoverEffect | undefined): this {
        throw new Error("Unimplemented method hoverEffect")
    }
    onMouse(value: ((event: MouseEvent) => void) | undefined): this {
        throw new Error("Unimplemented method onMouse")
    }
    onTouch(value: ((event: TouchEvent) => void) | undefined): this {
        throw new Error("Unimplemented method onTouch")
    }
    onKeyEvent(value: ((event: KeyEvent) => boolean) | undefined): this {
        throw new Error("Unimplemented method onKeyEvent")
    }
    onDigitalCrown(value: ((value0: CrownEvent) => void) | undefined): this {
        throw new Error("Unimplemented method onDigitalCrown")
    }
    onKeyPreIme(value: ((value0: KeyEvent) => boolean) | undefined): this {
        throw new Error("Unimplemented method onKeyPreIme")
    }
    onKeyEventDispatch(value: ((value0: KeyEvent) => boolean) | undefined): this {
        throw new Error("Unimplemented method onKeyEventDispatch")
    }
    onFocusAxisEvent(value: ((value0: FocusAxisEvent) => void) | undefined): this {
        throw new Error("Unimplemented method onFocusAxisEvent")
    }
    onAxisEvent(value: ((value0: AxisEvent) => void) | undefined): this {
        throw new Error("Unimplemented method onAxisEvent")
    }
    focusable(value: boolean | undefined): this {
        throw new Error("Unimplemented method focusable")
    }
    nextFocus(value: FocusMovement | undefined): this {
        throw new Error("Unimplemented method nextFocus")
    }
    tabStop(value: boolean | undefined): this {
        throw new Error("Unimplemented method tabStop")
    }
    onFocus(value: (() => void) | undefined): this {
        throw new Error("Unimplemented method onFocus")
    }
    onBlur(value: (() => void) | undefined): this {
        throw new Error("Unimplemented method onBlur")
    }
    tabIndex(value: int32 | undefined): this {
        throw new Error("Unimplemented method tabIndex")
    }
    defaultFocus(value: boolean | undefined): this {
        throw new Error("Unimplemented method defaultFocus")
    }
    groupDefaultFocus(value: boolean | undefined): this {
        throw new Error("Unimplemented method groupDefaultFocus")
    }
    focusOnTouch(value: boolean | undefined): this {
        throw new Error("Unimplemented method focusOnTouch")
    }
    focusBox(value: FocusBoxStyle | undefined): this {
        throw new Error("Unimplemented method focusBox")
    }

    // instructive change start
    animationStart(value: AnimateParam | undefined): this {
        throw new Error("Unimplemented method animationStart")
    }
    animationStop(value: AnimateParam | undefined): this {
        throw new Error("Unimplemented method animationStop")
    }
    __createOrSetAnimatableProperty<T>(functionName: string, value: number | AnimatableArithmetic<T>,
        callback: (value: number | AnimatableArithmetic<T>) => void): void {
        throw new Error("Unimplemented method __createOrSetAnimatableProperty")
    }
    // instructive change end

    transition(value: TransitionEffect | undefined): this {
        throw new Error("Unimplemented method transition")
    }
    motionBlur(value: MotionBlurOptions | undefined): this {
        throw new Error("Unimplemented method motionBlur")
    }
    brightness(value: double | undefined): this {
        throw new Error("Unimplemented method brightness")
    }
    contrast(value: double | undefined): this {
        throw new Error("Unimplemented method contrast")
    }
    grayscale(value: double | undefined): this {
        throw new Error("Unimplemented method grayscale")
    }
    colorBlend(value: Color | string | Resource | undefined): this {
        throw new Error("Unimplemented method colorBlend")
    }
    saturate(value: double | undefined): this {
        throw new Error("Unimplemented method saturate")
    }
    sepia(value: double | undefined): this {
        throw new Error("Unimplemented method sepia")
    }
    invert(value: double | InvertOptions | undefined): this {
        throw new Error("Unimplemented method invert")
    }
    hueRotate(value: double | string | undefined): this {
        throw new Error("Unimplemented method hueRotate")
    }
    useShadowBatching(value: boolean | undefined): this {
        throw new Error("Unimplemented method useShadowBatching")
    }
    useEffect(value: boolean | undefined): this {
        throw new Error("Unimplemented method useEffect")
    }
    renderGroup(value: boolean | undefined): this {
        throw new Error("Unimplemented method renderGroup")
    }
    freeze(value: boolean | undefined): this {
        throw new Error("Unimplemented method freeze")
    }
    translate(value: TranslateOptions | undefined): this {
        throw new Error("Unimplemented method translate")
    }
    scale(value: ScaleOptions | undefined): this {
        throw new Error("Unimplemented method scale")
    }
    rotate(value: RotateOptions | RotateAngleOptions | undefined): this {
        throw new Error("Unimplemented method rotate")
    }
    transform(value: matrix4.Matrix4Transit | undefined): this {
        throw new Error("Unimplemented method transform")
    }
    transform3D(value: matrix4.Matrix4Transit | undefined): this {
        throw new Error("Unimplemented method transform3D")
    }
    onAppear(value: (() => void) | undefined): this {
        throw new Error("Unimplemented method onAppear")
    }
    onDisAppear(value: (() => void) | undefined): this {
        throw new Error("Unimplemented method onDisAppear")
    }
    onAttach(value: VoidCallback | undefined): this {
        throw new Error("Unimplemented method onAttach")
    }
    onDetach(value: VoidCallback | undefined): this {
        throw new Error("Unimplemented method onDetach")
    }
    onAreaChange(value: ((oldValue: Area,newValue: Area) => void) | undefined): this {
        throw new Error("Unimplemented method onAreaChange")
    }
    visibility(value: Visibility | undefined): this {
        throw new Error("Unimplemented method visibility")
    }
    flexGrow(value: number | undefined): this {
        throw new Error("Unimplemented method flexGrow")
    }
    flexShrink(value: number | undefined): this {
        throw new Error("Unimplemented method flexShrink")
    }
    flexBasis(value: number | string | undefined): this {
        throw new Error("Unimplemented method flexBasis")
    }
    alignSelf(value: ItemAlign | undefined): this {
        throw new Error("Unimplemented method alignSelf")
    }
    displayPriority(value: number | undefined): this {
        throw new Error("Unimplemented method displayPriority")
    }
    zIndex(value: int32 | undefined): this {
        throw new Error("Unimplemented method zIndex")
    }
    direction(value: Direction | undefined): this {
        throw new Error("Unimplemented method direction")
    }
    align(value: Alignment | undefined): this {
        throw new Error("Unimplemented method align")
    }
    position(value: Position | Edges | LocalizedEdges | undefined): this {
        throw new Error("Unimplemented method position")
    }
    markAnchor(value: Position | LocalizedPosition | undefined): this {
        throw new Error("Unimplemented method markAnchor")
    }
    offset(value: Position | Edges | LocalizedEdges | undefined): this {
        throw new Error("Unimplemented method offset")
    }
    enabled(value: boolean | undefined): this {
        throw new Error("Unimplemented method enabled")
    }
    alignRules(value: AlignRuleOption | LocalizedAlignRuleOptions | undefined): this {
        throw new Error("Unimplemented method alignRules")
    }
    aspectRatio(value: number | undefined): this {
        throw new Error("Unimplemented method aspectRatio")
    }
    clickEffect(value: ClickEffect | null | undefined): this {
        throw new Error("Unimplemented method clickEffect")
    }
    onDragStart(value: ((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined): this {
        throw new Error("Unimplemented method onDragStart")
    }
    onDragEnter(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        throw new Error("Unimplemented method onDragEnter")
    }
    onDragMove(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        throw new Error("Unimplemented method onDragMove")
    }
    onDragLeave(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        throw new Error("Unimplemented method onDragLeave")
    }
    onDrop(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        throw new Error("Unimplemented method onDrop")
    }
    onDragEnd(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        throw new Error("Unimplemented method onDragEnd")
    }
    allowDrop(value: Array<uniformTypeDescriptor.UniformDataType> | null | Array<string> | undefined): this {
        throw new Error("Unimplemented method allowDrop")
    }
    draggable(value: boolean | undefined): this {
        throw new Error("Unimplemented method draggable")
    }
    dragPreview(value: CustomBuilder | DragItemInfo | string | undefined): this {
        throw new Error("Unimplemented method dragPreview")
    }
    onPreDrag(value: ((value0: PreDragStatus) => void) | undefined): this {
        throw new Error("Unimplemented method onPreDrag")
    }
    linearGradient(value: LinearGradientOptions | undefined): this {
        throw new Error("Unimplemented method linearGradient")
    }
    sweepGradient(value: SweepGradientOptions | undefined): this {
        throw new Error("Unimplemented method sweepGradient")
    }
    radialGradient(value: RadialGradientOptions | undefined): this {
        throw new Error("Unimplemented method radialGradient")
    }
    motionPath(value: MotionPathOptions | undefined): this {
        throw new Error("Unimplemented method motionPath")
    }
    shadow(value: ShadowOptions | ShadowStyle | undefined): this {
        throw new Error("Unimplemented method shadow")
    }
    clip(value: boolean | undefined): this {
        throw new Error("Unimplemented method clip")
    }
    clipShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        throw new Error("Unimplemented method clipShape")
    }
    mask(value: ProgressMask | undefined): this {
        throw new Error("Unimplemented method mask")
    }
    maskShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        throw new Error("Unimplemented method maskShape")
    }
    key(value: string | undefined): this {
        throw new Error("Unimplemented method key")
    }
    id(value: string | undefined): this {
        throw new Error("Unimplemented method id")
    }
    geometryTransition(value: string | undefined): this {
        throw new Error("Unimplemented method geometryTransition")
    }
    stateStyles(value: StateStyles | undefined): this {
        throw new Error("Unimplemented method stateStyles")
    }
    restoreId(value: int32 | undefined): this {
        throw new Error("Unimplemented method restoreId")
    }
    sphericalEffect(value: double | undefined): this {
        throw new Error("Unimplemented method sphericalEffect")
    }
    lightUpEffect(value: double | undefined): this {
        throw new Error("Unimplemented method lightUpEffect")
    }
    pixelStretchEffect(value: PixelStretchEffectOptions | undefined): this {
        throw new Error("Unimplemented method pixelStretchEffect")
    }
    accessibilityGroupWithValue(value: boolean | undefined): this {
        throw new Error("Unimplemented method accessibilityGroup")
    }
    accessibilityTextOfStringType(value: string | undefined): this {
        throw new Error("Unimplemented method accessibilityText")
    }
    accessibilityNextFocusId(value: string | undefined): this {
        throw new Error("Unimplemented method accessibilityNextFocusId")
    }
    accessibilityDefaultFocus(value: boolean | undefined): this {
        throw new Error("Unimplemented method accessibilityDefaultFocus")
    }
    accessibilityUseSamePage(value: AccessibilitySamePageMode | undefined): this {
        throw new Error("Unimplemented method accessibilityUseSamePage")
    }
    accessibilityScrollTriggerable(value: boolean | undefined): this {
        throw new Error("Unimplemented method accessibilityScrollTriggerable")
    }
    accessibilityTextOfResourceType(value: Resource | undefined): this {
        throw new Error("Unimplemented method accessibilityText")
    }
    accessibilityRole(value: AccessibilityRoleType | undefined): this {
        throw new Error("Unimplemented method accessibilityRole")
    }
    onAccessibilityFocus(value: AccessibilityFocusCallback | undefined): this {
        throw new Error("Unimplemented method onAccessibilityFocus")
    }
    onAccessibilityActionIntercept(value: AccessibilityActionInterceptCallback | undefined): this {
        throw new Error("Unimplemented method onAccessibilityActionIntercept")
    }
    accessibilityTextHint(value: string | undefined): this {
        throw new Error("Unimplemented method accessibilityTextHint")
    }
    accessibilityDescriptionOfStringType(value: string | undefined): this {
        throw new Error("Unimplemented method accessibilityDescription")
    }
    accessibilityDescriptionOfResourceType(value: Resource | undefined): this {
        throw new Error("Unimplemented method accessibilityDescription")
    }
    accessibilityLevel(value: string | undefined): this {
        throw new Error("Unimplemented method accessibilityLevel")
    }
    accessibilityVirtualNode(value: CustomBuilder | undefined): this {
        throw new Error("Unimplemented method accessibilityVirtualNode")
    }
    accessibilityChecked(value: boolean | undefined): this {
        throw new Error("Unimplemented method accessibilityChecked")
    }
    accessibilitySelected(value: boolean | undefined): this {
        throw new Error("Unimplemented method accessibilitySelected")
    }
    obscured(value: Array<ObscuredReasons> | undefined): this {
        throw new Error("Unimplemented method obscured")
    }
    reuseId(value: string | undefined): this {
        throw new Error("Unimplemented method reuseId")
    }
    reuse(value: ReuseOptions | undefined): this {
        throw new Error("Unimplemented method reuse")
    }
    renderFit(value: RenderFit | undefined): this {
        throw new Error("Unimplemented method renderFit")
    }
    gestureModifier(value: GestureModifier | undefined): this {
        throw new Error("Unimplemented method gestureModifier")
    }
    backgroundBrightness(value: BackgroundBrightnessOptions | undefined): this {
        throw new Error("Unimplemented method backgroundBrightness")
    }
    onGestureJudgeBegin(value: ((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined): this {
        throw new Error("Unimplemented method onGestureJudgeBegin")
    }
    onGestureRecognizerJudgeBegin(value: GestureRecognizerJudgeBeginCallback | undefined): this {
        throw new Error("Unimplemented method onGestureRecognizerJudgeBegin")
    }
    shouldBuiltInRecognizerParallelWith(value: ShouldBuiltInRecognizerParallelWithCallback | undefined): this {
        throw new Error("Unimplemented method shouldBuiltInRecognizerParallelWith")
    }
    monopolizeEvents(value: boolean | undefined): this {
        throw new Error("Unimplemented method monopolizeEvents")
    }
    onTouchIntercept(value: ((value0: TouchEvent) => HitTestMode) | undefined): this {
        throw new Error("Unimplemented method onTouchIntercept")
    }
    onSizeChange(value: SizeChangeCallback | undefined): this {
        throw new Error("Unimplemented method onSizeChange")
    }
    accessibilityFocusDrawLevel(value: FocusDrawLevel | undefined): this {
        throw new Error("Unimplemented method accessibilityFocusDrawLevel")
    }
    customProperty(name: string, value: CustomProperty): this {
        throw new Error("Unimplemented method customProperty")
    }
    expandSafeArea(types?: Array<SafeAreaType>, edges?: Array<SafeAreaEdge>): this {
        throw new Error("Unimplemented method expandSafeArea")
    }
    ignoreLayoutSafeArea(types?: Array<LayoutSafeAreaType>, edges?: Array<LayoutSafeAreaEdge>): this {
        throw new Error("Unimplemented method ignoreLayoutSafeArea")
    }
    background(builder: CustomBuilder | undefined, options?: BackgroundOptions): this {
        throw new Error("Unimplemented method background")
    }
    backgroundImage(value: ResourceStr | image.PixelMap | undefined): this {
        throw new Error("Unimplemented method backgroundImage")
    }
    backgroundImage(src: ResourceStr | image.PixelMap | undefined, options?: BackgroundImageOptions): this {
        throw new Error("Unimplemented method backgroundImage")
    }
    backgroundImage(src: ResourceStr | image.PixelMap | undefined, repeat?: ImageRepeat): this {
        throw new Error("Unimplemented method backgroundImage")
    }
    backgroundBlurStyle(style: BlurStyle | undefined, options?: BackgroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        throw new Error("Unimplemented method backgroundBlurStyle")
    }
    backgroundEffect(options: BackgroundEffectOptions | undefined, sysOptions?: SystemAdaptiveOptions): this {
        throw new Error("Unimplemented method backgroundEffect")
    }
    foregroundBlurStyle(style: BlurStyle | undefined, options?: ForegroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        throw new Error("Unimplemented method foregroundBlurStyle")
    }
    onClick(event: ((event: ClickEvent) => void) | undefined, distanceThreshold: double | undefined): this {
        throw new Error("Unimplemented method onClick")
    }
    focusScopeId(id: string | undefined, isGroup?: boolean, arrowStepOut?: boolean): this {
        throw new Error("Unimplemented method focusScopeId")
    }
    focusScopePriority(scopeId: string | undefined, priority?: FocusPriority): this {
        throw new Error("Unimplemented method focusScopePriority")
    }
    transition(effect: TransitionEffect | undefined, onFinish: TransitionFinishCallback | undefined): this {
        throw new Error("Unimplemented method transition")
    }
    gesture(gesture: GestureType, mask?: GestureMask): this {
        throw new Error("Unimplemented method gesture")
    }
    priorityGesture(gesture: GestureType, mask?: GestureMask): this {
        throw new Error("Unimplemented method priorityGesture")
    }
    parallelGesture(gesture: GestureType, mask?: GestureMask): this {
        throw new Error("Unimplemented method parallelGesture")
    }
    blur(blurRadius: double | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        throw new Error("Unimplemented method blur")
    }
    linearGradientBlur(value: double | undefined, options: LinearGradientBlurOptions | undefined): this {
        throw new Error("Unimplemented method linearGradientBlur")
    }
    systemBarEffect(): this {
        throw new Error("Unimplemented method systemBarEffect")
    }
    useEffect(useEffect: boolean | undefined, effectType: EffectType | undefined): this {
        throw new Error("Unimplemented method useEffect")
    }
    backdropBlur(radius: double | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        throw new Error("Unimplemented method backdropBlur")
    }
    sharedTransition(id: string | undefined, options?: sharedTransitionOptions): this {
        throw new Error("Unimplemented method sharedTransition")
    }
    chainMode(direction: Axis | undefined, style: ChainStyle | undefined): this {
        throw new Error("Unimplemented method chainMode")
    }
    onDrop(eventCallback: OnDragEventCallback | undefined, dropOptions?: DropOptions): this {
        throw new Error("Unimplemented method onDrop")
    }
    dragPreview(preview: CustomBuilder | DragItemInfo | string | undefined, config?: PreviewConfiguration): this {
        throw new Error("Unimplemented method dragPreview")
    }
    dragPreviewOptions(value: DragPreviewOptions | undefined, options?: DragInteractionOptions): this {
        throw new Error("Unimplemented method dragPreviewOptions")
    }
    overlay(value: string | CustomBuilder | ComponentContent | undefined, options?: OverlayOptions): this {
        throw new Error("Unimplemented method overlay")
    }
    blendMode(value: BlendMode | undefined, type?: BlendApplyType): this {
        throw new Error("Unimplemented method blendMode")
    }
    advancedBlendMode(effect: BlendMode | uiEffect.Blender, type?: BlendApplyType): this {
        throw new Error("Unimplemented method advancedBlendMode")
    }
    geometryTransition(id: string | undefined, options?: GeometryTransitionOptions): this {
        throw new Error("Unimplemented method geometryTransition")
    }
    bindTips(message: TipsMessageType | undefined, options?: TipsOptions): this {
        throw new Error("Unimplemented method bindTips")
    }
    bindPopup(show: boolean | undefined, popup: PopupOptions | CustomPopupOptions | undefined): this {
        throw new Error("Unimplemented method bindPopup")
    }
    bindMenu(content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): this {
        throw new Error("Unimplemented method bindMenu")
    }
    bindMenu(isShow: boolean | undefined, content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): this {
        throw new Error("Unimplemented method bindMenu")
    }
    bindContextMenu(content: CustomBuilder | undefined, responseType: ResponseType | undefined, options?: ContextMenuOptions): this {
        throw new Error("Unimplemented method bindContextMenu")
    }
    bindContextMenu(isShown: boolean | undefined, content: CustomBuilder | undefined, options?: ContextMenuOptions): this {
        throw new Error("Unimplemented method bindContextMenu")
    }
    bindContentCover(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, type?: ModalTransition): this {
        throw new Error("Unimplemented method bindContentCover")
    }
    bindContentCover(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, options?: ContentCoverOptions): this {
        throw new Error("Unimplemented method bindContentCover")
    }
    bindSheet(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, options?: SheetOptions): this {
        throw new Error("Unimplemented method bindSheet")
    }
    onVisibleAreaChange(ratios: Array<double> | undefined, event: VisibleAreaChangeCallback | undefined): this {
        throw new Error("Unimplemented method onVisibleAreaChange")
    }
    onVisibleAreaApproximateChange(options: VisibleAreaEventOptions | undefined, event: VisibleAreaChangeCallback | undefined): this {
        throw new Error("Unimplemented method onVisibleAreaApproximateChange")
    }
    keyboardShortcut(value: string | FunctionKey | undefined, keys: Array<ModifierKey> | undefined, action?: (() => void)): this {
        throw new Error("Unimplemented method keyboardShortcut")
    }
    accessibilityGroupWithConfig(isGroup: boolean | undefined, config: AccessibilityOptions | undefined): this {
        throw new Error("Unimplemented method accessibilityGroup")
    }
    onGestureRecognizerJudgeBegin(callback_: GestureRecognizerJudgeBeginCallback | undefined, exposeInnerGesture: boolean | undefined): this {
        throw new Error("Unimplemented method onGestureRecognizerJudgeBegin")
    }
    accessibilityGroup(isGroup: boolean | undefined, accessibilityOptions?: AccessibilityOptions): this {
        throw new Error("Unimplemented method accessibilityGroup")
    }
    accessibilityText(value: Resource | string | undefined): this {
        throw new Error("Unimplemented method accessibilityText")
    }
    accessibilityDescription(value: Resource | string | undefined): this {
        throw new Error("Unimplemented method accessibilityDescription")
    }
    // instructive change begin
    applyAttributesFinish(): void {}
    // instructive change end
}
export class ArkCommonMethodStyle implements CommonMethod {
    width_value?: Length | LayoutPolicy | undefined
    height_value?: Length | LayoutPolicy | undefined
    drawModifier_value?: DrawModifier | undefined
    responseRegion_value?: Array<Rectangle> | Rectangle | undefined
    mouseResponseRegion_value?: Array<Rectangle> | Rectangle | undefined
    size_value?: SizeOptions | undefined
    constraintSize_value?: ConstraintSizeOptions | undefined
    hitTestBehavior_value?: HitTestMode | undefined
    onChildTouchTest_value?: ((value: Array<TouchTestInfo>) => TouchResult) | undefined
    layoutWeight_value?: number | string | undefined
    chainWeight_value?: ChainWeightOptions | undefined
    padding_value?: Padding | Length | LocalizedPadding | undefined
    safeAreaPadding_value?: Padding | LengthMetrics | LocalizedPadding | undefined
    margin_value?: Padding | Length | LocalizedPadding | undefined
    backgroundColor_value?: ResourceColor | ColorMetrics | undefined
    pixelRound_value?: PixelRoundPolicy | undefined
    backgroundImage_value?: ResourceStr | image.PixelMap | undefined
    backgroundImageSize_value?: SizeOptions | ImageSize | undefined
    backgroundImagePosition_value?: Position | Alignment | undefined
    backgroundEffect_value?: BackgroundEffectOptions | undefined
    backgroundImageResizable_value?: ResizableOptions | undefined
    foregroundEffect_value?: ForegroundEffectOptions | undefined
    visualEffect_value?: uiEffect.VisualEffect | undefined
    backgroundFilter_value?: uiEffect.Filter | undefined
    foregroundFilter_value?: uiEffect.Filter | undefined
    compositingFilter_value?: uiEffect.Filter | undefined
    opacity_value?: double | Resource | undefined
    border_value?: BorderOptions | undefined
    borderStyle_value?: BorderStyle | EdgeStyles | undefined
    borderWidth_value?: Length | EdgeWidths | LocalizedEdgeWidths | undefined
    borderColor_value?: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined
    borderRadius_value?: Length | BorderRadiuses | LocalizedBorderRadiuses | undefined
    borderImage_value?: BorderImageOption | undefined
    outline_value?: OutlineOptions | undefined
    outlineStyle_value?: OutlineStyle | EdgeOutlineStyles | undefined
    outlineWidth_value?: Dimension | EdgeOutlineWidths | undefined
    outlineColor_value?: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined
    outlineRadius_value?: Dimension | OutlineRadiuses | undefined
    foregroundColor_value?: ResourceColor | ColoringStrategy | undefined
    onClick_value?: ((event: ClickEvent) => void) | undefined
    onHover_value?: ((isHover: boolean,event: HoverEvent) => void) | undefined
    onHoverMove_value?: ((value0: HoverEvent) => void) | undefined
    onAccessibilityHover_value?: AccessibilityCallback | undefined
    onAccessibilityHoverTransparent_value?: AccessibilityTransparentCallback | undefined
    hoverEffect_value?: HoverEffect | undefined
    onMouse_value?: ((event: MouseEvent) => void) | undefined
    onTouch_value?: ((event: TouchEvent) => void) | undefined
    onKeyEvent_value?: ((event: KeyEvent) => boolean) | undefined
    onDigitalCrown_value?: ((value0: CrownEvent) => void) | undefined
    onKeyPreIme_value?: ((value0: KeyEvent) => boolean) | undefined
    onKeyEventDispatch_value?: ((value0: KeyEvent) => boolean) | undefined
    onFocusAxisEvent_value?: ((value0: FocusAxisEvent) => void) | undefined
    onAxisEvent_value?: ((value0: AxisEvent) => void) | undefined
    focusable_value?: boolean | undefined
    nextFocus_value?: FocusMovement | undefined
    tabStop_value?: boolean | undefined
    onFocus_value?: (() => void) | undefined
    onBlur_value?: (() => void) | undefined
    tabIndex_value?: int32 | undefined
    defaultFocus_value?: boolean | undefined
    groupDefaultFocus_value?: boolean | undefined
    focusOnTouch_value?: boolean | undefined
    focusBox_value?: FocusBoxStyle | undefined
    animation_value?: AnimateParam | undefined
    transition_value?: TransitionEffect | undefined
    motionBlur_value?: MotionBlurOptions | undefined
    brightness_value?: double | undefined
    contrast_value?: double | undefined
    grayscale_value?: double | undefined
    colorBlend_value?: Color | string | Resource | undefined
    saturate_value?: double | undefined
    sepia_value?: double | undefined
    invert_value?: double | InvertOptions | undefined
    hueRotate_value?: double | string | undefined
    useShadowBatching_value?: boolean | undefined
    useEffect_value?: boolean | undefined
    renderGroup_value?: boolean | undefined
    freeze_value?: boolean | undefined
    translate_value?: TranslateOptions | undefined
    scale_value?: ScaleOptions | undefined
    rotate_value?: RotateOptions | RotateAngleOptions | undefined
    transform_value?: matrix4.Matrix4Transit | undefined
    transform3D_value?: matrix4.Matrix4Transit | undefined
    onAppear_value?: (() => void) | undefined
    onDisAppear_value?: (() => void) | undefined
    onAttach_value?: VoidCallback | undefined
    onDetach_value?: VoidCallback | undefined
    onAreaChange_value?: ((oldValue: Area,newValue: Area) => void) | undefined
    visibility_value?: Visibility | undefined
    flexGrow_value?: number | undefined
    flexShrink_value?: number | undefined
    flexBasis_value?: number | string | undefined
    alignSelf_value?: ItemAlign | undefined
    displayPriority_value?: number | undefined
    zIndex_value?: int32 | undefined
    direction_value?: Direction | undefined
    align_value?: Alignment | undefined
    position_value?: Position | Edges | LocalizedEdges | undefined
    markAnchor_value?: Position | LocalizedPosition | undefined
    offset_value?: Position | Edges | LocalizedEdges | undefined
    enabled_value?: boolean | undefined
    alignRules_value?: AlignRuleOption | LocalizedAlignRuleOptions | undefined
    aspectRatio_value?: number | undefined
    clickEffect_value?: ClickEffect | null | undefined
    onDragStart_value?: ((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined
    onDragEnter_value?: ((event: DragEvent,extraParams?: string) => void) | undefined
    onDragMove_value?: ((event: DragEvent,extraParams?: string) => void) | undefined
    onDragLeave_value?: ((event: DragEvent,extraParams?: string) => void) | undefined
    onDrop_value?: ((event: DragEvent,extraParams?: string) => void) | undefined
    onDragEnd_value?: ((event: DragEvent,extraParams?: string) => void) | undefined
    allowDrop_value?: Array<uniformTypeDescriptor.UniformDataType> | null | Array<string> | undefined
    draggable_value?: boolean | undefined
    dragPreview_value?: CustomBuilder | DragItemInfo | string | undefined
    onPreDrag_value?: ((value0: PreDragStatus) => void) | undefined
    linearGradient_value?: LinearGradientOptions | undefined
    sweepGradient_value?: SweepGradientOptions | undefined
    radialGradient_value?: RadialGradientOptions | undefined
    motionPath_value?: MotionPathOptions | undefined
    shadow_value?: ShadowOptions | ShadowStyle | undefined
    clip_value?: boolean | undefined
    clipShape_value?: CircleShape | EllipseShape | PathShape | RectShape | undefined
    mask_value?: ProgressMask | undefined
    maskShape_value?: CircleShape | EllipseShape | PathShape | RectShape | undefined
    key_value?: string | undefined
    id_value?: string | undefined
    geometryTransition_value?: string | undefined
    stateStyles_value?: StateStyles | undefined
    restoreId_value?: int32 | undefined
    sphericalEffect_value?: double | undefined
    lightUpEffect_value?: double | undefined
    pixelStretchEffect_value?: PixelStretchEffectOptions | undefined
    accessibilityGroup_value?: boolean | undefined
    accessibilityText_value?: string | undefined
    accessibilityNextFocusId_value?: string | undefined
    accessibilityDefaultFocus_value?: boolean | undefined
    accessibilityUseSamePage_value?: AccessibilitySamePageMode | undefined
    accessibilityScrollTriggerable_value?: boolean | undefined
    accessibilityRole_value?: AccessibilityRoleType | undefined
    onAccessibilityFocus_value?: AccessibilityFocusCallback | undefined
    onAccessibilityActionIntercept_value?: AccessibilityActionInterceptCallback | undefined
    accessibilityTextHint_value?: string | undefined
    accessibilityDescription_value?: string | undefined
    accessibilityLevel_value?: string | undefined
    accessibilityVirtualNode_value?: CustomBuilder | undefined
    accessibilityChecked_value?: boolean | undefined
    accessibilitySelected_value?: boolean | undefined
    obscured_value?: Array<ObscuredReasons> | undefined
    reuseId_value?: string | undefined
    reuse_value?: ReuseOptions | undefined
    renderFit_value?: RenderFit | undefined
    gestureModifier_value?: GestureModifier | undefined
    backgroundBrightness_value?: BackgroundBrightnessOptions | undefined
    onGestureJudgeBegin_value?: ((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined
    onGestureRecognizerJudgeBegin_value?: GestureRecognizerJudgeBeginCallback | undefined
    shouldBuiltInRecognizerParallelWith_value?: ShouldBuiltInRecognizerParallelWithCallback | undefined
    monopolizeEvents_value?: boolean | undefined
    onTouchIntercept_value?: ((value0: TouchEvent) => HitTestMode) | undefined
    onSizeChange_value?: SizeChangeCallback | undefined
    accessibilityFocusDrawLevel_value?: FocusDrawLevel | undefined
    width(value: Length | LayoutPolicy | undefined): this {
        return this
    }
    height(value: Length | LayoutPolicy | undefined): this {
        return this
    }
    drawModifier(value: DrawModifier | undefined): this {
        return this
    }
    responseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        return this
    }
    mouseResponseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        return this
    }
    size(value: SizeOptions | undefined): this {
        return this
    }
    constraintSize(value: ConstraintSizeOptions | undefined): this {
        return this
    }
    hitTestBehavior(value: HitTestMode | undefined): this {
        return this
    }
    onChildTouchTest(value: ((value: Array<TouchTestInfo>) => TouchResult) | undefined): this {
        return this
    }
    layoutWeight(value: number | string | undefined): this {
        return this
    }
    chainWeight(value: ChainWeightOptions | undefined): this {
        return this
    }
    padding(value: Padding | Length | LocalizedPadding | undefined): this {
        return this
    }
    safeAreaPadding(value: Padding | LengthMetrics | LocalizedPadding | undefined): this {
        return this
    }
    margin(value: Padding | Length | LocalizedPadding | undefined): this {
        return this
    }
    backgroundColor(value: ResourceColor | ColorMetrics | undefined): this {
        return this
    }
    pixelRound(value: PixelRoundPolicy | undefined): this {
        return this
    }
    backgroundImageSize(value: SizeOptions | ImageSize | undefined): this {
        return this
    }
    backgroundImagePosition(value: Position | Alignment | undefined): this {
        return this
    }
    backgroundEffect(value: BackgroundEffectOptions | undefined): this {
        return this
    }
    backgroundImageResizable(value: ResizableOptions | undefined): this {
        return this
    }
    foregroundEffect(value: ForegroundEffectOptions | undefined): this {
        return this
    }
    visualEffect(value: uiEffect.VisualEffect | undefined): this {
        return this
    }
    backgroundFilter(value: uiEffect.Filter | undefined): this {
        return this
    }
    foregroundFilter(value: uiEffect.Filter | undefined): this {
        return this
    }
    compositingFilter(value: uiEffect.Filter | undefined): this {
        return this
    }
    opacity(value: double | Resource | undefined): this {
        return this
    }
    border(value: BorderOptions | undefined): this {
        return this
    }
    borderStyle(value: BorderStyle | EdgeStyles | undefined): this {
        return this
    }
    borderWidth(value: Length | EdgeWidths | LocalizedEdgeWidths | undefined): this {
        return this
    }
    borderColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        return this
    }
    borderRadius(value: Length | BorderRadiuses | LocalizedBorderRadiuses | undefined): this {
        return this
    }
    borderImage(value: BorderImageOption | undefined): this {
        return this
    }
    outline(value: OutlineOptions | undefined): this {
        return this
    }
    outlineStyle(value: OutlineStyle | EdgeOutlineStyles | undefined): this {
        return this
    }
    outlineWidth(value: Dimension | EdgeOutlineWidths | undefined): this {
        return this
    }
    outlineColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        return this
    }
    outlineRadius(value: Dimension | OutlineRadiuses | undefined): this {
        return this
    }
    foregroundColor(value: ResourceColor | ColoringStrategy | undefined): this {
        return this
    }
    onClick(value: ((event: ClickEvent) => void) | undefined): this {
        return this
    }
    onHover(value: ((isHover: boolean,event: HoverEvent) => void) | undefined): this {
        return this
    }
    onHoverMove(value: ((value0: HoverEvent) => void) | undefined): this {
        return this
    }
    onAccessibilityHover(value: AccessibilityCallback | undefined): this {
        return this
    }
    onAccessibilityHoverTransparent(value: AccessibilityTransparentCallback | undefined): this {
        return this
    }
    hoverEffect(value: HoverEffect | undefined): this {
        return this
    }
    onMouse(value: ((event: MouseEvent) => void) | undefined): this {
        return this
    }
    onTouch(value: ((event: TouchEvent) => void) | undefined): this {
        return this
    }
    onKeyEvent(value: ((event: KeyEvent) => boolean) | undefined): this {
        return this
    }
    onDigitalCrown(value: ((value0: CrownEvent) => void) | undefined): this {
        return this
    }
    onKeyPreIme(value: ((value0: KeyEvent) => boolean) | undefined): this {
        return this
    }
    onKeyEventDispatch(value: ((value0: KeyEvent) => boolean) | undefined): this {
        return this
    }
    onFocusAxisEvent(value: ((value0: FocusAxisEvent) => void) | undefined): this {
        return this
    }
    onAxisEvent(value: ((value0: AxisEvent) => void) | undefined): this {
        return this
    }
    focusable(value: boolean | undefined): this {
        return this
    }
    nextFocus(value: FocusMovement | undefined): this {
        return this
    }
    tabStop(value: boolean | undefined): this {
        return this
    }
    onFocus(value: (() => void) | undefined): this {
        return this
    }
    onBlur(value: (() => void) | undefined): this {
        return this
    }
    tabIndex(value: int32 | undefined): this {
        return this
    }
    defaultFocus(value: boolean | undefined): this {
        return this
    }
    groupDefaultFocus(value: boolean | undefined): this {
        return this
    }
    focusOnTouch(value: boolean | undefined): this {
        return this
    }
    focusBox(value: FocusBoxStyle | undefined): this {
        return this
    }

    // instructive change start
    public animationStart(value: AnimateParam | undefined): this {
        return this
    }
    public animationStop(value: AnimateParam | undefined): this {
        return this
    }
    public __createOrSetAnimatableProperty<T>(functionName: string, value: number | AnimatableArithmetic<T>,
        callback: (value: number | AnimatableArithmetic<T>) => void): void {}
    // instructive change end

    transition(value: TransitionEffect | undefined): this {
        return this
    }
    motionBlur(value: MotionBlurOptions | undefined): this {
        return this
    }
    brightness(value: double | undefined): this {
        return this
    }
    contrast(value: double | undefined): this {
        return this
    }
    grayscale(value: double | undefined): this {
        return this
    }
    colorBlend(value: Color | string | Resource | undefined): this {
        return this
    }
    saturate(value: double | undefined): this {
        return this
    }
    sepia(value: double | undefined): this {
        return this
    }
    invert(value: double | InvertOptions | undefined): this {
        return this
    }
    hueRotate(value: double | string | undefined): this {
        return this
    }
    useShadowBatching(value: boolean | undefined): this {
        return this
    }
    useEffect(value: boolean | undefined): this {
        return this
    }
    renderGroup(value: boolean | undefined): this {
        return this
    }
    freeze(value: boolean | undefined): this {
        return this
    }
    translate(value: TranslateOptions | undefined): this {
        return this
    }
    scale(value: ScaleOptions | undefined): this {
        return this
    }
    rotate(value: RotateOptions | RotateAngleOptions | undefined): this {
        return this
    }
    transform(value: matrix4.Matrix4Transit | undefined): this {
        return this
    }
    transform3D(value: matrix4.Matrix4Transit | undefined): this {
        return this
    }
    onAppear(value: (() => void) | undefined): this {
        return this
    }
    onDisAppear(value: (() => void) | undefined): this {
        return this
    }
    onAttach(value: VoidCallback | undefined): this {
        return this
    }
    onDetach(value: VoidCallback | undefined): this {
        return this
    }
    onAreaChange(value: ((oldValue: Area,newValue: Area) => void) | undefined): this {
        return this
    }
    visibility(value: Visibility | undefined): this {
        return this
    }
    flexGrow(value: number | undefined): this {
        return this
    }
    flexShrink(value: number | undefined): this {
        return this
    }
    flexBasis(value: number | string | undefined): this {
        return this
    }
    alignSelf(value: ItemAlign | undefined): this {
        return this
    }
    displayPriority(value: number | undefined): this {
        return this
    }
    zIndex(value: int32 | undefined): this {
        return this
    }
    direction(value: Direction | undefined): this {
        return this
    }
    align(value: Alignment | undefined): this {
        return this
    }
    position(value: Position | Edges | LocalizedEdges | undefined): this {
        return this
    }
    markAnchor(value: Position | LocalizedPosition | undefined): this {
        return this
    }
    offset(value: Position | Edges | LocalizedEdges | undefined): this {
        return this
    }
    enabled(value: boolean | undefined): this {
        return this
    }
    alignRules(value: AlignRuleOption | LocalizedAlignRuleOptions | undefined): this {
        return this
    }
    aspectRatio(value: number | undefined): this {
        return this
    }
    clickEffect(value: ClickEffect | null | undefined): this {
        return this
    }
    onDragStart(value: ((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined): this {
        return this
    }
    onDragEnter(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        return this
    }
    onDragMove(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        return this
    }
    onDragLeave(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        return this
    }
    onDrop(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        return this
    }
    onDragEnd(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        return this
    }
    allowDrop(value: Array<uniformTypeDescriptor.UniformDataType> | null | Array<string> | undefined): this {
        return this
    }
    draggable(value: boolean | undefined): this {
        return this
    }
    dragPreview(value: CustomBuilder | DragItemInfo | string | undefined): this {
        return this
    }
    onPreDrag(value: ((value0: PreDragStatus) => void) | undefined): this {
        return this
    }
    linearGradient(value: LinearGradientOptions | undefined): this {
        return this
    }
    sweepGradient(value: SweepGradientOptions | undefined): this {
        return this
    }
    radialGradient(value: RadialGradientOptions | undefined): this {
        return this
    }
    motionPath(value: MotionPathOptions | undefined): this {
        return this
    }
    shadow(value: ShadowOptions | ShadowStyle | undefined): this {
        return this
    }
    clip(value: boolean | undefined): this {
        return this
    }
    clipShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        return this
    }
    mask(value: ProgressMask | undefined): this {
        return this
    }
    maskShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        return this
    }
    key(value: string | undefined): this {
        return this
    }
    id(value: string | undefined): this {
        return this
    }
    geometryTransition(value: string | undefined): this {
        return this
    }
    stateStyles(value: StateStyles | undefined): this {
        return this
    }
    restoreId(value: int32 | undefined): this {
        return this
    }
    sphericalEffect(value: double | undefined): this {
        return this
    }
    lightUpEffect(value: double | undefined): this {
        return this
    }
    pixelStretchEffect(value: PixelStretchEffectOptions | undefined): this {
        return this
    }
    accessibilityGroup(value: boolean | undefined): this {
        return this
    }
    accessibilityText(value: string | undefined): this {
        return this
    }
    accessibilityNextFocusId(value: string | undefined): this {
        return this
    }
    accessibilityDefaultFocus(value: boolean | undefined): this {
        return this
    }
    accessibilityUseSamePage(value: AccessibilitySamePageMode | undefined): this {
        return this
    }
    accessibilityScrollTriggerable(value: boolean | undefined): this {
        return this
    }
    accessibilityText(value: Resource | undefined): this {
        return this
    }
    accessibilityRole(value: AccessibilityRoleType | undefined): this {
        return this
    }
    onAccessibilityFocus(value: AccessibilityFocusCallback | undefined): this {
        return this
    }
    onAccessibilityActionIntercept(value: AccessibilityActionInterceptCallback | undefined): this {
        return this
    }
    accessibilityTextHint(value: string | undefined): this {
        return this
    }
    accessibilityDescription(value: string | undefined): this {
        return this
    }
    accessibilityDescription(value: Resource | undefined): this {
        return this
    }
    accessibilityLevel(value: string | undefined): this {
        return this
    }
    accessibilityVirtualNode(value: CustomBuilder | undefined): this {
        return this
    }
    accessibilityChecked(value: boolean | undefined): this {
        return this
    }
    accessibilitySelected(value: boolean | undefined): this {
        return this
    }
    obscured(value: Array<ObscuredReasons> | undefined): this {
        return this
    }
    reuseId(value: string | undefined): this {
        return this
    }
    reuse(value: ReuseOptions | undefined): this {
        return this
    }
    renderFit(value: RenderFit | undefined): this {
        return this
    }
    gestureModifier(value: GestureModifier | undefined): this {
        return this
    }
    backgroundBrightness(value: BackgroundBrightnessOptions | undefined): this {
        return this
    }
    onGestureJudgeBegin(value: ((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined): this {
        return this
    }
    onGestureRecognizerJudgeBegin(value: GestureRecognizerJudgeBeginCallback | undefined): this {
        return this
    }
    shouldBuiltInRecognizerParallelWith(value: ShouldBuiltInRecognizerParallelWithCallback | undefined): this {
        return this
    }
    monopolizeEvents(value: boolean | undefined): this {
        return this
    }
    onTouchIntercept(value: ((value0: TouchEvent) => HitTestMode) | undefined): this {
        return this
    }
    onSizeChange(value: SizeChangeCallback | undefined): this {
        return this
    }
    accessibilityFocusDrawLevel(value: FocusDrawLevel | undefined): this {
        return this
    }
    customProperty(name: string, value: CustomProperty): this {
        return this
    }
    expandSafeArea(types?: Array<SafeAreaType>, edges?: Array<SafeAreaEdge>): this {
        return this
    }
    ignoreLayoutSafeArea(types?: Array<LayoutSafeAreaType>, edges?: Array<LayoutSafeAreaEdge>): this {
        return this
    }
    background(builder: CustomBuilder | undefined, options?: BackgroundOptions): this {
        return this
    }
    backgroundImage(value: ResourceStr | image.PixelMap | undefined): this {
        return this
    }
    backgroundImage(src: ResourceStr | image.PixelMap | undefined, options: BackgroundImageOptions): this {
        return this
    }
    backgroundImage(src: ResourceStr | image.PixelMap | undefined, repeat: ImageRepeat): this {
        return this
    }
    backgroundBlurStyle(style: BlurStyle | undefined, options?: BackgroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        return this
    }
    backgroundEffect(options: BackgroundEffectOptions | undefined, sysOptions?: SystemAdaptiveOptions): this {
        return this
    }
    foregroundBlurStyle(style: BlurStyle | undefined, options?: ForegroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        return this
    }
    onClick(event: ((event: ClickEvent) => void) | undefined, distanceThreshold: double | undefined): this {
        return this
    }
    focusScopeId(id: string | undefined, isGroup?: boolean, arrowStepOut?: boolean): this {
        return this
    }
    focusScopePriority(scopeId: string | undefined, priority?: FocusPriority): this {
        return this
    }
    transition(effect: TransitionEffect | undefined, onFinish: TransitionFinishCallback | undefined): this {
        return this
    }
    gesture(gesture: GestureType, mask?: GestureMask): this {
        return this
    }
    priorityGesture(gesture: GestureType, mask?: GestureMask): this {
        return this
    }
    parallelGesture(gesture: GestureType, mask?: GestureMask): this {
        return this
    }
    blur(blurRadius: double | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        return this
    }
    linearGradientBlur(value: double | undefined, options: LinearGradientBlurOptions | undefined): this {
        return this
    }
    systemBarEffect(): this {
        return this
    }
    useEffect(useEffect: boolean | undefined, effectType: EffectType | undefined): this {
        return this
    }
    backdropBlur(radius: double | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        return this
    }
    sharedTransition(id: string | undefined, options?: sharedTransitionOptions): this {
        return this
    }
    chainMode(direction: Axis | undefined, style: ChainStyle | undefined): this {
        return this
    }
    onDrop(eventCallback: OnDragEventCallback | undefined, dropOptions?: DropOptions): this {
        return this
    }
    dragPreview(preview: CustomBuilder | DragItemInfo | string | undefined, config?: PreviewConfiguration): this {
        return this
    }
    dragPreviewOptions(value: DragPreviewOptions | undefined, options?: DragInteractionOptions): this {
        return this
    }
    overlay(value: string | CustomBuilder | ComponentContent | undefined, options?: OverlayOptions): this {
        return this
    }
    blendMode(value: BlendMode | undefined, type?: BlendApplyType): this {
        return this
    }
    advancedBlendMode(effect: BlendMode | uiEffect.Blender, type?: BlendApplyType): this {
        return this
    }
    geometryTransition(id: string | undefined, options?: GeometryTransitionOptions): this {
        return this
    }
    bindTips(message: TipsMessageType | undefined, options?: TipsOptions): this {
        return this
    }
    bindPopup(show: boolean | undefined, popup: PopupOptions | CustomPopupOptions | undefined): this {
        return this
    }
    bindMenu(content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): this {
        return this
    }
    bindMenu(isShow: boolean | undefined, content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): this {
        return this
    }
    bindContextMenu(content: CustomBuilder | undefined, responseType: ResponseType | undefined, options?: ContextMenuOptions): this {
        return this
    }
    bindContextMenu(isShown: boolean | undefined, content: CustomBuilder | undefined, options?: ContextMenuOptions): this {
        return this
    }
    bindContentCover(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, type?: ModalTransition): this {
        return this
    }
    bindContentCover(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, options?: ContentCoverOptions): this {
        return this
    }
    bindSheet(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, options?: SheetOptions): this {
        return this
    }
    onVisibleAreaChange(ratios: Array<double> | undefined, event: VisibleAreaChangeCallback | undefined): this {
        return this
    }
    onVisibleAreaApproximateChange(options: VisibleAreaEventOptions | undefined, event: VisibleAreaChangeCallback | undefined): this {
        return this
    }
    keyboardShortcut(value: string | FunctionKey | undefined, keys: Array<ModifierKey> | undefined, action?: (() => void)): this {
        return this
    }
    accessibilityGroup(isGroup: boolean | undefined, config: AccessibilityOptions | undefined): this {
        return this
    }
    onGestureRecognizerJudgeBegin(callback_: GestureRecognizerJudgeBeginCallback | undefined, exposeInnerGesture: boolean | undefined): this {
        return this
    }
    public attributeModifier(value: AttributeModifier<CommonMethod> | undefined): this {
        throw new Error("Not implemented")
    }
}
export type CommonAttribute = CommonMethod;
export interface OverlayOptions {
    align?: Alignment;
    offset?: OverlayOffset;
}
export interface OverlayOffset {
    x?: double;
    y?: double;
}
export type FractionStop = [
    double,
    double
]
export interface CommonShapeMethod extends CommonMethod {
    stroke(value: ResourceColor | undefined): this {
        throw new Error("Unimplemented method stroke")
    }
    fill(value: ResourceColor | undefined): this {
        throw new Error("Unimplemented method fill")
    }
    strokeDashOffset(value: number | string | undefined): this {
        throw new Error("Unimplemented method strokeDashOffset")
    }
    strokeLineCap(value: LineCapStyle | undefined): this {
        throw new Error("Unimplemented method strokeLineCap")
    }
    strokeLineJoin(value: LineJoinStyle | undefined): this {
        throw new Error("Unimplemented method strokeLineJoin")
    }
    strokeMiterLimit(value: number | string | undefined): this {
        throw new Error("Unimplemented method strokeMiterLimit")
    }
    strokeOpacity(value: number | string | Resource | undefined): this {
        throw new Error("Unimplemented method strokeOpacity")
    }
    fillOpacity(value: number | string | Resource | undefined): this {
        throw new Error("Unimplemented method fillOpacity")
    }
    strokeWidth(value: Length | undefined): this {
        throw new Error("Unimplemented method strokeWidth")
    }
    antiAlias(value: boolean | undefined): this {
        throw new Error("Unimplemented method antiAlias")
    }
    strokeDashArray(value: Array<Length> | undefined): this {
        throw new Error("Unimplemented method strokeDashArray")
    }
    attributeModifier(value: AttributeModifier<CommonShapeMethod> | AttributeModifier<CommonMethod> | undefined): this {
        throw new Error("Unimplemented method attributeModifier")
    }
}
export class ArkCommonShapeMethodStyle extends ArkCommonMethodStyle implements CommonShapeMethod {
    stroke_value?: ResourceColor | undefined
    fill_value?: ResourceColor | undefined
    strokeDashOffset_value?: number | string | undefined
    strokeLineCap_value?: LineCapStyle | undefined
    strokeLineJoin_value?: LineJoinStyle | undefined
    strokeMiterLimit_value?: number | string | undefined
    strokeOpacity_value?: number | string | Resource | undefined
    fillOpacity_value?: number | string | Resource | undefined
    strokeWidth_value?: Length | undefined
    antiAlias_value?: boolean | undefined
    strokeDashArray_value?: Array<Length> | undefined
    stroke(value: ResourceColor | undefined): this {
        return this
    }
    fill(value: ResourceColor | undefined): this {
        return this
    }
    strokeDashOffset(value: number | string | undefined): this {
        return this
    }
    strokeLineCap(value: LineCapStyle | undefined): this {
        return this
    }
    strokeLineJoin(value: LineJoinStyle | undefined): this {
        return this
    }
    strokeMiterLimit(value: number | string | undefined): this {
        return this
    }
    strokeOpacity(value: number | string | Resource | undefined): this {
        return this
    }
    fillOpacity(value: number | string | Resource | undefined): this {
        return this
    }
    strokeWidth(value: Length | undefined): this {
        return this
    }
    antiAlias(value: boolean | undefined): this {
        return this
    }
    strokeDashArray(value: Array<Length> | undefined): this {
        return this
    }
    public attributeModifier(value: AttributeModifier<CommonShapeMethod> | AttributeModifier<CommonMethod> | undefined): this {
        throw new Error("Not implemented")
    }
}
export interface PixelRoundPolicy {
    start?: PixelRoundCalcPolicy;
    top?: PixelRoundCalcPolicy;
    end?: PixelRoundCalcPolicy;
    bottom?: PixelRoundCalcPolicy;
}
export interface LinearGradientBlurOptions {
    fractionStops: Array<FractionStop>;
    direction: GradientDirection;
}
export interface MotionBlurAnchor {
    x: double;
    y: double;
}
export interface MotionBlurOptions {
    radius: double;
    anchor: MotionBlurAnchor;
}
export interface GeometryInfo extends SizeResult {
    borderWidth: EdgeWidths;
    margin: Padding;
    padding: Padding;
}
export interface SizeResult {
    width: number;
    height: number;
}
export interface MeasureResult extends SizeResult {
}
export type NavDestinationInfo = uiObserver.NavDestinationInfo;
export type NavigationInfo = uiObserver.NavigationInfo;
export type RouterPageInfo = uiObserver.RouterPageInfo;
export { UIContext } from "@ohos.arkui.UIContext"
export { DrawContext } from "arkui.Graphics"
export type VisualEffect = uiEffect.VisualEffect;
export type Filter = uiEffect.Filter;
export type Blender = uiEffect.Blender;
export type PromptActionDialogController = promptAction.DialogController;
export interface RectResult {
    x: double;
    y: double;
    width: double;
    height: double;
}
export interface CaretOffset {
    index: int32;
    x: int32;
    y: int32;
}
export interface TextContentControllerOptions {
    offset?: int32;
}
export enum ContentClipMode {
    CONTENT_ONLY = 0,
    BOUNDARY = 1,
    SAFE_AREA = 2
}
export interface ScrollableCommonMethod extends CommonMethod {
    scrollBar(value: BarState | undefined): this {
        throw new Error("Unimplemented method scrollBar")
    }
    scrollBarColor(value: Color | int32 | string | undefined): this {
        throw new Error("Unimplemented method scrollBarColor")
    }
    scrollBarWidth(value: double | string | undefined): this {
        throw new Error("Unimplemented method scrollBarWidth")
    }
    nestedScroll(value: NestedScrollOptions | undefined): this {
        throw new Error("Unimplemented method nestedScroll")
    }
    enableScrollInteraction(value: boolean | undefined): this {
        throw new Error("Unimplemented method enableScrollInteraction")
    }
    friction(value: double | Resource | undefined): this {
        throw new Error("Unimplemented method friction")
    }
    onReachStart(value: (() => void) | undefined): this {
        throw new Error("Unimplemented method onReachStart")
    }
    onReachEnd(value: (() => void) | undefined): this {
        throw new Error("Unimplemented method onReachEnd")
    }
    onScrollStart(value: (() => void) | undefined): this {
        throw new Error("Unimplemented method onScrollStart")
    }
    onScrollStop(value: (() => void) | undefined): this {
        throw new Error("Unimplemented method onScrollStop")
    }
    flingSpeedLimit(value: double | undefined): this {
        throw new Error("Unimplemented method flingSpeedLimit")
    }
    clipContent(value: ContentClipMode | RectShape | undefined): this {
        throw new Error("Unimplemented method clipContent")
    }
    digitalCrownSensitivity(value: CrownSensitivity | undefined): this {
        throw new Error("Unimplemented method digitalCrownSensitivity")
    }
    backToTop(value: boolean | undefined): this {
        throw new Error("Unimplemented method backToTop")
    }
    edgeEffect(edgeEffect: EdgeEffect | undefined, options?: EdgeEffectOptions): this {
        throw new Error("Unimplemented method edgeEffect")
    }
    fadingEdge(enabled: boolean | undefined, options?: FadingEdgeOptions): this {
        throw new Error("Unimplemented method fadingEdge")
    }
    attributeModifier(value: AttributeModifier<ScrollableCommonMethod> | AttributeModifier<CommonMethod> | undefined): this {
        throw new Error("Unimplemented method attributeModifier")
    }
}
export class ArkScrollableCommonMethodStyle extends ArkCommonMethodStyle implements ScrollableCommonMethod {
    scrollBar(value: BarState | undefined): this {
        return this
    }
    scrollBarColor(value: Color | int32 | string | undefined): this {
        return this
    }
    scrollBarWidth(value: double | string | undefined): this {
        return this
    }
    nestedScroll(value: NestedScrollOptions | undefined): this {
        return this
    }
    enableScrollInteraction(value: boolean | undefined): this {
        return this
    }
    friction(value: double | Resource | undefined): this {
        return this
    }
    onReachStart(value: (() => void) | undefined): this {
        return this
    }
    onReachEnd(value: (() => void) | undefined): this {
        return this
    }
    onScrollStart(value: (() => void) | undefined): this {
        return this
    }
    onScrollStop(value: (() => void) | undefined): this {
        return this
    }
    flingSpeedLimit(value: double | undefined): this {
        return this
    }
    clipContent(value: ContentClipMode | RectShape | undefined): this {
        return this
    }
    digitalCrownSensitivity(value: CrownSensitivity | undefined): this {
        return this
    }
    backToTop(value: boolean | undefined): this {
        return this
    }
    edgeEffect(edgeEffect: EdgeEffect | undefined, options?: EdgeEffectOptions): this {
        return this
    }
    fadingEdge(enabled: boolean | undefined, options?: FadingEdgeOptions): this {
        return this
    }
    public attributeModifier(value: AttributeModifier<ScrollableCommonMethod> | AttributeModifier<CommonMethod> | undefined): this {
        throw new Error("Not implemented")
    }
}
export type OnWillScrollCallback = (scrollOffset: double, scrollState: ScrollState, scrollSource: ScrollSource) => ScrollResult | undefined;
export type OnScrollCallback = (scrollOffset: double, scrollState: ScrollState) => void;
export type OnItemDragStartCallback = (event: ItemDragInfo, itemIndex: int32) => CustomBuilder | undefined;
export type OnMoveHandler = (from: int32, to: int32) => void;
export interface ItemDragEventHandler {
    onLongPress?: ((value0: int32) => void);
    onDragStart?: ((value0: int32) => void);
    onMoveThrough?: OnMoveHandler;
    onDrop?: ((value0: int32) => void);
}
export interface EdgeEffectOptions {
    alwaysEnabled: boolean;
    effectEdge?: int32;
}
export enum EffectEdge {
    START = 1,
    END = 2
}
export interface BackgroundBrightnessOptions {
    rate: double;
    lightUpDegree: double;
}
export interface PointLightStyle {
    lightSource?: LightSource;
    illuminated?: IlluminatedType;
    bloom?: number;
}
export interface LightSource {
    positionX: Dimension;
    positionY: Dimension;
    intensity: number;
    color?: ResourceColor;
}
export interface KeyframeAnimateParam {
    delay?: int32;
    iterations?: int32;
    onFinish?: (() => void);
    expectedFrameRateRange?: ExpectedFrameRateRange;
}
export interface KeyframeState {
    duration: int32;
    curve?: curves.Curve | string | curves.ICurve;
    event: (() => void);
}
export type Callback<T = void,V = void> = (data: T) => V;
export type HoverCallback = (isHover: boolean, event: HoverEvent) => void;
export type AccessibilityCallback = (isHover: boolean, event: AccessibilityHoverEvent) => void;
export type AccessibilityTransparentCallback = (event: TouchEvent) => void;
export interface VisibleAreaEventOptions {
    ratios: Array<double>;
    expectedUpdateInterval?: int32;
}
export type VisibleAreaChangeCallback = (isExpanding: boolean, currentRatio: double) => void;
export interface SelectionOptions {
    menuPolicy?: MenuPolicy;
}
export interface FocusMovement {
    forward?: string;
    backward?: string;
    up?: string;
    down?: string;
    left?: string;
    right?: string;
}
export enum KeyboardAvoidMode {
    DEFAULT = 0,
    NONE = 1
}
export enum HoverModeAreaType {
    TOP_SCREEN = 0,
    BOTTOM_SCREEN = 1
}
export interface DateRange {
    start?: Date;
    end?: Date;
}
export interface TerminationInfo {
    code: int32;
    want?: Want;
}
export type DateTimeOptions = intl.DateTimeOptions;
export interface Bindable<T = void> {
    readonly value: T;
    readonly onChange: ((value0: T) => void);
}
export type BindableResourceStr = ResourceStr | Bindable<ResourceStr> | Bindable<Resource> | Bindable<string>;
export type BindableResourceStrArray = Array<ResourceStr> | Bindable<Array<ResourceStr>> | Bindable<Array<Resource>> | Bindable<Array<string>>;
export class ArkCommonMethodComponent extends ComponentBase implements CommonMethod {
    getPeer(): ArkCommonMethodPeer {
        if (!this.peer) {
            throw new Error("Attribute function should be called in memo context")
        }
        return (this.peer as ArkCommonMethodPeer)
    }
    public width(value: Length | LayoutPolicy | undefined): this {
        if (this.checkPriority("width")) {
            const value_casted = value as (Length | LayoutPolicy | undefined)
            this.getPeer()?.setWidthAttribute(value_casted)
            return this
        }
        return this
    }
    public height(value: Length | LayoutPolicy | undefined): this {
        if (this.checkPriority("height")) {
            const value_casted = value as (Length | LayoutPolicy | undefined)
            this.getPeer()?.setHeightAttribute(value_casted)
            return this
        }
        return this
    }
    public drawModifier(value: DrawModifier | undefined): this {
        if (this.checkPriority("drawModifier")) {
            hookDrawModifier(this, value)
        }
        return this
    }
    public responseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        if (this.checkPriority("responseRegion")) {
            const value_casted = value as (Array<Rectangle> | Rectangle | undefined)
            this.getPeer()?.setResponseRegionAttribute(value_casted)
            return this
        }
        return this
    }
    public mouseResponseRegion(value: Array<Rectangle> | Rectangle | undefined): this {
        if (this.checkPriority("mouseResponseRegion")) {
            const value_casted = value as (Array<Rectangle> | Rectangle | undefined)
            this.getPeer()?.setMouseResponseRegionAttribute(value_casted)
            return this
        }
        return this
    }
    public responseRegionList(value: Array<ResponseRegion> | undefined): this {
        if (this.checkPriority("responseRegionList")) {
            const value_casted = value as (Array<ResponseRegion> | undefined)
            this.getPeer()?.setResponseRegionListAttribute(value_casted)
            return this
        }
        return this
    }
    public size(value: SizeOptions | undefined): this {
        if (this.checkPriority("size")) {
            const value_casted = value as (SizeOptions | undefined)
            this.getPeer()?.setSizeAttribute(value_casted)
            return this
        }
        return this
    }
    public constraintSize(value: ConstraintSizeOptions | undefined): this {
        if (this.checkPriority("constraintSize")) {
            const value_casted = value as (ConstraintSizeOptions | undefined)
            this.getPeer()?.setConstraintSizeAttribute(value_casted)
            return this
        }
        return this
    }
    public hitTestBehavior(value: HitTestMode | undefined): this {
        if (this.checkPriority("hitTestBehavior")) {
            const value_casted = value as (HitTestMode | undefined)
            this.getPeer()?.setHitTestBehaviorAttribute(value_casted)
            return this
        }
        return this
    }
    public onChildTouchTest(value: ((value: Array<TouchTestInfo>) => TouchResult) | undefined): this {
        if (this.checkPriority("onChildTouchTest")) {
            const value_casted = value as (((value: Array<TouchTestInfo>) => TouchResult) | undefined)
            this.getPeer()?.setOnChildTouchTestAttribute(value_casted)
            return this
        }
        return this
    }
    public layoutWeight(value: number | string | undefined): this {
        if (this.checkPriority("layoutWeight")) {
            const value_casted = value as (number | string | undefined)
            this.getPeer()?.setLayoutWeightAttribute(value_casted)
            return this
        }
        return this
    }
    public chainWeight(value: ChainWeightOptions | undefined): this {
        if (this.checkPriority("chainWeight")) {
            const value_casted = value as (ChainWeightOptions | undefined)
            this.getPeer()?.setChainWeightAttribute(value_casted)
            return this
        }
        return this
    }
    public padding(value: Padding | Length | LocalizedPadding | undefined): this {
        if (this.checkPriority("padding")) {
            const value_casted = value as (Padding | Length | LocalizedPadding | undefined)
            this.getPeer()?.setPaddingAttribute(value_casted)
            return this
        }
        return this
    }
    public safeAreaPadding(value: Padding | LengthMetrics | LocalizedPadding | undefined): this {
        if (this.checkPriority("safeAreaPadding")) {
            const value_casted = value as (Padding | LengthMetrics | LocalizedPadding | undefined)
            this.getPeer()?.setSafeAreaPaddingAttribute(value_casted)
            return this
        }
        return this
    }
    public margin(value: Padding | Length | LocalizedPadding | undefined): this {
        if (this.checkPriority("margin")) {
            const value_casted = value as (Padding | Length | LocalizedPadding | undefined)
            this.getPeer()?.setMarginAttribute(value_casted)
            return this
        }
        return this
    }
    public backgroundColor(value: ResourceColor | ColorMetrics | undefined): this {
        if (this.checkPriority("backgroundColor")) {
            const value_casted = value as (ResourceColor | ColorMetrics | undefined)
            this.getPeer()?.setBackgroundColorAttribute(value_casted)
            return this
        }
        return this
    }
    public pixelRound(value: PixelRoundPolicy | undefined): this {
        if (this.checkPriority("pixelRound")) {
            const value_casted = value as (PixelRoundPolicy | undefined)
            this.getPeer()?.setPixelRoundAttribute(value_casted)
            return this
        }
        return this
    }
    public backgroundImageSize(value: SizeOptions | ImageSize | undefined): this {
        if (this.checkPriority("backgroundImageSize")) {
            const value_casted = value as (SizeOptions | ImageSize | undefined)
            this.getPeer()?.setBackgroundImageSizeAttribute(value_casted)
            return this
        }
        return this
    }
    public backgroundImagePosition(value: Position | Alignment | undefined): this {
        if (this.checkPriority("backgroundImagePosition")) {
            const value_casted = value as (Position | Alignment | undefined)
            this.getPeer()?.setBackgroundImagePositionAttribute(value_casted)
            return this
        }
        return this
    }
    public backgroundEffect(value: BackgroundEffectOptions | undefined): this {
        if (this.checkPriority("backgroundEffect")) {
            const value_casted = value as (BackgroundEffectOptions | undefined)
            this.getPeer()?.setBackgroundEffect0Attribute(value_casted)
            return this
        }
        return this
    }
    public backgroundImageResizable(value: ResizableOptions | undefined): this {
        if (this.checkPriority("backgroundImageResizable")) {
            const value_casted = value as (ResizableOptions | undefined)
            this.getPeer()?.setBackgroundImageResizableAttribute(value_casted)
            return this
        }
        return this
    }
    public foregroundEffect(value: ForegroundEffectOptions | undefined): this {
        if (this.checkPriority("foregroundEffect")) {
            const value_casted = value as (ForegroundEffectOptions | undefined)
            this.getPeer()?.setForegroundEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public visualEffect(value: uiEffect.VisualEffect | undefined): this {
        if (this.checkPriority("visualEffect")) {
            const value_casted = value as (uiEffect.VisualEffect | undefined)
            this.getPeer()?.setVisualEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public backgroundFilter(value: uiEffect.Filter | undefined): this {
        if (this.checkPriority("backgroundFilter")) {
            const value_casted = value as (uiEffect.Filter | undefined)
            this.getPeer()?.setBackgroundFilterAttribute(value_casted)
            return this
        }
        return this
    }
    public foregroundFilter(value: uiEffect.Filter | undefined): this {
        if (this.checkPriority("foregroundFilter")) {
            const value_casted = value as (uiEffect.Filter | undefined)
            this.getPeer()?.setForegroundFilterAttribute(value_casted)
            return this
        }
        return this
    }
    public compositingFilter(value: uiEffect.Filter | undefined): this {
        if (this.checkPriority("compositingFilter")) {
            const value_casted = value as (uiEffect.Filter | undefined)
            this.getPeer()?.setCompositingFilterAttribute(value_casted)
            return this
        }
        return this
    }
    public opacity(value: double | Resource | undefined): this {
        if (this.checkPriority("opacity")) {
            const value_casted = value as (double | Resource | undefined)
            this.getPeer()?.setOpacityAttribute(value_casted)
            return this
        }
        return this
    }
    public border(value: BorderOptions | undefined): this {
        if (this.checkPriority("border")) {
            const value_casted = value as (BorderOptions | undefined)
            this.getPeer()?.setBorderAttribute(value_casted)
            return this
        }
        return this
    }
    public borderStyle(value: BorderStyle | EdgeStyles | undefined): this {
        if (this.checkPriority("borderStyle")) {
            const value_casted = value as (BorderStyle | EdgeStyles | undefined)
            this.getPeer()?.setBorderStyleAttribute(value_casted)
            return this
        }
        return this
    }
    public borderWidth(value: Length | EdgeWidths | LocalizedEdgeWidths | undefined): this {
        if (this.checkPriority("borderWidth")) {
            const value_casted = value as (Length | EdgeWidths | LocalizedEdgeWidths | undefined)
            this.getPeer()?.setBorderWidthAttribute(value_casted)
            return this
        }
        return this
    }
    public borderColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        if (this.checkPriority("borderColor")) {
            const value_casted = value as (ResourceColor | EdgeColors | LocalizedEdgeColors | undefined)
            this.getPeer()?.setBorderColorAttribute(value_casted)
            return this
        }
        return this
    }
    public borderRadius(value: Length | BorderRadiuses | LocalizedBorderRadiuses | undefined): this {
        if (this.checkPriority("borderRadius")) {
            const value_casted = value as (Length | BorderRadiuses | LocalizedBorderRadiuses | undefined)
            this.getPeer()?.setBorderRadiusAttribute(value_casted)
            return this
        }
        return this
    }
    public borderImage(value: BorderImageOption | undefined): this {
        if (this.checkPriority("borderImage")) {
            const value_casted = value as (BorderImageOption | undefined)
            this.getPeer()?.setBorderImageAttribute(value_casted)
            return this
        }
        return this
    }
    public outline(value: OutlineOptions | undefined): this {
        if (this.checkPriority("outline")) {
            const value_casted = value as (OutlineOptions | undefined)
            this.getPeer()?.setOutlineAttribute(value_casted)
            return this
        }
        return this
    }
    public outlineStyle(value: OutlineStyle | EdgeOutlineStyles | undefined): this {
        if (this.checkPriority("outlineStyle")) {
            const value_casted = value as (OutlineStyle | EdgeOutlineStyles | undefined)
            this.getPeer()?.setOutlineStyleAttribute(value_casted)
            return this
        }
        return this
    }
    public outlineWidth(value: Dimension | EdgeOutlineWidths | undefined): this {
        if (this.checkPriority("outlineWidth")) {
            const value_casted = value as (Dimension | EdgeOutlineWidths | undefined)
            this.getPeer()?.setOutlineWidthAttribute(value_casted)
            return this
        }
        return this
    }
    public outlineColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors | undefined): this {
        if (this.checkPriority("outlineColor")) {
            const value_casted = value as (ResourceColor | EdgeColors | LocalizedEdgeColors | undefined)
            this.getPeer()?.setOutlineColorAttribute(value_casted)
            return this
        }
        return this
    }
    public outlineRadius(value: Dimension | OutlineRadiuses | undefined): this {
        if (this.checkPriority("outlineRadius")) {
            const value_casted = value as (Dimension | OutlineRadiuses | undefined)
            this.getPeer()?.setOutlineRadiusAttribute(value_casted)
            return this
        }
        return this
    }
    public foregroundColor(value: ResourceColor | ColoringStrategy | undefined): this {
        if (this.checkPriority("foregroundColor")) {
            const value_casted = value as (ResourceColor | ColoringStrategy | undefined)
            this.getPeer()?.setForegroundColorAttribute(value_casted)
            return this
        }
        return this
    }
    public onClick(value: ((event: ClickEvent) => void) | undefined): this {
        if (this.checkPriority("onClick")) {
            const value_casted = value as (((event: ClickEvent) => void) | undefined)
            this.getPeer()?.setOnClick0Attribute(value_casted)
            return this
        }
        return this
    }
    public onHover(value: ((isHover: boolean,event: HoverEvent) => void) | undefined): this {
        if (this.checkPriority("onHover")) {
            const value_casted = value as (((isHover: boolean,event: HoverEvent) => void) | undefined)
            this.getPeer()?.setOnHoverAttribute(value_casted)
            return this
        }
        return this
    }
    public onHoverMove(value: ((value0: HoverEvent) => void) | undefined): this {
        if (this.checkPriority("onHoverMove")) {
            const value_casted = value as (((value0: HoverEvent) => void) | undefined)
            this.getPeer()?.setOnHoverMoveAttribute(value_casted)
            return this
        }
        return this
    }
    public onAccessibilityHover(value: AccessibilityCallback | undefined): this {
        if (this.checkPriority("onAccessibilityHover")) {
            const value_casted = value as (AccessibilityCallback | undefined)
            this.getPeer()?.setOnAccessibilityHoverAttribute(value_casted)
            return this
        }
        return this
    }
    public onAccessibilityHoverTransparent(value: AccessibilityTransparentCallback | undefined): this {
        if (this.checkPriority("onAccessibilityHoverTransparent")) {
            const value_casted = value as (AccessibilityTransparentCallback | undefined)
            this.getPeer()?.setOnAccessibilityHoverTransparentAttribute(value_casted)
            return this
        }
        return this
    }
    public hoverEffect(value: HoverEffect | undefined): this {
        if (this.checkPriority("hoverEffect")) {
            const value_casted = value as (HoverEffect | undefined)
            this.getPeer()?.setHoverEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public onMouse(value: ((event: MouseEvent) => void) | undefined): this {
        if (this.checkPriority("onMouse")) {
            const value_casted = value as (((event: MouseEvent) => void) | undefined)
            this.getPeer()?.setOnMouseAttribute(value_casted)
            return this
        }
        return this
    }
    public onTouch(value: ((event: TouchEvent) => void) | undefined): this {
        if (this.checkPriority("onTouch")) {
            const value_casted = value as (((event: TouchEvent) => void) | undefined)
            this.getPeer()?.setOnTouchAttribute(value_casted)
            return this
        }
        return this
    }
    public onKeyEvent(value: ((event: KeyEvent) => boolean) | undefined): this {
        if (this.checkPriority("onKeyEvent")) {
            const value_casted = value as (((event: KeyEvent) => boolean) | undefined)
            this.getPeer()?.setOnKeyEventAttribute(value_casted)
            return this
        }
        return this
    }
    public onDigitalCrown(value: ((value0: CrownEvent) => void) | undefined): this {
        if (this.checkPriority("onDigitalCrown")) {
            const value_casted = value as (((value0: CrownEvent) => void) | undefined)
            this.getPeer()?.setOnDigitalCrownAttribute(value_casted)
            return this
        }
        return this
    }
    public onKeyPreIme(value: ((value0: KeyEvent) => boolean) | undefined): this {
        if (this.checkPriority("onKeyPreIme")) {
            const value_casted = value as (((value0: KeyEvent) => boolean) | undefined)
            this.getPeer()?.setOnKeyPreImeAttribute(value_casted)
            return this
        }
        return this
    }
    public onKeyEventDispatch(value: ((value0: KeyEvent) => boolean) | undefined): this {
        if (this.checkPriority("onKeyEventDispatch")) {
            const value_casted = value as (((value0: KeyEvent) => boolean) | undefined)
            this.getPeer()?.setOnKeyEventDispatchAttribute(value_casted)
            return this
        }
        return this
    }
    public onFocusAxisEvent(value: ((value0: FocusAxisEvent) => void) | undefined): this {
        if (this.checkPriority("onFocusAxisEvent")) {
            const value_casted = value as (((value0: FocusAxisEvent) => void) | undefined)
            this.getPeer()?.setOnFocusAxisEventAttribute(value_casted)
            return this
        }
        return this
    }
    public onAxisEvent(value: ((value0: AxisEvent) => void) | undefined): this {
        if (this.checkPriority("onAxisEvent")) {
            const value_casted = value as (((value0: AxisEvent) => void) | undefined)
            this.getPeer()?.setOnAxisEventAttribute(value_casted)
            return this
        }
        return this
    }
    public focusable(value: boolean | undefined): this {
        if (this.checkPriority("focusable")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setFocusableAttribute(value_casted)
            return this
        }
        return this
    }
    public nextFocus(value: FocusMovement | undefined): this {
        if (this.checkPriority("nextFocus")) {
            const value_casted = value as (FocusMovement | undefined)
            this.getPeer()?.setNextFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public tabStop(value: boolean | undefined): this {
        if (this.checkPriority("tabStop")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setTabStopAttribute(value_casted)
            return this
        }
        return this
    }
    public onFocus(value: (() => void) | undefined): this {
        if (this.checkPriority("onFocus")) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public onBlur(value: (() => void) | undefined): this {
        if (this.checkPriority("onBlur")) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnBlurAttribute(value_casted)
            return this
        }
        return this
    }
    public tabIndex(value: int32 | undefined): this {
        if (this.checkPriority("tabIndex")) {
            const value_casted = value as (int32 | undefined)
            this.getPeer()?.setTabIndexAttribute(value_casted)
            return this
        }
        return this
    }
    public defaultFocus(value: boolean | undefined): this {
        if (this.checkPriority("defaultFocus")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setDefaultFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public groupDefaultFocus(value: boolean | undefined): this {
        if (this.checkPriority("groupDefaultFocus")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setGroupDefaultFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public focusOnTouch(value: boolean | undefined): this {
        if (this.checkPriority("focusOnTouch")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setFocusOnTouchAttribute(value_casted)
            return this
        }
        return this
    }
    public focusBox(value: FocusBoxStyle | undefined): this {
        if (this.checkPriority("focusBox")) {
            const value_casted = value as (FocusBoxStyle | undefined)
            this.getPeer()?.setFocusBoxAttribute(value_casted)
            return this
        }
        return this
    }

    // instructive change start
    public animationStart(value: AnimateParam | undefined): this {
        if (this.checkPriority("animationStart")) {
            _animationStart(this.getPeer()?.getPeerPtr(), value, this.isFirstBuild);
            return this
        }
        return this
    }
    public animationStop(value: AnimateParam | undefined): this {
        if (this.checkPriority("animationStop")) {
            _animationStop(this.getPeer()?.getPeerPtr(), value, this.isFirstBuild);
            return this
        }
        return this
    }
    public __createOrSetAnimatableProperty<T>(functionName: string, value: number | AnimatableArithmetic<T>,
        callback: (value: number | AnimatableArithmetic<T>) => void): void {
        if (this.getPeer()) {
            const peer = this.getPeer();
            let isFirst = true;
            const newCallback = (value: number | AnimatableArithmetic<T>): void => {
                if (isFirst) {
                    isFirst = false;
                    callback(value);
                    return;
                }
                this.setPeer(peer);
                callback(value);
                this.setPeer(undefined);
            }
            ArkUIAniModule._Animation_SetOrCreateAnimatableProperty(this.getPeer().getPeerPtr(), functionName, value, newCallback);
        }
    }
    // instructive change end

    public transition(value: TransitionEffect | undefined): this {
        if (this.checkPriority("transition")) {
            const value_casted = value as (TransitionEffect | undefined)
            this.getPeer()?.setTransition0Attribute(value_casted)
            return this
        }
        return this
    }
    public motionBlur(value: MotionBlurOptions | undefined): this {
        if (this.checkPriority("motionBlur")) {
            const value_casted = value as (MotionBlurOptions | undefined)
            this.getPeer()?.setMotionBlurAttribute(value_casted)
            return this
        }
        return this
    }
    public brightness(value: double | undefined): this {
        if (this.checkPriority("brightness")) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setBrightnessAttribute(value_casted)
            return this
        }
        return this
    }
    public contrast(value: double | undefined): this {
        if (this.checkPriority("contrast")) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setContrastAttribute(value_casted)
            return this
        }
        return this
    }
    public grayscale(value: double | undefined): this {
        if (this.checkPriority("grayscale")) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setGrayscaleAttribute(value_casted)
            return this
        }
        return this
    }
    public colorBlend(value: Color | string | Resource | undefined): this {
        if (this.checkPriority("colorBlend")) {
            const value_casted = value as (Color | string | Resource | undefined)
            this.getPeer()?.setColorBlendAttribute(value_casted)
            return this
        }
        return this
    }
    public saturate(value: double | undefined): this {
        if (this.checkPriority("saturate")) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setSaturateAttribute(value_casted)
            return this
        }
        return this
    }
    public sepia(value: double | undefined): this {
        if (this.checkPriority("sepia")) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setSepiaAttribute(value_casted)
            return this
        }
        return this
    }
    public invert(value: double | InvertOptions | undefined): this {
        if (this.checkPriority("invert")) {
            const value_casted = value as (double | InvertOptions | undefined)
            this.getPeer()?.setInvertAttribute(value_casted)
            return this
        }
        return this
    }
    public hueRotate(value: double | string | undefined): this {
        if (this.checkPriority("hueRotate")) {
            const value_casted = value as (double | string | undefined)
            this.getPeer()?.setHueRotateAttribute(value_casted)
            return this
        }
        return this
    }
    public useShadowBatching(value: boolean | undefined): this {
        if (this.checkPriority("useShadowBatching")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setUseShadowBatchingAttribute(value_casted)
            return this
        }
        return this
    }
    public useEffect(value: boolean | undefined): this {
        if (this.checkPriority("useEffect")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setUseEffect0Attribute(value_casted)
            return this
        }
        return this
    }
    public renderGroup(value: boolean | undefined): this {
        if (this.checkPriority("renderGroup")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setRenderGroupAttribute(value_casted)
            return this
        }
        return this
    }
    public freeze(value: boolean | undefined): this {
        if (this.checkPriority("freeze")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setFreezeAttribute(value_casted)
            return this
        }
        return this
    }
    public translate(value: TranslateOptions | undefined): this {
        if (this.checkPriority("translate")) {
            const value_casted = value as (TranslateOptions | undefined)
            this.getPeer()?.setTranslateAttribute(value_casted)
            return this
        }
        return this
    }
    public scale(value: ScaleOptions | undefined): this {
        if (this.checkPriority("scale")) {
            const value_casted = value as (ScaleOptions | undefined)
            this.getPeer()?.setScaleAttribute(value_casted)
            return this
        }
        return this
    }
    public rotate(value: RotateOptions | RotateAngleOptions | undefined): this {
        if (this.checkPriority("rotate")) {
            const value_casted = value as (RotateOptions | RotateAngleOptions | undefined)
            this.getPeer()?.setRotateAttribute(value_casted)
            return this
        }
        return this
    }
    public transform(value: matrix4.Matrix4Transit | undefined): this {
        if (this.checkPriority("transform")) {
            const value_casted = value as (matrix4.Matrix4Transit | undefined)
            this.getPeer()?.setTransformAttribute(value_casted)
            return this
        }
        return this
    }
    public transform3D(value: matrix4.Matrix4Transit | undefined): this {
        InteropNativeModule._NativeLog("zx transform3D")
        if (this.checkPriority("transform3D")) {
            const value_casted = value as (matrix4.Matrix4Transit | undefined)
            this.getPeer()?.setTransform3DAttribute(value_casted)
            return this
        }
        return this
    }
    public onAppear(value: (() => void) | undefined): this {
        if (this.checkPriority("onAppear")) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnAppearAttribute(value_casted)
            return this
        }
        return this
    }
    public onDisAppear(value: (() => void) | undefined): this {
        if (this.checkPriority("onDisAppear")) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnDisAppearAttribute(value_casted)
            return this
        }
        return this
    }
    public onAttach(value: VoidCallback | undefined): this {
        if (this.checkPriority("onAttach")) {
            const value_casted = value as (VoidCallback | undefined)
            this.getPeer()?.setOnAttachAttribute(value_casted)
            return this
        }
        return this
    }
    public onDetach(value: VoidCallback | undefined): this {
        if (this.checkPriority("onDetach")) {
            const value_casted = value as (VoidCallback | undefined)
            this.getPeer()?.setOnDetachAttribute(value_casted)
            return this
        }
        return this
    }
    public onAreaChange(value: ((oldValue: Area,newValue: Area) => void) | undefined): this {
        if (this.checkPriority("onAreaChange")) {
            const value_casted = value as (((oldValue: Area,newValue: Area) => void) | undefined)
            this.getPeer()?.setOnAreaChangeAttribute(value_casted)
            return this
        }
        return this
    }
    public visibility(value: Visibility | undefined): this {
        if (this.checkPriority("visibility")) {
            const value_casted = value as (Visibility | undefined)
            this.getPeer()?.setVisibilityAttribute(value_casted)
            return this
        }
        return this
    }
    public flexGrow(value: number | undefined): this {
        if (this.checkPriority("flexGrow")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setFlexGrowAttribute(value_casted)
            return this
        }
        return this
    }
    public flexShrink(value: number | undefined): this {
        if (this.checkPriority("flexShrink")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setFlexShrinkAttribute(value_casted)
            return this
        }
        return this
    }
    public flexBasis(value: number | string | undefined): this {
        if (this.checkPriority("flexBasis")) {
            const value_casted = value as (number | string | undefined)
            this.getPeer()?.setFlexBasisAttribute(value_casted)
            return this
        }
        return this
    }
    public alignSelf(value: ItemAlign | undefined): this {
        if (this.checkPriority("alignSelf")) {
            const value_casted = value as (ItemAlign | undefined)
            this.getPeer()?.setAlignSelfAttribute(value_casted)
            return this
        }
        return this
    }
    public displayPriority(value: number | undefined): this {
        if (this.checkPriority("displayPriority")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setDisplayPriorityAttribute(value_casted)
            return this
        }
        return this
    }
    public zIndex(value: int32 | undefined): this {
        if (this.checkPriority("zIndex")) {
            const value_casted = value as (int32 | undefined)
            this.getPeer()?.setZIndexAttribute(value_casted)
            return this
        }
        return this
    }
    public direction(value: Direction | undefined): this {
        if (this.checkPriority("direction")) {
            const value_casted = value as (Direction | undefined)
            this.getPeer()?.setDirectionAttribute(value_casted)
            return this
        }
        return this
    }
    public align(value: Alignment | undefined): this {
        if (this.checkPriority("align")) {
            const value_casted = value as (Alignment | undefined)
            this.getPeer()?.setAlignAttribute(value_casted)
            return this
        }
        return this
    }
    public position(value: Position | Edges | LocalizedEdges | undefined): this {
        if (this.checkPriority("position")) {
            const value_casted = value as (Position | Edges | LocalizedEdges | undefined)
            this.getPeer()?.setPositionAttribute(value_casted)
            return this
        }
        return this
    }
    public markAnchor(value: Position | LocalizedPosition | undefined): this {
        if (this.checkPriority("markAnchor")) {
            const value_casted = value as (Position | LocalizedPosition | undefined)
            this.getPeer()?.setMarkAnchorAttribute(value_casted)
            return this
        }
        return this
    }
    public offset(value: Position | Edges | LocalizedEdges | undefined): this {
        if (this.checkPriority("offset")) {
            const value_casted = value as (Position | Edges | LocalizedEdges | undefined)
            this.getPeer()?.setOffsetAttribute(value_casted)
            return this
        }
        return this
    }
    public enabled(value: boolean | undefined): this {
        if (this.checkPriority("enabled")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setEnabledAttribute(value_casted)
            return this
        }
        return this
    }
    public alignRules(value: AlignRuleOption | LocalizedAlignRuleOptions | undefined): this {
        if (this.checkPriority("alignRules")) {
            const value_casted = value as (AlignRuleOption | LocalizedAlignRuleOptions | undefined)
            this.getPeer()?.setAlignRulesAttribute(value_casted)
            return this
        }
        return this
    }
    public aspectRatio(value: number | undefined): this {
        if (this.checkPriority("aspectRatio")) {
            const value_casted = value as (number | undefined)
            this.getPeer()?.setAspectRatioAttribute(value_casted)
            return this
        }
        return this
    }
    public clickEffect(value: ClickEffect | null | undefined): this {
        if (this.checkPriority("clickEffect")) {
            const value_casted = value as (ClickEffect | null | undefined)
            this.getPeer()?.setClickEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public onDragStart(value: ((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined): this {
        if (this.checkPriority("onDragStart")) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => CustomBuilder | DragItemInfo) | undefined)
            this.getPeer()?.setOnDragStartAttribute(value_casted)
            return this
        }
        return this
    }
    public onDragEnter(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        if (this.checkPriority("onDragEnter")) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => void) | undefined)
            this.getPeer()?.setOnDragEnterAttribute(value_casted)
            return this
        }
        return this
    }
    public onDragMove(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        if (this.checkPriority("onDragMove")) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => void) | undefined)
            this.getPeer()?.setOnDragMoveAttribute(value_casted)
            return this
        }
        return this
    }
    public onDragLeave(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        if (this.checkPriority("onDragLeave")) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => void) | undefined)
            this.getPeer()?.setOnDragLeaveAttribute(value_casted)
            return this
        }
        return this
    }
    public onDrop(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        if (this.checkPriority("onDrop")) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => void) | undefined)
            this.getPeer()?.setOnDrop0Attribute(value_casted)
            return this
        }
        return this
    }
    public onDragEnd(value: ((event: DragEvent,extraParams?: string) => void) | undefined): this {
        if (this.checkPriority("onDragEnd")) {
            const value_casted = value as (((event: DragEvent,extraParams?: string) => void) | undefined)
            this.getPeer()?.setOnDragEndAttribute(value_casted)
            return this
        }
        return this
    }
    public allowDrop(value: Array<uniformTypeDescriptor.UniformDataType> | null | Array<string> | undefined): this {
        if (this.checkPriority("allowDrop")) {
            hookAllowDrop(this, value)
            return this
        }
        return this
    }
    public draggable(value: boolean | undefined): this {
        if (this.checkPriority("draggable")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setDraggableAttribute(value_casted)
            return this
        }
        return this
    }
    public dragPreview(value: CustomBuilder | DragItemInfo | string | undefined): this {
        if (this.checkPriority("dragPreview")) {
            const value_casted = value as (CustomBuilder | DragItemInfo | string | undefined)
            this.getPeer()?.setDragPreview0Attribute(value_casted)
            return this
        }
        return this
    }
    public onPreDrag(value: ((value0: PreDragStatus) => void) | undefined): this {
        if (this.checkPriority("onPreDrag")) {
            const value_casted = value as (((value0: PreDragStatus) => void) | undefined)
            this.getPeer()?.setOnPreDragAttribute(value_casted)
            return this
        }
        return this
    }
    public linearGradient(value: LinearGradientOptions | undefined): this {
        if (this.checkPriority("linearGradient")) {
            const value_casted = value as (LinearGradientOptions | undefined)
            this.getPeer()?.setLinearGradientAttribute(value_casted)
            return this
        }
        return this
    }
    public sweepGradient(value: SweepGradientOptions | undefined): this {
        if (this.checkPriority("sweepGradient")) {
            const value_casted = value as (SweepGradientOptions | undefined)
            this.getPeer()?.setSweepGradientAttribute(value_casted)
            return this
        }
        return this
    }
    public radialGradient(value: RadialGradientOptions | undefined): this {
        if (this.checkPriority("radialGradient")) {
            const value_casted = value as (RadialGradientOptions | undefined)
            this.getPeer()?.setRadialGradientAttribute(value_casted)
            return this
        }
        return this
    }
    public motionPath(value: MotionPathOptions | undefined): this {
        if (this.checkPriority("motionPath")) {
            const value_casted = value as (MotionPathOptions | undefined)
            this.getPeer()?.setMotionPathAttribute(value_casted)
            return this
        }
        return this
    }
    public shadow(value: ShadowOptions | ShadowStyle | undefined): this {
        if (this.checkPriority("shadow")) {
            const value_casted = value as (ShadowOptions | ShadowStyle | undefined)
            this.getPeer()?.setShadowAttribute(value_casted)
            return this
        }
        return this
    }
    public clip(value: boolean | undefined): this {
        if (this.checkPriority("clip")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setClipAttribute(value_casted)
            return this
        }
        return this
    }
    public clipShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        if (this.checkPriority("clipShape")) {
            const value_casted = value as (CircleShape | EllipseShape | PathShape | RectShape | undefined)
            this.getPeer()?.setClipShapeAttribute(value_casted)
            return this
        }
        return this
    }
    public mask(value: ProgressMask | undefined): this {
        if (this.checkPriority("mask")) {
            const value_casted = value as (ProgressMask | undefined)
            this.getPeer()?.setMaskAttribute(value_casted)
            return this
        }
        return this
    }
    public maskShape(value: CircleShape | EllipseShape | PathShape | RectShape | undefined): this {
        if (this.checkPriority("maskShape")) {
            const value_casted = value as (CircleShape | EllipseShape | PathShape | RectShape | undefined)
            this.getPeer()?.setMaskShapeAttribute(value_casted)
            return this
        }
        return this
    }
    public key(value: string | undefined): this {
        if (this.checkPriority("key")) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setKeyAttribute(value_casted)
            return this
        }
        return this
    }
    public id(value: string | undefined): this {
        if (this.checkPriority("id")) {
            hookId(this, value)
            const value_casted = value as (string | undefined)
            this.getPeer()?.setIdAttribute(value_casted)
            return this
        }
        return this
    }
    public geometryTransition(value: string | undefined): this {
        if (this.checkPriority("geometryTransition")) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setGeometryTransition0Attribute(value_casted)
            return this
        }
        return this
    }
    public stateStyles(value: StateStyles | undefined): this {
        if (this.checkPriority("stateStyles")) {
            hookStateStyleImpl(this, value)
        }
        return this
    }
    public restoreId(value: int32 | undefined): this {
        if (this.checkPriority("restoreId")) {
            const value_casted = value as (int32 | undefined)
            this.getPeer()?.setRestoreIdAttribute(value_casted)
            return this
        }
        return this
    }
    public sphericalEffect(value: double | undefined): this {
        if (this.checkPriority("sphericalEffect")) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setSphericalEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public lightUpEffect(value: double | undefined): this {
        if (this.checkPriority("lightUpEffect")) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setLightUpEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public pixelStretchEffect(value: PixelStretchEffectOptions | undefined): this {
        if (this.checkPriority("pixelStretchEffect")) {
            const value_casted = value as (PixelStretchEffectOptions | undefined)
            this.getPeer()?.setPixelStretchEffectAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityGroupWithValue(value: boolean | undefined): this {
        if (this.checkPriority("accessibilityGroupWithValue")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setAccessibilityGroupWithValueAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityTextOfStringType(value: string | undefined): this {
        if (this.checkPriority("accessibilityTextOfStringType")) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setAccessibilityTextOfStringTypeAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityNextFocusId(value: string | undefined): this {
        if (this.checkPriority("accessibilityNextFocusId")) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setAccessibilityNextFocusIdAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityDefaultFocus(value: boolean | undefined): this {
        if (this.checkPriority("accessibilityDefaultFocus")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setAccessibilityDefaultFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityUseSamePage(value: AccessibilitySamePageMode | undefined): this {
        if (this.checkPriority("accessibilityUseSamePage")) {
            const value_casted = value as (AccessibilitySamePageMode | undefined)
            this.getPeer()?.setAccessibilityUseSamePageAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityScrollTriggerable(value: boolean | undefined): this {
        if (this.checkPriority("accessibilityScrollTriggerable")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setAccessibilityScrollTriggerableAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityTextOfResourceType(value: Resource | undefined): this {
        if (this.checkPriority("accessibilityTextOfResourceType")) {
            const value_casted = value as (Resource | undefined)
            this.getPeer()?.setAccessibilityTextOfResourceTypeAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityText(value: Resource | string | undefined): this {
        if (this.checkPriority("accessibilityText")) {
            if (value instanceof Resource) {
                const value_casted = value as (Resource | undefined)
                this.getPeer()?.setAccessibilityTextOfResourceTypeAttribute(value_casted)
                return this
            } else {
                const value_casted = value as (string | undefined)
                this.getPeer()?.setAccessibilityTextOfStringTypeAttribute(value_casted)
                return this
            }
        }
        return this
    }
    public accessibilityRole(value: AccessibilityRoleType | undefined): this {
        if (this.checkPriority("accessibilityRole")) {
            const value_casted = value as (AccessibilityRoleType | undefined)
            this.getPeer()?.setAccessibilityRoleAttribute(value_casted)
            return this
        }
        return this
    }
    public onAccessibilityFocus(value: AccessibilityFocusCallback | undefined): this {
        if (this.checkPriority("onAccessibilityFocus")) {
            const value_casted = value as (AccessibilityFocusCallback | undefined)
            this.getPeer()?.setOnAccessibilityFocusAttribute(value_casted)
            return this
        }
        return this
    }
    public onAccessibilityActionIntercept(value: AccessibilityActionInterceptCallback | undefined): this {
        if (this.checkPriority("onAccessibilityActionIntercept")) {
            const value_casted = value as (AccessibilityActionInterceptCallback | undefined)
            this.getPeer()?.setOnAccessibilityActionInterceptAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityTextHint(value: string | undefined): this {
        if (this.checkPriority("accessibilityTextHint")) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setAccessibilityTextHintAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityDescriptionOfStringType(value: string | undefined): this {
        if (this.checkPriority("accessibilityDescriptionOfStringType")) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setAccessibilityDescriptionOfStringTypeAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityDescriptionOfResourceType(value: Resource | undefined): this {
        if (this.checkPriority("accessibilityDescriptionOfResourceType")) {
            const value_casted = value as (Resource | undefined)
            this.getPeer()?.setAccessibilityDescriptionOfResourceTypeAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityDescription(value: Resource | string | undefined): this {
        if (this.checkPriority("accessibilityDescription")) {
            if (value instanceof Resource) {
                const value_casted = value as (Resource | undefined)
                this.getPeer()?.setAccessibilityDescriptionOfResourceTypeAttribute(value_casted)
                return this
            } else {
                const value_casted = value as (string | undefined)
                this.getPeer()?.setAccessibilityDescriptionOfStringTypeAttribute(value_casted)
                return this
            }
        }
        return this
    }
    public accessibilityLevel(value: string | undefined): this {
        if (this.checkPriority("accessibilityLevel")) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setAccessibilityLevelAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityVirtualNode(value: CustomBuilder | undefined): this {
        if (this.checkPriority("accessibilityVirtualNode")) {
            const value_casted = value as (CustomBuilder | undefined)
            this.getPeer()?.setAccessibilityVirtualNodeAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityChecked(value: boolean | undefined): this {
        if (this.checkPriority("accessibilityChecked")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setAccessibilityCheckedAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilitySelected(value: boolean | undefined): this {
        if (this.checkPriority("accessibilitySelected")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setAccessibilitySelectedAttribute(value_casted)
            return this
        }
        return this
    }
    public obscured(value: Array<ObscuredReasons> | undefined): this {
        if (this.checkPriority("obscured")) {
            const value_casted = value as (Array<ObscuredReasons> | undefined)
            this.getPeer()?.setObscuredAttribute(value_casted)
            return this
        }
        return this
    }
    public reuseId(value: string | undefined): this {
        if (this.checkPriority("reuseId")) {
            const value_casted = value as (string | undefined)
            this.getPeer()?.setReuseIdAttribute(value_casted)
            return this
        }
        return this
    }
    public reuse(value: ReuseOptions | undefined): this {
        if (this.checkPriority("reuse")) {
            const value_casted = value as (ReuseOptions | undefined)
            this.getPeer()?.setReuseAttribute(value_casted)
            return this
        }
        return this
    }
    public renderFit(value: RenderFit | undefined): this {
        if (this.checkPriority("renderFit")) {
            const value_casted = value as (RenderFit | undefined)
            this.getPeer()?.setRenderFitAttribute(value_casted)
            return this
        }
        return this
    }
    public gestureModifier(value: GestureModifier | undefined): this {
        if (this.checkPriority("gestureModifier")) {
            hookGestureModifier(this, value)
        }
        return this
    }
    public backgroundBrightness(value: BackgroundBrightnessOptions | undefined): this {
        if (this.checkPriority("backgroundBrightness")) {
            const value_casted = value as (BackgroundBrightnessOptions | undefined)
            this.getPeer()?.setBackgroundBrightnessAttribute(value_casted)
            return this
        }
        return this
    }
    public onGestureJudgeBegin(value: ((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined): this {
        if (this.checkPriority("onGestureJudgeBegin")) {
            const value_casted = value as (((gestureInfo: GestureInfo,event: BaseGestureEvent) => GestureJudgeResult) | undefined)
            this.getPeer()?.setOnGestureJudgeBeginAttribute(value_casted)
            return this
        }
        return this
    }
    public onGestureRecognizerJudgeBegin(value: GestureRecognizerJudgeBeginCallback | undefined): this {
        if (this.checkPriority("onGestureRecognizerJudgeBegin")) {
            const value_casted = value as (GestureRecognizerJudgeBeginCallback | undefined)
            this.getPeer()?.setOnGestureRecognizerJudgeBegin0Attribute(value_casted)
            return this
        }
        return this
    }
    public shouldBuiltInRecognizerParallelWith(value: ShouldBuiltInRecognizerParallelWithCallback | undefined): this {
        if (this.checkPriority("shouldBuiltInRecognizerParallelWith")) {
            const value_casted = value as (ShouldBuiltInRecognizerParallelWithCallback | undefined)
            this.getPeer()?.setShouldBuiltInRecognizerParallelWithAttribute(value_casted)
            return this
        }
        return this
    }
    public monopolizeEvents(value: boolean | undefined): this {
        if (this.checkPriority("monopolizeEvents")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setMonopolizeEventsAttribute(value_casted)
            return this
        }
        return this
    }
    public onTouchIntercept(value: ((value0: TouchEvent) => HitTestMode) | undefined): this {
        if (this.checkPriority("onTouchIntercept")) {
            const value_casted = value as (((value0: TouchEvent) => HitTestMode) | undefined)
            this.getPeer()?.setOnTouchInterceptAttribute(value_casted)
            return this
        }
        return this
    }
    public onSizeChange(value: SizeChangeCallback | undefined): this {
        if (this.checkPriority("onSizeChange")) {
            const value_casted = value as (SizeChangeCallback | undefined)
            this.getPeer()?.setOnSizeChangeAttribute(value_casted)
            return this
        }
        return this
    }
    public accessibilityFocusDrawLevel(value: FocusDrawLevel | undefined): this {
        if (this.checkPriority("accessibilityFocusDrawLevel")) {
            const value_casted = value as (FocusDrawLevel | undefined)
            this.getPeer()?.setAccessibilityFocusDrawLevelAttribute(value_casted)
            return this
        }
        return this
    }
    public customProperty(name: string, value: CustomProperty): this {
        if (this.checkPriority("customProperty")) {
            hookCustomPropertyImpl(this, name, value)
        }
        return this
    }
    public expandSafeArea(types?: Array<SafeAreaType>, edges?: Array<SafeAreaEdge>): this {
        if (this.checkPriority("expandSafeArea")) {
            const types_casted = types as (Array<SafeAreaType> | undefined)
            const edges_casted = edges as (Array<SafeAreaEdge> | undefined)
            this.getPeer()?.setExpandSafeAreaAttribute(types_casted, edges_casted)
            return this
        }
        return this
    }
    public ignoreLayoutSafeArea(types?: Array<LayoutSafeAreaType>, edges?: Array<LayoutSafeAreaEdge>): this {
        if (this.checkPriority("ignoreLayoutSafeArea")) {
            const types_casted = types as (Array<LayoutSafeAreaType> | undefined)
            const edges_casted = edges as (Array<LayoutSafeAreaEdge> | undefined)
            this.getPeer()?.setIgnoreLayoutSafeAreaAttribute(types_casted, edges_casted)
            return this
        }
        return this
    }
    public background(builder: CustomBuilder | undefined, options?: BackgroundOptions): this {
        if (this.checkPriority("background")) {
            const builder_casted = builder as (CustomBuilder | undefined)
            const options_casted = options as (BackgroundOptions | undefined)
            this.getPeer()?.setBackgroundAttribute(builder_casted, options_casted)
            return this
        }
        return this
    }
    public backgroundImage(src: ResourceStr | image.PixelMap | undefined): this {
        if (this.checkPriority("backgroundImage")) {
            const src_casted = src as (ResourceStr | image.PixelMap | undefined)
            this.getPeer()?.setBackgroundImage0Attribute(src_casted)
            return this
        }
        return this
    }
    public backgroundImage(src: ResourceStr | image.PixelMap | undefined, options: BackgroundImageOptions): this {
        if (this.checkPriority("backgroundImage")) {
            const src_casted = src as (ResourceStr | image.PixelMap | undefined)
            const options_casted = options as (BackgroundImageOptions)
            this.getPeer()?.setBackgroundImage1Attribute(src_casted, options_casted)
            return this
        }
        return this
    }
    public backgroundImage(src: ResourceStr | image.PixelMap | undefined, repeat: ImageRepeat): this {
        if (this.checkPriority("backgroundImage")) {
            const src_casted = src as (ResourceStr | image.PixelMap | undefined)
            const repeat_casted = repeat as (ImageRepeat)
            this.getPeer()?.setBackgroundImage2Attribute(src_casted, repeat_casted)
            return this
        }
        return this
    }
    public backgroundBlurStyle(style: BlurStyle | undefined, options?: BackgroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        if (this.checkPriority("backgroundBlurStyle")) {
            const style_casted = style as (BlurStyle | undefined)
            const options_casted = options as (BackgroundBlurStyleOptions | undefined)
            const sysOptions_casted = sysOptions as (SystemAdaptiveOptions | undefined)
            this.getPeer()?.setBackgroundBlurStyleAttribute(style_casted, options_casted, sysOptions_casted)
            return this
        }
        return this
    }
    public backgroundEffect(options: BackgroundEffectOptions | undefined, sysOptions?: SystemAdaptiveOptions): this {
        if (this.checkPriority("backgroundEffect")) {
            const options_casted = options as (BackgroundEffectOptions | undefined)
            const sysOptions_casted = sysOptions as (SystemAdaptiveOptions | undefined)
            this.getPeer()?.setBackgroundEffect1Attribute(options_casted, sysOptions_casted)
            return this
        }
        return this
    }
    public foregroundBlurStyle(style: BlurStyle | undefined, options?: ForegroundBlurStyleOptions, sysOptions?: SystemAdaptiveOptions): this {
        if (this.checkPriority("foregroundBlurStyle")) {
            const style_casted = style as (BlurStyle | undefined)
            const options_casted = options as (ForegroundBlurStyleOptions | undefined)
            const sysOptions_casted = sysOptions as (SystemAdaptiveOptions | undefined)
            this.getPeer()?.setForegroundBlurStyleAttribute(style_casted, options_casted, sysOptions_casted)
            return this
        }
        return this
    }
    public onClick(event: ((event: ClickEvent) => void) | undefined, distanceThreshold: double | undefined): this {
        if (this.checkPriority("onClick")) {
            const event_casted = event as (((event: ClickEvent) => void) | undefined)
            const distanceThreshold_casted = distanceThreshold as (double | undefined)
            this.getPeer()?.setOnClick1Attribute(event_casted, distanceThreshold_casted)
            return this
        }
        return this
    }
    public focusScopeId(id: string | undefined, isGroup?: boolean, arrowStepOut?: boolean): this {
        if (this.checkPriority("focusScopeId")) {
            const id_casted = id as (string | undefined)
            const isGroup_casted = isGroup as (boolean | undefined)
            const arrowStepOut_casted = arrowStepOut as (boolean | undefined)
            this.getPeer()?.setFocusScopeIdAttribute(id_casted, isGroup_casted, arrowStepOut_casted)
            return this
        }
        return this
    }
    public focusScopePriority(scopeId: string | undefined, priority?: FocusPriority): this {
        if (this.checkPriority("focusScopePriority")) {
            const scopeId_casted = scopeId as (string | undefined)
            const priority_casted = priority as (FocusPriority | undefined)
            this.getPeer()?.setFocusScopePriorityAttribute(scopeId_casted, priority_casted)
            return this
        }
        return this
    }
    public transition(effect: TransitionEffect | undefined, onFinish: TransitionFinishCallback | undefined): this {
        if (this.checkPriority("transition")) {
            const effect_casted = effect as (TransitionEffect | undefined)
            const onFinish_casted = onFinish as (TransitionFinishCallback | undefined)
            this.getPeer()?.setTransition1Attribute(effect_casted, onFinish_casted)
            return this
        }
        return this
    }
    public gesture(gesture: GestureType, mask?: GestureMask): this {
        if (this.checkPriority("gesture")) {
            hookGesture(this, gesture, mask)
        }
        return this
    }
    public priorityGesture(gesture: GestureType, mask?: GestureMask): this {
        if (this.checkPriority("priorityGesture")) {
            hookPriorityGesture(this, gesture, mask)
        }
        return this
    }
    public parallelGesture(gesture: GestureType, mask?: GestureMask): this {
        if (this.checkPriority("parallelGesture")) {
            hookParallelGesture(this, gesture, mask)
        }
        return this
    }
    public blur(blurRadius: double | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        if (this.checkPriority("blur")) {
            const blurRadius_casted = blurRadius as (double | undefined)
            const options_casted = options as (BlurOptions | undefined)
            const sysOptions_casted = sysOptions as (SystemAdaptiveOptions | undefined)
            this.getPeer()?.setBlurAttribute(blurRadius_casted, options_casted, sysOptions_casted)
            return this
        }
        return this
    }
    public linearGradientBlur(value: double | undefined, options: LinearGradientBlurOptions | undefined): this {
        if (this.checkPriority("linearGradientBlur")) {
            const value_casted = value as (double | undefined)
            const options_casted = options as (LinearGradientBlurOptions | undefined)
            this.getPeer()?.setLinearGradientBlurAttribute(value_casted, options_casted)
            return this
        }
        return this
    }
    public systemBarEffect(): this {
        if (this.checkPriority("systemBarEffect")) {
            this.getPeer()?.setSystemBarEffectAttribute()
            return this
        }
        return this
    }
    public useEffect(useEffect: boolean | undefined, effectType: EffectType | undefined): this {
        if (this.checkPriority("useEffect")) {
            const useEffect_casted = useEffect as (boolean | undefined)
            const effectType_casted = effectType as (EffectType | undefined)
            this.getPeer()?.setUseEffect1Attribute(useEffect_casted, effectType_casted)
            return this
        }
        return this
    }
    public backdropBlur(radius: double | undefined, options?: BlurOptions, sysOptions?: SystemAdaptiveOptions): this {
        if (this.checkPriority("backdropBlur")) {
            const radius_casted = radius as (double | undefined)
            const options_casted = options as (BlurOptions | undefined)
            const sysOptions_casted = sysOptions as (SystemAdaptiveOptions | undefined)
            this.getPeer()?.setBackdropBlurAttribute(radius_casted, options_casted, sysOptions_casted)
            return this
        }
        return this
    }
    public sharedTransition(id: string | undefined, options?: sharedTransitionOptions): this {
        if (this.checkPriority("sharedTransition")) {
            const id_casted = id as (string | undefined)
            const options_casted = options as (sharedTransitionOptions | undefined)
            this.getPeer()?.setSharedTransitionAttribute(id_casted, options_casted)
            return this
        }
        return this
    }
    public chainMode(direction: Axis | undefined, style: ChainStyle | undefined): this {
        if (this.checkPriority("chainMode")) {
            const direction_casted = direction as (Axis | undefined)
            const style_casted = style as (ChainStyle | undefined)
            this.getPeer()?.setChainModeAttribute(direction_casted, style_casted)
            return this
        }
        return this
    }
    public onDrop(eventCallback: OnDragEventCallback | undefined, dropOptions?: DropOptions): this {
        if (this.checkPriority("onDrop")) {
            const eventCallback_casted = eventCallback as (OnDragEventCallback | undefined)
            const dropOptions_casted = dropOptions as (DropOptions | undefined)
            this.getPeer()?.setOnDrop1Attribute(eventCallback_casted, dropOptions_casted)
            return this
        }
        return this
    }
    public dragPreview(preview: CustomBuilder | DragItemInfo | string | undefined, config?: PreviewConfiguration): this {
        if (this.checkPriority("dragPreview")) {
            const preview_casted = preview as (CustomBuilder | DragItemInfo | string | undefined)
            const config_casted = config as (PreviewConfiguration | undefined)
            this.getPeer()?.setDragPreview1Attribute(preview_casted, config_casted)
            return this
        }
        return this
    }
    public dragPreviewOptions(value: DragPreviewOptions | undefined, options?: DragInteractionOptions): this {
        if (this.checkPriority("dragPreviewOptions")) {
            hookDragPreviewOptions(this, value, options)
            return this
        }
        return this
    }
    public overlay(value: string | CustomBuilder | ComponentContent | undefined, options?: OverlayOptions): this {
        if (this.checkPriority("overlay")) {
            const value_casted = value as (string | CustomBuilder | ComponentContent | undefined)
            const options_casted = options as (OverlayOptions | undefined)
            this.getPeer()?.setOverlayAttribute(value_casted, options_casted)
            return this
        }
        return this
    }
    public blendMode(value: BlendMode | undefined, type?: BlendApplyType): this {
        if (this.checkPriority("blendMode")) {
            const value_casted = value as (BlendMode | undefined)
            const type_casted = type as (BlendApplyType | undefined)
            this.getPeer()?.setBlendModeAttribute(value_casted, type_casted)
            return this
        }
        return this
    }
    public advancedBlendMode(effect: BlendMode | uiEffect.Blender, type?: BlendApplyType): this {
        if (this.checkPriority("advancedBlendMode")) {
            const effect_casted = effect as (BlendMode | uiEffect.Blender)
            const type_casted = type as (BlendApplyType | undefined)
            this.getPeer()?.setAdvancedBlendModeAttribute(effect_casted, type_casted)
            return this
        }
        return this
    }
    public geometryTransition(id: string | undefined, options?: GeometryTransitionOptions): this {
        if (this.checkPriority("geometryTransition")) {
            const id_casted = id as (string | undefined)
            const options_casted = options as (GeometryTransitionOptions | undefined)
            this.getPeer()?.setGeometryTransition1Attribute(id_casted, options_casted)
            return this
        }
        return this
    }
    public bindTips(message: TipsMessageType | undefined, options?: TipsOptions): this {
        if (this.checkPriority("bindTips")) {
            const message_casted = message as (TipsMessageType | undefined)
            const options_casted = options as (TipsOptions | undefined)
            this.getPeer()?.setBindTipsAttribute(message_casted, options_casted)
            return this
        }
        return this
    }
    public bindPopup(show: boolean | undefined, popup: PopupOptions | CustomPopupOptions | undefined): this {
        if (this.checkPriority("bindPopup")) {
            const show_casted = show as (boolean | undefined)
            const popup_casted = popup as (PopupOptions | CustomPopupOptions | undefined)
            this.getPeer()?.setBindPopupAttribute(show_casted, popup_casted)
            return this
        }
        return this
    }
    public bindMenu(content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): this {
        if (this.checkPriority("bindMenu")) {
            const content_casted = content as (Array<MenuElement> | CustomBuilder | undefined)
            const options_casted = options as (MenuOptions | undefined)
            this.getPeer()?.setBindMenu0Attribute(content_casted, options_casted)
            return this
        }
        return this
    }
    public bindMenu(isShow: boolean | undefined, content: Array<MenuElement> | CustomBuilder | undefined, options?: MenuOptions): this {
        if (this.checkPriority("bindMenu")) {
            const isShow_casted = isShow as (boolean | undefined)
            const content_casted = content as (Array<MenuElement> | CustomBuilder | undefined)
            const options_casted = options as (MenuOptions | undefined)
            this.getPeer()?.setBindMenu1Attribute(isShow_casted, content_casted, options_casted)
            return this
        }
        return this
    }
    public bindContextMenu(content: CustomBuilder | undefined, responseType: ResponseType | undefined, options?: ContextMenuOptions): this {
        if (this.checkPriority("bindContextMenu")) {
            const content_casted = content as (CustomBuilder | undefined)
            const responseType_casted = responseType as (ResponseType | undefined)
            const options_casted = options as (ContextMenuOptions | undefined)
            this.getPeer()?.setBindContextMenu0Attribute(content_casted, responseType_casted, options_casted)
            return this
        }
        return this
    }
    public bindContextMenu(isShown: boolean | undefined, content: CustomBuilder | undefined, options?: ContextMenuOptions): this {
        if (this.checkPriority("bindContextMenu")) {
            const isShown_casted = isShown as (boolean | undefined)
            const content_casted = content as (CustomBuilder | undefined)
            const options_casted = options as (ContextMenuOptions | undefined)
            this.getPeer()?.setBindContextMenu1Attribute(isShown_casted, content_casted, options_casted)
            return this
        }
        return this
    }
    public bindContentCover(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, type?: ModalTransition): this {
        if (this.checkPriority("bindContentCover")) {
            const isShow_casted = isShow as (boolean | Bindable<boolean> | undefined)
            const builder_casted = builder as (CustomBuilder | undefined)
            const type_casted = type as (ModalTransition | undefined)
            this.getPeer()?.setBindContentCover0Attribute(isShow_casted, builder_casted, type_casted)
            return this
        }
        return this
    }
    public bindContentCover(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, options?: ContentCoverOptions): this {
        if (this.checkPriority("bindContentCover")) {
            const isShow_casted = isShow as (boolean | Bindable<boolean> | undefined)
            const builder_casted = builder as (CustomBuilder | undefined)
            const options_casted = options as (ContentCoverOptions | undefined)
            this.getPeer()?.setBindContentCover1Attribute(isShow_casted, builder_casted, options_casted)
            return this
        }
        return this
    }
    public bindSheet(isShow: boolean | Bindable<boolean> | undefined, builder: CustomBuilder | undefined, options?: SheetOptions): this {
        if (this.checkPriority("bindSheet")) {
            const isShow_casted = isShow as (boolean | Bindable<boolean> | undefined)
            const builder_casted = builder as (CustomBuilder | undefined)
            const options_casted = options as (SheetOptions | undefined)
            this.getPeer()?.setBindSheetAttribute(isShow_casted, builder_casted, options_casted)
            return this
        }
        return this
    }
    public onVisibleAreaChange(ratios: Array<double> | undefined, event: VisibleAreaChangeCallback | undefined): this {
        if (this.checkPriority("onVisibleAreaChange")) {
            const ratios_casted = ratios as (Array<double> | undefined)
            const event_casted = event as (VisibleAreaChangeCallback | undefined)
            this.getPeer()?.setOnVisibleAreaChangeAttribute(ratios_casted, event_casted)
            return this
        }
        return this
    }
    public onVisibleAreaApproximateChange(options: VisibleAreaEventOptions | undefined, event: VisibleAreaChangeCallback | undefined): this {
        if (this.checkPriority("onVisibleAreaApproximateChange")) {
            const options_casted = options as (VisibleAreaEventOptions | undefined)
            const event_casted = event as (VisibleAreaChangeCallback | undefined)
            this.getPeer()?.setOnVisibleAreaApproximateChangeAttribute(options_casted, event_casted)
            return this
        }
        return this
    }
    public keyboardShortcut(value: string | FunctionKey | undefined, keys: Array<ModifierKey> | undefined, action?: (() => void)): this {
        if (this.checkPriority("keyboardShortcut")) {
            const value_casted = value as (string | FunctionKey | undefined)
            const keys_casted = keys as (Array<ModifierKey> | undefined)
            const action_casted = action as ((() => void) | undefined)
            this.getPeer()?.setKeyboardShortcutAttribute(value_casted, keys_casted, action_casted)
            return this
        }
        return this
    }
    public accessibilityGroupWithConfig(isGroup: boolean | undefined, config: AccessibilityOptions | undefined): this {
        if (this.checkPriority("accessibilityGroupWithConfig")) {
            const isGroup_casted = isGroup as (boolean | undefined)
            const config_casted = config as (AccessibilityOptions | undefined)
            this.getPeer()?.setAccessibilityGroupWithConfigAttribute(isGroup_casted, config_casted)
            return this
        }
        return this
    }
    public accessibilityGroup(isGroup: boolean | undefined, accessibilityOptions?: AccessibilityOptions): this {
        if (this.checkPriority("accessibilityGroup")) {
            const isGroup_casted = isGroup as (boolean | undefined)
            const config_casted = accessibilityOptions as (AccessibilityOptions | undefined)
            this.getPeer()?.setAccessibilityGroupWithConfigAttribute(isGroup_casted, config_casted)
            return this
        }
        return this
    }
    public onGestureRecognizerJudgeBegin(callback_: GestureRecognizerJudgeBeginCallback | undefined, exposeInnerGesture: boolean | undefined): this {
        if (this.checkPriority("onGestureRecognizerJudgeBegin")) {
            const callback__casted = callback_ as (GestureRecognizerJudgeBeginCallback | undefined)
            const exposeInnerGesture_casted = exposeInnerGesture as (boolean | undefined)
            this.getPeer()?.setOnGestureRecognizerJudgeBegin1Attribute(callback__casted, exposeInnerGesture_casted)
            return this
        }
        return this
    }
    public attributeModifier(value: AttributeModifier<CommonMethod> | undefined): this {
        hookCommonMethodAttributeModifier(this, value);
        return this
    }
    public applyAttributesFinish(): void {
        // we call this function outside of class, so need to make it public
        super.applyAttributesFinish()
    }
    public applyOptionsFinish(traceName: string): void {
        super.applyOptionsFinish(traceName)
    }
}
export class ArkCommonShapeMethodComponent extends ArkCommonMethodComponent implements CommonShapeMethod {
    getPeer(): ArkCommonShapeMethodPeer {
        if (!this.peer) {
            throw new Error("Attribute function should be called in memo context")
        }
        return (this.peer as ArkCommonShapeMethodPeer)
    }
    public stroke(value: ResourceColor | undefined): this {
        if (this.checkPriority("stroke")) {
            const value_casted = value as (ResourceColor | undefined)
            this.getPeer()?.setStrokeAttribute(value_casted)
            return this
        }
        return this
    }
    public fill(value: ResourceColor | undefined): this {
        if (this.checkPriority("fill")) {
            const value_casted = value as (ResourceColor | undefined)
            this.getPeer()?.setFillAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeDashOffset(value: number | string | undefined): this {
        if (this.checkPriority("strokeDashOffset")) {
            const value_casted = value as (number | string | undefined)
            this.getPeer()?.setStrokeDashOffsetAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeLineCap(value: LineCapStyle | undefined): this {
        if (this.checkPriority("strokeLineCap")) {
            const value_casted = value as (LineCapStyle | undefined)
            this.getPeer()?.setStrokeLineCapAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeLineJoin(value: LineJoinStyle | undefined): this {
        if (this.checkPriority("strokeLineJoin")) {
            const value_casted = value as (LineJoinStyle | undefined)
            this.getPeer()?.setStrokeLineJoinAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeMiterLimit(value: number | string | undefined): this {
        if (this.checkPriority("strokeMiterLimit")) {
            const value_casted = value as (number | string | undefined)
            this.getPeer()?.setStrokeMiterLimitAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeOpacity(value: number | string | Resource | undefined): this {
        if (this.checkPriority("strokeOpacity")) {
            const value_casted = value as (number | string | Resource | undefined)
            this.getPeer()?.setStrokeOpacityAttribute(value_casted)
            return this
        }
        return this
    }
    public fillOpacity(value: number | string | Resource | undefined): this {
        if (this.checkPriority("fillOpacity")) {
            const value_casted = value as (number | string | Resource | undefined)
            this.getPeer()?.setFillOpacityAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeWidth(value: Length | undefined): this {
        if (this.checkPriority("strokeWidth")) {
            const value_casted = value as (Length | undefined)
            this.getPeer()?.setStrokeWidthAttribute(value_casted)
            return this
        }
        return this
    }
    public antiAlias(value: boolean | undefined): this {
        if (this.checkPriority("antiAlias")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setAntiAliasAttribute(value_casted)
            return this
        }
        return this
    }
    public strokeDashArray(value: Array<Length> | undefined): this {
        if (this.checkPriority("strokeDashArray")) {
            const value_casted = value as (Array<Length> | undefined)
            this.getPeer()?.setStrokeDashArrayAttribute(value_casted)
            return this
        }
        return this
    }
    public attributeModifier(value: AttributeModifier<CommonShapeMethod> | AttributeModifier<CommonMethod> | undefined): this {
        hookCommonShapeMethodAttributeModifier(this, value);
        return this
    }
    public applyAttributesFinish(): void {
        // we call this function outside of class, so need to make it public
        super.applyAttributesFinish()
    }
    public applyOptionsFinish(traceName: string): void {
        super.applyOptionsFinish(traceName)
    }
}
export class ArkScrollableCommonMethodComponent extends ArkCommonMethodComponent implements ScrollableCommonMethod {
    getPeer(): ArkScrollableCommonMethodPeer {
        if (!this.peer) {
            throw new Error("Attribute function should be called in memo context")
        }
        return (this.peer as ArkScrollableCommonMethodPeer)
    }
    public scrollBar(value: BarState | undefined): this {
        if (this.checkPriority("scrollBar")) {
            const value_casted = value as (BarState | undefined)
            this.getPeer()?.setScrollBarAttribute(value_casted)
            return this
        }
        return this
    }
    public scrollBarColor(value: Color | int32 | string | undefined): this {
        if (this.checkPriority("scrollBarColor")) {
            const value_casted = value as (Color | int32 | string | undefined)
            this.getPeer()?.setScrollBarColorAttribute(value_casted)
            return this
        }
        return this
    }
    public scrollBarWidth(value: double | string | undefined): this {
        if (this.checkPriority("scrollBarWidth")) {
            const value_casted = value as (double | string | undefined)
            this.getPeer()?.setScrollBarWidthAttribute(value_casted)
            return this
        }
        return this
    }
    public nestedScroll(value: NestedScrollOptions | undefined): this {
        if (this.checkPriority("nestedScroll")) {
            const value_casted = value as (NestedScrollOptions | undefined)
            this.getPeer()?.setNestedScrollAttribute(value_casted)
            return this
        }
        return this
    }
    public enableScrollInteraction(value: boolean | undefined): this {
        if (this.checkPriority("enableScrollInteraction")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setEnableScrollInteractionAttribute(value_casted)
            return this
        }
        return this
    }
    public friction(value: double | Resource | undefined): this {
        if (this.checkPriority("friction")) {
            const value_casted = value as (double | Resource | undefined)
            this.getPeer()?.setFrictionAttribute(value_casted)
            return this
        }
        return this
    }
    public onReachStart(value: (() => void) | undefined): this {
        if (this.checkPriority("onReachStart")) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnReachStartAttribute(value_casted)
            return this
        }
        return this
    }
    public onReachEnd(value: (() => void) | undefined): this {
        if (this.checkPriority("onReachEnd")) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnReachEndAttribute(value_casted)
            return this
        }
        return this
    }
    public onScrollStart(value: (() => void) | undefined): this {
        if (this.checkPriority("onScrollStart")) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnScrollStartAttribute(value_casted)
            return this
        }
        return this
    }
    public onScrollStop(value: (() => void) | undefined): this {
        if (this.checkPriority("onScrollStop")) {
            const value_casted = value as ((() => void) | undefined)
            this.getPeer()?.setOnScrollStopAttribute(value_casted)
            return this
        }
        return this
    }
    public flingSpeedLimit(value: double | undefined): this {
        if (this.checkPriority("flingSpeedLimit")) {
            const value_casted = value as (double | undefined)
            this.getPeer()?.setFlingSpeedLimitAttribute(value_casted)
            return this
        }
        return this
    }
    public clipContent(value: ContentClipMode | RectShape | undefined): this {
        if (this.checkPriority("clipContent")) {
            const value_casted = value as (ContentClipMode | RectShape | undefined)
            this.getPeer()?.setClipContentAttribute(value_casted)
            return this
        }
        return this
    }
    public digitalCrownSensitivity(value: CrownSensitivity | undefined): this {
        if (this.checkPriority("digitalCrownSensitivity")) {
            const value_casted = value as (CrownSensitivity | undefined)
            this.getPeer()?.setDigitalCrownSensitivityAttribute(value_casted)
            return this
        }
        return this
    }
    public backToTop(value: boolean | undefined): this {
        if (this.checkPriority("backToTop")) {
            const value_casted = value as (boolean | undefined)
            this.getPeer()?.setBackToTopAttribute(value_casted)
            return this
        }
        return this
    }
    public edgeEffect(edgeEffect: EdgeEffect | undefined, options?: EdgeEffectOptions): this {
        if (this.checkPriority("edgeEffect")) {
            const edgeEffect_casted = edgeEffect as (EdgeEffect | undefined)
            const options_casted = options as (EdgeEffectOptions | undefined)
            this.getPeer()?.setEdgeEffectAttribute(edgeEffect_casted, options_casted)
            return this
        }
        return this
    }
    public fadingEdge(enabled: boolean | undefined, options?: FadingEdgeOptions): this {
        if (this.checkPriority("fadingEdge")) {
            const enabled_casted = enabled as (boolean | undefined)
            const options_casted = options as (FadingEdgeOptions | undefined)
            this.getPeer()?.setFadingEdgeAttribute(enabled_casted, options_casted)
            return this
        }
        return this
    }
    public attributeModifier(value: AttributeModifier<ScrollableCommonMethod> | AttributeModifier<CommonMethod> | undefined): this {
        hookScrollableCommonMethodAttributeModifier(this, value);
        return this
    }
    public applyAttributesFinish(): void {
        // we call this function outside of class, so need to make it public
        super.applyAttributesFinish()
    }
    public applyOptionsFinish(traceName: string): void {
        super.applyOptionsFinish(traceName)
    }
}
export function postCardAction(component: Object, action: Object): void {
    GlobalScope.postCardAction(component, action)
}
export function $r(value: string, params: Array<Object | null | undefined>): Resource {
    return GlobalScope.$r(value, params)
}
export function $rawfile(value: string): Resource {
    return GlobalScope.$rawfile(value)
}
export function animateTo(value: AnimateParam, event: (() => void)): void {
    // instructive change start
    AnimationExtender.AnimateToImmediatelyImpl(value, event, false)
    // instructive change end
}
export function animateToImmediately(value: AnimateParam, event: (() => void)): void {
    // instructive change start
    AnimationExtender.AnimateToImmediatelyImpl(value, event, true)
    // instructive change end
}
export function vp2px(value: number): number {
    return GlobalScope.vp2px(value)
}
export function px2vp(value: number): number {
    return GlobalScope.px2vp(value)
}
export class ForegroundEffectOptions_serializer {
    public static write(buffer: SerializerBase, value: ForegroundEffectOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForRadius  = value.radius
        valueSerializer.writeFloat64(valueHolderForRadius)
    }
    public static read(buffer: DeserializerBase): ForegroundEffectOptions {
        let valueDeserializer : DeserializerBase = buffer
        const radiusTmpResult : double = valueDeserializer.readFloat64()
        let value : ForegroundEffectOptions = ({radius: radiusTmpResult} as ForegroundEffectOptions)
        return value
    }
}
export class InvertOptions_serializer {
    public static write(buffer: SerializerBase, value: InvertOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForLow  = value.low
        valueSerializer.writeFloat64(valueHolderForLow)
        const valueHolderForHigh  = value.high
        valueSerializer.writeFloat64(valueHolderForHigh)
        const valueHolderForThreshold  = value.threshold
        valueSerializer.writeFloat64(valueHolderForThreshold)
        const valueHolderForThresholdRange  = value.thresholdRange
        valueSerializer.writeFloat64(valueHolderForThresholdRange)
    }
    public static read(buffer: DeserializerBase): InvertOptions {
        let valueDeserializer : DeserializerBase = buffer
        const lowTmpResult : double = valueDeserializer.readFloat64()
        const highTmpResult : double = valueDeserializer.readFloat64()
        const thresholdTmpResult : double = valueDeserializer.readFloat64()
        const thresholdRangeTmpResult : double = valueDeserializer.readFloat64()
        let value : InvertOptions = ({low: lowTmpResult, high: highTmpResult, threshold: thresholdTmpResult, thresholdRange: thresholdRangeTmpResult} as InvertOptions)
        return value
    }
}
export class LayoutPolicy_serializer {
    public static write(buffer: SerializerBase, value: LayoutPolicy): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): LayoutPolicy {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return LayoutPolicyInternal.fromPtr(ptr)
    }
}
export class MotionBlurAnchor_serializer {
    public static write(buffer: SerializerBase, value: MotionBlurAnchor): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForX  = value.x
        valueSerializer.writeFloat64(valueHolderForX)
        const valueHolderForY  = value.y
        valueSerializer.writeFloat64(valueHolderForY)
    }
    public static read(buffer: DeserializerBase): MotionBlurAnchor {
        let valueDeserializer : DeserializerBase = buffer
        const xTmpResult : double = valueDeserializer.readFloat64()
        const yTmpResult : double = valueDeserializer.readFloat64()
        let value : MotionBlurAnchor = ({x: xTmpResult, y: yTmpResult} as MotionBlurAnchor)
        return value
    }
}
export class NestedScrollOptions_serializer {
    public static write(buffer: SerializerBase, value: NestedScrollOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForScrollForward  = value.scrollForward
        valueSerializer.writeInt32(valueHolderForScrollForward.valueOf())
        const valueHolderForScrollBackward  = value.scrollBackward
        valueSerializer.writeInt32(valueHolderForScrollBackward.valueOf())
    }
    public static read(buffer: DeserializerBase): NestedScrollOptions {
        let valueDeserializer : DeserializerBase = buffer
        const scrollForwardTmpResult : NestedScrollMode = NestedScrollMode.fromValue(valueDeserializer.readInt32())
        const scrollBackwardTmpResult : NestedScrollMode = NestedScrollMode.fromValue(valueDeserializer.readInt32())
        let value : NestedScrollOptions = ({scrollForward: scrollForwardTmpResult, scrollBackward: scrollBackwardTmpResult} as NestedScrollOptions)
        return value
    }
}
export class PixelMapMock_serializer {
    public static write(buffer: SerializerBase, value: PixelMapMock): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): PixelMapMock {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return PixelMapMockInternal.fromPtr(ptr)
    }
}
export class PopupStateChangeParam_serializer {
    public static write(buffer: SerializerBase, value: PopupStateChangeParam): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForIsVisible  = value.isVisible
        valueSerializer.writeBoolean(valueHolderForIsVisible)
    }
    public static read(buffer: DeserializerBase): PopupStateChangeParam {
        let valueDeserializer : DeserializerBase = buffer
        const isVisibleTmpResult : boolean = valueDeserializer.readBoolean()
        let value : PopupStateChangeParam = ({isVisible: isVisibleTmpResult} as PopupStateChangeParam)
        return value
    }
}
export class ProgressMask_serializer {
    public static write(buffer: SerializerBase, value: ProgressMask): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): ProgressMask {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return ProgressMaskInternal.fromPtr(ptr)
    }
}
export class RectResult_serializer {
    public static write(buffer: SerializerBase, value: RectResult): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForX  = value.x
        valueSerializer.writeFloat64(valueHolderForX)
        const valueHolderForY  = value.y
        valueSerializer.writeFloat64(valueHolderForY)
        const valueHolderForWidth  = value.width
        valueSerializer.writeFloat64(valueHolderForWidth)
        const valueHolderForHeight  = value.height
        valueSerializer.writeFloat64(valueHolderForHeight)
    }
    public static read(buffer: DeserializerBase): RectResult {
        let valueDeserializer : DeserializerBase = buffer
        const xTmpResult : double = valueDeserializer.readFloat64()
        const yTmpResult : double = valueDeserializer.readFloat64()
        const widthTmpResult : double = valueDeserializer.readFloat64()
        const heightTmpResult : double = valueDeserializer.readFloat64()
        let value : RectResult = ({x: xTmpResult, y: yTmpResult, width: widthTmpResult, height: heightTmpResult} as RectResult)
        return value
    }
}
export class ScrollResult_serializer {
    public static write(buffer: SerializerBase, value: ScrollResult): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): ScrollResult {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return ScrollResultInternal.fromPtr(ptr)
    }
}
export class SizeResult_serializer {
    public static write(buffer: SerializerBase, value: SizeResult): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForWidth  = value.width
        valueSerializer.writeNumber(valueHolderForWidth)
        const valueHolderForHeight  = value.height
        valueSerializer.writeNumber(valueHolderForHeight)
    }
    public static read(buffer: DeserializerBase): SizeResult {
        let valueDeserializer : DeserializerBase = buffer
        const widthTmpResult : number = (valueDeserializer.readNumber() as number)
        const heightTmpResult : number = (valueDeserializer.readNumber() as number)
        let value : SizeResult = ({width: widthTmpResult, height: heightTmpResult} as SizeResult)
        return value
    }
}
export class TextContentControllerBase_serializer {
    public static write(buffer: SerializerBase, value: TextContentControllerBase): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): TextContentControllerBase {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return TextContentControllerBaseInternal.fromPtr(ptr)
    }
}
export class TouchTestInfo_serializer {
    public static write(buffer: SerializerBase, value: TouchTestInfo): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForWindowX  = value.windowX
        valueSerializer.writeFloat64(valueHolderForWindowX)
        const valueHolderForWindowY  = value.windowY
        valueSerializer.writeFloat64(valueHolderForWindowY)
        const valueHolderForParentX  = value.parentX
        valueSerializer.writeFloat64(valueHolderForParentX)
        const valueHolderForParentY  = value.parentY
        valueSerializer.writeFloat64(valueHolderForParentY)
        const valueHolderForX  = value.x
        valueSerializer.writeFloat64(valueHolderForX)
        const valueHolderForY  = value.y
        valueSerializer.writeFloat64(valueHolderForY)
        const valueHolderForRect  = value.rect
        RectResult_serializer.write(valueSerializer, valueHolderForRect)
        const valueHolderForId  = value.id
        valueSerializer.writeString(valueHolderForId)
    }
    public static read(buffer: DeserializerBase): TouchTestInfo {
        let valueDeserializer : DeserializerBase = buffer
        const windowXTmpResult : double = valueDeserializer.readFloat64()
        const windowYTmpResult : double = valueDeserializer.readFloat64()
        const parentXTmpResult : double = valueDeserializer.readFloat64()
        const parentYTmpResult : double = valueDeserializer.readFloat64()
        const xTmpResult : double = valueDeserializer.readFloat64()
        const yTmpResult : double = valueDeserializer.readFloat64()
        const rectTmpResult : RectResult = RectResult_serializer.read(valueDeserializer)
        const idTmpResult : string = (valueDeserializer.readString() as string)
        let value : TouchTestInfo = ({windowX: windowXTmpResult, windowY: windowYTmpResult, parentX: parentXTmpResult, parentY: parentYTmpResult, x: xTmpResult, y: yTmpResult, rect: rectTmpResult, id: idTmpResult} as TouchTestInfo)
        return value
    }
}
export class TransitionEffect_serializer {
    public static write(buffer: SerializerBase, value: TransitionEffect): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): TransitionEffect {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return TransitionEffectInternal.fromPtr(ptr)
    }
}
export class UICommonEvent_serializer {
    public static write(buffer: SerializerBase, value: UICommonEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): UICommonEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return UICommonEventInternal.fromPtr(ptr)
    }
}
export class VerticalAlignParam_serializer {
    public static write(buffer: SerializerBase, value: VerticalAlignParam): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAnchor  = value.anchor
        valueSerializer.writeString(valueHolderForAnchor)
        const valueHolderForAlign  = value.align
        valueSerializer.writeInt32(valueHolderForAlign.valueOf())
    }
    public static read(buffer: DeserializerBase): VerticalAlignParam {
        let valueDeserializer : DeserializerBase = buffer
        const anchorTmpResult : string = (valueDeserializer.readString() as string)
        const alignTmpResult : VerticalAlign = VerticalAlign.fromValue(valueDeserializer.readInt32())
        let value : VerticalAlignParam = ({anchor: anchorTmpResult, align: alignTmpResult} as VerticalAlignParam)
        return value
    }
}
export class AsymmetricTransitionOption_serializer {
    public static write(buffer: SerializerBase, value: AsymmetricTransitionOption): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAppear  = value.appear
        TransitionEffect_serializer.write(valueSerializer, valueHolderForAppear)
        const valueHolderForDisappear  = value.disappear
        TransitionEffect_serializer.write(valueSerializer, valueHolderForDisappear)
    }
    public static read(buffer: DeserializerBase): AsymmetricTransitionOption {
        let valueDeserializer : DeserializerBase = buffer
        const appearTmpResult : TransitionEffect = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        const disappearTmpResult : TransitionEffect = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        let value : AsymmetricTransitionOption = ({appear: appearTmpResult, disappear: disappearTmpResult} as AsymmetricTransitionOption)
        return value
    }
}
export class BackgroundBrightnessOptions_serializer {
    public static write(buffer: SerializerBase, value: BackgroundBrightnessOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForRate  = value.rate
        valueSerializer.writeFloat64(valueHolderForRate)
        const valueHolderForLightUpDegree  = value.lightUpDegree
        valueSerializer.writeFloat64(valueHolderForLightUpDegree)
    }
    public static read(buffer: DeserializerBase): BackgroundBrightnessOptions {
        let valueDeserializer : DeserializerBase = buffer
        const rateTmpResult : double = valueDeserializer.readFloat64()
        const lightUpDegreeTmpResult : double = valueDeserializer.readFloat64()
        let value : BackgroundBrightnessOptions = ({rate: rateTmpResult, lightUpDegree: lightUpDegreeTmpResult} as BackgroundBrightnessOptions)
        return value
    }
}
export class BackgroundImageOptions_serializer {
    public static write(buffer: SerializerBase, value: BackgroundImageOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForSyncLoad  = value.syncLoad
        if (valueHolderForSyncLoad !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForSyncLoadTmpValue  = valueHolderForSyncLoad!
            valueSerializer.writeBoolean(valueHolderForSyncLoadTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRepeat  = value.repeat
        if (valueHolderForRepeat !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRepeatTmpValue  = (valueHolderForRepeat as ImageRepeat)
            valueSerializer.writeInt32(valueHolderForRepeatTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): BackgroundImageOptions {
        let valueDeserializer : DeserializerBase = buffer
        const syncLoadTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let syncLoadTmpBuf : boolean | undefined = undefined
        if ((syncLoadTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            syncLoadTmpBuf = valueDeserializer.readBoolean()
        }
        const syncLoadTmpResult : boolean | undefined = syncLoadTmpBuf
        const repeatTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let repeatTmpBuf : ImageRepeat | undefined = undefined
        if ((repeatTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            repeatTmpBuf = ImageRepeat.fromValue(valueDeserializer.readInt32())
        }
        const repeatTmpResult : ImageRepeat | undefined = repeatTmpBuf
        let value : BackgroundImageOptions = ({syncLoad: syncLoadTmpResult, repeat: repeatTmpResult} as BackgroundImageOptions)
        return value
    }
}
export class BackgroundOptions_serializer {
    public static write(buffer: SerializerBase, value: BackgroundOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAlign  = value.align
        if (valueHolderForAlign !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAlignTmpValue  = (valueHolderForAlign as Alignment)
            valueSerializer.writeInt32(valueHolderForAlignTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): BackgroundOptions {
        let valueDeserializer : DeserializerBase = buffer
        const alignTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let alignTmpBuf : Alignment | undefined = undefined
        if ((alignTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            alignTmpBuf = Alignment.fromValue(valueDeserializer.readInt32())
        }
        const alignTmpResult : Alignment | undefined = alignTmpBuf
        let value : BackgroundOptions = ({align: alignTmpResult} as BackgroundOptions)
        return value
    }
}
export class Bindable_Array_Arkui_Component_Units_ResourceStr_serializer {
    public static write(buffer: SerializerBase, value: Bindable<Array<ResourceStr>>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeInt32((valueHolderForValue.length).toInt())
        for (let valueHolderForValueCounterI = 0; valueHolderForValueCounterI < valueHolderForValue.length; valueHolderForValueCounterI++) {
            const valueHolderForValueTmpElement : ResourceStr = valueHolderForValue[valueHolderForValueCounterI]
            if (valueHolderForValueTmpElement instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForValueTmpElementForIdx0  = valueHolderForValueTmpElement as string
                valueSerializer.writeString(valueHolderForValueTmpElementForIdx0)
            } else if (valueHolderForValueTmpElement instanceof Resource) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForValueTmpElementForIdx1  = valueHolderForValueTmpElement as Resource
                Resource_serializer.write(valueSerializer, valueHolderForValueTmpElementForIdx1)
            }
        }
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<Array<ResourceStr>> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpBufLength : int32 = valueDeserializer.readInt32()
        let valueTmpBuf : Array<ResourceStr> = new Array<ResourceStr>(valueTmpBufLength)
        for (let valueTmpBufBufCounterI = 0; valueTmpBufBufCounterI < valueTmpBufLength; valueTmpBufBufCounterI++) {
            const valueTmpBufTempBufUnionSelector : int32 = valueDeserializer.readInt8()
            let valueTmpBufTempBuf : string | Resource | undefined
            if (valueTmpBufTempBufUnionSelector == (0).toChar()) {
                valueTmpBufTempBuf = (valueDeserializer.readString() as string)
            } else if (valueTmpBufTempBufUnionSelector == (1).toChar()) {
                valueTmpBufTempBuf = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for valueTmpBufTempBuf has to be chosen through deserialisation.")
            }
            valueTmpBuf[valueTmpBufBufCounterI] = (valueTmpBufTempBuf as string | Resource)
        }
        const valueTmpResult : Array<ResourceStr> = valueTmpBuf
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpResult : ((value0: Array<ResourceStr>) => void) = (value0: Array<ResourceStr>):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            onChangeTmpBufBufArgsSerializer.writeInt32((value0.length).toInt());
            for (let value0CounterI = 0; value0CounterI < value0.length; value0CounterI++) {
                const value0TmpElement : ResourceStr = value0[value0CounterI];
                if (value0TmpElement instanceof string) {
                    onChangeTmpBufBufArgsSerializer.writeInt8((0).toByte());
                    const value0TmpElementForIdx0  = value0TmpElement as string;
                    onChangeTmpBufBufArgsSerializer.writeString(value0TmpElementForIdx0);
                } else if (value0TmpElement instanceof Resource) {
                    onChangeTmpBufBufArgsSerializer.writeInt8((1).toByte());
                    const value0TmpElementForIdx1  = value0TmpElement as Resource;
                    Resource_serializer.write(onChangeTmpBufBufArgsSerializer, value0TmpElementForIdx1);
                }
            }
            InteropNativeModule._CallCallbackSync(10, 354105852, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        let value : Bindable<Array<ResourceStr>> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<Array<ResourceStr>>)
        return value
    }
}
export class Bindable_Array_I32_serializer {
    public static write(buffer: SerializerBase, value: Bindable<Array<int32>>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeInt32((valueHolderForValue.length).toInt())
        for (let valueHolderForValueCounterI = 0; valueHolderForValueCounterI < valueHolderForValue.length; valueHolderForValueCounterI++) {
            const valueHolderForValueTmpElement : int32 = valueHolderForValue[valueHolderForValueCounterI]
            valueSerializer.writeInt32(valueHolderForValueTmpElement)
        }
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<Array<int32>> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpBufLength : int32 = valueDeserializer.readInt32()
        let valueTmpBuf : Array<int32> = new int32[valueTmpBufLength]
        for (let valueTmpBufBufCounterI = 0; valueTmpBufBufCounterI < valueTmpBufLength; valueTmpBufBufCounterI++) {
            valueTmpBuf[valueTmpBufBufCounterI] = valueDeserializer.readInt32()
        }
        const valueTmpResult : Array<int32> = valueTmpBuf
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpResult : ((value0: Array<int32>) => void) = (value0: Array<int32>):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            onChangeTmpBufBufArgsSerializer.writeInt32((value0.length).toInt());
            for (let value0CounterI = 0; value0CounterI < value0.length; value0CounterI++) {
                const value0TmpElement : int32 = value0[value0CounterI];
                onChangeTmpBufBufArgsSerializer.writeInt32(value0TmpElement);
            }
            InteropNativeModule._CallCallbackSync(10, 552547050, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        let value : Bindable<Array<int32>> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<Array<int32>>)
        return value
    }
}
export class Bindable_F64_serializer {
    public static write(buffer: SerializerBase, value: Bindable<double>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeFloat64(valueHolderForValue)
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<double> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpResult : double = valueDeserializer.readFloat64()
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpResult : ((value0: double) => void) = (value0: double):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            onChangeTmpBufBufArgsSerializer.writeFloat64(value0);
            InteropNativeModule._CallCallbackSync(10, -747300352, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        let value : Bindable<double> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<double>)
        return value
    }
}
export class Bindable_Boolean_serializer {
    public static write(buffer: SerializerBase, value: Bindable<boolean>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeBoolean(valueHolderForValue)
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<boolean> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpResult : boolean = valueDeserializer.readBoolean()
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpResult : ((value0: boolean) => void) = (value0: boolean):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            onChangeTmpBufBufArgsSerializer.writeBoolean(value0);
            InteropNativeModule._CallCallbackSync(10, 217914240, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        let value : Bindable<boolean> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<boolean>)
        return value
    }
}
export class Bindable_Date_serializer {
    public static write(buffer: SerializerBase, value: Bindable<Date>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeInt64(valueHolderForValue.getTime().toLong())
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<Date> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpResult : Date = new Date(valueDeserializer.readInt64())
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpResult : ((value0: Date) => void) = (value0: Date):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            onChangeTmpBufBufArgsSerializer.writeInt64(value0.getTime().toLong());
            InteropNativeModule._CallCallbackSync(10, 1108733360, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        let value : Bindable<Date> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<Date>)
        return value
    }
}
export class Bindable_I32_serializer {
    public static write(buffer: SerializerBase, value: Bindable<int32>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeInt32(valueHolderForValue)
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<int32> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpResult : int32 = valueDeserializer.readInt32()
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpResult : ((value0: int32) => void) = (value0: int32):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            onChangeTmpBufBufArgsSerializer.writeInt32(value0);
            InteropNativeModule._CallCallbackSync(10, -747290452, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        let value : Bindable<int32> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<int32>)
        return value
    }
}
export class Bindable_Number_serializer {
    public static write(buffer: SerializerBase, value: Bindable<number>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeNumber(valueHolderForValue)
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<number> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpResult : number = (valueDeserializer.readNumber() as number)
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpResult : ((value0: number) => void) = (value0: number):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            onChangeTmpBufBufArgsSerializer.writeNumber(value0);
            InteropNativeModule._CallCallbackSync(10, 1090440167, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        let value : Bindable<number> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<number>)
        return value
    }
}
export class Bindable_String_serializer {
    public static write(buffer: SerializerBase, value: Bindable<string>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeString(valueHolderForValue)
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<string> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpResult : string = (valueDeserializer.readString() as string)
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpResult : ((value0: string) => void) = (value0: string):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            onChangeTmpBufBufArgsSerializer.writeString(value0);
            InteropNativeModule._CallCallbackSync(10, 1477958353, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        let value : Bindable<string> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<string>)
        return value
    }
}
export class BlurOptions_serializer {
    public static write(buffer: SerializerBase, value: BlurOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForGrayscale  = value.grayscale
        const valueHolderForGrayscale_0  = valueHolderForGrayscale[0]
        valueSerializer.writeFloat64(valueHolderForGrayscale_0)
        const valueHolderForGrayscale_1  = valueHolderForGrayscale[1]
        valueSerializer.writeFloat64(valueHolderForGrayscale_1)
    }
    public static read(buffer: DeserializerBase): BlurOptions {
        let valueDeserializer : DeserializerBase = buffer
        const grayscaleTmpBufValue0 : double = valueDeserializer.readFloat64()
        const grayscaleTmpBufValue1 : double = valueDeserializer.readFloat64()
        const grayscaleTmpResult : [ double, double ] = ([grayscaleTmpBufValue0, grayscaleTmpBufValue1] as [ double, double ])
        let value : BlurOptions = ({grayscale: grayscaleTmpResult} as BlurOptions)
        return value
    }
}
export class CaretOffset_serializer {
    public static write(buffer: SerializerBase, value: CaretOffset): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForIndex  = value.index
        valueSerializer.writeInt32(valueHolderForIndex)
        const valueHolderForX  = value.x
        valueSerializer.writeInt32(valueHolderForX)
        const valueHolderForY  = value.y
        valueSerializer.writeInt32(valueHolderForY)
    }
    public static read(buffer: DeserializerBase): CaretOffset {
        let valueDeserializer : DeserializerBase = buffer
        const indexTmpResult : int32 = valueDeserializer.readInt32()
        const xTmpResult : int32 = valueDeserializer.readInt32()
        const yTmpResult : int32 = valueDeserializer.readInt32()
        let value : CaretOffset = ({index: indexTmpResult, x: xTmpResult, y: yTmpResult} as CaretOffset)
        return value
    }
}
export class ChildrenMainSize_serializer {
    public static write(buffer: SerializerBase, value: ChildrenMainSize): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): ChildrenMainSize {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return ChildrenMainSizeInternal.fromPtr(ptr)
    }
}
export class ClickEffect_serializer {
    public static write(buffer: SerializerBase, value: ClickEffect): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForLevel  = value.level
        valueSerializer.writeInt32(valueHolderForLevel.valueOf())
        const valueHolderForScale  = value.scale
        if (valueHolderForScale !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForScaleTmpValue  = valueHolderForScale!
            valueSerializer.writeFloat64(valueHolderForScaleTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ClickEffect {
        let valueDeserializer : DeserializerBase = buffer
        const levelTmpResult : ClickEffectLevel = ClickEffectLevel.fromValue(valueDeserializer.readInt32())
        const scaleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let scaleTmpBuf : double | undefined = undefined
        if ((scaleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            scaleTmpBuf = valueDeserializer.readFloat64()
        }
        const scaleTmpResult : double | undefined = scaleTmpBuf
        let value : ClickEffect = ({level: levelTmpResult, scale: scaleTmpResult} as ClickEffect)
        return value
    }
}
export class CrownEvent_serializer {
    public static write(buffer: SerializerBase, value: CrownEvent): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForTimestamp  = value.timestamp
        valueSerializer.writeInt64(valueHolderForTimestamp)
        const valueHolderForAngularVelocity  = value.angularVelocity
        valueSerializer.writeFloat64(valueHolderForAngularVelocity)
        const valueHolderForDegree  = value.degree
        valueSerializer.writeFloat64(valueHolderForDegree)
        const valueHolderForAction  = value.action
        valueSerializer.writeInt32(valueHolderForAction.valueOf())
        const valueHolderForStopPropagation  = value.stopPropagation
        valueSerializer.holdAndWriteCallback(valueHolderForStopPropagation)
    }
    public static read(buffer: DeserializerBase): CrownEvent {
        let valueDeserializer : DeserializerBase = buffer
        const timestampTmpResult : int64 = valueDeserializer.readInt64()
        const angularVelocityTmpResult : double = valueDeserializer.readFloat64()
        const degreeTmpResult : double = valueDeserializer.readFloat64()
        const actionTmpResult : CrownAction = CrownAction.fromValue(valueDeserializer.readInt32())
        const stopPropagationTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const stopPropagationTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const stopPropagationTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const stopPropagationTmpResult : (() => void) = ():void => {
            const stopPropagationTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            stopPropagationTmpBufBufArgsSerializer.writeInt32(stopPropagationTmpBufBufResource.resourceId);
            stopPropagationTmpBufBufArgsSerializer.writePointer(stopPropagationTmpBufBufCall);
            stopPropagationTmpBufBufArgsSerializer.writePointer(stopPropagationTmpBufBufCallSync);
            InteropNativeModule._CallCallbackSync(10, -1867723152, stopPropagationTmpBufBufArgsSerializer.asBuffer(), stopPropagationTmpBufBufArgsSerializer.length());
            stopPropagationTmpBufBufArgsSerializer.release();
            return;
        }
        let value : CrownEvent = ({timestamp: timestampTmpResult, angularVelocity: angularVelocityTmpResult, degree: degreeTmpResult, action: actionTmpResult, stopPropagation: stopPropagationTmpResult} as CrownEvent)
        return value
    }
}
export class DateRange_serializer {
    public static write(buffer: SerializerBase, value: DateRange): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForStart  = value.start
        if (valueHolderForStart !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForStartTmpValue  = valueHolderForStart!
            valueSerializer.writeInt64(valueHolderForStartTmpValue.getTime().toLong())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnd  = value.end
        if (valueHolderForEnd !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEndTmpValue  = valueHolderForEnd!
            valueSerializer.writeInt64(valueHolderForEndTmpValue.getTime().toLong())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): DateRange {
        let valueDeserializer : DeserializerBase = buffer
        const startTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let startTmpBuf : Date | undefined = undefined
        if ((startTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            startTmpBuf = new Date(valueDeserializer.readInt64())
        }
        const startTmpResult : Date | undefined = startTmpBuf
        const endTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let endTmpBuf : Date | undefined = undefined
        if ((endTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            endTmpBuf = new Date(valueDeserializer.readInt64())
        }
        const endTmpResult : Date | undefined = endTmpBuf
        let value : DateRange = ({start: startTmpResult, end: endTmpResult} as DateRange)
        return value
    }
}
export class DismissContentCoverAction_serializer {
    public static write(buffer: SerializerBase, value: DismissContentCoverAction): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDismiss  = value.dismiss
        valueSerializer.holdAndWriteCallback(valueHolderForDismiss)
        const valueHolderForReason  = value.reason
        valueSerializer.writeInt32(valueHolderForReason.valueOf())
    }
    public static read(buffer: DeserializerBase): DismissContentCoverAction {
        let valueDeserializer : DeserializerBase = buffer
        const dismissTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const dismissTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const dismissTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const dismissTmpResult : VoidCallback = ():void => {
            const dismissTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            dismissTmpBufBufArgsSerializer.writeInt32(dismissTmpBufBufResource.resourceId);
            dismissTmpBufBufArgsSerializer.writePointer(dismissTmpBufBufCall);
            dismissTmpBufBufArgsSerializer.writePointer(dismissTmpBufBufCallSync);
            InteropNativeModule._CallCallbackSync(10, -2038961969, dismissTmpBufBufArgsSerializer.asBuffer(), dismissTmpBufBufArgsSerializer.length());
            dismissTmpBufBufArgsSerializer.release();
            return;
        }
        const reasonTmpResult : DismissReason = DismissReason.fromValue(valueDeserializer.readInt32())
        let value : DismissContentCoverAction = ({dismiss: dismissTmpResult, reason: reasonTmpResult} as DismissContentCoverAction)
        return value
    }
}
export class DismissPopupAction_serializer {
    public static write(buffer: SerializerBase, value: DismissPopupAction): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): DismissPopupAction {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return DismissPopupActionInternal.fromPtr(ptr)
    }
}
export class DismissSheetAction_serializer {
    public static write(buffer: SerializerBase, value: DismissSheetAction): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDismiss  = value.dismiss
        valueSerializer.holdAndWriteCallback(valueHolderForDismiss)
        const valueHolderForReason  = value.reason
        valueSerializer.writeInt32(valueHolderForReason.valueOf())
    }
    public static read(buffer: DeserializerBase): DismissSheetAction {
        let valueDeserializer : DeserializerBase = buffer
        const dismissTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const dismissTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const dismissTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const dismissTmpResult : VoidCallback = ():void => {
            const dismissTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            dismissTmpBufBufArgsSerializer.writeInt32(dismissTmpBufBufResource.resourceId);
            dismissTmpBufBufArgsSerializer.writePointer(dismissTmpBufBufCall);
            dismissTmpBufBufArgsSerializer.writePointer(dismissTmpBufBufCallSync);
            InteropNativeModule._CallCallbackSync(10, -2038961969, dismissTmpBufBufArgsSerializer.asBuffer(), dismissTmpBufBufArgsSerializer.length());
            dismissTmpBufBufArgsSerializer.release();
            return;
        }
        const reasonTmpResult : DismissReason = DismissReason.fromValue(valueDeserializer.readInt32())
        let value : DismissSheetAction = ({dismiss: dismissTmpResult, reason: reasonTmpResult} as DismissSheetAction)
        return value
    }
}
export class DragEvent_serializer {
    public static write(buffer: SerializerBase, value: DragEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): DragEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return DragEventInternal.fromPtr(ptr)
    }
}
export class DragInteractionOptions_serializer {
    public static write(buffer: SerializerBase, value: DragInteractionOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForIsMultiSelectionEnabled  = value.isMultiSelectionEnabled
        if (valueHolderForIsMultiSelectionEnabled !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForIsMultiSelectionEnabledTmpValue  = valueHolderForIsMultiSelectionEnabled!
            valueSerializer.writeBoolean(valueHolderForIsMultiSelectionEnabledTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDefaultAnimationBeforeLifting  = value.defaultAnimationBeforeLifting
        if (valueHolderForDefaultAnimationBeforeLifting !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDefaultAnimationBeforeLiftingTmpValue  = valueHolderForDefaultAnimationBeforeLifting!
            valueSerializer.writeBoolean(valueHolderForDefaultAnimationBeforeLiftingTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableEdgeAutoScroll  = value.enableEdgeAutoScroll
        if (valueHolderForEnableEdgeAutoScroll !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableEdgeAutoScrollTmpValue  = valueHolderForEnableEdgeAutoScroll!
            valueSerializer.writeBoolean(valueHolderForEnableEdgeAutoScrollTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableHapticFeedback  = value.enableHapticFeedback
        if (valueHolderForEnableHapticFeedback !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableHapticFeedbackTmpValue  = valueHolderForEnableHapticFeedback!
            valueSerializer.writeBoolean(valueHolderForEnableHapticFeedbackTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForIsLiftingDisabled  = value.isLiftingDisabled
        if (valueHolderForIsLiftingDisabled !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForIsLiftingDisabledTmpValue  = valueHolderForIsLiftingDisabled!
            valueSerializer.writeBoolean(valueHolderForIsLiftingDisabledTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): DragInteractionOptions {
        let valueDeserializer : DeserializerBase = buffer
        const isMultiSelectionEnabledTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let isMultiSelectionEnabledTmpBuf : boolean | undefined = undefined
        if ((isMultiSelectionEnabledTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            isMultiSelectionEnabledTmpBuf = valueDeserializer.readBoolean()
        }
        const isMultiSelectionEnabledTmpResult : boolean | undefined = isMultiSelectionEnabledTmpBuf
        const defaultAnimationBeforeLiftingTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let defaultAnimationBeforeLiftingTmpBuf : boolean | undefined = undefined
        if ((defaultAnimationBeforeLiftingTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            defaultAnimationBeforeLiftingTmpBuf = valueDeserializer.readBoolean()
        }
        const defaultAnimationBeforeLiftingTmpResult : boolean | undefined = defaultAnimationBeforeLiftingTmpBuf
        const enableEdgeAutoScrollTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableEdgeAutoScrollTmpBuf : boolean | undefined = undefined
        if ((enableEdgeAutoScrollTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableEdgeAutoScrollTmpBuf = valueDeserializer.readBoolean()
        }
        const enableEdgeAutoScrollTmpResult : boolean | undefined = enableEdgeAutoScrollTmpBuf
        const enableHapticFeedbackTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableHapticFeedbackTmpBuf : boolean | undefined = undefined
        if ((enableHapticFeedbackTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableHapticFeedbackTmpBuf = valueDeserializer.readBoolean()
        }
        const enableHapticFeedbackTmpResult : boolean | undefined = enableHapticFeedbackTmpBuf
        const isLiftingDisabledTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let isLiftingDisabledTmpBuf : boolean | undefined = undefined
        if ((isLiftingDisabledTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            isLiftingDisabledTmpBuf = valueDeserializer.readBoolean()
        }
        const isLiftingDisabledTmpResult : boolean | undefined = isLiftingDisabledTmpBuf
        let value : DragInteractionOptions = ({isMultiSelectionEnabled: isMultiSelectionEnabledTmpResult, defaultAnimationBeforeLifting: defaultAnimationBeforeLiftingTmpResult, enableEdgeAutoScroll: enableEdgeAutoScrollTmpResult, enableHapticFeedback: enableHapticFeedbackTmpResult, isLiftingDisabled: isLiftingDisabledTmpResult} as DragInteractionOptions)
        return value
    }
}
export class DragItemInfo_serializer {
    public static write(buffer: SerializerBase, value: DragItemInfo): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForPixelMap  = value.pixelMap
        if (valueHolderForPixelMap !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPixelMapTmpValue  = valueHolderForPixelMap!
            image_PixelMap_serializer.write(valueSerializer, valueHolderForPixelMapTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBuilder  = value.builder
        if (valueHolderForBuilder !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBuilderTmpValue  = valueHolderForBuilder!
            valueSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(valueHolderForBuilderTmpValue))
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForExtraInfo  = value.extraInfo
        if (valueHolderForExtraInfo !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForExtraInfoTmpValue  = valueHolderForExtraInfo!
            valueSerializer.writeString(valueHolderForExtraInfoTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): DragItemInfo {
        let valueDeserializer : DeserializerBase = buffer
        const pixelMapTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let pixelMapTmpBuf : image.PixelMap | undefined = undefined
        if ((pixelMapTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            pixelMapTmpBuf = (image_PixelMap_serializer.read(valueDeserializer) as image.PixelMap)
        }
        const pixelMapTmpResult : image.PixelMap | undefined = pixelMapTmpBuf
        const builderTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let builderTmpBuf : CustomBuilder | undefined = undefined
        if ((builderTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const builderTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const builderTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const builderTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            builderTmpBuf = ():void => {
                const builderTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                builderTmpBuf_BufArgsSerializer.writeInt32(builderTmpBuf_BufResource.resourceId);
                builderTmpBuf_BufArgsSerializer.writePointer(builderTmpBuf_BufCall);
                builderTmpBuf_BufArgsSerializer.writePointer(builderTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, 737226752, builderTmpBuf_BufArgsSerializer.asBuffer(), builderTmpBuf_BufArgsSerializer.length());
                builderTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const builderTmpResult : CustomBuilder | undefined = builderTmpBuf
        const extraInfoTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let extraInfoTmpBuf : string | undefined = undefined
        if ((extraInfoTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            extraInfoTmpBuf = (valueDeserializer.readString() as string)
        }
        const extraInfoTmpResult : string | undefined = extraInfoTmpBuf
        let value : DragItemInfo = ({pixelMap: pixelMapTmpResult, builder: builderTmpResult, extraInfo: extraInfoTmpResult} as DragItemInfo)
        return value
    }
}
export class DropOptions_serializer {
    public static write(buffer: SerializerBase, value: DropOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDisableDataPrefetch  = value.disableDataPrefetch
        if (valueHolderForDisableDataPrefetch !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDisableDataPrefetchTmpValue  = valueHolderForDisableDataPrefetch!
            valueSerializer.writeBoolean(valueHolderForDisableDataPrefetchTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): DropOptions {
        let valueDeserializer : DeserializerBase = buffer
        const disableDataPrefetchTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let disableDataPrefetchTmpBuf : boolean | undefined = undefined
        if ((disableDataPrefetchTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            disableDataPrefetchTmpBuf = valueDeserializer.readBoolean()
        }
        const disableDataPrefetchTmpResult : boolean | undefined = disableDataPrefetchTmpBuf
        let value : DropOptions = ({disableDataPrefetch: disableDataPrefetchTmpResult} as DropOptions)
        return value
    }
}
export class EdgeEffectOptions_serializer {
    public static write(buffer: SerializerBase, value: EdgeEffectOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAlwaysEnabled  = value.alwaysEnabled
        valueSerializer.writeBoolean(valueHolderForAlwaysEnabled)
        const valueHolderForEffectEdge  = value.effectEdge
        if (valueHolderForEffectEdge !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEffectEdgeTmpValue  = valueHolderForEffectEdge!
            valueSerializer.writeInt32(valueHolderForEffectEdgeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): EdgeEffectOptions {
        let valueDeserializer : DeserializerBase = buffer
        const alwaysEnabledTmpResult : boolean = valueDeserializer.readBoolean()
        const effectEdgeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let effectEdgeTmpBuf : int32 | undefined = undefined
        if ((effectEdgeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            effectEdgeTmpBuf = valueDeserializer.readInt32()
        }
        const effectEdgeTmpResult : int32 | undefined = effectEdgeTmpBuf
        let value : EdgeEffectOptions = ({alwaysEnabled: alwaysEnabledTmpResult, effectEdge: effectEdgeTmpResult} as EdgeEffectOptions)
        return value
    }
}
export class ExpectedFrameRateRange_serializer {
    public static write(buffer: SerializerBase, value: ExpectedFrameRateRange): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForMin  = value.min
        valueSerializer.writeInt32(valueHolderForMin)
        const valueHolderForMax  = value.max
        valueSerializer.writeInt32(valueHolderForMax)
        const valueHolderForExpected  = value.expected
        valueSerializer.writeInt32(valueHolderForExpected)
    }
    public static read(buffer: DeserializerBase): ExpectedFrameRateRange {
        let valueDeserializer : DeserializerBase = buffer
        const minTmpResult : int32 = valueDeserializer.readInt32()
        const maxTmpResult : int32 = valueDeserializer.readInt32()
        const expectedTmpResult : int32 = valueDeserializer.readInt32()
        let value : ExpectedFrameRateRange = ({min: minTmpResult, max: maxTmpResult, expected: expectedTmpResult} as ExpectedFrameRateRange)
        return value
    }
}
export class FocusMovement_serializer {
    public static write(buffer: SerializerBase, value: FocusMovement): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForForward  = value.forward
        if (valueHolderForForward !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForForwardTmpValue  = valueHolderForForward!
            valueSerializer.writeString(valueHolderForForwardTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackward  = value.backward
        if (valueHolderForBackward !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackwardTmpValue  = valueHolderForBackward!
            valueSerializer.writeString(valueHolderForBackwardTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForUp  = value.up
        if (valueHolderForUp !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForUpTmpValue  = valueHolderForUp!
            valueSerializer.writeString(valueHolderForUpTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDown  = value.down
        if (valueHolderForDown !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDownTmpValue  = valueHolderForDown!
            valueSerializer.writeString(valueHolderForDownTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForLeft  = value.left
        if (valueHolderForLeft !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForLeftTmpValue  = valueHolderForLeft!
            valueSerializer.writeString(valueHolderForLeftTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRight  = value.right
        if (valueHolderForRight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRightTmpValue  = valueHolderForRight!
            valueSerializer.writeString(valueHolderForRightTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): FocusMovement {
        let valueDeserializer : DeserializerBase = buffer
        const forwardTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let forwardTmpBuf : string | undefined = undefined
        if ((forwardTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            forwardTmpBuf = (valueDeserializer.readString() as string)
        }
        const forwardTmpResult : string | undefined = forwardTmpBuf
        const backwardTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backwardTmpBuf : string | undefined = undefined
        if ((backwardTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backwardTmpBuf = (valueDeserializer.readString() as string)
        }
        const backwardTmpResult : string | undefined = backwardTmpBuf
        const upTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let upTmpBuf : string | undefined = undefined
        if ((upTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            upTmpBuf = (valueDeserializer.readString() as string)
        }
        const upTmpResult : string | undefined = upTmpBuf
        const downTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let downTmpBuf : string | undefined = undefined
        if ((downTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            downTmpBuf = (valueDeserializer.readString() as string)
        }
        const downTmpResult : string | undefined = downTmpBuf
        const leftTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let leftTmpBuf : string | undefined = undefined
        if ((leftTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            leftTmpBuf = (valueDeserializer.readString() as string)
        }
        const leftTmpResult : string | undefined = leftTmpBuf
        const rightTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let rightTmpBuf : string | undefined = undefined
        if ((rightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            rightTmpBuf = (valueDeserializer.readString() as string)
        }
        const rightTmpResult : string | undefined = rightTmpBuf
        let value : FocusMovement = ({forward: forwardTmpResult, backward: backwardTmpResult, up: upTmpResult, down: downTmpResult, left: leftTmpResult, right: rightTmpResult} as FocusMovement)
        return value
    }
}
export class GeometryTransitionOptions_serializer {
    public static write(buffer: SerializerBase, value: GeometryTransitionOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForFollow  = value.follow
        if (valueHolderForFollow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFollowTmpValue  = valueHolderForFollow!
            valueSerializer.writeBoolean(valueHolderForFollowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHierarchyStrategy  = value.hierarchyStrategy
        if (valueHolderForHierarchyStrategy !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHierarchyStrategyTmpValue  = (valueHolderForHierarchyStrategy as TransitionHierarchyStrategy)
            valueSerializer.writeInt32(valueHolderForHierarchyStrategyTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): GeometryTransitionOptions {
        let valueDeserializer : DeserializerBase = buffer
        const followTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let followTmpBuf : boolean | undefined = undefined
        if ((followTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            followTmpBuf = valueDeserializer.readBoolean()
        }
        const followTmpResult : boolean | undefined = followTmpBuf
        const hierarchyStrategyTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let hierarchyStrategyTmpBuf : TransitionHierarchyStrategy | undefined = undefined
        if ((hierarchyStrategyTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            hierarchyStrategyTmpBuf = TransitionHierarchyStrategy.fromValue(valueDeserializer.readInt32())
        }
        const hierarchyStrategyTmpResult : TransitionHierarchyStrategy | undefined = hierarchyStrategyTmpBuf
        let value : GeometryTransitionOptions = ({follow: followTmpResult, hierarchyStrategy: hierarchyStrategyTmpResult} as GeometryTransitionOptions)
        return value
    }
}
export class HorizontalAlignParam_serializer {
    public static write(buffer: SerializerBase, value: HorizontalAlignParam): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAnchor  = value.anchor
        valueSerializer.writeString(valueHolderForAnchor)
        const valueHolderForAlign  = value.align
        valueSerializer.writeInt32(valueHolderForAlign.valueOf())
    }
    public static read(buffer: DeserializerBase): HorizontalAlignParam {
        let valueDeserializer : DeserializerBase = buffer
        const anchorTmpResult : string = (valueDeserializer.readString() as string)
        const alignTmpResult : HorizontalAlign = HorizontalAlign.fromValue(valueDeserializer.readInt32())
        let value : HorizontalAlignParam = ({anchor: anchorTmpResult, align: alignTmpResult} as HorizontalAlignParam)
        return value
    }
}
export class InputCounterOptions_serializer {
    public static write(buffer: SerializerBase, value: InputCounterOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForThresholdPercentage  = value.thresholdPercentage
        if (valueHolderForThresholdPercentage !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForThresholdPercentageTmpValue  = valueHolderForThresholdPercentage!
            valueSerializer.writeFloat64(valueHolderForThresholdPercentageTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHighlightBorder  = value.highlightBorder
        if (valueHolderForHighlightBorder !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHighlightBorderTmpValue  = valueHolderForHighlightBorder!
            valueSerializer.writeBoolean(valueHolderForHighlightBorderTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): InputCounterOptions {
        let valueDeserializer : DeserializerBase = buffer
        const thresholdPercentageTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let thresholdPercentageTmpBuf : double | undefined = undefined
        if ((thresholdPercentageTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            thresholdPercentageTmpBuf = valueDeserializer.readFloat64()
        }
        const thresholdPercentageTmpResult : double | undefined = thresholdPercentageTmpBuf
        const highlightBorderTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let highlightBorderTmpBuf : boolean | undefined = undefined
        if ((highlightBorderTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            highlightBorderTmpBuf = valueDeserializer.readBoolean()
        }
        const highlightBorderTmpResult : boolean | undefined = highlightBorderTmpBuf
        let value : InputCounterOptions = ({thresholdPercentage: thresholdPercentageTmpResult, highlightBorder: highlightBorderTmpResult} as InputCounterOptions)
        return value
    }
}
export class ItemDragEventHandler_serializer {
    public static write(buffer: SerializerBase, value: ItemDragEventHandler): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForOnLongPress  = value.onLongPress
        if (valueHolderForOnLongPress !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnLongPressTmpValue  = valueHolderForOnLongPress!
            valueSerializer.holdAndWriteCallback(valueHolderForOnLongPressTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnDragStart  = value.onDragStart
        if (valueHolderForOnDragStart !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnDragStartTmpValue  = valueHolderForOnDragStart!
            valueSerializer.holdAndWriteCallback(valueHolderForOnDragStartTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnMoveThrough  = value.onMoveThrough
        if (valueHolderForOnMoveThrough !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnMoveThroughTmpValue  = valueHolderForOnMoveThrough!
            valueSerializer.holdAndWriteCallback(valueHolderForOnMoveThroughTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnDrop  = value.onDrop
        if (valueHolderForOnDrop !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnDropTmpValue  = valueHolderForOnDrop!
            valueSerializer.holdAndWriteCallback(valueHolderForOnDropTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ItemDragEventHandler {
        let valueDeserializer : DeserializerBase = buffer
        const onLongPressTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onLongPressTmpBuf : ((value0: int32) => void) | undefined = undefined
        if ((onLongPressTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onLongPressTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onLongPressTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onLongPressTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onLongPressTmpBuf = (value0: int32):void => {
                const onLongPressTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onLongPressTmpBuf_BufArgsSerializer.writeInt32(onLongPressTmpBuf_BufResource.resourceId);
                onLongPressTmpBuf_BufArgsSerializer.writePointer(onLongPressTmpBuf_BufCall);
                onLongPressTmpBuf_BufArgsSerializer.writePointer(onLongPressTmpBuf_BufCallSync);
                onLongPressTmpBuf_BufArgsSerializer.writeInt32(value0);
                InteropNativeModule._CallCallbackSync(10, 1148910599, onLongPressTmpBuf_BufArgsSerializer.asBuffer(), onLongPressTmpBuf_BufArgsSerializer.length());
                onLongPressTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onLongPressTmpResult : ((value0: int32) => void) | undefined = onLongPressTmpBuf
        const onDragStartTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onDragStartTmpBuf : ((value0: int32) => void) | undefined = undefined
        if ((onDragStartTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onDragStartTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDragStartTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onDragStartTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onDragStartTmpBuf = (value0: int32):void => {
                const onDragStartTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onDragStartTmpBuf_BufArgsSerializer.writeInt32(onDragStartTmpBuf_BufResource.resourceId);
                onDragStartTmpBuf_BufArgsSerializer.writePointer(onDragStartTmpBuf_BufCall);
                onDragStartTmpBuf_BufArgsSerializer.writePointer(onDragStartTmpBuf_BufCallSync);
                onDragStartTmpBuf_BufArgsSerializer.writeInt32(value0);
                InteropNativeModule._CallCallbackSync(10, 1148910599, onDragStartTmpBuf_BufArgsSerializer.asBuffer(), onDragStartTmpBuf_BufArgsSerializer.length());
                onDragStartTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onDragStartTmpResult : ((value0: int32) => void) | undefined = onDragStartTmpBuf
        const onMoveThroughTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onMoveThroughTmpBuf : OnMoveHandler | undefined = undefined
        if ((onMoveThroughTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onMoveThroughTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onMoveThroughTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onMoveThroughTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onMoveThroughTmpBuf = (from: int32, to: int32):void => {
                const onMoveThroughTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onMoveThroughTmpBuf_BufArgsSerializer.writeInt32(onMoveThroughTmpBuf_BufResource.resourceId);
                onMoveThroughTmpBuf_BufArgsSerializer.writePointer(onMoveThroughTmpBuf_BufCall);
                onMoveThroughTmpBuf_BufArgsSerializer.writePointer(onMoveThroughTmpBuf_BufCallSync);
                onMoveThroughTmpBuf_BufArgsSerializer.writeInt32(from);
                onMoveThroughTmpBuf_BufArgsSerializer.writeInt32(to);
                InteropNativeModule._CallCallbackSync(10, -1200281222, onMoveThroughTmpBuf_BufArgsSerializer.asBuffer(), onMoveThroughTmpBuf_BufArgsSerializer.length());
                onMoveThroughTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onMoveThroughTmpResult : OnMoveHandler | undefined = onMoveThroughTmpBuf
        const onDropTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onDropTmpBuf : ((value0: int32) => void) | undefined = undefined
        if ((onDropTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onDropTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDropTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onDropTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onDropTmpBuf = (value0: int32):void => {
                const onDropTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onDropTmpBuf_BufArgsSerializer.writeInt32(onDropTmpBuf_BufResource.resourceId);
                onDropTmpBuf_BufArgsSerializer.writePointer(onDropTmpBuf_BufCall);
                onDropTmpBuf_BufArgsSerializer.writePointer(onDropTmpBuf_BufCallSync);
                onDropTmpBuf_BufArgsSerializer.writeInt32(value0);
                InteropNativeModule._CallCallbackSync(10, 1148910599, onDropTmpBuf_BufArgsSerializer.asBuffer(), onDropTmpBuf_BufArgsSerializer.length());
                onDropTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onDropTmpResult : ((value0: int32) => void) | undefined = onDropTmpBuf
        let value : ItemDragEventHandler = ({onLongPress: onLongPressTmpResult, onDragStart: onDragStartTmpResult, onMoveThrough: onMoveThroughTmpResult, onDrop: onDropTmpResult} as ItemDragEventHandler)
        return value
    }
}
export class ItemDragInfo_serializer {
    public static write(buffer: SerializerBase, value: ItemDragInfo): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForX  = value.x
        valueSerializer.writeFloat64(valueHolderForX)
        const valueHolderForY  = value.y
        valueSerializer.writeFloat64(valueHolderForY)
    }
    public static read(buffer: DeserializerBase): ItemDragInfo {
        let valueDeserializer : DeserializerBase = buffer
        const xTmpResult : double = valueDeserializer.readFloat64()
        const yTmpResult : double = valueDeserializer.readFloat64()
        let value : ItemDragInfo = ({x: xTmpResult, y: yTmpResult} as ItemDragInfo)
        return value
    }
}
export class KeyEvent_serializer {
    public static write(buffer: SerializerBase, value: KeyEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): KeyEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return KeyEventInternal.fromPtr(ptr)
    }
}
export class KeyframeState_serializer {
    public static write(buffer: SerializerBase, value: KeyframeState): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDuration  = value.duration
        valueSerializer.writeInt32(valueHolderForDuration)
        const valueHolderForCurve  = value.curve
        if (valueHolderForCurve !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCurveTmpValue  = valueHolderForCurve!
            if (valueHolderForCurveTmpValue instanceof curves.Curve) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForCurveTmpValueForIdx0  = valueHolderForCurveTmpValue as curves.Curve
                valueSerializer.writeInt32(valueHolderForCurveTmpValueForIdx0.valueOf())
            } else if (valueHolderForCurveTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForCurveTmpValueForIdx1  = valueHolderForCurveTmpValue as string
                valueSerializer.writeString(valueHolderForCurveTmpValueForIdx1)
            } else if (valueHolderForCurveTmpValue instanceof curves.ICurve) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForCurveTmpValueForIdx2  = valueHolderForCurveTmpValue as curves.ICurve
                curves_ICurve_serializer.write(valueSerializer, valueHolderForCurveTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEvent  = value.event
        valueSerializer.holdAndWriteCallback(valueHolderForEvent)
    }
    public static read(buffer: DeserializerBase): KeyframeState {
        let valueDeserializer : DeserializerBase = buffer
        const durationTmpResult : int32 = valueDeserializer.readInt32()
        const curveTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let curveTmpBuf : curves.Curve | string | curves.ICurve | undefined = undefined
        if ((curveTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const curveTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let curveTmpBuf_ : curves.Curve | string | curves.ICurve | undefined
            if (curveTmpBuf_UnionSelector == (0).toChar()) {
                curveTmpBuf_ = curves.Curve.fromValue(valueDeserializer.readInt32())
            } else if (curveTmpBuf_UnionSelector == (1).toChar()) {
                curveTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (curveTmpBuf_UnionSelector == (2).toChar()) {
                curveTmpBuf_ = (curves_ICurve_serializer.read(valueDeserializer) as curves.ICurve)
            } else {
                throw new Error("One of the branches for curveTmpBuf_ has to be chosen through deserialisation.")
            }
            curveTmpBuf = (curveTmpBuf_ as curves.Curve | string | curves.ICurve)
        }
        const curveTmpResult : curves.Curve | string | curves.ICurve | undefined = curveTmpBuf
        const eventTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const eventTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const eventTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const eventTmpResult : (() => void) = ():void => {
            const eventTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            eventTmpBufBufArgsSerializer.writeInt32(eventTmpBufBufResource.resourceId);
            eventTmpBufBufArgsSerializer.writePointer(eventTmpBufBufCall);
            eventTmpBufBufArgsSerializer.writePointer(eventTmpBufBufCallSync);
            InteropNativeModule._CallCallbackSync(10, -1867723152, eventTmpBufBufArgsSerializer.asBuffer(), eventTmpBufBufArgsSerializer.length());
            eventTmpBufBufArgsSerializer.release();
            return;
        }
        let value : KeyframeState = ({duration: durationTmpResult, curve: curveTmpResult, event: eventTmpResult} as KeyframeState)
        return value
    }
}
export class LinearGradientBlurOptions_serializer {
    public static write(buffer: SerializerBase, value: LinearGradientBlurOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForFractionStops  = value.fractionStops
        valueSerializer.writeInt32((valueHolderForFractionStops.length).toInt())
        for (let valueHolderForFractionStopsCounterI = 0; valueHolderForFractionStopsCounterI < valueHolderForFractionStops.length; valueHolderForFractionStopsCounterI++) {
            const valueHolderForFractionStopsTmpElement : FractionStop = valueHolderForFractionStops[valueHolderForFractionStopsCounterI]
            const valueHolderForFractionStopsTmpElement_0  = valueHolderForFractionStopsTmpElement[0]
            valueSerializer.writeFloat64(valueHolderForFractionStopsTmpElement_0)
            const valueHolderForFractionStopsTmpElement_1  = valueHolderForFractionStopsTmpElement[1]
            valueSerializer.writeFloat64(valueHolderForFractionStopsTmpElement_1)
        }
        const valueHolderForDirection  = value.direction
        valueSerializer.writeInt32(valueHolderForDirection.valueOf())
    }
    public static read(buffer: DeserializerBase): LinearGradientBlurOptions {
        let valueDeserializer : DeserializerBase = buffer
        const fractionStopsTmpBufLength : int32 = valueDeserializer.readInt32()
        let fractionStopsTmpBuf : Array<FractionStop> = new Array<FractionStop>(fractionStopsTmpBufLength)
        for (let fractionStopsTmpBufBufCounterI = 0; fractionStopsTmpBufBufCounterI < fractionStopsTmpBufLength; fractionStopsTmpBufBufCounterI++) {
            const fractionStopsTmpBufTempBufValue0 : double = valueDeserializer.readFloat64()
            const fractionStopsTmpBufTempBufValue1 : double = valueDeserializer.readFloat64()
            fractionStopsTmpBuf[fractionStopsTmpBufBufCounterI] = ([fractionStopsTmpBufTempBufValue0, fractionStopsTmpBufTempBufValue1] as FractionStop)
        }
        const fractionStopsTmpResult : Array<FractionStop> = fractionStopsTmpBuf
        const directionTmpResult : GradientDirection = GradientDirection.fromValue(valueDeserializer.readInt32())
        let value : LinearGradientBlurOptions = ({fractionStops: fractionStopsTmpResult, direction: directionTmpResult} as LinearGradientBlurOptions)
        return value
    }
}
export class LinearGradientOptions_serializer {
    public static write(buffer: SerializerBase, value: LinearGradientOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAngle  = value.angle
        if (valueHolderForAngle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAngleTmpValue  = valueHolderForAngle!
            if (valueHolderForAngleTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForAngleTmpValueForIdx0  = valueHolderForAngleTmpValue as double
                valueSerializer.writeFloat64(valueHolderForAngleTmpValueForIdx0)
            } else if (valueHolderForAngleTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForAngleTmpValueForIdx1  = valueHolderForAngleTmpValue as string
                valueSerializer.writeString(valueHolderForAngleTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDirection  = value.direction
        if (valueHolderForDirection !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDirectionTmpValue  = (valueHolderForDirection as GradientDirection)
            valueSerializer.writeInt32(valueHolderForDirectionTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForColors  = value.colors
        valueSerializer.writeInt32((valueHolderForColors.length).toInt())
        for (let valueHolderForColorsCounterI = 0; valueHolderForColorsCounterI < valueHolderForColors.length; valueHolderForColorsCounterI++) {
            const valueHolderForColorsTmpElement : [ ResourceColor, double ] = valueHolderForColors[valueHolderForColorsCounterI]
            const valueHolderForColorsTmpElement_0  = valueHolderForColorsTmpElement[0]
            if (valueHolderForColorsTmpElement_0 instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorsTmpElement_0ForIdx0  = valueHolderForColorsTmpElement_0 as Color
                valueSerializer.writeInt32(valueHolderForColorsTmpElement_0ForIdx0.getOrdinal())
            } else if (valueHolderForColorsTmpElement_0 instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorsTmpElement_0ForIdx1  = valueHolderForColorsTmpElement_0 as number
                valueSerializer.writeNumber(valueHolderForColorsTmpElement_0ForIdx1)
            } else if (valueHolderForColorsTmpElement_0 instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorsTmpElement_0ForIdx2  = valueHolderForColorsTmpElement_0 as string
                valueSerializer.writeString(valueHolderForColorsTmpElement_0ForIdx2)
            } else if (valueHolderForColorsTmpElement_0 instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorsTmpElement_0ForIdx3  = valueHolderForColorsTmpElement_0 as Resource
                Resource_serializer.write(valueSerializer, valueHolderForColorsTmpElement_0ForIdx3)
            }
            const valueHolderForColorsTmpElement_1  = valueHolderForColorsTmpElement[1]
            valueSerializer.writeFloat64(valueHolderForColorsTmpElement_1)
        }
        const valueHolderForRepeating  = value.repeating
        if (valueHolderForRepeating !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRepeatingTmpValue  = valueHolderForRepeating!
            valueSerializer.writeBoolean(valueHolderForRepeatingTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): LinearGradientOptions {
        let valueDeserializer : DeserializerBase = buffer
        const angleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let angleTmpBuf : double | string | undefined = undefined
        if ((angleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const angleTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let angleTmpBuf_ : double | string | undefined
            if (angleTmpBuf_UnionSelector == (0).toChar()) {
                angleTmpBuf_ = valueDeserializer.readFloat64()
            } else if (angleTmpBuf_UnionSelector == (1).toChar()) {
                angleTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for angleTmpBuf_ has to be chosen through deserialisation.")
            }
            angleTmpBuf = (angleTmpBuf_ as double | string)
        }
        const angleTmpResult : double | string | undefined = angleTmpBuf
        const directionTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let directionTmpBuf : GradientDirection | undefined = undefined
        if ((directionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            directionTmpBuf = GradientDirection.fromValue(valueDeserializer.readInt32())
        }
        const directionTmpResult : GradientDirection | undefined = directionTmpBuf
        const colorsTmpBufLength : int32 = valueDeserializer.readInt32()
        let colorsTmpBuf : Array<[ ResourceColor, double ]> = new Array<[ ResourceColor, double ]>(colorsTmpBufLength)
        for (let colorsTmpBufBufCounterI = 0; colorsTmpBufBufCounterI < colorsTmpBufLength; colorsTmpBufBufCounterI++) {
            const colorsTmpBufTempBufValue0TempBufUnionSelector : int32 = valueDeserializer.readInt8()
            let colorsTmpBufTempBufValue0TempBuf : Color | number | string | Resource | undefined
            if (colorsTmpBufTempBufValue0TempBufUnionSelector == (0).toChar()) {
                colorsTmpBufTempBufValue0TempBuf = Color.values()[valueDeserializer.readInt32()]
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (1).toChar()) {
                colorsTmpBufTempBufValue0TempBuf = (valueDeserializer.readNumber() as number)
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (2).toChar()) {
                colorsTmpBufTempBufValue0TempBuf = (valueDeserializer.readString() as string)
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (3).toChar()) {
                colorsTmpBufTempBufValue0TempBuf = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for colorsTmpBufTempBufValue0TempBuf has to be chosen through deserialisation.")
            }
            const colorsTmpBufTempBufValue0 : ResourceColor = (colorsTmpBufTempBufValue0TempBuf as Color | number | string | Resource)
            const colorsTmpBufTempBufValue1 : double = valueDeserializer.readFloat64()
            colorsTmpBuf[colorsTmpBufBufCounterI] = ([colorsTmpBufTempBufValue0, colorsTmpBufTempBufValue1] as [ ResourceColor, double ])
        }
        const colorsTmpResult : Array<[ ResourceColor, double ]> = colorsTmpBuf
        const repeatingTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let repeatingTmpBuf : boolean | undefined = undefined
        if ((repeatingTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            repeatingTmpBuf = valueDeserializer.readBoolean()
        }
        const repeatingTmpResult : boolean | undefined = repeatingTmpBuf
        let value : LinearGradientOptions = ({angle: angleTmpResult, direction: directionTmpResult, colors: colorsTmpResult, repeating: repeatingTmpResult} as LinearGradientOptions)
        return value
    }
}
export class LocalizedHorizontalAlignParam_serializer {
    public static write(buffer: SerializerBase, value: LocalizedHorizontalAlignParam): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAnchor  = value.anchor
        valueSerializer.writeString(valueHolderForAnchor)
        const valueHolderForAlign  = value.align
        valueSerializer.writeInt32(valueHolderForAlign.valueOf())
    }
    public static read(buffer: DeserializerBase): LocalizedHorizontalAlignParam {
        let valueDeserializer : DeserializerBase = buffer
        const anchorTmpResult : string = (valueDeserializer.readString() as string)
        const alignTmpResult : HorizontalAlign = HorizontalAlign.fromValue(valueDeserializer.readInt32())
        let value : LocalizedHorizontalAlignParam = ({anchor: anchorTmpResult, align: alignTmpResult} as LocalizedHorizontalAlignParam)
        return value
    }
}
export class LocalizedVerticalAlignParam_serializer {
    public static write(buffer: SerializerBase, value: LocalizedVerticalAlignParam): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAnchor  = value.anchor
        valueSerializer.writeString(valueHolderForAnchor)
        const valueHolderForAlign  = value.align
        valueSerializer.writeInt32(valueHolderForAlign.valueOf())
    }
    public static read(buffer: DeserializerBase): LocalizedVerticalAlignParam {
        let valueDeserializer : DeserializerBase = buffer
        const anchorTmpResult : string = (valueDeserializer.readString() as string)
        const alignTmpResult : VerticalAlign = VerticalAlign.fromValue(valueDeserializer.readInt32())
        let value : LocalizedVerticalAlignParam = ({anchor: anchorTmpResult, align: alignTmpResult} as LocalizedVerticalAlignParam)
        return value
    }
}
export class Measurable_serializer {
    public static write(buffer: SerializerBase, value: Measurable): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): Measurable {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return MeasurableInternal.fromPtr(ptr)
    }
}
export class MeasureResult_serializer {
    public static write(buffer: SerializerBase, value: MeasureResult): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForWidth  = value.width
        valueSerializer.writeNumber(valueHolderForWidth)
        const valueHolderForHeight  = value.height
        valueSerializer.writeNumber(valueHolderForHeight)
    }
    public static read(buffer: DeserializerBase): MeasureResult {
        let valueDeserializer : DeserializerBase = buffer
        const widthTmpResult : number = (valueDeserializer.readNumber() as number)
        const heightTmpResult : number = (valueDeserializer.readNumber() as number)
        let value : MeasureResult = ({width: widthTmpResult, height: heightTmpResult} as MeasureResult)
        return value
    }
}
export class MotionBlurOptions_serializer {
    public static write(buffer: SerializerBase, value: MotionBlurOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForRadius  = value.radius
        valueSerializer.writeNumber(valueHolderForRadius)
        const valueHolderForAnchor  = value.anchor
        MotionBlurAnchor_serializer.write(valueSerializer, valueHolderForAnchor)
    }
    public static read(buffer: DeserializerBase): MotionBlurOptions {
        let valueDeserializer : DeserializerBase = buffer
        const radiusTmpResult : number = (valueDeserializer.readNumber() as number)
        const anchorTmpResult : MotionBlurAnchor = MotionBlurAnchor_serializer.read(valueDeserializer)
        let value : MotionBlurOptions = ({radius: radiusTmpResult, anchor: anchorTmpResult} as MotionBlurOptions)
        return value
    }
}
export class MotionPathOptions_serializer {
    public static write(buffer: SerializerBase, value: MotionPathOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForPath  = value.path
        valueSerializer.writeString(valueHolderForPath)
        const valueHolderForFrom  = value.from
        if (valueHolderForFrom !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFromTmpValue  = valueHolderForFrom!
            valueSerializer.writeFloat64(valueHolderForFromTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTo  = value.to
        if (valueHolderForTo !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForToTmpValue  = valueHolderForTo!
            valueSerializer.writeFloat64(valueHolderForToTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRotatable  = value.rotatable
        if (valueHolderForRotatable !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRotatableTmpValue  = valueHolderForRotatable!
            valueSerializer.writeBoolean(valueHolderForRotatableTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): MotionPathOptions {
        let valueDeserializer : DeserializerBase = buffer
        const pathTmpResult : string = (valueDeserializer.readString() as string)
        const fromTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fromTmpBuf : double | undefined = undefined
        if ((fromTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            fromTmpBuf = valueDeserializer.readFloat64()
        }
        const fromTmpResult : double | undefined = fromTmpBuf
        const toTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let toTmpBuf : double | undefined = undefined
        if ((toTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            toTmpBuf = valueDeserializer.readFloat64()
        }
        const toTmpResult : double | undefined = toTmpBuf
        const rotatableTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let rotatableTmpBuf : boolean | undefined = undefined
        if ((rotatableTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            rotatableTmpBuf = valueDeserializer.readBoolean()
        }
        const rotatableTmpResult : boolean | undefined = rotatableTmpBuf
        let value : MotionPathOptions = ({path: pathTmpResult, from: fromTmpResult, to: toTmpResult, rotatable: rotatableTmpResult} as MotionPathOptions)
        return value
    }
}
export class OverlayOffset_serializer {
    public static write(buffer: SerializerBase, value: OverlayOffset): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForX  = value.x
        if (valueHolderForX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForXTmpValue  = valueHolderForX!
            valueSerializer.writeFloat64(valueHolderForXTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForY  = value.y
        if (valueHolderForY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForYTmpValue  = valueHolderForY!
            valueSerializer.writeFloat64(valueHolderForYTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): OverlayOffset {
        let valueDeserializer : DeserializerBase = buffer
        const xTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let xTmpBuf : double | undefined = undefined
        if ((xTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            xTmpBuf = valueDeserializer.readFloat64()
        }
        const xTmpResult : double | undefined = xTmpBuf
        const yTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let yTmpBuf : double | undefined = undefined
        if ((yTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            yTmpBuf = valueDeserializer.readFloat64()
        }
        const yTmpResult : double | undefined = yTmpBuf
        let value : OverlayOffset = ({x: xTmpResult, y: yTmpResult} as OverlayOffset)
        return value
    }
}
export class PixelRoundPolicy_serializer {
    public static write(buffer: SerializerBase, value: PixelRoundPolicy): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForStart  = value.start
        if (valueHolderForStart !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForStartTmpValue  = (valueHolderForStart as PixelRoundCalcPolicy)
            valueSerializer.writeInt32(valueHolderForStartTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTop  = value.top
        if (valueHolderForTop !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTopTmpValue  = (valueHolderForTop as PixelRoundCalcPolicy)
            valueSerializer.writeInt32(valueHolderForTopTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnd  = value.end
        if (valueHolderForEnd !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEndTmpValue  = (valueHolderForEnd as PixelRoundCalcPolicy)
            valueSerializer.writeInt32(valueHolderForEndTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBottom  = value.bottom
        if (valueHolderForBottom !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBottomTmpValue  = (valueHolderForBottom as PixelRoundCalcPolicy)
            valueSerializer.writeInt32(valueHolderForBottomTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PixelRoundPolicy {
        let valueDeserializer : DeserializerBase = buffer
        const startTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let startTmpBuf : PixelRoundCalcPolicy | undefined = undefined
        if ((startTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            startTmpBuf = PixelRoundCalcPolicy.fromValue(valueDeserializer.readInt32())
        }
        const startTmpResult : PixelRoundCalcPolicy | undefined = startTmpBuf
        const topTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let topTmpBuf : PixelRoundCalcPolicy | undefined = undefined
        if ((topTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            topTmpBuf = PixelRoundCalcPolicy.fromValue(valueDeserializer.readInt32())
        }
        const topTmpResult : PixelRoundCalcPolicy | undefined = topTmpBuf
        const endTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let endTmpBuf : PixelRoundCalcPolicy | undefined = undefined
        if ((endTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            endTmpBuf = PixelRoundCalcPolicy.fromValue(valueDeserializer.readInt32())
        }
        const endTmpResult : PixelRoundCalcPolicy | undefined = endTmpBuf
        const bottomTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let bottomTmpBuf : PixelRoundCalcPolicy | undefined = undefined
        if ((bottomTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            bottomTmpBuf = PixelRoundCalcPolicy.fromValue(valueDeserializer.readInt32())
        }
        const bottomTmpResult : PixelRoundCalcPolicy | undefined = bottomTmpBuf
        let value : PixelRoundPolicy = ({start: startTmpResult, top: topTmpResult, end: endTmpResult, bottom: bottomTmpResult} as PixelRoundPolicy)
        return value
    }
}
export class PopupButton_serializer {
    public static write(buffer: SerializerBase, value: PopupButton): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        valueSerializer.writeString(valueHolderForValue)
        const valueHolderForAction  = value.action
        valueSerializer.holdAndWriteCallback(valueHolderForAction)
    }
    public static read(buffer: DeserializerBase): PopupButton {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpResult : string = (valueDeserializer.readString() as string)
        const actionTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const actionTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const actionTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const actionTmpResult : VoidCallback = ():void => {
            const actionTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            actionTmpBufBufArgsSerializer.writeInt32(actionTmpBufBufResource.resourceId);
            actionTmpBufBufArgsSerializer.writePointer(actionTmpBufBufCall);
            actionTmpBufBufArgsSerializer.writePointer(actionTmpBufBufCallSync);
            InteropNativeModule._CallCallbackSync(10, -2038961969, actionTmpBufBufArgsSerializer.asBuffer(), actionTmpBufBufArgsSerializer.length());
            actionTmpBufBufArgsSerializer.release();
            return;
        }
        let value : PopupButton = ({value: valueTmpResult, action: actionTmpResult} as PopupButton)
        return value
    }
}
export class PreviewConfiguration_serializer {
    public static write(buffer: SerializerBase, value: PreviewConfiguration): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForOnlyForLifting  = value.onlyForLifting
        if (valueHolderForOnlyForLifting !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnlyForLiftingTmpValue  = valueHolderForOnlyForLifting!
            valueSerializer.writeBoolean(valueHolderForOnlyForLiftingTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDelayCreating  = value.delayCreating
        if (valueHolderForDelayCreating !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDelayCreatingTmpValue  = valueHolderForDelayCreating!
            valueSerializer.writeBoolean(valueHolderForDelayCreatingTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PreviewConfiguration {
        let valueDeserializer : DeserializerBase = buffer
        const onlyForLiftingTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onlyForLiftingTmpBuf : boolean | undefined = undefined
        if ((onlyForLiftingTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            onlyForLiftingTmpBuf = valueDeserializer.readBoolean()
        }
        const onlyForLiftingTmpResult : boolean | undefined = onlyForLiftingTmpBuf
        const delayCreatingTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let delayCreatingTmpBuf : boolean | undefined = undefined
        if ((delayCreatingTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            delayCreatingTmpBuf = valueDeserializer.readBoolean()
        }
        const delayCreatingTmpResult : boolean | undefined = delayCreatingTmpBuf
        let value : PreviewConfiguration = ({onlyForLifting: onlyForLiftingTmpResult, delayCreating: delayCreatingTmpResult} as PreviewConfiguration)
        return value
    }
}
export class RotateAngleOptions_serializer {
    public static write(buffer: SerializerBase, value: RotateAngleOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAngleX  = value.angleX
        if (valueHolderForAngleX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAngleXTmpValue  = valueHolderForAngleX!
            if (valueHolderForAngleXTmpValue instanceof number) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForAngleXTmpValueForIdx0  = valueHolderForAngleXTmpValue as number
                valueSerializer.writeNumber(valueHolderForAngleXTmpValueForIdx0)
            } else if (valueHolderForAngleXTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForAngleXTmpValueForIdx1  = valueHolderForAngleXTmpValue as string
                valueSerializer.writeString(valueHolderForAngleXTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAngleY  = value.angleY
        if (valueHolderForAngleY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAngleYTmpValue  = valueHolderForAngleY!
            if (valueHolderForAngleYTmpValue instanceof number) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForAngleYTmpValueForIdx0  = valueHolderForAngleYTmpValue as number
                valueSerializer.writeNumber(valueHolderForAngleYTmpValueForIdx0)
            } else if (valueHolderForAngleYTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForAngleYTmpValueForIdx1  = valueHolderForAngleYTmpValue as string
                valueSerializer.writeString(valueHolderForAngleYTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAngleZ  = value.angleZ
        if (valueHolderForAngleZ !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAngleZTmpValue  = valueHolderForAngleZ!
            if (valueHolderForAngleZTmpValue instanceof number) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForAngleZTmpValueForIdx0  = valueHolderForAngleZTmpValue as number
                valueSerializer.writeNumber(valueHolderForAngleZTmpValueForIdx0)
            } else if (valueHolderForAngleZTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForAngleZTmpValueForIdx1  = valueHolderForAngleZTmpValue as string
                valueSerializer.writeString(valueHolderForAngleZTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCenterX  = value.centerX
        if (valueHolderForCenterX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCenterXTmpValue  = valueHolderForCenterX!
            if (valueHolderForCenterXTmpValue instanceof number) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForCenterXTmpValueForIdx0  = valueHolderForCenterXTmpValue as number
                valueSerializer.writeNumber(valueHolderForCenterXTmpValueForIdx0)
            } else if (valueHolderForCenterXTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForCenterXTmpValueForIdx1  = valueHolderForCenterXTmpValue as string
                valueSerializer.writeString(valueHolderForCenterXTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCenterY  = value.centerY
        if (valueHolderForCenterY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCenterYTmpValue  = valueHolderForCenterY!
            if (valueHolderForCenterYTmpValue instanceof number) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForCenterYTmpValueForIdx0  = valueHolderForCenterYTmpValue as number
                valueSerializer.writeNumber(valueHolderForCenterYTmpValueForIdx0)
            } else if (valueHolderForCenterYTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForCenterYTmpValueForIdx1  = valueHolderForCenterYTmpValue as string
                valueSerializer.writeString(valueHolderForCenterYTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCenterZ  = value.centerZ
        if (valueHolderForCenterZ !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCenterZTmpValue  = valueHolderForCenterZ!
            valueSerializer.writeNumber(valueHolderForCenterZTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPerspective  = value.perspective
        if (valueHolderForPerspective !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPerspectiveTmpValue  = valueHolderForPerspective!
            valueSerializer.writeNumber(valueHolderForPerspectiveTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): RotateAngleOptions {
        let valueDeserializer : DeserializerBase = buffer
        const angleXTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let angleXTmpBuf : number | string | undefined = undefined
        if ((angleXTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const angleXTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let angleXTmpBuf_ : number | string | undefined
            if (angleXTmpBuf_UnionSelector == (0).toChar()) {
                angleXTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (angleXTmpBuf_UnionSelector == (1).toChar()) {
                angleXTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for angleXTmpBuf_ has to be chosen through deserialisation.")
            }
            angleXTmpBuf = (angleXTmpBuf_ as number | string)
        }
        const angleXTmpResult : number | string | undefined = angleXTmpBuf
        const angleYTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let angleYTmpBuf : number | string | undefined = undefined
        if ((angleYTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const angleYTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let angleYTmpBuf_ : number | string | undefined
            if (angleYTmpBuf_UnionSelector == (0).toChar()) {
                angleYTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (angleYTmpBuf_UnionSelector == (1).toChar()) {
                angleYTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for angleYTmpBuf_ has to be chosen through deserialisation.")
            }
            angleYTmpBuf = (angleYTmpBuf_ as number | string)
        }
        const angleYTmpResult : number | string | undefined = angleYTmpBuf
        const angleZTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let angleZTmpBuf : number | string | undefined = undefined
        if ((angleZTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const angleZTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let angleZTmpBuf_ : number | string | undefined
            if (angleZTmpBuf_UnionSelector == (0).toChar()) {
                angleZTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (angleZTmpBuf_UnionSelector == (1).toChar()) {
                angleZTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for angleZTmpBuf_ has to be chosen through deserialisation.")
            }
            angleZTmpBuf = (angleZTmpBuf_ as number | string)
        }
        const angleZTmpResult : number | string | undefined = angleZTmpBuf
        const centerXTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let centerXTmpBuf : number | string | undefined = undefined
        if ((centerXTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const centerXTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let centerXTmpBuf_ : number | string | undefined
            if (centerXTmpBuf_UnionSelector == (0).toChar()) {
                centerXTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (centerXTmpBuf_UnionSelector == (1).toChar()) {
                centerXTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for centerXTmpBuf_ has to be chosen through deserialisation.")
            }
            centerXTmpBuf = (centerXTmpBuf_ as number | string)
        }
        const centerXTmpResult : number | string | undefined = centerXTmpBuf
        const centerYTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let centerYTmpBuf : number | string | undefined = undefined
        if ((centerYTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const centerYTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let centerYTmpBuf_ : number | string | undefined
            if (centerYTmpBuf_UnionSelector == (0).toChar()) {
                centerYTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (centerYTmpBuf_UnionSelector == (1).toChar()) {
                centerYTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for centerYTmpBuf_ has to be chosen through deserialisation.")
            }
            centerYTmpBuf = (centerYTmpBuf_ as number | string)
        }
        const centerYTmpResult : number | string | undefined = centerYTmpBuf
        const centerZTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let centerZTmpBuf : number | undefined = undefined
        if ((centerZTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            centerZTmpBuf = (valueDeserializer.readNumber() as number)
        }
        const centerZTmpResult : number | undefined = centerZTmpBuf
        const perspectiveTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let perspectiveTmpBuf : number | undefined = undefined
        if ((perspectiveTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            perspectiveTmpBuf = (valueDeserializer.readNumber() as number)
        }
        const perspectiveTmpResult : number | undefined = perspectiveTmpBuf
        let value : RotateAngleOptions = ({angleX: angleXTmpResult, angleY: angleYTmpResult, angleZ: angleZTmpResult, centerX: centerXTmpResult, centerY: centerYTmpResult, centerZ: centerZTmpResult, perspective: perspectiveTmpResult} as RotateAngleOptions)
        return value
    }
}
export class RotateOptions_serializer {
    public static write(buffer: SerializerBase, value: RotateOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForX  = value.x
        if (valueHolderForX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForXTmpValue  = valueHolderForX!
            valueSerializer.writeFloat64(valueHolderForXTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForY  = value.y
        if (valueHolderForY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForYTmpValue  = valueHolderForY!
            valueSerializer.writeFloat64(valueHolderForYTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForZ  = value.z
        if (valueHolderForZ !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForZTmpValue  = valueHolderForZ!
            valueSerializer.writeFloat64(valueHolderForZTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCenterX  = value.centerX
        if (valueHolderForCenterX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCenterXTmpValue  = valueHolderForCenterX!
            if (valueHolderForCenterXTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForCenterXTmpValueForIdx0  = valueHolderForCenterXTmpValue as double
                valueSerializer.writeFloat64(valueHolderForCenterXTmpValueForIdx0)
            } else if (valueHolderForCenterXTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForCenterXTmpValueForIdx1  = valueHolderForCenterXTmpValue as string
                valueSerializer.writeString(valueHolderForCenterXTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCenterY  = value.centerY
        if (valueHolderForCenterY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCenterYTmpValue  = valueHolderForCenterY!
            if (valueHolderForCenterYTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForCenterYTmpValueForIdx0  = valueHolderForCenterYTmpValue as double
                valueSerializer.writeFloat64(valueHolderForCenterYTmpValueForIdx0)
            } else if (valueHolderForCenterYTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForCenterYTmpValueForIdx1  = valueHolderForCenterYTmpValue as string
                valueSerializer.writeString(valueHolderForCenterYTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCenterZ  = value.centerZ
        if (valueHolderForCenterZ !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCenterZTmpValue  = valueHolderForCenterZ!
            valueSerializer.writeFloat64(valueHolderForCenterZTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPerspective  = value.perspective
        if (valueHolderForPerspective !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPerspectiveTmpValue  = valueHolderForPerspective!
            valueSerializer.writeFloat64(valueHolderForPerspectiveTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAngle  = value.angle
        if (valueHolderForAngle instanceof double) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForAngleForIdx0  = valueHolderForAngle as double
            valueSerializer.writeFloat64(valueHolderForAngleForIdx0)
        } else if (valueHolderForAngle instanceof string) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForAngleForIdx1  = valueHolderForAngle as string
            valueSerializer.writeString(valueHolderForAngleForIdx1)
        }
    }
    public static read(buffer: DeserializerBase): RotateOptions {
        let valueDeserializer : DeserializerBase = buffer
        const xTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let xTmpBuf : double | undefined = undefined
        if ((xTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            xTmpBuf = valueDeserializer.readFloat64()
        }
        const xTmpResult : double | undefined = xTmpBuf
        const yTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let yTmpBuf : double | undefined = undefined
        if ((yTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            yTmpBuf = valueDeserializer.readFloat64()
        }
        const yTmpResult : double | undefined = yTmpBuf
        const zTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let zTmpBuf : double | undefined = undefined
        if ((zTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            zTmpBuf = valueDeserializer.readFloat64()
        }
        const zTmpResult : double | undefined = zTmpBuf
        const centerXTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let centerXTmpBuf : double | string | undefined = undefined
        if ((centerXTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const centerXTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let centerXTmpBuf_ : double | string | undefined
            if (centerXTmpBuf_UnionSelector == (0).toChar()) {
                centerXTmpBuf_ = valueDeserializer.readFloat64()
            } else if (centerXTmpBuf_UnionSelector == (1).toChar()) {
                centerXTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for centerXTmpBuf_ has to be chosen through deserialisation.")
            }
            centerXTmpBuf = (centerXTmpBuf_ as double | string)
        }
        const centerXTmpResult : double | string | undefined = centerXTmpBuf
        const centerYTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let centerYTmpBuf : double | string | undefined = undefined
        if ((centerYTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const centerYTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let centerYTmpBuf_ : double | string | undefined
            if (centerYTmpBuf_UnionSelector == (0).toChar()) {
                centerYTmpBuf_ = valueDeserializer.readFloat64()
            } else if (centerYTmpBuf_UnionSelector == (1).toChar()) {
                centerYTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for centerYTmpBuf_ has to be chosen through deserialisation.")
            }
            centerYTmpBuf = (centerYTmpBuf_ as double | string)
        }
        const centerYTmpResult : double | string | undefined = centerYTmpBuf
        const centerZTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let centerZTmpBuf : double | undefined = undefined
        if ((centerZTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            centerZTmpBuf = valueDeserializer.readFloat64()
        }
        const centerZTmpResult : double | undefined = centerZTmpBuf
        const perspectiveTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let perspectiveTmpBuf : double | undefined = undefined
        if ((perspectiveTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            perspectiveTmpBuf = valueDeserializer.readFloat64()
        }
        const perspectiveTmpResult : double | undefined = perspectiveTmpBuf
        const angleTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let angleTmpBuf : double | string | undefined
        if (angleTmpBufUnionSelector == (0).toChar()) {
            angleTmpBuf = valueDeserializer.readFloat64()
        } else if (angleTmpBufUnionSelector == (1).toChar()) {
            angleTmpBuf = (valueDeserializer.readString() as string)
        } else {
            throw new Error("One of the branches for angleTmpBuf has to be chosen through deserialisation.")
        }
        const angleTmpResult : double | string = (angleTmpBuf as double | string)
        let value : RotateOptions = ({x: xTmpResult, y: yTmpResult, z: zTmpResult, centerX: centerXTmpResult, centerY: centerYTmpResult, centerZ: centerZTmpResult, perspective: perspectiveTmpResult, angle: angleTmpResult} as RotateOptions)
        return value
    }
}
export class ScaleOptions_serializer {
    public static write(buffer: SerializerBase, value: ScaleOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForX  = value.x
        if (valueHolderForX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForXTmpValue  = valueHolderForX!
            valueSerializer.writeFloat64(valueHolderForXTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForY  = value.y
        if (valueHolderForY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForYTmpValue  = valueHolderForY!
            valueSerializer.writeFloat64(valueHolderForYTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForZ  = value.z
        if (valueHolderForZ !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForZTmpValue  = valueHolderForZ!
            valueSerializer.writeFloat64(valueHolderForZTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCenterX  = value.centerX
        if (valueHolderForCenterX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCenterXTmpValue  = valueHolderForCenterX!
            if (valueHolderForCenterXTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForCenterXTmpValueForIdx0  = valueHolderForCenterXTmpValue as double
                valueSerializer.writeFloat64(valueHolderForCenterXTmpValueForIdx0)
            } else if (valueHolderForCenterXTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForCenterXTmpValueForIdx1  = valueHolderForCenterXTmpValue as string
                valueSerializer.writeString(valueHolderForCenterXTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCenterY  = value.centerY
        if (valueHolderForCenterY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCenterYTmpValue  = valueHolderForCenterY!
            if (valueHolderForCenterYTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForCenterYTmpValueForIdx0  = valueHolderForCenterYTmpValue as double
                valueSerializer.writeFloat64(valueHolderForCenterYTmpValueForIdx0)
            } else if (valueHolderForCenterYTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForCenterYTmpValueForIdx1  = valueHolderForCenterYTmpValue as string
                valueSerializer.writeString(valueHolderForCenterYTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ScaleOptions {
        let valueDeserializer : DeserializerBase = buffer
        const xTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let xTmpBuf : double | undefined = undefined
        if ((xTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            xTmpBuf = valueDeserializer.readFloat64()
        }
        const xTmpResult : double | undefined = xTmpBuf
        const yTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let yTmpBuf : double | undefined = undefined
        if ((yTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            yTmpBuf = valueDeserializer.readFloat64()
        }
        const yTmpResult : double | undefined = yTmpBuf
        const zTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let zTmpBuf : double | undefined = undefined
        if ((zTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            zTmpBuf = valueDeserializer.readFloat64()
        }
        const zTmpResult : double | undefined = zTmpBuf
        const centerXTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let centerXTmpBuf : double | string | undefined = undefined
        if ((centerXTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const centerXTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let centerXTmpBuf_ : double | string | undefined
            if (centerXTmpBuf_UnionSelector == (0).toChar()) {
                centerXTmpBuf_ = valueDeserializer.readFloat64()
            } else if (centerXTmpBuf_UnionSelector == (1).toChar()) {
                centerXTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for centerXTmpBuf_ has to be chosen through deserialisation.")
            }
            centerXTmpBuf = (centerXTmpBuf_ as double | string)
        }
        const centerXTmpResult : double | string | undefined = centerXTmpBuf
        const centerYTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let centerYTmpBuf : double | string | undefined = undefined
        if ((centerYTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const centerYTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let centerYTmpBuf_ : double | string | undefined
            if (centerYTmpBuf_UnionSelector == (0).toChar()) {
                centerYTmpBuf_ = valueDeserializer.readFloat64()
            } else if (centerYTmpBuf_UnionSelector == (1).toChar()) {
                centerYTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for centerYTmpBuf_ has to be chosen through deserialisation.")
            }
            centerYTmpBuf = (centerYTmpBuf_ as double | string)
        }
        const centerYTmpResult : double | string | undefined = centerYTmpBuf
        let value : ScaleOptions = ({x: xTmpResult, y: yTmpResult, z: zTmpResult, centerX: centerXTmpResult, centerY: centerYTmpResult} as ScaleOptions)
        return value
    }
}
export class SelectionOptions_serializer {
    public static write(buffer: SerializerBase, value: SelectionOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForMenuPolicy  = value.menuPolicy
        if (valueHolderForMenuPolicy !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMenuPolicyTmpValue  = (valueHolderForMenuPolicy as MenuPolicy)
            valueSerializer.writeInt32(valueHolderForMenuPolicyTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): SelectionOptions {
        let valueDeserializer : DeserializerBase = buffer
        const menuPolicyTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let menuPolicyTmpBuf : MenuPolicy | undefined = undefined
        if ((menuPolicyTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            menuPolicyTmpBuf = MenuPolicy.fromValue(valueDeserializer.readInt32())
        }
        const menuPolicyTmpResult : MenuPolicy | undefined = menuPolicyTmpBuf
        let value : SelectionOptions = ({menuPolicy: menuPolicyTmpResult} as SelectionOptions)
        return value
    }
}
export class SheetDismiss_serializer {
    public static write(buffer: SerializerBase, value: SheetDismiss): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDismiss  = value.dismiss
        valueSerializer.holdAndWriteCallback(valueHolderForDismiss)
    }
    public static read(buffer: DeserializerBase): SheetDismiss {
        let valueDeserializer : DeserializerBase = buffer
        const dismissTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const dismissTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const dismissTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const dismissTmpResult : VoidCallback = ():void => {
            const dismissTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            dismissTmpBufBufArgsSerializer.writeInt32(dismissTmpBufBufResource.resourceId);
            dismissTmpBufBufArgsSerializer.writePointer(dismissTmpBufBufCall);
            dismissTmpBufBufArgsSerializer.writePointer(dismissTmpBufBufCallSync);
            InteropNativeModule._CallCallbackSync(10, -2038961969, dismissTmpBufBufArgsSerializer.asBuffer(), dismissTmpBufBufArgsSerializer.length());
            dismissTmpBufBufArgsSerializer.release();
            return;
        }
        let value : SheetDismiss = ({dismiss: dismissTmpResult} as SheetDismiss)
        return value
    }
}
export class SpringBackAction_serializer {
    public static write(buffer: SerializerBase, value: SpringBackAction): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): SpringBackAction {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return SpringBackActionInternal.fromPtr(ptr)
    }
}
export class SystemAdaptiveOptions_serializer {
    public static write(buffer: SerializerBase, value: SystemAdaptiveOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDisableSystemAdaptation  = value.disableSystemAdaptation
        if (valueHolderForDisableSystemAdaptation !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDisableSystemAdaptationTmpValue  = valueHolderForDisableSystemAdaptation!
            valueSerializer.writeBoolean(valueHolderForDisableSystemAdaptationTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): SystemAdaptiveOptions {
        let valueDeserializer : DeserializerBase = buffer
        const disableSystemAdaptationTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let disableSystemAdaptationTmpBuf : boolean | undefined = undefined
        if ((disableSystemAdaptationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            disableSystemAdaptationTmpBuf = valueDeserializer.readBoolean()
        }
        const disableSystemAdaptationTmpResult : boolean | undefined = disableSystemAdaptationTmpBuf
        let value : SystemAdaptiveOptions = ({disableSystemAdaptation: disableSystemAdaptationTmpResult} as SystemAdaptiveOptions)
        return value
    }
}
export class TextContentControllerOptions_serializer {
    public static write(buffer: SerializerBase, value: TextContentControllerOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForOffset  = value.offset
        if (valueHolderForOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetTmpValue  = valueHolderForOffset!
            valueSerializer.writeInt32(valueHolderForOffsetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): TextContentControllerOptions {
        let valueDeserializer : DeserializerBase = buffer
        const offsetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offsetTmpBuf : int32 | undefined = undefined
        if ((offsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            offsetTmpBuf = valueDeserializer.readInt32()
        }
        const offsetTmpResult : int32 | undefined = offsetTmpBuf
        let value : TextContentControllerOptions = ({offset: offsetTmpResult} as TextContentControllerOptions)
        return value
    }
}
export class TouchObject_serializer {
    public static write(buffer: SerializerBase, value: TouchObject): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForType  = value.type
        valueSerializer.writeInt32(valueHolderForType.valueOf())
        const valueHolderForId  = value.id
        valueSerializer.writeInt32(valueHolderForId)
        const valueHolderForDisplayX  = value.displayX
        valueSerializer.writeFloat64(valueHolderForDisplayX)
        const valueHolderForDisplayY  = value.displayY
        valueSerializer.writeFloat64(valueHolderForDisplayY)
        const valueHolderForWindowX  = value.windowX
        valueSerializer.writeFloat64(valueHolderForWindowX)
        const valueHolderForWindowY  = value.windowY
        valueSerializer.writeFloat64(valueHolderForWindowY)
        const valueHolderForX  = value.x
        valueSerializer.writeFloat64(valueHolderForX)
        const valueHolderForY  = value.y
        valueSerializer.writeFloat64(valueHolderForY)
        const valueHolderForHand  = value.hand
        if (valueHolderForHand !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHandTmpValue  = (valueHolderForHand as InteractionHand)
            valueSerializer.writeInt32(valueHolderForHandTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPressedTime  = value.pressedTime
        if (valueHolderForPressedTime !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPressedTimeTmpValue  = valueHolderForPressedTime!
            valueSerializer.writeInt64(valueHolderForPressedTimeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPressure  = value.pressure
        if (valueHolderForPressure !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPressureTmpValue  = valueHolderForPressure!
            valueSerializer.writeFloat64(valueHolderForPressureTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForWidth  = value.width
        if (valueHolderForWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForWidthTmpValue  = valueHolderForWidth!
            valueSerializer.writeFloat64(valueHolderForWidthTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHeight  = value.height
        if (valueHolderForHeight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHeightTmpValue  = valueHolderForHeight!
            valueSerializer.writeFloat64(valueHolderForHeightTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): TouchObject {
        let valueDeserializer : DeserializerBase = buffer
        const typeTmpResult : TouchType = TouchType.fromValue(valueDeserializer.readInt32())
        const idTmpResult : int32 = valueDeserializer.readInt32()
        const displayXTmpResult : double = valueDeserializer.readFloat64()
        const displayYTmpResult : double = valueDeserializer.readFloat64()
        const windowXTmpResult : double = valueDeserializer.readFloat64()
        const windowYTmpResult : double = valueDeserializer.readFloat64()
        const xTmpResult : double = valueDeserializer.readFloat64()
        const yTmpResult : double = valueDeserializer.readFloat64()
        const handTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let handTmpBuf : InteractionHand | undefined = undefined
        if ((handTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            handTmpBuf = InteractionHand.fromValue(valueDeserializer.readInt32())
        }
        const handTmpResult : InteractionHand | undefined = handTmpBuf
        const pressedTimeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let pressedTimeTmpBuf : int64 | undefined = undefined
        if ((pressedTimeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            pressedTimeTmpBuf = valueDeserializer.readInt64()
        }
        const pressedTimeTmpResult : int64 | undefined = pressedTimeTmpBuf
        const pressureTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let pressureTmpBuf : double | undefined = undefined
        if ((pressureTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            pressureTmpBuf = valueDeserializer.readFloat64()
        }
        const pressureTmpResult : double | undefined = pressureTmpBuf
        const widthTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let widthTmpBuf : double | undefined = undefined
        if ((widthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            widthTmpBuf = valueDeserializer.readFloat64()
        }
        const widthTmpResult : double | undefined = widthTmpBuf
        const heightTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let heightTmpBuf : double | undefined = undefined
        if ((heightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            heightTmpBuf = valueDeserializer.readFloat64()
        }
        const heightTmpResult : double | undefined = heightTmpBuf
        let value : TouchObject = ({type: typeTmpResult, id: idTmpResult, displayX: displayXTmpResult, displayY: displayYTmpResult, windowX: windowXTmpResult, windowY: windowYTmpResult, x: xTmpResult, y: yTmpResult, hand: handTmpResult, pressedTime: pressedTimeTmpResult, pressure: pressureTmpResult, width: widthTmpResult, height: heightTmpResult} as TouchObject)
        return value
    }
}
export class TouchResult_serializer {
    public static write(buffer: SerializerBase, value: TouchResult): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForStrategy  = value.strategy
        valueSerializer.writeInt32(valueHolderForStrategy.valueOf())
        const valueHolderForId  = value.id
        if (valueHolderForId !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForIdTmpValue  = valueHolderForId!
            valueSerializer.writeString(valueHolderForIdTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): TouchResult {
        let valueDeserializer : DeserializerBase = buffer
        const strategyTmpResult : TouchTestStrategy = TouchTestStrategy.fromValue(valueDeserializer.readInt32())
        const idTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let idTmpBuf : string | undefined = undefined
        if ((idTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            idTmpBuf = (valueDeserializer.readString() as string)
        }
        const idTmpResult : string | undefined = idTmpBuf
        let value : TouchResult = ({strategy: strategyTmpResult, id: idTmpResult} as TouchResult)
        return value
    }
}
export class TranslateOptions_serializer {
    public static write(buffer: SerializerBase, value: TranslateOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForX  = value.x
        if (valueHolderForX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForXTmpValue  = valueHolderForX!
            if (valueHolderForXTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForXTmpValueForIdx0  = valueHolderForXTmpValue as double
                valueSerializer.writeFloat64(valueHolderForXTmpValueForIdx0)
            } else if (valueHolderForXTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForXTmpValueForIdx1  = valueHolderForXTmpValue as string
                valueSerializer.writeString(valueHolderForXTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForY  = value.y
        if (valueHolderForY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForYTmpValue  = valueHolderForY!
            if (valueHolderForYTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForYTmpValueForIdx0  = valueHolderForYTmpValue as double
                valueSerializer.writeFloat64(valueHolderForYTmpValueForIdx0)
            } else if (valueHolderForYTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForYTmpValueForIdx1  = valueHolderForYTmpValue as string
                valueSerializer.writeString(valueHolderForYTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForZ  = value.z
        if (valueHolderForZ !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForZTmpValue  = valueHolderForZ!
            if (valueHolderForZTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForZTmpValueForIdx0  = valueHolderForZTmpValue as double
                valueSerializer.writeFloat64(valueHolderForZTmpValueForIdx0)
            } else if (valueHolderForZTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForZTmpValueForIdx1  = valueHolderForZTmpValue as string
                valueSerializer.writeString(valueHolderForZTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): TranslateOptions {
        let valueDeserializer : DeserializerBase = buffer
        const xTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let xTmpBuf : double | string | undefined = undefined
        if ((xTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const xTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let xTmpBuf_ : double | string | undefined
            if (xTmpBuf_UnionSelector == (0).toChar()) {
                xTmpBuf_ = valueDeserializer.readFloat64()
            } else if (xTmpBuf_UnionSelector == (1).toChar()) {
                xTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for xTmpBuf_ has to be chosen through deserialisation.")
            }
            xTmpBuf = (xTmpBuf_ as double | string)
        }
        const xTmpResult : double | string | undefined = xTmpBuf
        const yTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let yTmpBuf : double | string | undefined = undefined
        if ((yTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const yTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let yTmpBuf_ : double | string | undefined
            if (yTmpBuf_UnionSelector == (0).toChar()) {
                yTmpBuf_ = valueDeserializer.readFloat64()
            } else if (yTmpBuf_UnionSelector == (1).toChar()) {
                yTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for yTmpBuf_ has to be chosen through deserialisation.")
            }
            yTmpBuf = (yTmpBuf_ as double | string)
        }
        const yTmpResult : double | string | undefined = yTmpBuf
        const zTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let zTmpBuf : double | string | undefined = undefined
        if ((zTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const zTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let zTmpBuf_ : double | string | undefined
            if (zTmpBuf_UnionSelector == (0).toChar()) {
                zTmpBuf_ = valueDeserializer.readFloat64()
            } else if (zTmpBuf_UnionSelector == (1).toChar()) {
                zTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for zTmpBuf_ has to be chosen through deserialisation.")
            }
            zTmpBuf = (zTmpBuf_ as double | string)
        }
        const zTmpResult : double | string | undefined = zTmpBuf
        let value : TranslateOptions = ({x: xTmpResult, y: yTmpResult, z: zTmpResult} as TranslateOptions)
        return value
    }
}
export class VisibleAreaEventOptions_serializer {
    public static write(buffer: SerializerBase, value: VisibleAreaEventOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForRatios  = value.ratios
        valueSerializer.writeInt32((valueHolderForRatios.length).toInt())
        for (let valueHolderForRatiosCounterI = 0; valueHolderForRatiosCounterI < valueHolderForRatios.length; valueHolderForRatiosCounterI++) {
            const valueHolderForRatiosTmpElement : double = valueHolderForRatios[valueHolderForRatiosCounterI]
            valueSerializer.writeFloat64(valueHolderForRatiosTmpElement)
        }
        const valueHolderForExpectedUpdateInterval  = value.expectedUpdateInterval
        if (valueHolderForExpectedUpdateInterval !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForExpectedUpdateIntervalTmpValue  = valueHolderForExpectedUpdateInterval!
            valueSerializer.writeInt32(valueHolderForExpectedUpdateIntervalTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): VisibleAreaEventOptions {
        let valueDeserializer : DeserializerBase = buffer
        const ratiosTmpBufLength : int32 = valueDeserializer.readInt32()
        let ratiosTmpBuf : Array<double> = new Array<double>(ratiosTmpBufLength)
        for (let ratiosTmpBufBufCounterI = 0; ratiosTmpBufBufCounterI < ratiosTmpBufLength; ratiosTmpBufBufCounterI++) {
            ratiosTmpBuf[ratiosTmpBufBufCounterI] = valueDeserializer.readFloat64()
        }
        const ratiosTmpResult : Array<double> = ratiosTmpBuf
        const expectedUpdateIntervalTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let expectedUpdateIntervalTmpBuf : int32 | undefined = undefined
        if ((expectedUpdateIntervalTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            expectedUpdateIntervalTmpBuf = valueDeserializer.readInt32()
        }
        const expectedUpdateIntervalTmpResult : int32 | undefined = expectedUpdateIntervalTmpBuf
        let value : VisibleAreaEventOptions = ({ratios: ratiosTmpResult, expectedUpdateInterval: expectedUpdateIntervalTmpResult} as VisibleAreaEventOptions)
        return value
    }
}
export class AlignRuleOption_serializer {
    public static write(buffer: SerializerBase, value: AlignRuleOption): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForLeft  = value.left
        if (valueHolderForLeft !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForLeftTmpValue  = valueHolderForLeft!
            HorizontalAlignParam_serializer.write(valueSerializer, valueHolderForLeftTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRight  = value.right
        if (valueHolderForRight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRightTmpValue  = valueHolderForRight!
            HorizontalAlignParam_serializer.write(valueSerializer, valueHolderForRightTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMiddle  = value.middle
        if (valueHolderForMiddle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMiddleTmpValue  = valueHolderForMiddle!
            HorizontalAlignParam_serializer.write(valueSerializer, valueHolderForMiddleTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTop  = value.top
        if (valueHolderForTop !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTopTmpValue  = valueHolderForTop!
            VerticalAlignParam_serializer.write(valueSerializer, valueHolderForTopTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBottom  = value.bottom
        if (valueHolderForBottom !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBottomTmpValue  = valueHolderForBottom!
            VerticalAlignParam_serializer.write(valueSerializer, valueHolderForBottomTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCenter  = value.center
        if (valueHolderForCenter !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCenterTmpValue  = valueHolderForCenter!
            VerticalAlignParam_serializer.write(valueSerializer, valueHolderForCenterTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBias  = value.bias
        if (valueHolderForBias !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBiasTmpValue  = valueHolderForBias!
            Bias_serializer.write(valueSerializer, valueHolderForBiasTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): AlignRuleOption {
        let valueDeserializer : DeserializerBase = buffer
        const leftTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let leftTmpBuf : HorizontalAlignParam | undefined = undefined
        if ((leftTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            leftTmpBuf = HorizontalAlignParam_serializer.read(valueDeserializer)
        }
        const leftTmpResult : HorizontalAlignParam | undefined = leftTmpBuf
        const rightTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let rightTmpBuf : HorizontalAlignParam | undefined = undefined
        if ((rightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            rightTmpBuf = HorizontalAlignParam_serializer.read(valueDeserializer)
        }
        const rightTmpResult : HorizontalAlignParam | undefined = rightTmpBuf
        const middleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let middleTmpBuf : HorizontalAlignParam | undefined = undefined
        if ((middleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            middleTmpBuf = HorizontalAlignParam_serializer.read(valueDeserializer)
        }
        const middleTmpResult : HorizontalAlignParam | undefined = middleTmpBuf
        const topTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let topTmpBuf : VerticalAlignParam | undefined = undefined
        if ((topTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            topTmpBuf = VerticalAlignParam_serializer.read(valueDeserializer)
        }
        const topTmpResult : VerticalAlignParam | undefined = topTmpBuf
        const bottomTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let bottomTmpBuf : VerticalAlignParam | undefined = undefined
        if ((bottomTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            bottomTmpBuf = VerticalAlignParam_serializer.read(valueDeserializer)
        }
        const bottomTmpResult : VerticalAlignParam | undefined = bottomTmpBuf
        const centerTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let centerTmpBuf : VerticalAlignParam | undefined = undefined
        if ((centerTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            centerTmpBuf = VerticalAlignParam_serializer.read(valueDeserializer)
        }
        const centerTmpResult : VerticalAlignParam | undefined = centerTmpBuf
        const biasTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let biasTmpBuf : Bias | undefined = undefined
        if ((biasTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            biasTmpBuf = Bias_serializer.read(valueDeserializer)
        }
        const biasTmpResult : Bias | undefined = biasTmpBuf
        let value : AlignRuleOption = ({left: leftTmpResult, right: rightTmpResult, middle: middleTmpResult, top: topTmpResult, bottom: bottomTmpResult, center: centerTmpResult, bias: biasTmpResult} as AlignRuleOption)
        return value
    }
}
export class AnimateParam_serializer {
    public static write(buffer: SerializerBase, value: AnimateParam): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDuration  = value.duration
        if (valueHolderForDuration !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDurationTmpValue  = valueHolderForDuration!
            valueSerializer.writeInt32(valueHolderForDurationTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTempo  = value.tempo
        if (valueHolderForTempo !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTempoTmpValue  = valueHolderForTempo!
            valueSerializer.writeFloat64(valueHolderForTempoTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCurve  = value.curve
        if (valueHolderForCurve !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCurveTmpValue  = valueHolderForCurve!
            if (valueHolderForCurveTmpValue instanceof curves.Curve) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForCurveTmpValueForIdx0  = valueHolderForCurveTmpValue as curves.Curve
                valueSerializer.writeInt32(valueHolderForCurveTmpValueForIdx0.valueOf())
            } else if (valueHolderForCurveTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForCurveTmpValueForIdx1  = valueHolderForCurveTmpValue as string
                valueSerializer.writeString(valueHolderForCurveTmpValueForIdx1)
            } else if (valueHolderForCurveTmpValue instanceof curves.ICurve) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForCurveTmpValueForIdx2  = valueHolderForCurveTmpValue as curves.ICurve
                curves_ICurve_serializer.write(valueSerializer, valueHolderForCurveTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDelay  = value.delay
        if (valueHolderForDelay !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDelayTmpValue  = valueHolderForDelay!
            valueSerializer.writeInt32(valueHolderForDelayTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForIterations  = value.iterations
        if (valueHolderForIterations !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForIterationsTmpValue  = valueHolderForIterations!
            valueSerializer.writeInt32(valueHolderForIterationsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPlayMode  = value.playMode
        if (valueHolderForPlayMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPlayModeTmpValue  = (valueHolderForPlayMode as PlayMode)
            valueSerializer.writeInt32(valueHolderForPlayModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnFinish  = value.onFinish
        if (valueHolderForOnFinish !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnFinishTmpValue  = valueHolderForOnFinish!
            valueSerializer.holdAndWriteCallback(valueHolderForOnFinishTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFinishCallbackType  = value.finishCallbackType
        if (valueHolderForFinishCallbackType !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFinishCallbackTypeTmpValue  = (valueHolderForFinishCallbackType as FinishCallbackType)
            valueSerializer.writeInt32(valueHolderForFinishCallbackTypeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForExpectedFrameRateRange  = value.expectedFrameRateRange
        if (valueHolderForExpectedFrameRateRange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForExpectedFrameRateRangeTmpValue  = valueHolderForExpectedFrameRateRange!
            ExpectedFrameRateRange_serializer.write(valueSerializer, valueHolderForExpectedFrameRateRangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): AnimateParam {
        let valueDeserializer : DeserializerBase = buffer
        const durationTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let durationTmpBuf : int32 | undefined = undefined
        if ((durationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            durationTmpBuf = valueDeserializer.readInt32()
        }
        const durationTmpResult : int32 | undefined = durationTmpBuf
        const tempoTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let tempoTmpBuf : double | undefined = undefined
        if ((tempoTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            tempoTmpBuf = valueDeserializer.readFloat64()
        }
        const tempoTmpResult : double | undefined = tempoTmpBuf
        const curveTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let curveTmpBuf : curves.Curve | string | curves.ICurve | undefined = undefined
        if ((curveTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const curveTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let curveTmpBuf_ : curves.Curve | string | curves.ICurve | undefined
            if (curveTmpBuf_UnionSelector == (0).toChar()) {
                curveTmpBuf_ = curves.Curve.fromValue(valueDeserializer.readInt32())
            } else if (curveTmpBuf_UnionSelector == (1).toChar()) {
                curveTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (curveTmpBuf_UnionSelector == (2).toChar()) {
                curveTmpBuf_ = (curves_ICurve_serializer.read(valueDeserializer) as curves.ICurve)
            } else {
                throw new Error("One of the branches for curveTmpBuf_ has to be chosen through deserialisation.")
            }
            curveTmpBuf = (curveTmpBuf_ as curves.Curve | string | curves.ICurve)
        }
        const curveTmpResult : curves.Curve | string | curves.ICurve | undefined = curveTmpBuf
        const delayTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let delayTmpBuf : int32 | undefined = undefined
        if ((delayTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            delayTmpBuf = valueDeserializer.readInt32()
        }
        const delayTmpResult : int32 | undefined = delayTmpBuf
        const iterationsTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let iterationsTmpBuf : int32 | undefined = undefined
        if ((iterationsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            iterationsTmpBuf = valueDeserializer.readInt32()
        }
        const iterationsTmpResult : int32 | undefined = iterationsTmpBuf
        const playModeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let playModeTmpBuf : PlayMode | undefined = undefined
        if ((playModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            playModeTmpBuf = PlayMode.fromValue(valueDeserializer.readInt32())
        }
        const playModeTmpResult : PlayMode | undefined = playModeTmpBuf
        const onFinishTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onFinishTmpBuf : (() => void) | undefined = undefined
        if ((onFinishTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onFinishTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onFinishTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onFinishTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onFinishTmpBuf = ():void => {
                const onFinishTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onFinishTmpBuf_BufArgsSerializer.writeInt32(onFinishTmpBuf_BufResource.resourceId);
                onFinishTmpBuf_BufArgsSerializer.writePointer(onFinishTmpBuf_BufCall);
                onFinishTmpBuf_BufArgsSerializer.writePointer(onFinishTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, onFinishTmpBuf_BufArgsSerializer.asBuffer(), onFinishTmpBuf_BufArgsSerializer.length());
                onFinishTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onFinishTmpResult : (() => void) | undefined = onFinishTmpBuf
        const finishCallbackTypeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let finishCallbackTypeTmpBuf : FinishCallbackType | undefined = undefined
        if ((finishCallbackTypeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            finishCallbackTypeTmpBuf = FinishCallbackType.fromValue(valueDeserializer.readInt32())
        }
        const finishCallbackTypeTmpResult : FinishCallbackType | undefined = finishCallbackTypeTmpBuf
        const expectedFrameRateRangeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let expectedFrameRateRangeTmpBuf : ExpectedFrameRateRange | undefined = undefined
        if ((expectedFrameRateRangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            expectedFrameRateRangeTmpBuf = ExpectedFrameRateRange_serializer.read(valueDeserializer)
        }
        const expectedFrameRateRangeTmpResult : ExpectedFrameRateRange | undefined = expectedFrameRateRangeTmpBuf
        let value : AnimateParam = ({duration: durationTmpResult, tempo: tempoTmpResult, curve: curveTmpResult, delay: delayTmpResult, iterations: iterationsTmpResult, playMode: playModeTmpResult, onFinish: onFinishTmpResult, finishCallbackType: finishCallbackTypeTmpResult, expectedFrameRateRange: expectedFrameRateRangeTmpResult} as AnimateParam)
        return value
    }
}
export class BackgroundBlurStyleOptions_serializer {
    public static write(buffer: SerializerBase, value: BackgroundBlurStyleOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForColorMode  = value.colorMode
        if (valueHolderForColorMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForColorModeTmpValue  = (valueHolderForColorMode as ThemeColorMode)
            valueSerializer.writeInt32(valueHolderForColorModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAdaptiveColor  = value.adaptiveColor
        if (valueHolderForAdaptiveColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAdaptiveColorTmpValue  = (valueHolderForAdaptiveColor as AdaptiveColor)
            valueSerializer.writeInt32(valueHolderForAdaptiveColorTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForScale  = value.scale
        if (valueHolderForScale !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForScaleTmpValue  = valueHolderForScale!
            valueSerializer.writeFloat64(valueHolderForScaleTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBlurOptions  = value.blurOptions
        if (valueHolderForBlurOptions !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBlurOptionsTmpValue  = valueHolderForBlurOptions!
            BlurOptions_serializer.write(valueSerializer, valueHolderForBlurOptionsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPolicy  = value.policy
        if (valueHolderForPolicy !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPolicyTmpValue  = (valueHolderForPolicy as BlurStyleActivePolicy)
            valueSerializer.writeInt32(valueHolderForPolicyTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForInactiveColor  = value.inactiveColor
        if (valueHolderForInactiveColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForInactiveColorTmpValue  = valueHolderForInactiveColor!
            if (valueHolderForInactiveColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForInactiveColorTmpValueForIdx0  = valueHolderForInactiveColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForInactiveColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForInactiveColorTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForInactiveColorTmpValueForIdx1  = valueHolderForInactiveColorTmpValue as number
                valueSerializer.writeNumber(valueHolderForInactiveColorTmpValueForIdx1)
            } else if (valueHolderForInactiveColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForInactiveColorTmpValueForIdx2  = valueHolderForInactiveColorTmpValue as string
                valueSerializer.writeString(valueHolderForInactiveColorTmpValueForIdx2)
            } else if (valueHolderForInactiveColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForInactiveColorTmpValueForIdx3  = valueHolderForInactiveColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForInactiveColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): BackgroundBlurStyleOptions {
        let valueDeserializer : DeserializerBase = buffer
        const colorModeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let colorModeTmpBuf : ThemeColorMode | undefined = undefined
        if ((colorModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            colorModeTmpBuf = ThemeColorMode.fromValue(valueDeserializer.readInt32())
        }
        const colorModeTmpResult : ThemeColorMode | undefined = colorModeTmpBuf
        const adaptiveColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let adaptiveColorTmpBuf : AdaptiveColor | undefined = undefined
        if ((adaptiveColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            adaptiveColorTmpBuf = AdaptiveColor.fromValue(valueDeserializer.readInt32())
        }
        const adaptiveColorTmpResult : AdaptiveColor | undefined = adaptiveColorTmpBuf
        const scaleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let scaleTmpBuf : double | undefined = undefined
        if ((scaleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            scaleTmpBuf = valueDeserializer.readFloat64()
        }
        const scaleTmpResult : double | undefined = scaleTmpBuf
        const blurOptionsTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let blurOptionsTmpBuf : BlurOptions | undefined = undefined
        if ((blurOptionsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            blurOptionsTmpBuf = BlurOptions_serializer.read(valueDeserializer)
        }
        const blurOptionsTmpResult : BlurOptions | undefined = blurOptionsTmpBuf
        const policyTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let policyTmpBuf : BlurStyleActivePolicy | undefined = undefined
        if ((policyTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            policyTmpBuf = BlurStyleActivePolicy.fromValue(valueDeserializer.readInt32())
        }
        const policyTmpResult : BlurStyleActivePolicy | undefined = policyTmpBuf
        const inactiveColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let inactiveColorTmpBuf : ResourceColor | undefined = undefined
        if ((inactiveColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const inactiveColorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let inactiveColorTmpBuf_ : Color | number | string | Resource | undefined
            if (inactiveColorTmpBuf_UnionSelector == (0).toChar()) {
                inactiveColorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (inactiveColorTmpBuf_UnionSelector == (1).toChar()) {
                inactiveColorTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (inactiveColorTmpBuf_UnionSelector == (2).toChar()) {
                inactiveColorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (inactiveColorTmpBuf_UnionSelector == (3).toChar()) {
                inactiveColorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for inactiveColorTmpBuf_ has to be chosen through deserialisation.")
            }
            inactiveColorTmpBuf = (inactiveColorTmpBuf_ as Color | number | string | Resource)
        }
        const inactiveColorTmpResult : ResourceColor | undefined = inactiveColorTmpBuf
        let value : BackgroundBlurStyleOptions = ({colorMode: colorModeTmpResult, adaptiveColor: adaptiveColorTmpResult, scale: scaleTmpResult, blurOptions: blurOptionsTmpResult, policy: policyTmpResult, inactiveColor: inactiveColorTmpResult} as BackgroundBlurStyleOptions)
        return value
    }
}
export class BackgroundEffectOptions_serializer {
    public static write(buffer: SerializerBase, value: BackgroundEffectOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForRadius  = value.radius
        valueSerializer.writeFloat64(valueHolderForRadius)
        const valueHolderForSaturation  = value.saturation
        if (valueHolderForSaturation !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForSaturationTmpValue  = valueHolderForSaturation!
            valueSerializer.writeFloat64(valueHolderForSaturationTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBrightness  = value.brightness
        if (valueHolderForBrightness !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBrightnessTmpValue  = valueHolderForBrightness!
            valueSerializer.writeFloat64(valueHolderForBrightnessTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForColor  = value.color
        if (valueHolderForColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForColorTmpValue  = valueHolderForColor!
            if (valueHolderForColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorTmpValueForIdx0  = valueHolderForColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForColorTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorTmpValueForIdx1  = valueHolderForColorTmpValue as number
                valueSerializer.writeNumber(valueHolderForColorTmpValueForIdx1)
            } else if (valueHolderForColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorTmpValueForIdx2  = valueHolderForColorTmpValue as string
                valueSerializer.writeString(valueHolderForColorTmpValueForIdx2)
            } else if (valueHolderForColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorTmpValueForIdx3  = valueHolderForColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAdaptiveColor  = value.adaptiveColor
        if (valueHolderForAdaptiveColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAdaptiveColorTmpValue  = (valueHolderForAdaptiveColor as AdaptiveColor)
            valueSerializer.writeInt32(valueHolderForAdaptiveColorTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBlurOptions  = value.blurOptions
        if (valueHolderForBlurOptions !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBlurOptionsTmpValue  = valueHolderForBlurOptions!
            BlurOptions_serializer.write(valueSerializer, valueHolderForBlurOptionsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPolicy  = value.policy
        if (valueHolderForPolicy !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPolicyTmpValue  = (valueHolderForPolicy as BlurStyleActivePolicy)
            valueSerializer.writeInt32(valueHolderForPolicyTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForInactiveColor  = value.inactiveColor
        if (valueHolderForInactiveColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForInactiveColorTmpValue  = valueHolderForInactiveColor!
            if (valueHolderForInactiveColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForInactiveColorTmpValueForIdx0  = valueHolderForInactiveColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForInactiveColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForInactiveColorTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForInactiveColorTmpValueForIdx1  = valueHolderForInactiveColorTmpValue as number
                valueSerializer.writeNumber(valueHolderForInactiveColorTmpValueForIdx1)
            } else if (valueHolderForInactiveColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForInactiveColorTmpValueForIdx2  = valueHolderForInactiveColorTmpValue as string
                valueSerializer.writeString(valueHolderForInactiveColorTmpValueForIdx2)
            } else if (valueHolderForInactiveColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForInactiveColorTmpValueForIdx3  = valueHolderForInactiveColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForInactiveColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): BackgroundEffectOptions {
        let valueDeserializer : DeserializerBase = buffer
        const radiusTmpResult : double = valueDeserializer.readFloat64()
        const saturationTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let saturationTmpBuf : double | undefined = undefined
        if ((saturationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            saturationTmpBuf = valueDeserializer.readFloat64()
        }
        const saturationTmpResult : double | undefined = saturationTmpBuf
        const brightnessTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let brightnessTmpBuf : double | undefined = undefined
        if ((brightnessTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            brightnessTmpBuf = valueDeserializer.readFloat64()
        }
        const brightnessTmpResult : double | undefined = brightnessTmpBuf
        const colorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let colorTmpBuf : ResourceColor | undefined = undefined
        if ((colorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const colorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let colorTmpBuf_ : Color | number | string | Resource | undefined
            if (colorTmpBuf_UnionSelector == (0).toChar()) {
                colorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (colorTmpBuf_UnionSelector == (1).toChar()) {
                colorTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (colorTmpBuf_UnionSelector == (2).toChar()) {
                colorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (colorTmpBuf_UnionSelector == (3).toChar()) {
                colorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for colorTmpBuf_ has to be chosen through deserialisation.")
            }
            colorTmpBuf = (colorTmpBuf_ as Color | number | string | Resource)
        }
        const colorTmpResult : ResourceColor | undefined = colorTmpBuf
        const adaptiveColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let adaptiveColorTmpBuf : AdaptiveColor | undefined = undefined
        if ((adaptiveColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            adaptiveColorTmpBuf = AdaptiveColor.fromValue(valueDeserializer.readInt32())
        }
        const adaptiveColorTmpResult : AdaptiveColor | undefined = adaptiveColorTmpBuf
        const blurOptionsTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let blurOptionsTmpBuf : BlurOptions | undefined = undefined
        if ((blurOptionsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            blurOptionsTmpBuf = BlurOptions_serializer.read(valueDeserializer)
        }
        const blurOptionsTmpResult : BlurOptions | undefined = blurOptionsTmpBuf
        const policyTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let policyTmpBuf : BlurStyleActivePolicy | undefined = undefined
        if ((policyTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            policyTmpBuf = BlurStyleActivePolicy.fromValue(valueDeserializer.readInt32())
        }
        const policyTmpResult : BlurStyleActivePolicy | undefined = policyTmpBuf
        const inactiveColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let inactiveColorTmpBuf : ResourceColor | undefined = undefined
        if ((inactiveColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const inactiveColorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let inactiveColorTmpBuf_ : Color | number | string | Resource | undefined
            if (inactiveColorTmpBuf_UnionSelector == (0).toChar()) {
                inactiveColorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (inactiveColorTmpBuf_UnionSelector == (1).toChar()) {
                inactiveColorTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (inactiveColorTmpBuf_UnionSelector == (2).toChar()) {
                inactiveColorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (inactiveColorTmpBuf_UnionSelector == (3).toChar()) {
                inactiveColorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for inactiveColorTmpBuf_ has to be chosen through deserialisation.")
            }
            inactiveColorTmpBuf = (inactiveColorTmpBuf_ as Color | number | string | Resource)
        }
        const inactiveColorTmpResult : ResourceColor | undefined = inactiveColorTmpBuf
        let value : BackgroundEffectOptions = ({radius: radiusTmpResult, saturation: saturationTmpResult, brightness: brightnessTmpResult, color: colorTmpResult, adaptiveColor: adaptiveColorTmpResult, blurOptions: blurOptionsTmpResult, policy: policyTmpResult, inactiveColor: inactiveColorTmpResult} as BackgroundEffectOptions)
        return value
    }
}
export class Bindable_Arkui_Component_Units_ResourceStr_serializer {
    public static write(buffer: SerializerBase, value: Bindable<ResourceStr>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        if (valueHolderForValue instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForValueForIdx0  = valueHolderForValue as string
            valueSerializer.writeString(valueHolderForValueForIdx0)
        } else if (valueHolderForValue instanceof Resource) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForValueForIdx1  = valueHolderForValue as Resource
            Resource_serializer.write(valueSerializer, valueHolderForValueForIdx1)
        }
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<ResourceStr> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let valueTmpBuf : string | Resource | undefined
        if (valueTmpBufUnionSelector == (0).toChar()) {
            valueTmpBuf = (valueDeserializer.readString() as string)
        } else if (valueTmpBufUnionSelector == (1).toChar()) {
            valueTmpBuf = Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error("One of the branches for valueTmpBuf has to be chosen through deserialisation.")
        }
        const valueTmpResult : ResourceStr = (valueTmpBuf as string | Resource)
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpResult : ((value0: ResourceStr) => void) = (value0: ResourceStr):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            if (value0 instanceof string) {
                onChangeTmpBufBufArgsSerializer.writeInt8((0).toByte());
                const value0ForIdx0  = value0 as string;
                onChangeTmpBufBufArgsSerializer.writeString(value0ForIdx0);
            } else if (value0 instanceof Resource) {
                onChangeTmpBufBufArgsSerializer.writeInt8((1).toByte());
                const value0ForIdx1  = value0 as Resource;
                Resource_serializer.write(onChangeTmpBufBufArgsSerializer, value0ForIdx1);
            }
            InteropNativeModule._CallCallbackSync(10, 487399354, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        let value : Bindable<ResourceStr> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<ResourceStr>)
        return value
    }
}
export class Bindable_Global_Resource_Resource_serializer {
    public static write(buffer: SerializerBase, value: Bindable<Resource>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        Resource_serializer.write(valueSerializer, valueHolderForValue)
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<Resource> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpResult : Resource = Resource_serializer.read(valueDeserializer)
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpResult : ((value0: Resource) => void) = (value0: Resource):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            Resource_serializer.write(onChangeTmpBufBufArgsSerializer, value0);
            InteropNativeModule._CallCallbackSync(10, -941798353, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        let value : Bindable<Resource> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<Resource>)
        return value
    }
}
export class ContentCoverOptions_serializer {
    public static write(buffer: SerializerBase, value: ContentCoverOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForBackgroundColor  = value.backgroundColor
        if (valueHolderForBackgroundColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundColorTmpValue  = valueHolderForBackgroundColor!
            if (valueHolderForBackgroundColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx0  = valueHolderForBackgroundColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForBackgroundColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForBackgroundColorTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx1  = valueHolderForBackgroundColorTmpValue as number
                valueSerializer.writeNumber(valueHolderForBackgroundColorTmpValueForIdx1)
            } else if (valueHolderForBackgroundColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx2  = valueHolderForBackgroundColorTmpValue as string
                valueSerializer.writeString(valueHolderForBackgroundColorTmpValueForIdx2)
            } else if (valueHolderForBackgroundColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx3  = valueHolderForBackgroundColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForBackgroundColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnAppear  = value.onAppear
        if (valueHolderForOnAppear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnAppearTmpValue  = valueHolderForOnAppear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnAppearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnDisappear  = value.onDisappear
        if (valueHolderForOnDisappear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnDisappearTmpValue  = valueHolderForOnDisappear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnDisappearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillAppear  = value.onWillAppear
        if (valueHolderForOnWillAppear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillAppearTmpValue  = valueHolderForOnWillAppear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnWillAppearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillDisappear  = value.onWillDisappear
        if (valueHolderForOnWillDisappear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillDisappearTmpValue  = valueHolderForOnWillDisappear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnWillDisappearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForModalTransition  = value.modalTransition
        if (valueHolderForModalTransition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForModalTransitionTmpValue  = (valueHolderForModalTransition as ModalTransition)
            valueSerializer.writeInt32(valueHolderForModalTransitionTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillDismiss  = value.onWillDismiss
        if (valueHolderForOnWillDismiss !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillDismissTmpValue  = valueHolderForOnWillDismiss!
            valueSerializer.holdAndWriteCallback(valueHolderForOnWillDismissTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTransition  = value.transition
        if (valueHolderForTransition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTransitionTmpValue  = valueHolderForTransition!
            TransitionEffect_serializer.write(valueSerializer, valueHolderForTransitionTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableSafeArea  = value.enableSafeArea
        if (valueHolderForEnableSafeArea !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableSafeAreaTmpValue  = valueHolderForEnableSafeArea!
            valueSerializer.writeBoolean(valueHolderForEnableSafeAreaTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ContentCoverOptions {
        let valueDeserializer : DeserializerBase = buffer
        const backgroundColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundColorTmpBuf : ResourceColor | undefined = undefined
        if ((backgroundColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const backgroundColorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let backgroundColorTmpBuf_ : Color | number | string | Resource | undefined
            if (backgroundColorTmpBuf_UnionSelector == (0).toChar()) {
                backgroundColorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (backgroundColorTmpBuf_UnionSelector == (1).toChar()) {
                backgroundColorTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (backgroundColorTmpBuf_UnionSelector == (2).toChar()) {
                backgroundColorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (backgroundColorTmpBuf_UnionSelector == (3).toChar()) {
                backgroundColorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for backgroundColorTmpBuf_ has to be chosen through deserialisation.")
            }
            backgroundColorTmpBuf = (backgroundColorTmpBuf_ as Color | number | string | Resource)
        }
        const backgroundColorTmpResult : ResourceColor | undefined = backgroundColorTmpBuf
        const onAppearTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onAppearTmpBuf : (() => void) | undefined = undefined
        if ((onAppearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onAppearTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onAppearTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onAppearTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onAppearTmpBuf = ():void => {
                const onAppearTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onAppearTmpBuf_BufArgsSerializer.writeInt32(onAppearTmpBuf_BufResource.resourceId);
                onAppearTmpBuf_BufArgsSerializer.writePointer(onAppearTmpBuf_BufCall);
                onAppearTmpBuf_BufArgsSerializer.writePointer(onAppearTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, onAppearTmpBuf_BufArgsSerializer.asBuffer(), onAppearTmpBuf_BufArgsSerializer.length());
                onAppearTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onAppearTmpResult : (() => void) | undefined = onAppearTmpBuf
        const onDisappearTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onDisappearTmpBuf : (() => void) | undefined = undefined
        if ((onDisappearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onDisappearTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDisappearTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onDisappearTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onDisappearTmpBuf = ():void => {
                const onDisappearTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onDisappearTmpBuf_BufArgsSerializer.writeInt32(onDisappearTmpBuf_BufResource.resourceId);
                onDisappearTmpBuf_BufArgsSerializer.writePointer(onDisappearTmpBuf_BufCall);
                onDisappearTmpBuf_BufArgsSerializer.writePointer(onDisappearTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, onDisappearTmpBuf_BufArgsSerializer.asBuffer(), onDisappearTmpBuf_BufArgsSerializer.length());
                onDisappearTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onDisappearTmpResult : (() => void) | undefined = onDisappearTmpBuf
        const onWillAppearTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillAppearTmpBuf : (() => void) | undefined = undefined
        if ((onWillAppearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillAppearTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillAppearTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onWillAppearTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onWillAppearTmpBuf = ():void => {
                const onWillAppearTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onWillAppearTmpBuf_BufArgsSerializer.writeInt32(onWillAppearTmpBuf_BufResource.resourceId);
                onWillAppearTmpBuf_BufArgsSerializer.writePointer(onWillAppearTmpBuf_BufCall);
                onWillAppearTmpBuf_BufArgsSerializer.writePointer(onWillAppearTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, onWillAppearTmpBuf_BufArgsSerializer.asBuffer(), onWillAppearTmpBuf_BufArgsSerializer.length());
                onWillAppearTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onWillAppearTmpResult : (() => void) | undefined = onWillAppearTmpBuf
        const onWillDisappearTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillDisappearTmpBuf : (() => void) | undefined = undefined
        if ((onWillDisappearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillDisappearTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillDisappearTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onWillDisappearTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onWillDisappearTmpBuf = ():void => {
                const onWillDisappearTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onWillDisappearTmpBuf_BufArgsSerializer.writeInt32(onWillDisappearTmpBuf_BufResource.resourceId);
                onWillDisappearTmpBuf_BufArgsSerializer.writePointer(onWillDisappearTmpBuf_BufCall);
                onWillDisappearTmpBuf_BufArgsSerializer.writePointer(onWillDisappearTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, onWillDisappearTmpBuf_BufArgsSerializer.asBuffer(), onWillDisappearTmpBuf_BufArgsSerializer.length());
                onWillDisappearTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onWillDisappearTmpResult : (() => void) | undefined = onWillDisappearTmpBuf
        const modalTransitionTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let modalTransitionTmpBuf : ModalTransition | undefined = undefined
        if ((modalTransitionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            modalTransitionTmpBuf = ModalTransition.fromValue(valueDeserializer.readInt32())
        }
        const modalTransitionTmpResult : ModalTransition | undefined = modalTransitionTmpBuf
        const onWillDismissTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillDismissTmpBuf : ((value0: DismissContentCoverAction) => void) | undefined = undefined
        if ((onWillDismissTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillDismissTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillDismissTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onWillDismissTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onWillDismissTmpBuf = (value0: DismissContentCoverAction):void => {
                const onWillDismissTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onWillDismissTmpBuf_BufArgsSerializer.writeInt32(onWillDismissTmpBuf_BufResource.resourceId);
                onWillDismissTmpBuf_BufArgsSerializer.writePointer(onWillDismissTmpBuf_BufCall);
                onWillDismissTmpBuf_BufArgsSerializer.writePointer(onWillDismissTmpBuf_BufCallSync);
                DismissContentCoverAction_serializer.write(onWillDismissTmpBuf_BufArgsSerializer, value0);
                InteropNativeModule._CallCallbackSync(10, -1283506641, onWillDismissTmpBuf_BufArgsSerializer.asBuffer(), onWillDismissTmpBuf_BufArgsSerializer.length());
                onWillDismissTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onWillDismissTmpResult : ((value0: DismissContentCoverAction) => void) | undefined = onWillDismissTmpBuf
        const transitionTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let transitionTmpBuf : TransitionEffect | undefined = undefined
        if ((transitionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            transitionTmpBuf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transitionTmpResult : TransitionEffect | undefined = transitionTmpBuf
        const enableSafeAreaTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableSafeAreaTmpBuf : boolean | undefined = undefined
        if ((enableSafeAreaTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableSafeAreaTmpBuf = valueDeserializer.readBoolean()
        }
        const enableSafeAreaTmpResult : boolean | undefined = enableSafeAreaTmpBuf
        let value : ContentCoverOptions = ({backgroundColor: backgroundColorTmpResult, onAppear: onAppearTmpResult, onDisappear: onDisappearTmpResult, onWillAppear: onWillAppearTmpResult, onWillDisappear: onWillDisappearTmpResult, modalTransition: modalTransitionTmpResult, onWillDismiss: onWillDismissTmpResult, transition: transitionTmpResult, enableSafeArea: enableSafeAreaTmpResult} as ContentCoverOptions)
        return value
    }
}
export class ContextMenuAnimationOptions_serializer {
    public static write(buffer: SerializerBase, value: ContextMenuAnimationOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForScale  = value.scale
        if (valueHolderForScale !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForScaleTmpValue  = valueHolderForScale!
            const valueHolderForScaleTmpValue_0  = valueHolderForScaleTmpValue[0]
            valueSerializer.writeFloat64(valueHolderForScaleTmpValue_0)
            const valueHolderForScaleTmpValue_1  = valueHolderForScaleTmpValue[1]
            valueSerializer.writeFloat64(valueHolderForScaleTmpValue_1)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTransition  = value.transition
        if (valueHolderForTransition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTransitionTmpValue  = valueHolderForTransition!
            TransitionEffect_serializer.write(valueSerializer, valueHolderForTransitionTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHoverScale  = value.hoverScale
        if (valueHolderForHoverScale !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHoverScaleTmpValue  = valueHolderForHoverScale!
            const valueHolderForHoverScaleTmpValue_0  = valueHolderForHoverScaleTmpValue[0]
            valueSerializer.writeFloat64(valueHolderForHoverScaleTmpValue_0)
            const valueHolderForHoverScaleTmpValue_1  = valueHolderForHoverScaleTmpValue[1]
            valueSerializer.writeFloat64(valueHolderForHoverScaleTmpValue_1)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ContextMenuAnimationOptions {
        let valueDeserializer : DeserializerBase = buffer
        const scaleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let scaleTmpBuf : AnimationNumberRange | undefined = undefined
        if ((scaleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const scaleTmpBuf_Value0 : double = valueDeserializer.readFloat64()
            const scaleTmpBuf_Value1 : double = valueDeserializer.readFloat64()
            scaleTmpBuf = ([scaleTmpBuf_Value0, scaleTmpBuf_Value1] as AnimationNumberRange)
        }
        const scaleTmpResult : AnimationNumberRange | undefined = scaleTmpBuf
        const transitionTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let transitionTmpBuf : TransitionEffect | undefined = undefined
        if ((transitionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            transitionTmpBuf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transitionTmpResult : TransitionEffect | undefined = transitionTmpBuf
        const hoverScaleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let hoverScaleTmpBuf : AnimationNumberRange | undefined = undefined
        if ((hoverScaleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const hoverScaleTmpBuf_Value0 : double = valueDeserializer.readFloat64()
            const hoverScaleTmpBuf_Value1 : double = valueDeserializer.readFloat64()
            hoverScaleTmpBuf = ([hoverScaleTmpBuf_Value0, hoverScaleTmpBuf_Value1] as AnimationNumberRange)
        }
        const hoverScaleTmpResult : AnimationNumberRange | undefined = hoverScaleTmpBuf
        let value : ContextMenuAnimationOptions = ({scale: scaleTmpResult, transition: transitionTmpResult, hoverScale: hoverScaleTmpResult} as ContextMenuAnimationOptions)
        return value
    }
}
export class DragPreviewOptions_serializer {
    public static write(buffer: SerializerBase, value: DragPreviewOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForMode  = value.mode
        if (valueHolderForMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForModeTmpValue  = valueHolderForMode!
            if (TypeChecker.isDragPreviewMode(valueHolderForModeTmpValue)) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForModeTmpValueForIdx0  = valueHolderForModeTmpValue as DragPreviewMode
                valueSerializer.writeInt32(valueHolderForModeTmpValueForIdx0.valueOf())
            } else if (TypeChecker.isArray_DragPreviewMode(valueHolderForModeTmpValue)) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForModeTmpValueForIdx1  = valueHolderForModeTmpValue as Array<DragPreviewMode>
                valueSerializer.writeInt32((valueHolderForModeTmpValueForIdx1.length).toInt())
                for (let valueHolderForModeTmpValueForIdx1CounterI = 0; valueHolderForModeTmpValueForIdx1CounterI < valueHolderForModeTmpValueForIdx1.length; valueHolderForModeTmpValueForIdx1CounterI++) {
                    const valueHolderForModeTmpValueForIdx1TmpElement : DragPreviewMode = valueHolderForModeTmpValueForIdx1[valueHolderForModeTmpValueForIdx1CounterI]
                    valueSerializer.writeInt32(valueHolderForModeTmpValueForIdx1TmpElement.valueOf())
                }
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForModifier  = value.modifier
        if (valueHolderForModifier !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForModifierTmpValue  = valueHolderForModifier!
            ImageModifier_serializer.write(valueSerializer, valueHolderForModifierTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForNumberBadge  = value.numberBadge
        if (valueHolderForNumberBadge !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForNumberBadgeTmpValue  = valueHolderForNumberBadge!
            if (valueHolderForNumberBadgeTmpValue instanceof boolean) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForNumberBadgeTmpValueForIdx0  = valueHolderForNumberBadgeTmpValue as boolean
                valueSerializer.writeBoolean(valueHolderForNumberBadgeTmpValueForIdx0)
            } else if (valueHolderForNumberBadgeTmpValue instanceof int64) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForNumberBadgeTmpValueForIdx1  = valueHolderForNumberBadgeTmpValue as int64
                valueSerializer.writeInt64(valueHolderForNumberBadgeTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForSizeChangeEffect  = value.sizeChangeEffect
        if (valueHolderForSizeChangeEffect !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForSizeChangeEffectTmpValue  = (valueHolderForSizeChangeEffect as DraggingSizeChangeEffect)
            valueSerializer.writeInt32(valueHolderForSizeChangeEffectTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): DragPreviewOptions {
        let valueDeserializer : DeserializerBase = buffer
        const modeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let modeTmpBuf : DragPreviewMode | Array<DragPreviewMode> | undefined = undefined
        if ((modeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const modeTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let modeTmpBuf_ : DragPreviewMode | Array<DragPreviewMode> | undefined
            if (modeTmpBuf_UnionSelector == (0).toChar()) {
                modeTmpBuf_ = DragPreviewMode.fromValue(valueDeserializer.readInt32())
            } else if (modeTmpBuf_UnionSelector == (1).toChar()) {
                const modeTmpBuf_BufULength : int32 = valueDeserializer.readInt32()
                let modeTmpBuf_BufU : Array<DragPreviewMode> = new Array<DragPreviewMode>(modeTmpBuf_BufULength)
                for (let modeTmpBuf_BufUBufCounterI = 0; modeTmpBuf_BufUBufCounterI < modeTmpBuf_BufULength; modeTmpBuf_BufUBufCounterI++) {
                    modeTmpBuf_BufU[modeTmpBuf_BufUBufCounterI] = DragPreviewMode.fromValue(valueDeserializer.readInt32())
                }
                modeTmpBuf_ = modeTmpBuf_BufU
            } else {
                throw new Error("One of the branches for modeTmpBuf_ has to be chosen through deserialisation.")
            }
            modeTmpBuf = (modeTmpBuf_ as DragPreviewMode | Array<DragPreviewMode>)
        }
        const modeTmpResult : DragPreviewMode | Array<DragPreviewMode> | undefined = modeTmpBuf
        const modifierTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let modifierTmpBuf : ImageModifier | undefined = undefined
        if ((modifierTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            modifierTmpBuf = (ImageModifier_serializer.read(valueDeserializer) as ImageModifier)
        }
        const modifierTmpResult : ImageModifier | undefined = modifierTmpBuf
        const numberBadgeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let numberBadgeTmpBuf : boolean | int64 | undefined = undefined
        if ((numberBadgeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const numberBadgeTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let numberBadgeTmpBuf_ : boolean | int64 | undefined
            if (numberBadgeTmpBuf_UnionSelector == (0).toChar()) {
                numberBadgeTmpBuf_ = valueDeserializer.readBoolean()
            } else if (numberBadgeTmpBuf_UnionSelector == (1).toChar()) {
                numberBadgeTmpBuf_ = valueDeserializer.readInt64()
            } else {
                throw new Error("One of the branches for numberBadgeTmpBuf_ has to be chosen through deserialisation.")
            }
            numberBadgeTmpBuf = (numberBadgeTmpBuf_ as boolean | int64)
        }
        const numberBadgeTmpResult : boolean | int64 | undefined = numberBadgeTmpBuf
        const sizeChangeEffectTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let sizeChangeEffectTmpBuf : DraggingSizeChangeEffect | undefined = undefined
        if ((sizeChangeEffectTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            sizeChangeEffectTmpBuf = DraggingSizeChangeEffect.fromValue(valueDeserializer.readInt32())
        }
        const sizeChangeEffectTmpResult : DraggingSizeChangeEffect | undefined = sizeChangeEffectTmpBuf
        let value : DragPreviewOptions = ({mode: modeTmpResult, modifier: modifierTmpResult, numberBadge: numberBadgeTmpResult, sizeChangeEffect: sizeChangeEffectTmpResult} as DragPreviewOptions)
        return value
    }
}
export class FadingEdgeOptions_serializer {
    public static write(buffer: SerializerBase, value: FadingEdgeOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForFadingEdgeLength  = value.fadingEdgeLength
        if (valueHolderForFadingEdgeLength !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFadingEdgeLengthTmpValue  = valueHolderForFadingEdgeLength!
            LengthMetrics_serializer.write(valueSerializer, valueHolderForFadingEdgeLengthTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): FadingEdgeOptions {
        let valueDeserializer : DeserializerBase = buffer
        const fadingEdgeLengthTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fadingEdgeLengthTmpBuf : LengthMetrics | undefined = undefined
        if ((fadingEdgeLengthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            fadingEdgeLengthTmpBuf = LengthMetrics_serializer.read(valueDeserializer)
        }
        const fadingEdgeLengthTmpResult : LengthMetrics | undefined = fadingEdgeLengthTmpBuf
        let value : FadingEdgeOptions = ({fadingEdgeLength: fadingEdgeLengthTmpResult} as FadingEdgeOptions)
        return value
    }
}
export class ForegroundBlurStyleOptions_serializer {
    public static write(buffer: SerializerBase, value: ForegroundBlurStyleOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForColorMode  = value.colorMode
        if (valueHolderForColorMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForColorModeTmpValue  = (valueHolderForColorMode as ThemeColorMode)
            valueSerializer.writeInt32(valueHolderForColorModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAdaptiveColor  = value.adaptiveColor
        if (valueHolderForAdaptiveColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAdaptiveColorTmpValue  = (valueHolderForAdaptiveColor as AdaptiveColor)
            valueSerializer.writeInt32(valueHolderForAdaptiveColorTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForScale  = value.scale
        if (valueHolderForScale !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForScaleTmpValue  = valueHolderForScale!
            valueSerializer.writeFloat64(valueHolderForScaleTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBlurOptions  = value.blurOptions
        if (valueHolderForBlurOptions !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBlurOptionsTmpValue  = valueHolderForBlurOptions!
            BlurOptions_serializer.write(valueSerializer, valueHolderForBlurOptionsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ForegroundBlurStyleOptions {
        let valueDeserializer : DeserializerBase = buffer
        const colorModeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let colorModeTmpBuf : ThemeColorMode | undefined = undefined
        if ((colorModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            colorModeTmpBuf = ThemeColorMode.fromValue(valueDeserializer.readInt32())
        }
        const colorModeTmpResult : ThemeColorMode | undefined = colorModeTmpBuf
        const adaptiveColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let adaptiveColorTmpBuf : AdaptiveColor | undefined = undefined
        if ((adaptiveColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            adaptiveColorTmpBuf = AdaptiveColor.fromValue(valueDeserializer.readInt32())
        }
        const adaptiveColorTmpResult : AdaptiveColor | undefined = adaptiveColorTmpBuf
        const scaleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let scaleTmpBuf : double | undefined = undefined
        if ((scaleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            scaleTmpBuf = valueDeserializer.readFloat64()
        }
        const scaleTmpResult : double | undefined = scaleTmpBuf
        const blurOptionsTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let blurOptionsTmpBuf : BlurOptions | undefined = undefined
        if ((blurOptionsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            blurOptionsTmpBuf = BlurOptions_serializer.read(valueDeserializer)
        }
        const blurOptionsTmpResult : BlurOptions | undefined = blurOptionsTmpBuf
        let value : ForegroundBlurStyleOptions = ({colorMode: colorModeTmpResult, adaptiveColor: adaptiveColorTmpResult, scale: scaleTmpResult, blurOptions: blurOptionsTmpResult} as ForegroundBlurStyleOptions)
        return value
    }
}
export class HistoricalPoint_serializer {
    public static write(buffer: SerializerBase, value: HistoricalPoint): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForTouchObject  = value.touchObject
        TouchObject_serializer.write(valueSerializer, valueHolderForTouchObject)
        const valueHolderForSize  = value.size
        valueSerializer.writeInt32(valueHolderForSize)
        const valueHolderForForce  = value.force
        valueSerializer.writeFloat64(valueHolderForForce)
        const valueHolderForTimestamp  = value.timestamp
        valueSerializer.writeInt64(valueHolderForTimestamp)
    }
    public static read(buffer: DeserializerBase): HistoricalPoint {
        let valueDeserializer : DeserializerBase = buffer
        const touchObjectTmpResult : TouchObject = TouchObject_serializer.read(valueDeserializer)
        const sizeTmpResult : int32 = valueDeserializer.readInt32()
        const forceTmpResult : double = valueDeserializer.readFloat64()
        const timestampTmpResult : int64 = valueDeserializer.readInt64()
        let value : HistoricalPoint = ({touchObject: touchObjectTmpResult, size: sizeTmpResult, force: forceTmpResult, timestamp: timestampTmpResult} as HistoricalPoint)
        return value
    }
}
export class KeyframeAnimateParam_serializer {
    public static write(buffer: SerializerBase, value: KeyframeAnimateParam): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDelay  = value.delay
        if (valueHolderForDelay !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDelayTmpValue  = valueHolderForDelay!
            valueSerializer.writeInt32(valueHolderForDelayTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForIterations  = value.iterations
        if (valueHolderForIterations !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForIterationsTmpValue  = valueHolderForIterations!
            valueSerializer.writeInt32(valueHolderForIterationsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnFinish  = value.onFinish
        if (valueHolderForOnFinish !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnFinishTmpValue  = valueHolderForOnFinish!
            valueSerializer.holdAndWriteCallback(valueHolderForOnFinishTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForExpectedFrameRateRange  = value.expectedFrameRateRange
        if (valueHolderForExpectedFrameRateRange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForExpectedFrameRateRangeTmpValue  = valueHolderForExpectedFrameRateRange!
            ExpectedFrameRateRange_serializer.write(valueSerializer, valueHolderForExpectedFrameRateRangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): KeyframeAnimateParam {
        let valueDeserializer : DeserializerBase = buffer
        const delayTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let delayTmpBuf : int32 | undefined = undefined
        if ((delayTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            delayTmpBuf = valueDeserializer.readInt32()
        }
        const delayTmpResult : int32 | undefined = delayTmpBuf
        const iterationsTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let iterationsTmpBuf : int32 | undefined = undefined
        if ((iterationsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            iterationsTmpBuf = valueDeserializer.readInt32()
        }
        const iterationsTmpResult : int32 | undefined = iterationsTmpBuf
        const onFinishTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onFinishTmpBuf : (() => void) | undefined = undefined
        if ((onFinishTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onFinishTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onFinishTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onFinishTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onFinishTmpBuf = ():void => {
                const onFinishTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onFinishTmpBuf_BufArgsSerializer.writeInt32(onFinishTmpBuf_BufResource.resourceId);
                onFinishTmpBuf_BufArgsSerializer.writePointer(onFinishTmpBuf_BufCall);
                onFinishTmpBuf_BufArgsSerializer.writePointer(onFinishTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, onFinishTmpBuf_BufArgsSerializer.asBuffer(), onFinishTmpBuf_BufArgsSerializer.length());
                onFinishTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onFinishTmpResult : (() => void) | undefined = onFinishTmpBuf
        const expectedFrameRateRangeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let expectedFrameRateRangeTmpBuf : ExpectedFrameRateRange | undefined = undefined
        if ((expectedFrameRateRangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            expectedFrameRateRangeTmpBuf = ExpectedFrameRateRange_serializer.read(valueDeserializer)
        }
        const expectedFrameRateRangeTmpResult : ExpectedFrameRateRange | undefined = expectedFrameRateRangeTmpBuf
        let value : KeyframeAnimateParam = ({delay: delayTmpResult, iterations: iterationsTmpResult, onFinish: onFinishTmpResult, expectedFrameRateRange: expectedFrameRateRangeTmpResult} as KeyframeAnimateParam)
        return value
    }
}
export class Layoutable_serializer {
    public static write(buffer: SerializerBase, value: Layoutable): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): Layoutable {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return LayoutableInternal.fromPtr(ptr)
    }
}
export class LightSource_serializer {
    public static write(buffer: SerializerBase, value: LightSource): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForPositionX  = value.positionX
        if (valueHolderForPositionX instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForPositionXForIdx0  = valueHolderForPositionX as string
            valueSerializer.writeString(valueHolderForPositionXForIdx0)
        } else if (valueHolderForPositionX instanceof number) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForPositionXForIdx1  = valueHolderForPositionX as number
            valueSerializer.writeNumber(valueHolderForPositionXForIdx1)
        } else if (valueHolderForPositionX instanceof Resource) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForPositionXForIdx2  = valueHolderForPositionX as Resource
            Resource_serializer.write(valueSerializer, valueHolderForPositionXForIdx2)
        }
        const valueHolderForPositionY  = value.positionY
        if (valueHolderForPositionY instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForPositionYForIdx0  = valueHolderForPositionY as string
            valueSerializer.writeString(valueHolderForPositionYForIdx0)
        } else if (valueHolderForPositionY instanceof number) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForPositionYForIdx1  = valueHolderForPositionY as number
            valueSerializer.writeNumber(valueHolderForPositionYForIdx1)
        } else if (valueHolderForPositionY instanceof Resource) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForPositionYForIdx2  = valueHolderForPositionY as Resource
            Resource_serializer.write(valueSerializer, valueHolderForPositionYForIdx2)
        }
        const valueHolderForIntensity  = value.intensity
        valueSerializer.writeNumber(valueHolderForIntensity)
        const valueHolderForColor  = value.color
        if (valueHolderForColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForColorTmpValue  = valueHolderForColor!
            if (valueHolderForColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorTmpValueForIdx0  = valueHolderForColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForColorTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorTmpValueForIdx1  = valueHolderForColorTmpValue as number
                valueSerializer.writeNumber(valueHolderForColorTmpValueForIdx1)
            } else if (valueHolderForColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorTmpValueForIdx2  = valueHolderForColorTmpValue as string
                valueSerializer.writeString(valueHolderForColorTmpValueForIdx2)
            } else if (valueHolderForColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorTmpValueForIdx3  = valueHolderForColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): LightSource {
        let valueDeserializer : DeserializerBase = buffer
        const positionXTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let positionXTmpBuf : string | number | Resource | undefined
        if (positionXTmpBufUnionSelector == (0).toChar()) {
            positionXTmpBuf = (valueDeserializer.readString() as string)
        } else if (positionXTmpBufUnionSelector == (1).toChar()) {
            positionXTmpBuf = (valueDeserializer.readNumber() as number)
        } else if (positionXTmpBufUnionSelector == (2).toChar()) {
            positionXTmpBuf = Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error("One of the branches for positionXTmpBuf has to be chosen through deserialisation.")
        }
        const positionXTmpResult : Dimension = (positionXTmpBuf as string | number | Resource)
        const positionYTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let positionYTmpBuf : string | number | Resource | undefined
        if (positionYTmpBufUnionSelector == (0).toChar()) {
            positionYTmpBuf = (valueDeserializer.readString() as string)
        } else if (positionYTmpBufUnionSelector == (1).toChar()) {
            positionYTmpBuf = (valueDeserializer.readNumber() as number)
        } else if (positionYTmpBufUnionSelector == (2).toChar()) {
            positionYTmpBuf = Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error("One of the branches for positionYTmpBuf has to be chosen through deserialisation.")
        }
        const positionYTmpResult : Dimension = (positionYTmpBuf as string | number | Resource)
        const intensityTmpResult : number = (valueDeserializer.readNumber() as number)
        const colorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let colorTmpBuf : ResourceColor | undefined = undefined
        if ((colorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const colorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let colorTmpBuf_ : Color | number | string | Resource | undefined
            if (colorTmpBuf_UnionSelector == (0).toChar()) {
                colorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (colorTmpBuf_UnionSelector == (1).toChar()) {
                colorTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (colorTmpBuf_UnionSelector == (2).toChar()) {
                colorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (colorTmpBuf_UnionSelector == (3).toChar()) {
                colorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for colorTmpBuf_ has to be chosen through deserialisation.")
            }
            colorTmpBuf = (colorTmpBuf_ as Color | number | string | Resource)
        }
        const colorTmpResult : ResourceColor | undefined = colorTmpBuf
        let value : LightSource = ({positionX: positionXTmpResult, positionY: positionYTmpResult, intensity: intensityTmpResult, color: colorTmpResult} as LightSource)
        return value
    }
}
export class LocalizedAlignRuleOptions_serializer {
    public static write(buffer: SerializerBase, value: LocalizedAlignRuleOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForStart  = value.start
        if (valueHolderForStart !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForStartTmpValue  = valueHolderForStart!
            LocalizedHorizontalAlignParam_serializer.write(valueSerializer, valueHolderForStartTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnd  = value.end
        if (valueHolderForEnd !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEndTmpValue  = valueHolderForEnd!
            LocalizedHorizontalAlignParam_serializer.write(valueSerializer, valueHolderForEndTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMiddle  = value.middle
        if (valueHolderForMiddle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMiddleTmpValue  = valueHolderForMiddle!
            LocalizedHorizontalAlignParam_serializer.write(valueSerializer, valueHolderForMiddleTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTop  = value.top
        if (valueHolderForTop !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTopTmpValue  = valueHolderForTop!
            LocalizedVerticalAlignParam_serializer.write(valueSerializer, valueHolderForTopTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBottom  = value.bottom
        if (valueHolderForBottom !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBottomTmpValue  = valueHolderForBottom!
            LocalizedVerticalAlignParam_serializer.write(valueSerializer, valueHolderForBottomTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCenter  = value.center
        if (valueHolderForCenter !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCenterTmpValue  = valueHolderForCenter!
            LocalizedVerticalAlignParam_serializer.write(valueSerializer, valueHolderForCenterTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBias  = value.bias
        if (valueHolderForBias !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBiasTmpValue  = valueHolderForBias!
            Bias_serializer.write(valueSerializer, valueHolderForBiasTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): LocalizedAlignRuleOptions {
        let valueDeserializer : DeserializerBase = buffer
        const startTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let startTmpBuf : LocalizedHorizontalAlignParam | undefined = undefined
        if ((startTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            startTmpBuf = LocalizedHorizontalAlignParam_serializer.read(valueDeserializer)
        }
        const startTmpResult : LocalizedHorizontalAlignParam | undefined = startTmpBuf
        const endTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let endTmpBuf : LocalizedHorizontalAlignParam | undefined = undefined
        if ((endTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            endTmpBuf = LocalizedHorizontalAlignParam_serializer.read(valueDeserializer)
        }
        const endTmpResult : LocalizedHorizontalAlignParam | undefined = endTmpBuf
        const middleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let middleTmpBuf : LocalizedHorizontalAlignParam | undefined = undefined
        if ((middleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            middleTmpBuf = LocalizedHorizontalAlignParam_serializer.read(valueDeserializer)
        }
        const middleTmpResult : LocalizedHorizontalAlignParam | undefined = middleTmpBuf
        const topTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let topTmpBuf : LocalizedVerticalAlignParam | undefined = undefined
        if ((topTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            topTmpBuf = LocalizedVerticalAlignParam_serializer.read(valueDeserializer)
        }
        const topTmpResult : LocalizedVerticalAlignParam | undefined = topTmpBuf
        const bottomTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let bottomTmpBuf : LocalizedVerticalAlignParam | undefined = undefined
        if ((bottomTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            bottomTmpBuf = LocalizedVerticalAlignParam_serializer.read(valueDeserializer)
        }
        const bottomTmpResult : LocalizedVerticalAlignParam | undefined = bottomTmpBuf
        const centerTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let centerTmpBuf : LocalizedVerticalAlignParam | undefined = undefined
        if ((centerTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            centerTmpBuf = LocalizedVerticalAlignParam_serializer.read(valueDeserializer)
        }
        const centerTmpResult : LocalizedVerticalAlignParam | undefined = centerTmpBuf
        const biasTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let biasTmpBuf : Bias | undefined = undefined
        if ((biasTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            biasTmpBuf = Bias_serializer.read(valueDeserializer)
        }
        const biasTmpResult : Bias | undefined = biasTmpBuf
        let value : LocalizedAlignRuleOptions = ({start: startTmpResult, end: endTmpResult, middle: middleTmpResult, top: topTmpResult, bottom: bottomTmpResult, center: centerTmpResult, bias: biasTmpResult} as LocalizedAlignRuleOptions)
        return value
    }
}
export class MenuElement_serializer {
    public static write(buffer: SerializerBase, value: MenuElement): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        if (valueHolderForValue instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForValueForIdx0  = valueHolderForValue as string
            valueSerializer.writeString(valueHolderForValueForIdx0)
        } else if (valueHolderForValue instanceof Resource) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForValueForIdx1  = valueHolderForValue as Resource
            Resource_serializer.write(valueSerializer, valueHolderForValueForIdx1)
        }
        const valueHolderForIcon  = value.icon
        if (valueHolderForIcon !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForIconTmpValue  = valueHolderForIcon!
            if (valueHolderForIconTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForIconTmpValueForIdx0  = valueHolderForIconTmpValue as string
                valueSerializer.writeString(valueHolderForIconTmpValueForIdx0)
            } else if (valueHolderForIconTmpValue instanceof Resource) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForIconTmpValueForIdx1  = valueHolderForIconTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForIconTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForSymbolIcon  = value.symbolIcon
        if (valueHolderForSymbolIcon !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForSymbolIconTmpValue  = valueHolderForSymbolIcon!
            SymbolGlyphModifier_serializer.write(valueSerializer, valueHolderForSymbolIconTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnabled  = value.enabled
        if (valueHolderForEnabled !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnabledTmpValue  = valueHolderForEnabled!
            valueSerializer.writeBoolean(valueHolderForEnabledTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAction  = value.action
        valueSerializer.holdAndWriteCallback(valueHolderForAction)
    }
    public static read(buffer: DeserializerBase): MenuElement {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let valueTmpBuf : string | Resource | undefined
        if (valueTmpBufUnionSelector == (0).toChar()) {
            valueTmpBuf = (valueDeserializer.readString() as string)
        } else if (valueTmpBufUnionSelector == (1).toChar()) {
            valueTmpBuf = Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error("One of the branches for valueTmpBuf has to be chosen through deserialisation.")
        }
        const valueTmpResult : ResourceStr = (valueTmpBuf as string | Resource)
        const iconTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let iconTmpBuf : ResourceStr | undefined = undefined
        if ((iconTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const iconTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let iconTmpBuf_ : string | Resource | undefined
            if (iconTmpBuf_UnionSelector == (0).toChar()) {
                iconTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (iconTmpBuf_UnionSelector == (1).toChar()) {
                iconTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for iconTmpBuf_ has to be chosen through deserialisation.")
            }
            iconTmpBuf = (iconTmpBuf_ as string | Resource)
        }
        const iconTmpResult : ResourceStr | undefined = iconTmpBuf
        const symbolIconTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let symbolIconTmpBuf : SymbolGlyphModifier | undefined = undefined
        if ((symbolIconTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            symbolIconTmpBuf = (SymbolGlyphModifier_serializer.read(valueDeserializer) as SymbolGlyphModifier)
        }
        const symbolIconTmpResult : SymbolGlyphModifier | undefined = symbolIconTmpBuf
        const enabledTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enabledTmpBuf : boolean | undefined = undefined
        if ((enabledTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enabledTmpBuf = valueDeserializer.readBoolean()
        }
        const enabledTmpResult : boolean | undefined = enabledTmpBuf
        const actionTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const actionTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const actionTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const actionTmpResult : (() => void) = ():void => {
            const actionTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            actionTmpBufBufArgsSerializer.writeInt32(actionTmpBufBufResource.resourceId);
            actionTmpBufBufArgsSerializer.writePointer(actionTmpBufBufCall);
            actionTmpBufBufArgsSerializer.writePointer(actionTmpBufBufCallSync);
            InteropNativeModule._CallCallbackSync(10, -1867723152, actionTmpBufBufArgsSerializer.asBuffer(), actionTmpBufBufArgsSerializer.length());
            actionTmpBufBufArgsSerializer.release();
            return;
        }
        let value : MenuElement = ({value: valueTmpResult, icon: iconTmpResult, symbolIcon: symbolIconTmpResult, enabled: enabledTmpResult, action: actionTmpResult} as MenuElement)
        return value
    }
}
export class OverlayOptions_serializer {
    public static write(buffer: SerializerBase, value: OverlayOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAlign  = value.align
        if (valueHolderForAlign !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAlignTmpValue  = (valueHolderForAlign as Alignment)
            valueSerializer.writeInt32(valueHolderForAlignTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOffset  = value.offset
        if (valueHolderForOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetTmpValue  = valueHolderForOffset!
            OverlayOffset_serializer.write(valueSerializer, valueHolderForOffsetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): OverlayOptions {
        let valueDeserializer : DeserializerBase = buffer
        const alignTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let alignTmpBuf : Alignment | undefined = undefined
        if ((alignTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            alignTmpBuf = Alignment.fromValue(valueDeserializer.readInt32())
        }
        const alignTmpResult : Alignment | undefined = alignTmpBuf
        const offsetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offsetTmpBuf : OverlayOffset | undefined = undefined
        if ((offsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            offsetTmpBuf = OverlayOffset_serializer.read(valueDeserializer)
        }
        const offsetTmpResult : OverlayOffset | undefined = offsetTmpBuf
        let value : OverlayOptions = ({align: alignTmpResult, offset: offsetTmpResult} as OverlayOptions)
        return value
    }
}
export class PopupMaskType_serializer {
    public static write(buffer: SerializerBase, value: PopupMaskType): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForColor  = value.color
        if (valueHolderForColor instanceof Color) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForColorForIdx0  = valueHolderForColor as Color
            valueSerializer.writeInt32(valueHolderForColorForIdx0.getOrdinal())
        } else if (valueHolderForColor instanceof number) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForColorForIdx1  = valueHolderForColor as number
            valueSerializer.writeNumber(valueHolderForColorForIdx1)
        } else if (valueHolderForColor instanceof string) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForColorForIdx2  = valueHolderForColor as string
            valueSerializer.writeString(valueHolderForColorForIdx2)
        } else if (valueHolderForColor instanceof Resource) {
            valueSerializer.writeInt8((3).toByte())
            const valueHolderForColorForIdx3  = valueHolderForColor as Resource
            Resource_serializer.write(valueSerializer, valueHolderForColorForIdx3)
        }
    }
    public static read(buffer: DeserializerBase): PopupMaskType {
        let valueDeserializer : DeserializerBase = buffer
        const colorTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let colorTmpBuf : Color | number | string | Resource | undefined
        if (colorTmpBufUnionSelector == (0).toChar()) {
            colorTmpBuf = Color.values()[valueDeserializer.readInt32()]
        } else if (colorTmpBufUnionSelector == (1).toChar()) {
            colorTmpBuf = (valueDeserializer.readNumber() as number)
        } else if (colorTmpBufUnionSelector == (2).toChar()) {
            colorTmpBuf = (valueDeserializer.readString() as string)
        } else if (colorTmpBufUnionSelector == (3).toChar()) {
            colorTmpBuf = Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error("One of the branches for colorTmpBuf has to be chosen through deserialisation.")
        }
        const colorTmpResult : ResourceColor = (colorTmpBuf as Color | number | string | Resource)
        let value : PopupMaskType = ({color: colorTmpResult} as PopupMaskType)
        return value
    }
}
export class ResponseRegion_serializer {
    public static write(buffer: SerializerBase, value: ResponseRegion): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForTool  = value.tool
        if (valueHolderForTool !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForToolTmpValue  = (valueHolderForTool as ResponseRegionSupportedTool)
            valueSerializer.writeInt32(valueHolderForToolTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForX  = value.x
        if (valueHolderForX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForXTmpValue  = valueHolderForX!
            LengthMetrics_serializer.write(valueSerializer, valueHolderForXTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForY  = value.y
        if (valueHolderForY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForYTmpValue  = valueHolderForY!
            LengthMetrics_serializer.write(valueSerializer, valueHolderForYTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForWidth  = value.width
        if (valueHolderForWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForWidthTmpValue  = valueHolderForWidth!
            if (valueHolderForWidthTmpValue instanceof LengthMetrics) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForWidthTmpValueForIdx0  = valueHolderForWidthTmpValue as LengthMetrics
                LengthMetrics_serializer.write(valueSerializer, valueHolderForWidthTmpValueForIdx0)
            } else if (valueHolderForWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForWidthTmpValueForIdx1  = valueHolderForWidthTmpValue as string
                valueSerializer.writeString(valueHolderForWidthTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHeight  = value.height
        if (valueHolderForHeight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHeightTmpValue  = valueHolderForHeight!
            if (valueHolderForHeightTmpValue instanceof LengthMetrics) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForHeightTmpValueForIdx0  = valueHolderForHeightTmpValue as LengthMetrics
                LengthMetrics_serializer.write(valueSerializer, valueHolderForHeightTmpValueForIdx0)
            } else if (valueHolderForHeightTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForHeightTmpValueForIdx1  = valueHolderForHeightTmpValue as string
                valueSerializer.writeString(valueHolderForHeightTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ResponseRegion {
        let valueDeserializer : DeserializerBase = buffer
        const toolTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let toolTmpBuf : ResponseRegionSupportedTool | undefined = undefined
        if ((toolTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            toolTmpBuf = ResponseRegionSupportedTool.fromValue(valueDeserializer.readInt32())
        }
        const toolTmpResult : ResponseRegionSupportedTool | undefined = toolTmpBuf
        const xTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let xTmpBuf : LengthMetrics | undefined = undefined
        if ((xTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            xTmpBuf = LengthMetrics_serializer.read(valueDeserializer)
        }
        const xTmpResult : LengthMetrics | undefined = xTmpBuf
        const yTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let yTmpBuf : LengthMetrics | undefined = undefined
        if ((yTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            yTmpBuf = LengthMetrics_serializer.read(valueDeserializer)
        }
        const yTmpResult : LengthMetrics | undefined = yTmpBuf
        const widthTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let widthTmpBuf : LengthMetrics | string | undefined = undefined
        if ((widthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const widthTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let widthTmpBuf_ : LengthMetrics | string | undefined
            if (widthTmpBuf_UnionSelector == (0).toChar()) {
                widthTmpBuf_ = LengthMetrics_serializer.read(valueDeserializer)
            } else if (widthTmpBuf_UnionSelector == (1).toChar()) {
                widthTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for widthTmpBuf_ has to be chosen through deserialisation.")
            }
            widthTmpBuf = (widthTmpBuf_ as LengthMetrics | string)
        }
        const widthTmpResult : LengthMetrics | string | undefined = widthTmpBuf
        const heightTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let heightTmpBuf : LengthMetrics | string | undefined = undefined
        if ((heightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const heightTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let heightTmpBuf_ : LengthMetrics | string | undefined
            if (heightTmpBuf_UnionSelector == (0).toChar()) {
                heightTmpBuf_ = LengthMetrics_serializer.read(valueDeserializer)
            } else if (heightTmpBuf_UnionSelector == (1).toChar()) {
                heightTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for heightTmpBuf_ has to be chosen through deserialisation.")
            }
            heightTmpBuf = (heightTmpBuf_ as LengthMetrics | string)
        }
        const heightTmpResult : LengthMetrics | string | undefined = heightTmpBuf
        let value : ResponseRegion = ({tool: toolTmpResult, x: xTmpResult, y: yTmpResult, width: widthTmpResult, height: heightTmpResult} as ResponseRegion)
        return value
    }
}
export class ReuseOptions_serializer {
    public static write(buffer: SerializerBase, value: ReuseOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForReuseId  = value.reuseId
        if (valueHolderForReuseId !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForReuseIdTmpValue  = valueHolderForReuseId!
            valueSerializer.holdAndWriteCallback(valueHolderForReuseIdTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ReuseOptions {
        let valueDeserializer : DeserializerBase = buffer
        const reuseIdTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let reuseIdTmpBuf : ReuseIdCallback | undefined = undefined
        if ((reuseIdTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const reuseIdTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const reuseIdTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const reuseIdTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            reuseIdTmpBuf = ():string => {
                const reuseIdTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                reuseIdTmpBuf_BufArgsSerializer.writeInt32(reuseIdTmpBuf_BufResource.resourceId);
                reuseIdTmpBuf_BufArgsSerializer.writePointer(reuseIdTmpBuf_BufCall);
                reuseIdTmpBuf_BufArgsSerializer.writePointer(reuseIdTmpBuf_BufCallSync);
                let reuseIdTmpBuf_BufContinuationValue : string | undefined;
                const reuseIdTmpBuf_BufContinuationCallback : ((breakpoints: string) => void) = (value: string):void => {
                reuseIdTmpBuf_BufContinuationValue = value;
            }
                reuseIdTmpBuf_BufArgsSerializer.holdAndWriteCallback(reuseIdTmpBuf_BufContinuationCallback);
                InteropNativeModule._CallCallbackSync(10, 1110529154, reuseIdTmpBuf_BufArgsSerializer.asBuffer(), reuseIdTmpBuf_BufArgsSerializer.length());
                reuseIdTmpBuf_BufArgsSerializer.release();
                return (reuseIdTmpBuf_BufContinuationValue as string);
            }
        }
        const reuseIdTmpResult : ReuseIdCallback | undefined = reuseIdTmpBuf
        let value : ReuseOptions = ({reuseId: reuseIdTmpResult} as ReuseOptions)
        return value
    }
}
export class ShadowOptions_serializer {
    public static write(buffer: SerializerBase, value: ShadowOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForRadius  = value.radius
        if (valueHolderForRadius instanceof double) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForRadiusForIdx0  = valueHolderForRadius as double
            valueSerializer.writeFloat64(valueHolderForRadiusForIdx0)
        } else if (valueHolderForRadius instanceof Resource) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForRadiusForIdx1  = valueHolderForRadius as Resource
            Resource_serializer.write(valueSerializer, valueHolderForRadiusForIdx1)
        }
        const valueHolderForType  = value.type
        if (valueHolderForType !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTypeTmpValue  = (valueHolderForType as ShadowType)
            valueSerializer.writeInt32(valueHolderForTypeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForColor  = value.color
        if (valueHolderForColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForColorTmpValue  = valueHolderForColor!
            if (valueHolderForColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorTmpValueForIdx0  = valueHolderForColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForColorTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorTmpValueForIdx1  = valueHolderForColorTmpValue as string
                valueSerializer.writeString(valueHolderForColorTmpValueForIdx1)
            } else if (valueHolderForColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorTmpValueForIdx2  = valueHolderForColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForColorTmpValueForIdx2)
            } else if (valueHolderForColorTmpValue instanceof ColoringStrategy) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorTmpValueForIdx3  = valueHolderForColorTmpValue as ColoringStrategy
                valueSerializer.writeInt32(valueHolderForColorTmpValueForIdx3.getOrdinal())
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOffsetX  = value.offsetX
        if (valueHolderForOffsetX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetXTmpValue  = valueHolderForOffsetX!
            if (valueHolderForOffsetXTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOffsetXTmpValueForIdx0  = valueHolderForOffsetXTmpValue as double
                valueSerializer.writeFloat64(valueHolderForOffsetXTmpValueForIdx0)
            } else if (valueHolderForOffsetXTmpValue instanceof Resource) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOffsetXTmpValueForIdx1  = valueHolderForOffsetXTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForOffsetXTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOffsetY  = value.offsetY
        if (valueHolderForOffsetY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetYTmpValue  = valueHolderForOffsetY!
            if (valueHolderForOffsetYTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOffsetYTmpValueForIdx0  = valueHolderForOffsetYTmpValue as double
                valueSerializer.writeFloat64(valueHolderForOffsetYTmpValueForIdx0)
            } else if (valueHolderForOffsetYTmpValue instanceof Resource) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOffsetYTmpValueForIdx1  = valueHolderForOffsetYTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForOffsetYTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFill  = value.fill
        if (valueHolderForFill !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFillTmpValue  = valueHolderForFill!
            valueSerializer.writeBoolean(valueHolderForFillTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ShadowOptions {
        let valueDeserializer : DeserializerBase = buffer
        const radiusTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let radiusTmpBuf : double | Resource | undefined
        if (radiusTmpBufUnionSelector == (0).toChar()) {
            radiusTmpBuf = valueDeserializer.readFloat64()
        } else if (radiusTmpBufUnionSelector == (1).toChar()) {
            radiusTmpBuf = Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error("One of the branches for radiusTmpBuf has to be chosen through deserialisation.")
        }
        const radiusTmpResult : double | Resource = (radiusTmpBuf as double | Resource)
        const typeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let typeTmpBuf : ShadowType | undefined = undefined
        if ((typeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            typeTmpBuf = ShadowType.fromValue(valueDeserializer.readInt32())
        }
        const typeTmpResult : ShadowType | undefined = typeTmpBuf
        const colorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let colorTmpBuf : Color | string | Resource | ColoringStrategy | undefined = undefined
        if ((colorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const colorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let colorTmpBuf_ : Color | string | Resource | ColoringStrategy | undefined
            if (colorTmpBuf_UnionSelector == (0).toChar()) {
                colorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (colorTmpBuf_UnionSelector == (1).toChar()) {
                colorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (colorTmpBuf_UnionSelector == (2).toChar()) {
                colorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else if (colorTmpBuf_UnionSelector == (3).toChar()) {
                colorTmpBuf_ = ColoringStrategy.values()[valueDeserializer.readInt32()]
            } else {
                throw new Error("One of the branches for colorTmpBuf_ has to be chosen through deserialisation.")
            }
            colorTmpBuf = (colorTmpBuf_ as Color | string | Resource | ColoringStrategy)
        }
        const colorTmpResult : Color | string | Resource | ColoringStrategy | undefined = colorTmpBuf
        const offsetXTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offsetXTmpBuf : double | Resource | undefined = undefined
        if ((offsetXTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const offsetXTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let offsetXTmpBuf_ : double | Resource | undefined
            if (offsetXTmpBuf_UnionSelector == (0).toChar()) {
                offsetXTmpBuf_ = valueDeserializer.readFloat64()
            } else if (offsetXTmpBuf_UnionSelector == (1).toChar()) {
                offsetXTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for offsetXTmpBuf_ has to be chosen through deserialisation.")
            }
            offsetXTmpBuf = (offsetXTmpBuf_ as double | Resource)
        }
        const offsetXTmpResult : double | Resource | undefined = offsetXTmpBuf
        const offsetYTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offsetYTmpBuf : double | Resource | undefined = undefined
        if ((offsetYTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const offsetYTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let offsetYTmpBuf_ : double | Resource | undefined
            if (offsetYTmpBuf_UnionSelector == (0).toChar()) {
                offsetYTmpBuf_ = valueDeserializer.readFloat64()
            } else if (offsetYTmpBuf_UnionSelector == (1).toChar()) {
                offsetYTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for offsetYTmpBuf_ has to be chosen through deserialisation.")
            }
            offsetYTmpBuf = (offsetYTmpBuf_ as double | Resource)
        }
        const offsetYTmpResult : double | Resource | undefined = offsetYTmpBuf
        const fillTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fillTmpBuf : boolean | undefined = undefined
        if ((fillTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            fillTmpBuf = valueDeserializer.readBoolean()
        }
        const fillTmpResult : boolean | undefined = fillTmpBuf
        let value : ShadowOptions = ({radius: radiusTmpResult, type: typeTmpResult, color: colorTmpResult, offsetX: offsetXTmpResult, offsetY: offsetYTmpResult, fill: fillTmpResult} as ShadowOptions)
        return value
    }
}
export class sharedTransitionOptions_serializer {
    public static write(buffer: SerializerBase, value: sharedTransitionOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForDuration  = value.duration
        if (valueHolderForDuration !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDurationTmpValue  = valueHolderForDuration!
            valueSerializer.writeInt32(valueHolderForDurationTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForCurve  = value.curve
        if (valueHolderForCurve !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForCurveTmpValue  = valueHolderForCurve!
            if (valueHolderForCurveTmpValue instanceof curves.Curve) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForCurveTmpValueForIdx0  = valueHolderForCurveTmpValue as curves.Curve
                valueSerializer.writeInt32(valueHolderForCurveTmpValueForIdx0.valueOf())
            } else if (valueHolderForCurveTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForCurveTmpValueForIdx1  = valueHolderForCurveTmpValue as string
                valueSerializer.writeString(valueHolderForCurveTmpValueForIdx1)
            } else if (valueHolderForCurveTmpValue instanceof curves.ICurve) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForCurveTmpValueForIdx2  = valueHolderForCurveTmpValue as curves.ICurve
                curves_ICurve_serializer.write(valueSerializer, valueHolderForCurveTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDelay  = value.delay
        if (valueHolderForDelay !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDelayTmpValue  = valueHolderForDelay!
            valueSerializer.writeInt32(valueHolderForDelayTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMotionPath  = value.motionPath
        if (valueHolderForMotionPath !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMotionPathTmpValue  = valueHolderForMotionPath!
            MotionPathOptions_serializer.write(valueSerializer, valueHolderForMotionPathTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForZIndex  = value.zIndex
        if (valueHolderForZIndex !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForZIndexTmpValue  = valueHolderForZIndex!
            valueSerializer.writeInt32(valueHolderForZIndexTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForType  = value.type
        if (valueHolderForType !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTypeTmpValue  = (valueHolderForType as SharedTransitionEffectType)
            valueSerializer.writeInt32(valueHolderForTypeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): sharedTransitionOptions {
        let valueDeserializer : DeserializerBase = buffer
        const durationTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let durationTmpBuf : int32 | undefined = undefined
        if ((durationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            durationTmpBuf = valueDeserializer.readInt32()
        }
        const durationTmpResult : int32 | undefined = durationTmpBuf
        const curveTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let curveTmpBuf : curves.Curve | string | curves.ICurve | undefined = undefined
        if ((curveTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const curveTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let curveTmpBuf_ : curves.Curve | string | curves.ICurve | undefined
            if (curveTmpBuf_UnionSelector == (0).toChar()) {
                curveTmpBuf_ = curves.Curve.fromValue(valueDeserializer.readInt32())
            } else if (curveTmpBuf_UnionSelector == (1).toChar()) {
                curveTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (curveTmpBuf_UnionSelector == (2).toChar()) {
                curveTmpBuf_ = (curves_ICurve_serializer.read(valueDeserializer) as curves.ICurve)
            } else {
                throw new Error("One of the branches for curveTmpBuf_ has to be chosen through deserialisation.")
            }
            curveTmpBuf = (curveTmpBuf_ as curves.Curve | string | curves.ICurve)
        }
        const curveTmpResult : curves.Curve | string | curves.ICurve | undefined = curveTmpBuf
        const delayTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let delayTmpBuf : int32 | undefined = undefined
        if ((delayTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            delayTmpBuf = valueDeserializer.readInt32()
        }
        const delayTmpResult : int32 | undefined = delayTmpBuf
        const motionPathTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let motionPathTmpBuf : MotionPathOptions | undefined = undefined
        if ((motionPathTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            motionPathTmpBuf = MotionPathOptions_serializer.read(valueDeserializer)
        }
        const motionPathTmpResult : MotionPathOptions | undefined = motionPathTmpBuf
        const zIndexTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let zIndexTmpBuf : int32 | undefined = undefined
        if ((zIndexTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            zIndexTmpBuf = valueDeserializer.readInt32()
        }
        const zIndexTmpResult : int32 | undefined = zIndexTmpBuf
        const typeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let typeTmpBuf : SharedTransitionEffectType | undefined = undefined
        if ((typeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            typeTmpBuf = SharedTransitionEffectType.fromValue(valueDeserializer.readInt32())
        }
        const typeTmpResult : SharedTransitionEffectType | undefined = typeTmpBuf
        let value : sharedTransitionOptions = ({duration: durationTmpResult, curve: curveTmpResult, delay: delayTmpResult, motionPath: motionPathTmpResult, zIndex: zIndexTmpResult, type: typeTmpResult} as sharedTransitionOptions)
        return value
    }
}
export class SheetTitleOptions_serializer {
    public static write(buffer: SerializerBase, value: SheetTitleOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForTitle  = value.title
        if (valueHolderForTitle instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForTitleForIdx0  = valueHolderForTitle as string
            valueSerializer.writeString(valueHolderForTitleForIdx0)
        } else if (valueHolderForTitle instanceof Resource) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForTitleForIdx1  = valueHolderForTitle as Resource
            Resource_serializer.write(valueSerializer, valueHolderForTitleForIdx1)
        }
        const valueHolderForSubtitle  = value.subtitle
        if (valueHolderForSubtitle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForSubtitleTmpValue  = valueHolderForSubtitle!
            if (valueHolderForSubtitleTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForSubtitleTmpValueForIdx0  = valueHolderForSubtitleTmpValue as string
                valueSerializer.writeString(valueHolderForSubtitleTmpValueForIdx0)
            } else if (valueHolderForSubtitleTmpValue instanceof Resource) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForSubtitleTmpValueForIdx1  = valueHolderForSubtitleTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForSubtitleTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): SheetTitleOptions {
        let valueDeserializer : DeserializerBase = buffer
        const titleTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let titleTmpBuf : string | Resource | undefined
        if (titleTmpBufUnionSelector == (0).toChar()) {
            titleTmpBuf = (valueDeserializer.readString() as string)
        } else if (titleTmpBufUnionSelector == (1).toChar()) {
            titleTmpBuf = Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error("One of the branches for titleTmpBuf has to be chosen through deserialisation.")
        }
        const titleTmpResult : ResourceStr = (titleTmpBuf as string | Resource)
        const subtitleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let subtitleTmpBuf : ResourceStr | undefined = undefined
        if ((subtitleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const subtitleTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let subtitleTmpBuf_ : string | Resource | undefined
            if (subtitleTmpBuf_UnionSelector == (0).toChar()) {
                subtitleTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (subtitleTmpBuf_UnionSelector == (1).toChar()) {
                subtitleTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for subtitleTmpBuf_ has to be chosen through deserialisation.")
            }
            subtitleTmpBuf = (subtitleTmpBuf_ as string | Resource)
        }
        const subtitleTmpResult : ResourceStr | undefined = subtitleTmpBuf
        let value : SheetTitleOptions = ({title: titleTmpResult, subtitle: subtitleTmpResult} as SheetTitleOptions)
        return value
    }
}
export class TerminationInfo_serializer {
    public static write(buffer: SerializerBase, value: TerminationInfo): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForCode  = value.code
        valueSerializer.writeInt32(valueHolderForCode)
        const valueHolderForWant  = value.want
        if (valueHolderForWant !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForWantTmpValue  = valueHolderForWant!
            Want_serializer.write(valueSerializer, valueHolderForWantTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): TerminationInfo {
        let valueDeserializer : DeserializerBase = buffer
        const codeTmpResult : int32 = valueDeserializer.readInt32()
        const wantTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let wantTmpBuf : Want | undefined = undefined
        if ((wantTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            wantTmpBuf = (Want_serializer.read(valueDeserializer) as Want)
        }
        const wantTmpResult : Want | undefined = wantTmpBuf
        let value : TerminationInfo = ({code: codeTmpResult, want: wantTmpResult} as TerminationInfo)
        return value
    }
}
export class TextDecorationOptions_serializer {
    public static write(buffer: SerializerBase, value: TextDecorationOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForType  = value.type
        if (valueHolderForType !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTypeTmpValue  = (valueHolderForType as TextDecorationType)
            valueSerializer.writeInt32(valueHolderForTypeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForColor  = value.color
        if (valueHolderForColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForColorTmpValue  = valueHolderForColor!
            if (valueHolderForColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorTmpValueForIdx0  = valueHolderForColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForColorTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorTmpValueForIdx1  = valueHolderForColorTmpValue as number
                valueSerializer.writeNumber(valueHolderForColorTmpValueForIdx1)
            } else if (valueHolderForColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorTmpValueForIdx2  = valueHolderForColorTmpValue as string
                valueSerializer.writeString(valueHolderForColorTmpValueForIdx2)
            } else if (valueHolderForColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorTmpValueForIdx3  = valueHolderForColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForStyle  = value.style
        if (valueHolderForStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForStyleTmpValue  = (valueHolderForStyle as TextDecorationStyle)
            valueSerializer.writeInt32(valueHolderForStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): TextDecorationOptions {
        let valueDeserializer : DeserializerBase = buffer
        const typeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let typeTmpBuf : TextDecorationType | undefined = undefined
        if ((typeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            typeTmpBuf = TextDecorationType.fromValue(valueDeserializer.readInt32())
        }
        const typeTmpResult : TextDecorationType | undefined = typeTmpBuf
        const colorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let colorTmpBuf : ResourceColor | undefined = undefined
        if ((colorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const colorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let colorTmpBuf_ : Color | number | string | Resource | undefined
            if (colorTmpBuf_UnionSelector == (0).toChar()) {
                colorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (colorTmpBuf_UnionSelector == (1).toChar()) {
                colorTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (colorTmpBuf_UnionSelector == (2).toChar()) {
                colorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (colorTmpBuf_UnionSelector == (3).toChar()) {
                colorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for colorTmpBuf_ has to be chosen through deserialisation.")
            }
            colorTmpBuf = (colorTmpBuf_ as Color | number | string | Resource)
        }
        const colorTmpResult : ResourceColor | undefined = colorTmpBuf
        const styleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let styleTmpBuf : TextDecorationStyle | undefined = undefined
        if ((styleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            styleTmpBuf = TextDecorationStyle.fromValue(valueDeserializer.readInt32())
        }
        const styleTmpResult : TextDecorationStyle | undefined = styleTmpBuf
        let value : TextDecorationOptions = ({type: typeTmpResult, color: colorTmpResult, style: styleTmpResult} as TextDecorationOptions)
        return value
    }
}
export class Bindable_Arkui_Component_Units_Length_serializer {
    public static write(buffer: SerializerBase, value: Bindable<Length>): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForValue  = value.value
        if (valueHolderForValue instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForValueForIdx0  = valueHolderForValue as string
            valueSerializer.writeString(valueHolderForValueForIdx0)
        } else if (valueHolderForValue instanceof number) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForValueForIdx1  = valueHolderForValue as number
            valueSerializer.writeNumber(valueHolderForValueForIdx1)
        } else if (valueHolderForValue instanceof Resource) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForValueForIdx2  = valueHolderForValue as Resource
            Resource_serializer.write(valueSerializer, valueHolderForValueForIdx2)
        }
        const valueHolderForOnChange  = value.onChange
        valueSerializer.holdAndWriteCallback(valueHolderForOnChange)
    }
    public static read(buffer: DeserializerBase): Bindable<Length> {
        let valueDeserializer : DeserializerBase = buffer
        const valueTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let valueTmpBuf : string | number | Resource | undefined
        if (valueTmpBufUnionSelector == (0).toChar()) {
            valueTmpBuf = (valueDeserializer.readString() as string)
        } else if (valueTmpBufUnionSelector == (1).toChar()) {
            valueTmpBuf = (valueDeserializer.readNumber() as number)
        } else if (valueTmpBufUnionSelector == (2).toChar()) {
            valueTmpBuf = Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error("One of the branches for valueTmpBuf has to be chosen through deserialisation.")
        }
        const valueTmpResult : Length = (valueTmpBuf as string | number | Resource)
        const onChangeTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const onChangeTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const onChangeTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const onChangeTmpResult : ((value0: Length) => void) = (value0: Length):void => {
            const onChangeTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            onChangeTmpBufBufArgsSerializer.writeInt32(onChangeTmpBufBufResource.resourceId);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCall);
            onChangeTmpBufBufArgsSerializer.writePointer(onChangeTmpBufBufCallSync);
            if (value0 instanceof string) {
                onChangeTmpBufBufArgsSerializer.writeInt8((0).toByte());
                const value0ForIdx0  = value0 as string;
                onChangeTmpBufBufArgsSerializer.writeString(value0ForIdx0);
            } else if (value0 instanceof number) {
                onChangeTmpBufBufArgsSerializer.writeInt8((1).toByte());
                const value0ForIdx1  = value0 as number;
                onChangeTmpBufBufArgsSerializer.writeNumber(value0ForIdx1);
            } else if (value0 instanceof Resource) {
                onChangeTmpBufBufArgsSerializer.writeInt8((2).toByte());
                const value0ForIdx2  = value0 as Resource;
                Resource_serializer.write(onChangeTmpBufBufArgsSerializer, value0ForIdx2);
            }
            InteropNativeModule._CallCallbackSync(10, 46299833, onChangeTmpBufBufArgsSerializer.asBuffer(), onChangeTmpBufBufArgsSerializer.length());
            onChangeTmpBufBufArgsSerializer.release();
            return;
        }
        let value : Bindable<Length> = ({value: valueTmpResult, onChange: onChangeTmpResult} as Bindable<Length>)
        return value
    }
}
export class DividerStyle_serializer {
    public static write(buffer: SerializerBase, value: DividerStyle): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForStrokeWidth  = value.strokeWidth
        if (valueHolderForStrokeWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForStrokeWidthTmpValue  = valueHolderForStrokeWidth!
            if (valueHolderForStrokeWidthTmpValue instanceof string) {
            valueSerializer.writeInt8((0).toByte())
                const valueHolderForStrokeWidthTmpValueForIdx0  = valueHolderForStrokeWidthTmpValue as string
                valueSerializer.writeString(valueHolderForStrokeWidthTmpValueForIdx0)
            } else if (valueHolderForStrokeWidthTmpValue instanceof number) {
            valueSerializer.writeInt8((1).toByte())
                const valueHolderForStrokeWidthTmpValueForIdx1  = valueHolderForStrokeWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForStrokeWidthTmpValueForIdx1)
            } else if (valueHolderForStrokeWidthTmpValue instanceof Resource) {
            valueSerializer.writeInt8((2).toByte())
                const valueHolderForStrokeWidthTmpValueForIdx2  = valueHolderForStrokeWidthTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForStrokeWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForColor  = value.color
        if (valueHolderForColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForColorTmpValue  = valueHolderForColor!
            if (valueHolderForColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorTmpValueForIdx0  = valueHolderForColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForColorTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorTmpValueForIdx1  = valueHolderForColorTmpValue as number
                valueSerializer.writeNumber(valueHolderForColorTmpValueForIdx1)
            } else if (valueHolderForColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorTmpValueForIdx2  = valueHolderForColorTmpValue as string
                valueSerializer.writeString(valueHolderForColorTmpValueForIdx2)
            } else if (valueHolderForColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorTmpValueForIdx3  = valueHolderForColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForStartMargin  = value.startMargin
        if (valueHolderForStartMargin !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForStartMarginTmpValue  = valueHolderForStartMargin!
            if (valueHolderForStartMarginTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForStartMarginTmpValueForIdx0  = valueHolderForStartMarginTmpValue as string
                valueSerializer.writeString(valueHolderForStartMarginTmpValueForIdx0)
            } else if (valueHolderForStartMarginTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForStartMarginTmpValueForIdx1  = valueHolderForStartMarginTmpValue as number
                valueSerializer.writeNumber(valueHolderForStartMarginTmpValueForIdx1)
            } else if (valueHolderForStartMarginTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForStartMarginTmpValueForIdx2  = valueHolderForStartMarginTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForStartMarginTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEndMargin  = value.endMargin
        if (valueHolderForEndMargin !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEndMarginTmpValue  = valueHolderForEndMargin!
            if (valueHolderForEndMarginTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForEndMarginTmpValueForIdx0  = valueHolderForEndMarginTmpValue as string
                valueSerializer.writeString(valueHolderForEndMarginTmpValueForIdx0)
            } else if (valueHolderForEndMarginTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForEndMarginTmpValueForIdx1  = valueHolderForEndMarginTmpValue as number
                valueSerializer.writeNumber(valueHolderForEndMarginTmpValueForIdx1)
            } else if (valueHolderForEndMarginTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForEndMarginTmpValueForIdx2  = valueHolderForEndMarginTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForEndMarginTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): DividerStyle {
        let valueDeserializer : DeserializerBase = buffer
        const strokeWidthTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let strokeWidthTmpBuf : Length | undefined = undefined
        if ((strokeWidthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const strokeWidthTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let strokeWidthTmpBuf_ : string | number | Resource | undefined
            if (strokeWidthTmpBuf_UnionSelector == (0).toChar()) {
                strokeWidthTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (strokeWidthTmpBuf_UnionSelector == (1).toChar()) {
                strokeWidthTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (strokeWidthTmpBuf_UnionSelector == (2).toChar()) {
                strokeWidthTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for strokeWidthTmpBuf_ has to be chosen through deserialisation.")
            }
            strokeWidthTmpBuf = (strokeWidthTmpBuf_ as string | number | Resource)
        }
        const strokeWidthTmpResult : Length | undefined = strokeWidthTmpBuf
        const colorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let colorTmpBuf : ResourceColor | undefined = undefined
        if ((colorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const colorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let colorTmpBuf_ : Color | number | string | Resource | undefined
            if (colorTmpBuf_UnionSelector == (0).toChar()) {
                colorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (colorTmpBuf_UnionSelector == (1).toChar()) {
                colorTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (colorTmpBuf_UnionSelector == (2).toChar()) {
                colorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (colorTmpBuf_UnionSelector == (3).toChar()) {
                colorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for colorTmpBuf_ has to be chosen through deserialisation.")
            }
            colorTmpBuf = (colorTmpBuf_ as Color | number | string | Resource)
        }
        const colorTmpResult : ResourceColor | undefined = colorTmpBuf
        const startMarginTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let startMarginTmpBuf : Length | undefined = undefined
        if ((startMarginTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const startMarginTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let startMarginTmpBuf_ : string | number | Resource | undefined
            if (startMarginTmpBuf_UnionSelector == (0).toChar()) {
                startMarginTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (startMarginTmpBuf_UnionSelector == (1).toChar()) {
                startMarginTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (startMarginTmpBuf_UnionSelector == (2).toChar()) {
                startMarginTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for startMarginTmpBuf_ has to be chosen through deserialisation.")
            }
            startMarginTmpBuf = (startMarginTmpBuf_ as string | number | Resource)
        }
        const startMarginTmpResult : Length | undefined = startMarginTmpBuf
        const endMarginTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let endMarginTmpBuf : Length | undefined = undefined
        if ((endMarginTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const endMarginTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let endMarginTmpBuf_ : string | number | Resource | undefined
            if (endMarginTmpBuf_UnionSelector == (0).toChar()) {
                endMarginTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (endMarginTmpBuf_UnionSelector == (1).toChar()) {
                endMarginTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (endMarginTmpBuf_UnionSelector == (2).toChar()) {
                endMarginTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for endMarginTmpBuf_ has to be chosen through deserialisation.")
            }
            endMarginTmpBuf = (endMarginTmpBuf_ as string | number | Resource)
        }
        const endMarginTmpResult : Length | undefined = endMarginTmpBuf
        let value : DividerStyle = ({strokeWidth: strokeWidthTmpResult, color: colorTmpResult, startMargin: startMarginTmpResult, endMargin: endMarginTmpResult} as DividerStyle)
        return value
    }
}
export class PixelStretchEffectOptions_serializer {
    public static write(buffer: SerializerBase, value: PixelStretchEffectOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForTop  = value.top
        if (valueHolderForTop !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTopTmpValue  = valueHolderForTop!
            if (valueHolderForTopTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForTopTmpValueForIdx0  = valueHolderForTopTmpValue as string
                valueSerializer.writeString(valueHolderForTopTmpValueForIdx0)
            } else if (valueHolderForTopTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForTopTmpValueForIdx1  = valueHolderForTopTmpValue as number
                valueSerializer.writeNumber(valueHolderForTopTmpValueForIdx1)
            } else if (valueHolderForTopTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForTopTmpValueForIdx2  = valueHolderForTopTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForTopTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBottom  = value.bottom
        if (valueHolderForBottom !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBottomTmpValue  = valueHolderForBottom!
            if (valueHolderForBottomTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBottomTmpValueForIdx0  = valueHolderForBottomTmpValue as string
                valueSerializer.writeString(valueHolderForBottomTmpValueForIdx0)
            } else if (valueHolderForBottomTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBottomTmpValueForIdx1  = valueHolderForBottomTmpValue as number
                valueSerializer.writeNumber(valueHolderForBottomTmpValueForIdx1)
            } else if (valueHolderForBottomTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBottomTmpValueForIdx2  = valueHolderForBottomTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForBottomTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForLeft  = value.left
        if (valueHolderForLeft !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForLeftTmpValue  = valueHolderForLeft!
            if (valueHolderForLeftTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForLeftTmpValueForIdx0  = valueHolderForLeftTmpValue as string
                valueSerializer.writeString(valueHolderForLeftTmpValueForIdx0)
            } else if (valueHolderForLeftTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForLeftTmpValueForIdx1  = valueHolderForLeftTmpValue as number
                valueSerializer.writeNumber(valueHolderForLeftTmpValueForIdx1)
            } else if (valueHolderForLeftTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForLeftTmpValueForIdx2  = valueHolderForLeftTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForLeftTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRight  = value.right
        if (valueHolderForRight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRightTmpValue  = valueHolderForRight!
            if (valueHolderForRightTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForRightTmpValueForIdx0  = valueHolderForRightTmpValue as string
                valueSerializer.writeString(valueHolderForRightTmpValueForIdx0)
            } else if (valueHolderForRightTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForRightTmpValueForIdx1  = valueHolderForRightTmpValue as number
                valueSerializer.writeNumber(valueHolderForRightTmpValueForIdx1)
            } else if (valueHolderForRightTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForRightTmpValueForIdx2  = valueHolderForRightTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForRightTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PixelStretchEffectOptions {
        let valueDeserializer : DeserializerBase = buffer
        const topTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let topTmpBuf : Length | undefined = undefined
        if ((topTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const topTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let topTmpBuf_ : string | number | Resource | undefined
            if (topTmpBuf_UnionSelector == (0).toChar()) {
                topTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (topTmpBuf_UnionSelector == (1).toChar()) {
                topTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (topTmpBuf_UnionSelector == (2).toChar()) {
                topTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for topTmpBuf_ has to be chosen through deserialisation.")
            }
            topTmpBuf = (topTmpBuf_ as string | number | Resource)
        }
        const topTmpResult : Length | undefined = topTmpBuf
        const bottomTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let bottomTmpBuf : Length | undefined = undefined
        if ((bottomTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const bottomTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let bottomTmpBuf_ : string | number | Resource | undefined
            if (bottomTmpBuf_UnionSelector == (0).toChar()) {
                bottomTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (bottomTmpBuf_UnionSelector == (1).toChar()) {
                bottomTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (bottomTmpBuf_UnionSelector == (2).toChar()) {
                bottomTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for bottomTmpBuf_ has to be chosen through deserialisation.")
            }
            bottomTmpBuf = (bottomTmpBuf_ as string | number | Resource)
        }
        const bottomTmpResult : Length | undefined = bottomTmpBuf
        const leftTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let leftTmpBuf : Length | undefined = undefined
        if ((leftTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const leftTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let leftTmpBuf_ : string | number | Resource | undefined
            if (leftTmpBuf_UnionSelector == (0).toChar()) {
                leftTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (leftTmpBuf_UnionSelector == (1).toChar()) {
                leftTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (leftTmpBuf_UnionSelector == (2).toChar()) {
                leftTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for leftTmpBuf_ has to be chosen through deserialisation.")
            }
            leftTmpBuf = (leftTmpBuf_ as string | number | Resource)
        }
        const leftTmpResult : Length | undefined = leftTmpBuf
        const rightTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let rightTmpBuf : Length | undefined = undefined
        if ((rightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const rightTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let rightTmpBuf_ : string | number | Resource | undefined
            if (rightTmpBuf_UnionSelector == (0).toChar()) {
                rightTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (rightTmpBuf_UnionSelector == (1).toChar()) {
                rightTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (rightTmpBuf_UnionSelector == (2).toChar()) {
                rightTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for rightTmpBuf_ has to be chosen through deserialisation.")
            }
            rightTmpBuf = (rightTmpBuf_ as string | number | Resource)
        }
        const rightTmpResult : Length | undefined = rightTmpBuf
        let value : PixelStretchEffectOptions = ({top: topTmpResult, bottom: bottomTmpResult, left: leftTmpResult, right: rightTmpResult} as PixelStretchEffectOptions)
        return value
    }
}
export class PointLightStyle_serializer {
    public static write(buffer: SerializerBase, value: PointLightStyle): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForLightSource  = value.lightSource
        if (valueHolderForLightSource !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForLightSourceTmpValue  = valueHolderForLightSource!
            LightSource_serializer.write(valueSerializer, valueHolderForLightSourceTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForIlluminated  = value.illuminated
        if (valueHolderForIlluminated !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForIlluminatedTmpValue  = (valueHolderForIlluminated as IlluminatedType)
            valueSerializer.writeInt32(valueHolderForIlluminatedTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBloom  = value.bloom
        if (valueHolderForBloom !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBloomTmpValue  = valueHolderForBloom!
            valueSerializer.writeNumber(valueHolderForBloomTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PointLightStyle {
        let valueDeserializer : DeserializerBase = buffer
        const lightSourceTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let lightSourceTmpBuf : LightSource | undefined = undefined
        if ((lightSourceTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            lightSourceTmpBuf = LightSource_serializer.read(valueDeserializer)
        }
        const lightSourceTmpResult : LightSource | undefined = lightSourceTmpBuf
        const illuminatedTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let illuminatedTmpBuf : IlluminatedType | undefined = undefined
        if ((illuminatedTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            illuminatedTmpBuf = IlluminatedType.fromValue(valueDeserializer.readInt32())
        }
        const illuminatedTmpResult : IlluminatedType | undefined = illuminatedTmpBuf
        const bloomTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let bloomTmpBuf : number | undefined = undefined
        if ((bloomTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            bloomTmpBuf = (valueDeserializer.readNumber() as number)
        }
        const bloomTmpResult : number | undefined = bloomTmpBuf
        let value : PointLightStyle = ({lightSource: lightSourceTmpResult, illuminated: illuminatedTmpResult, bloom: bloomTmpResult} as PointLightStyle)
        return value
    }
}
export class RadialGradientOptions_serializer {
    public static write(buffer: SerializerBase, value: RadialGradientOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForCenter  = value.center
        const valueHolderForCenter_0  = valueHolderForCenter[0]
        if (valueHolderForCenter_0 instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForCenter_0ForIdx0  = valueHolderForCenter_0 as string
            valueSerializer.writeString(valueHolderForCenter_0ForIdx0)
        } else if (valueHolderForCenter_0 instanceof number) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForCenter_0ForIdx1  = valueHolderForCenter_0 as number
            valueSerializer.writeNumber(valueHolderForCenter_0ForIdx1)
        } else if (valueHolderForCenter_0 instanceof Resource) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForCenter_0ForIdx2  = valueHolderForCenter_0 as Resource
            Resource_serializer.write(valueSerializer, valueHolderForCenter_0ForIdx2)
        }
        const valueHolderForCenter_1  = valueHolderForCenter[1]
        if (valueHolderForCenter_1 instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForCenter_1ForIdx0  = valueHolderForCenter_1 as string
            valueSerializer.writeString(valueHolderForCenter_1ForIdx0)
        } else if (valueHolderForCenter_1 instanceof number) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForCenter_1ForIdx1  = valueHolderForCenter_1 as number
            valueSerializer.writeNumber(valueHolderForCenter_1ForIdx1)
        } else if (valueHolderForCenter_1 instanceof Resource) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForCenter_1ForIdx2  = valueHolderForCenter_1 as Resource
            Resource_serializer.write(valueSerializer, valueHolderForCenter_1ForIdx2)
        }
        const valueHolderForRadius  = value.radius
        if (valueHolderForRadius instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForRadiusForIdx0  = valueHolderForRadius as string
            valueSerializer.writeString(valueHolderForRadiusForIdx0)
        } else if (valueHolderForRadius instanceof number) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForRadiusForIdx1  = valueHolderForRadius as number
            valueSerializer.writeNumber(valueHolderForRadiusForIdx1)
        } else if (valueHolderForRadius instanceof Resource) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForRadiusForIdx2  = valueHolderForRadius as Resource
            Resource_serializer.write(valueSerializer, valueHolderForRadiusForIdx2)
        }
        const valueHolderForColors  = value.colors
        valueSerializer.writeInt32((valueHolderForColors.length).toInt())
        for (let valueHolderForColorsCounterI = 0; valueHolderForColorsCounterI < valueHolderForColors.length; valueHolderForColorsCounterI++) {
            const valueHolderForColorsTmpElement : [ ResourceColor, double ] = valueHolderForColors[valueHolderForColorsCounterI]
            const valueHolderForColorsTmpElement_0  = valueHolderForColorsTmpElement[0]
            if (valueHolderForColorsTmpElement_0 instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorsTmpElement_0ForIdx0  = valueHolderForColorsTmpElement_0 as Color
                valueSerializer.writeInt32(valueHolderForColorsTmpElement_0ForIdx0.getOrdinal())
            } else if (valueHolderForColorsTmpElement_0 instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorsTmpElement_0ForIdx1  = valueHolderForColorsTmpElement_0 as number
                valueSerializer.writeNumber(valueHolderForColorsTmpElement_0ForIdx1)
            } else if (valueHolderForColorsTmpElement_0 instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorsTmpElement_0ForIdx2  = valueHolderForColorsTmpElement_0 as string
                valueSerializer.writeString(valueHolderForColorsTmpElement_0ForIdx2)
            } else if (valueHolderForColorsTmpElement_0 instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorsTmpElement_0ForIdx3  = valueHolderForColorsTmpElement_0 as Resource
                Resource_serializer.write(valueSerializer, valueHolderForColorsTmpElement_0ForIdx3)
            }
            const valueHolderForColorsTmpElement_1  = valueHolderForColorsTmpElement[1]
            valueSerializer.writeFloat64(valueHolderForColorsTmpElement_1)
        }
        const valueHolderForRepeating  = value.repeating
        if (valueHolderForRepeating !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRepeatingTmpValue  = valueHolderForRepeating!
            valueSerializer.writeBoolean(valueHolderForRepeatingTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): RadialGradientOptions {
        let valueDeserializer : DeserializerBase = buffer
        const centerTmpBufValue0TempBufUnionSelector : int32 = valueDeserializer.readInt8()
        let centerTmpBufValue0TempBuf : string | number | Resource | undefined
        if (centerTmpBufValue0TempBufUnionSelector == (0).toChar()) {
            centerTmpBufValue0TempBuf = (valueDeserializer.readString() as string)
        } else if (centerTmpBufValue0TempBufUnionSelector == (1).toChar()) {
            centerTmpBufValue0TempBuf = (valueDeserializer.readNumber() as number)
        } else if (centerTmpBufValue0TempBufUnionSelector == (2).toChar()) {
            centerTmpBufValue0TempBuf = Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error("One of the branches for centerTmpBufValue0TempBuf has to be chosen through deserialisation.")
        }
        const centerTmpBufValue0 : Length = (centerTmpBufValue0TempBuf as string | number | Resource)
        const centerTmpBufValue1TempBufUnionSelector : int32 = valueDeserializer.readInt8()
        let centerTmpBufValue1TempBuf : string | number | Resource | undefined
        if (centerTmpBufValue1TempBufUnionSelector == (0).toChar()) {
            centerTmpBufValue1TempBuf = (valueDeserializer.readString() as string)
        } else if (centerTmpBufValue1TempBufUnionSelector == (1).toChar()) {
            centerTmpBufValue1TempBuf = (valueDeserializer.readNumber() as number)
        } else if (centerTmpBufValue1TempBufUnionSelector == (2).toChar()) {
            centerTmpBufValue1TempBuf = Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error("One of the branches for centerTmpBufValue1TempBuf has to be chosen through deserialisation.")
        }
        const centerTmpBufValue1 : Length = (centerTmpBufValue1TempBuf as string | number | Resource)
        const centerTmpResult : [ Length, Length ] = ([centerTmpBufValue0, centerTmpBufValue1] as [ Length, Length ])
        const radiusTmpBufUnionSelector : int32 = valueDeserializer.readInt8()
        let radiusTmpBuf : string | number | Resource | undefined
        if (radiusTmpBufUnionSelector == (0).toChar()) {
            radiusTmpBuf = (valueDeserializer.readString() as string)
        } else if (radiusTmpBufUnionSelector == (1).toChar()) {
            radiusTmpBuf = (valueDeserializer.readNumber() as number)
        } else if (radiusTmpBufUnionSelector == (2).toChar()) {
            radiusTmpBuf = Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error("One of the branches for radiusTmpBuf has to be chosen through deserialisation.")
        }
        const radiusTmpResult : Length = (radiusTmpBuf as string | number | Resource)
        const colorsTmpBufLength : int32 = valueDeserializer.readInt32()
        let colorsTmpBuf : Array<[ ResourceColor, double ]> = new Array<[ ResourceColor, double ]>(colorsTmpBufLength)
        for (let colorsTmpBufBufCounterI = 0; colorsTmpBufBufCounterI < colorsTmpBufLength; colorsTmpBufBufCounterI++) {
            const colorsTmpBufTempBufValue0TempBufUnionSelector : int32 = valueDeserializer.readInt8()
            let colorsTmpBufTempBufValue0TempBuf : Color | number | string | Resource | undefined
            if (colorsTmpBufTempBufValue0TempBufUnionSelector == (0).toChar()) {
                colorsTmpBufTempBufValue0TempBuf = Color.values()[valueDeserializer.readInt32()]
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (1).toChar()) {
                colorsTmpBufTempBufValue0TempBuf = (valueDeserializer.readNumber() as number)
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (2).toChar()) {
                colorsTmpBufTempBufValue0TempBuf = (valueDeserializer.readString() as string)
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (3).toChar()) {
                colorsTmpBufTempBufValue0TempBuf = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for colorsTmpBufTempBufValue0TempBuf has to be chosen through deserialisation.")
            }
            const colorsTmpBufTempBufValue0 : ResourceColor = (colorsTmpBufTempBufValue0TempBuf as Color | number | string | Resource)
            const colorsTmpBufTempBufValue1 : double = valueDeserializer.readFloat64()
            colorsTmpBuf[colorsTmpBufBufCounterI] = ([colorsTmpBufTempBufValue0, colorsTmpBufTempBufValue1] as [ ResourceColor, double ])
        }
        const colorsTmpResult : Array<[ ResourceColor, double ]> = colorsTmpBuf
        const repeatingTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let repeatingTmpBuf : boolean | undefined = undefined
        if ((repeatingTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            repeatingTmpBuf = valueDeserializer.readBoolean()
        }
        const repeatingTmpResult : boolean | undefined = repeatingTmpBuf
        let value : RadialGradientOptions = ({center: centerTmpResult, radius: radiusTmpResult, colors: colorsTmpResult, repeating: repeatingTmpResult} as RadialGradientOptions)
        return value
    }
}
export class Rectangle_serializer {
    public static write(buffer: SerializerBase, value: Rectangle): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForX  = value.x
        if (valueHolderForX !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForXTmpValue  = valueHolderForX!
            if (valueHolderForXTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForXTmpValueForIdx0  = valueHolderForXTmpValue as string
                valueSerializer.writeString(valueHolderForXTmpValueForIdx0)
            } else if (valueHolderForXTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForXTmpValueForIdx1  = valueHolderForXTmpValue as number
                valueSerializer.writeNumber(valueHolderForXTmpValueForIdx1)
            } else if (valueHolderForXTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForXTmpValueForIdx2  = valueHolderForXTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForXTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForY  = value.y
        if (valueHolderForY !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForYTmpValue  = valueHolderForY!
            if (valueHolderForYTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForYTmpValueForIdx0  = valueHolderForYTmpValue as string
                valueSerializer.writeString(valueHolderForYTmpValueForIdx0)
            } else if (valueHolderForYTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForYTmpValueForIdx1  = valueHolderForYTmpValue as number
                valueSerializer.writeNumber(valueHolderForYTmpValueForIdx1)
            } else if (valueHolderForYTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForYTmpValueForIdx2  = valueHolderForYTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForYTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForWidth  = value.width
        if (valueHolderForWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForWidthTmpValue  = valueHolderForWidth!
            if (valueHolderForWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForWidthTmpValueForIdx0  = valueHolderForWidthTmpValue as string
                valueSerializer.writeString(valueHolderForWidthTmpValueForIdx0)
            } else if (valueHolderForWidthTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForWidthTmpValueForIdx1  = valueHolderForWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForWidthTmpValueForIdx1)
            } else if (valueHolderForWidthTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForWidthTmpValueForIdx2  = valueHolderForWidthTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHeight  = value.height
        if (valueHolderForHeight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHeightTmpValue  = valueHolderForHeight!
            if (valueHolderForHeightTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForHeightTmpValueForIdx0  = valueHolderForHeightTmpValue as string
                valueSerializer.writeString(valueHolderForHeightTmpValueForIdx0)
            } else if (valueHolderForHeightTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForHeightTmpValueForIdx1  = valueHolderForHeightTmpValue as number
                valueSerializer.writeNumber(valueHolderForHeightTmpValueForIdx1)
            } else if (valueHolderForHeightTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForHeightTmpValueForIdx2  = valueHolderForHeightTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForHeightTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): Rectangle {
        let valueDeserializer : DeserializerBase = buffer
        const xTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let xTmpBuf : Length | undefined = undefined
        if ((xTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const xTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let xTmpBuf_ : string | number | Resource | undefined
            if (xTmpBuf_UnionSelector == (0).toChar()) {
                xTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (xTmpBuf_UnionSelector == (1).toChar()) {
                xTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (xTmpBuf_UnionSelector == (2).toChar()) {
                xTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for xTmpBuf_ has to be chosen through deserialisation.")
            }
            xTmpBuf = (xTmpBuf_ as string | number | Resource)
        }
        const xTmpResult : Length | undefined = xTmpBuf
        const yTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let yTmpBuf : Length | undefined = undefined
        if ((yTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const yTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let yTmpBuf_ : string | number | Resource | undefined
            if (yTmpBuf_UnionSelector == (0).toChar()) {
                yTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (yTmpBuf_UnionSelector == (1).toChar()) {
                yTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (yTmpBuf_UnionSelector == (2).toChar()) {
                yTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for yTmpBuf_ has to be chosen through deserialisation.")
            }
            yTmpBuf = (yTmpBuf_ as string | number | Resource)
        }
        const yTmpResult : Length | undefined = yTmpBuf
        const widthTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let widthTmpBuf : Length | undefined = undefined
        if ((widthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const widthTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let widthTmpBuf_ : string | number | Resource | undefined
            if (widthTmpBuf_UnionSelector == (0).toChar()) {
                widthTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (widthTmpBuf_UnionSelector == (1).toChar()) {
                widthTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (widthTmpBuf_UnionSelector == (2).toChar()) {
                widthTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for widthTmpBuf_ has to be chosen through deserialisation.")
            }
            widthTmpBuf = (widthTmpBuf_ as string | number | Resource)
        }
        const widthTmpResult : Length | undefined = widthTmpBuf
        const heightTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let heightTmpBuf : Length | undefined = undefined
        if ((heightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const heightTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let heightTmpBuf_ : string | number | Resource | undefined
            if (heightTmpBuf_UnionSelector == (0).toChar()) {
                heightTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (heightTmpBuf_UnionSelector == (1).toChar()) {
                heightTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (heightTmpBuf_UnionSelector == (2).toChar()) {
                heightTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for heightTmpBuf_ has to be chosen through deserialisation.")
            }
            heightTmpBuf = (heightTmpBuf_ as string | number | Resource)
        }
        const heightTmpResult : Length | undefined = heightTmpBuf
        let value : Rectangle = ({x: xTmpResult, y: yTmpResult, width: widthTmpResult, height: heightTmpResult} as Rectangle)
        return value
    }
}
export class SweepGradientOptions_serializer {
    public static write(buffer: SerializerBase, value: SweepGradientOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForCenter  = value.center
        const valueHolderForCenter_0  = valueHolderForCenter[0]
        if (valueHolderForCenter_0 instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForCenter_0ForIdx0  = valueHolderForCenter_0 as string
            valueSerializer.writeString(valueHolderForCenter_0ForIdx0)
        } else if (valueHolderForCenter_0 instanceof number) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForCenter_0ForIdx1  = valueHolderForCenter_0 as number
            valueSerializer.writeNumber(valueHolderForCenter_0ForIdx1)
        } else if (valueHolderForCenter_0 instanceof Resource) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForCenter_0ForIdx2  = valueHolderForCenter_0 as Resource
            Resource_serializer.write(valueSerializer, valueHolderForCenter_0ForIdx2)
        }
        const valueHolderForCenter_1  = valueHolderForCenter[1]
        if (valueHolderForCenter_1 instanceof string) {
            valueSerializer.writeInt8((0).toByte())
            const valueHolderForCenter_1ForIdx0  = valueHolderForCenter_1 as string
            valueSerializer.writeString(valueHolderForCenter_1ForIdx0)
        } else if (valueHolderForCenter_1 instanceof number) {
            valueSerializer.writeInt8((1).toByte())
            const valueHolderForCenter_1ForIdx1  = valueHolderForCenter_1 as number
            valueSerializer.writeNumber(valueHolderForCenter_1ForIdx1)
        } else if (valueHolderForCenter_1 instanceof Resource) {
            valueSerializer.writeInt8((2).toByte())
            const valueHolderForCenter_1ForIdx2  = valueHolderForCenter_1 as Resource
            Resource_serializer.write(valueSerializer, valueHolderForCenter_1ForIdx2)
        }
        const valueHolderForStart  = value.start
        if (valueHolderForStart !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForStartTmpValue  = valueHolderForStart!
            if (valueHolderForStartTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForStartTmpValueForIdx0  = valueHolderForStartTmpValue as double
                valueSerializer.writeFloat64(valueHolderForStartTmpValueForIdx0)
            } else if (valueHolderForStartTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForStartTmpValueForIdx1  = valueHolderForStartTmpValue as string
                valueSerializer.writeString(valueHolderForStartTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnd  = value.end
        if (valueHolderForEnd !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEndTmpValue  = valueHolderForEnd!
            if (valueHolderForEndTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForEndTmpValueForIdx0  = valueHolderForEndTmpValue as double
                valueSerializer.writeFloat64(valueHolderForEndTmpValueForIdx0)
            } else if (valueHolderForEndTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForEndTmpValueForIdx1  = valueHolderForEndTmpValue as string
                valueSerializer.writeString(valueHolderForEndTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRotation  = value.rotation
        if (valueHolderForRotation !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRotationTmpValue  = valueHolderForRotation!
            if (valueHolderForRotationTmpValue instanceof double) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForRotationTmpValueForIdx0  = valueHolderForRotationTmpValue as double
                valueSerializer.writeFloat64(valueHolderForRotationTmpValueForIdx0)
            } else if (valueHolderForRotationTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForRotationTmpValueForIdx1  = valueHolderForRotationTmpValue as string
                valueSerializer.writeString(valueHolderForRotationTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForColors  = value.colors
        valueSerializer.writeInt32((valueHolderForColors.length).toInt())
        for (let valueHolderForColorsCounterI = 0; valueHolderForColorsCounterI < valueHolderForColors.length; valueHolderForColorsCounterI++) {
            const valueHolderForColorsTmpElement : [ ResourceColor, double ] = valueHolderForColors[valueHolderForColorsCounterI]
            const valueHolderForColorsTmpElement_0  = valueHolderForColorsTmpElement[0]
            if (valueHolderForColorsTmpElement_0 instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorsTmpElement_0ForIdx0  = valueHolderForColorsTmpElement_0 as Color
                valueSerializer.writeInt32(valueHolderForColorsTmpElement_0ForIdx0.getOrdinal())
            } else if (valueHolderForColorsTmpElement_0 instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorsTmpElement_0ForIdx1  = valueHolderForColorsTmpElement_0 as number
                valueSerializer.writeNumber(valueHolderForColorsTmpElement_0ForIdx1)
            } else if (valueHolderForColorsTmpElement_0 instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorsTmpElement_0ForIdx2  = valueHolderForColorsTmpElement_0 as string
                valueSerializer.writeString(valueHolderForColorsTmpElement_0ForIdx2)
            } else if (valueHolderForColorsTmpElement_0 instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorsTmpElement_0ForIdx3  = valueHolderForColorsTmpElement_0 as Resource
                Resource_serializer.write(valueSerializer, valueHolderForColorsTmpElement_0ForIdx3)
            }
            const valueHolderForColorsTmpElement_1  = valueHolderForColorsTmpElement[1]
            valueSerializer.writeFloat64(valueHolderForColorsTmpElement_1)
        }
        const valueHolderForRepeating  = value.repeating
        if (valueHolderForRepeating !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRepeatingTmpValue  = valueHolderForRepeating!
            valueSerializer.writeBoolean(valueHolderForRepeatingTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): SweepGradientOptions {
        let valueDeserializer : DeserializerBase = buffer
        const centerTmpBufValue0TempBufUnionSelector : int32 = valueDeserializer.readInt8()
        let centerTmpBufValue0TempBuf : string | number | Resource | undefined
        if (centerTmpBufValue0TempBufUnionSelector == (0).toChar()) {
            centerTmpBufValue0TempBuf = (valueDeserializer.readString() as string)
        } else if (centerTmpBufValue0TempBufUnionSelector == (1).toChar()) {
            centerTmpBufValue0TempBuf = (valueDeserializer.readNumber() as number)
        } else if (centerTmpBufValue0TempBufUnionSelector == (2).toChar()) {
            centerTmpBufValue0TempBuf = Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error("One of the branches for centerTmpBufValue0TempBuf has to be chosen through deserialisation.")
        }
        const centerTmpBufValue0 : Length = (centerTmpBufValue0TempBuf as string | number | Resource)
        const centerTmpBufValue1TempBufUnionSelector : int32 = valueDeserializer.readInt8()
        let centerTmpBufValue1TempBuf : string | number | Resource | undefined
        if (centerTmpBufValue1TempBufUnionSelector == (0).toChar()) {
            centerTmpBufValue1TempBuf = (valueDeserializer.readString() as string)
        } else if (centerTmpBufValue1TempBufUnionSelector == (1).toChar()) {
            centerTmpBufValue1TempBuf = (valueDeserializer.readNumber() as number)
        } else if (centerTmpBufValue1TempBufUnionSelector == (2).toChar()) {
            centerTmpBufValue1TempBuf = Resource_serializer.read(valueDeserializer)
        } else {
            throw new Error("One of the branches for centerTmpBufValue1TempBuf has to be chosen through deserialisation.")
        }
        const centerTmpBufValue1 : Length = (centerTmpBufValue1TempBuf as string | number | Resource)
        const centerTmpResult : [ Length, Length ] = ([centerTmpBufValue0, centerTmpBufValue1] as [ Length, Length ])
        const startTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let startTmpBuf : double | string | undefined = undefined
        if ((startTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const startTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let startTmpBuf_ : double | string | undefined
            if (startTmpBuf_UnionSelector == (0).toChar()) {
                startTmpBuf_ = valueDeserializer.readFloat64()
            } else if (startTmpBuf_UnionSelector == (1).toChar()) {
                startTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for startTmpBuf_ has to be chosen through deserialisation.")
            }
            startTmpBuf = (startTmpBuf_ as double | string)
        }
        const startTmpResult : double | string | undefined = startTmpBuf
        const endTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let endTmpBuf : double | string | undefined = undefined
        if ((endTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const endTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let endTmpBuf_ : double | string | undefined
            if (endTmpBuf_UnionSelector == (0).toChar()) {
                endTmpBuf_ = valueDeserializer.readFloat64()
            } else if (endTmpBuf_UnionSelector == (1).toChar()) {
                endTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for endTmpBuf_ has to be chosen through deserialisation.")
            }
            endTmpBuf = (endTmpBuf_ as double | string)
        }
        const endTmpResult : double | string | undefined = endTmpBuf
        const rotationTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let rotationTmpBuf : double | string | undefined = undefined
        if ((rotationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const rotationTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let rotationTmpBuf_ : double | string | undefined
            if (rotationTmpBuf_UnionSelector == (0).toChar()) {
                rotationTmpBuf_ = valueDeserializer.readFloat64()
            } else if (rotationTmpBuf_UnionSelector == (1).toChar()) {
                rotationTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for rotationTmpBuf_ has to be chosen through deserialisation.")
            }
            rotationTmpBuf = (rotationTmpBuf_ as double | string)
        }
        const rotationTmpResult : number | string | undefined = rotationTmpBuf
        const colorsTmpBufLength : int32 = valueDeserializer.readInt32()
        let colorsTmpBuf : Array<[ ResourceColor, double ]> = new Array<[ ResourceColor, double ]>(colorsTmpBufLength)
        for (let colorsTmpBufBufCounterI = 0; colorsTmpBufBufCounterI < colorsTmpBufLength; colorsTmpBufBufCounterI++) {
            const colorsTmpBufTempBufValue0TempBufUnionSelector : int32 = valueDeserializer.readInt8()
            let colorsTmpBufTempBufValue0TempBuf : Color | number | string | Resource | undefined
            if (colorsTmpBufTempBufValue0TempBufUnionSelector == (0).toChar()) {
                colorsTmpBufTempBufValue0TempBuf = Color.values()[valueDeserializer.readInt32()]
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (1).toChar()) {
                colorsTmpBufTempBufValue0TempBuf = (valueDeserializer.readNumber() as number)
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (2).toChar()) {
                colorsTmpBufTempBufValue0TempBuf = (valueDeserializer.readString() as string)
            } else if (colorsTmpBufTempBufValue0TempBufUnionSelector == (3).toChar()) {
                colorsTmpBufTempBufValue0TempBuf = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for colorsTmpBufTempBufValue0TempBuf has to be chosen through deserialisation.")
            }
            const colorsTmpBufTempBufValue0 : ResourceColor = (colorsTmpBufTempBufValue0TempBuf as Color | number | string | Resource)
            const colorsTmpBufTempBufValue1 : double = valueDeserializer.readFloat64()
            colorsTmpBuf[colorsTmpBufBufCounterI] = ([colorsTmpBufTempBufValue0, colorsTmpBufTempBufValue1] as [ ResourceColor, double ])
        }
        const colorsTmpResult : Array<[ ResourceColor, double ]> = colorsTmpBuf
        const repeatingTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let repeatingTmpBuf : boolean | undefined = undefined
        if ((repeatingTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            repeatingTmpBuf = valueDeserializer.readBoolean()
        }
        const repeatingTmpResult : boolean | undefined = repeatingTmpBuf
        let value : SweepGradientOptions = ({center: centerTmpResult, start: startTmpResult, end: endTmpResult, rotation: rotationTmpResult, colors: colorsTmpResult, repeating: repeatingTmpResult} as SweepGradientOptions)
        return value
    }
}
export class TipsOptions_serializer {
    public static write(buffer: SerializerBase, value: TipsOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForAppearingTime  = value.appearingTime
        if (valueHolderForAppearingTime !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAppearingTimeTmpValue  = valueHolderForAppearingTime!
            valueSerializer.writeInt32(valueHolderForAppearingTimeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDisappearingTime  = value.disappearingTime
        if (valueHolderForDisappearingTime !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDisappearingTimeTmpValue  = valueHolderForDisappearingTime!
            valueSerializer.writeInt32(valueHolderForDisappearingTimeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAppearingTimeWithContinuousOperation  = value.appearingTimeWithContinuousOperation
        if (valueHolderForAppearingTimeWithContinuousOperation !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAppearingTimeWithContinuousOperationTmpValue  = valueHolderForAppearingTimeWithContinuousOperation!
            valueSerializer.writeInt32(valueHolderForAppearingTimeWithContinuousOperationTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDisappearingTimeWithContinuousOperation  = value.disappearingTimeWithContinuousOperation
        if (valueHolderForDisappearingTimeWithContinuousOperation !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDisappearingTimeWithContinuousOperationTmpValue  = valueHolderForDisappearingTimeWithContinuousOperation!
            valueSerializer.writeInt32(valueHolderForDisappearingTimeWithContinuousOperationTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableArrow  = value.enableArrow
        if (valueHolderForEnableArrow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableArrowTmpValue  = valueHolderForEnableArrow!
            valueSerializer.writeBoolean(valueHolderForEnableArrowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowPointPosition  = value.arrowPointPosition
        if (valueHolderForArrowPointPosition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowPointPositionTmpValue  = (valueHolderForArrowPointPosition as ArrowPointPosition)
            valueSerializer.writeInt32(valueHolderForArrowPointPositionTmpValue.getOrdinal())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowWidth  = value.arrowWidth
        if (valueHolderForArrowWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowWidthTmpValue  = valueHolderForArrowWidth!
            if (valueHolderForArrowWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowWidthTmpValueForIdx0  = valueHolderForArrowWidthTmpValue as string
                valueSerializer.writeString(valueHolderForArrowWidthTmpValueForIdx0)
            } else if (valueHolderForArrowWidthTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowWidthTmpValueForIdx1  = valueHolderForArrowWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowWidthTmpValueForIdx1)
            } else if (valueHolderForArrowWidthTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowWidthTmpValueForIdx2  = valueHolderForArrowWidthTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForArrowWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowHeight  = value.arrowHeight
        if (valueHolderForArrowHeight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowHeightTmpValue  = valueHolderForArrowHeight!
            if (valueHolderForArrowHeightTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowHeightTmpValueForIdx0  = valueHolderForArrowHeightTmpValue as string
                valueSerializer.writeString(valueHolderForArrowHeightTmpValueForIdx0)
            } else if (valueHolderForArrowHeightTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowHeightTmpValueForIdx1  = valueHolderForArrowHeightTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowHeightTmpValueForIdx1)
            } else if (valueHolderForArrowHeightTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowHeightTmpValueForIdx2  = valueHolderForArrowHeightTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForArrowHeightTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): TipsOptions {
        let valueDeserializer : DeserializerBase = buffer
        const appearingTimeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let appearingTimeTmpBuf : int32 | undefined = undefined
        if ((appearingTimeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            appearingTimeTmpBuf = valueDeserializer.readInt32()
        }
        const appearingTimeTmpResult : int32 | undefined = appearingTimeTmpBuf
        const disappearingTimeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let disappearingTimeTmpBuf : int32 | undefined = undefined
        if ((disappearingTimeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            disappearingTimeTmpBuf = valueDeserializer.readInt32()
        }
        const disappearingTimeTmpResult : int32 | undefined = disappearingTimeTmpBuf
        const appearingTimeWithContinuousOperationTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let appearingTimeWithContinuousOperationTmpBuf : int32 | undefined = undefined
        if ((appearingTimeWithContinuousOperationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            appearingTimeWithContinuousOperationTmpBuf = valueDeserializer.readInt32()
        }
        const appearingTimeWithContinuousOperationTmpResult : int32 | undefined = appearingTimeWithContinuousOperationTmpBuf
        const disappearingTimeWithContinuousOperationTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let disappearingTimeWithContinuousOperationTmpBuf : int32 | undefined = undefined
        if ((disappearingTimeWithContinuousOperationTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            disappearingTimeWithContinuousOperationTmpBuf = valueDeserializer.readInt32()
        }
        const disappearingTimeWithContinuousOperationTmpResult : int32 | undefined = disappearingTimeWithContinuousOperationTmpBuf
        const enableArrowTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableArrowTmpBuf : boolean | undefined = undefined
        if ((enableArrowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableArrowTmpBuf = valueDeserializer.readBoolean()
        }
        const enableArrowTmpResult : boolean | undefined = enableArrowTmpBuf
        const arrowPointPositionTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowPointPositionTmpBuf : ArrowPointPosition | undefined = undefined
        if ((arrowPointPositionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            arrowPointPositionTmpBuf = ArrowPointPosition.values()[valueDeserializer.readInt32()]
        }
        const arrowPointPositionTmpResult : ArrowPointPosition | undefined = arrowPointPositionTmpBuf
        const arrowWidthTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowWidthTmpBuf : Dimension | undefined = undefined
        if ((arrowWidthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowWidthTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let arrowWidthTmpBuf_ : string | number | Resource | undefined
            if (arrowWidthTmpBuf_UnionSelector == (0).toChar()) {
                arrowWidthTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (arrowWidthTmpBuf_UnionSelector == (1).toChar()) {
                arrowWidthTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (arrowWidthTmpBuf_UnionSelector == (2).toChar()) {
                arrowWidthTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for arrowWidthTmpBuf_ has to be chosen through deserialisation.")
            }
            arrowWidthTmpBuf = (arrowWidthTmpBuf_ as string | number | Resource)
        }
        const arrowWidthTmpResult : Dimension | undefined = arrowWidthTmpBuf
        const arrowHeightTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowHeightTmpBuf : Dimension | undefined = undefined
        if ((arrowHeightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowHeightTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let arrowHeightTmpBuf_ : string | number | Resource | undefined
            if (arrowHeightTmpBuf_UnionSelector == (0).toChar()) {
                arrowHeightTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (arrowHeightTmpBuf_UnionSelector == (1).toChar()) {
                arrowHeightTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (arrowHeightTmpBuf_UnionSelector == (2).toChar()) {
                arrowHeightTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for arrowHeightTmpBuf_ has to be chosen through deserialisation.")
            }
            arrowHeightTmpBuf = (arrowHeightTmpBuf_ as string | number | Resource)
        }
        const arrowHeightTmpResult : Dimension | undefined = arrowHeightTmpBuf
        let value : TipsOptions = ({appearingTime: appearingTimeTmpResult, disappearingTime: disappearingTimeTmpResult, appearingTimeWithContinuousOperation: appearingTimeWithContinuousOperationTmpResult, disappearingTimeWithContinuousOperation: disappearingTimeWithContinuousOperationTmpResult, enableArrow: enableArrowTmpResult, arrowPointPosition: arrowPointPositionTmpResult, arrowWidth: arrowWidthTmpResult, arrowHeight: arrowHeightTmpResult} as TipsOptions)
        return value
    }
}
export class BorderImageOption_serializer {
    public static write(buffer: SerializerBase, value: BorderImageOption): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForSlice  = value.slice
        if (valueHolderForSlice !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForSliceTmpValue  = valueHolderForSlice!
            if (valueHolderForSliceTmpValue instanceof Length) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForSliceTmpValueForIdx0  = valueHolderForSliceTmpValue as Length
                if (valueHolderForSliceTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForSliceTmpValueForIdx0ForIdx0  = valueHolderForSliceTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForSliceTmpValueForIdx0ForIdx0)
                } else if (valueHolderForSliceTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForSliceTmpValueForIdx0ForIdx1  = valueHolderForSliceTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForSliceTmpValueForIdx0ForIdx1)
                } else if (valueHolderForSliceTmpValueForIdx0 instanceof Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForSliceTmpValueForIdx0ForIdx2  = valueHolderForSliceTmpValueForIdx0 as Resource
                    Resource_serializer.write(valueSerializer, valueHolderForSliceTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForSliceTmpValue instanceof EdgeWidths) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForSliceTmpValueForIdx1  = valueHolderForSliceTmpValue as EdgeWidths
                EdgeWidths_serializer.write(valueSerializer, valueHolderForSliceTmpValueForIdx1)
            } else if (valueHolderForSliceTmpValue instanceof LocalizedEdgeWidths) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForSliceTmpValueForIdx2  = valueHolderForSliceTmpValue as LocalizedEdgeWidths
                LocalizedEdgeWidths_serializer.write(valueSerializer, valueHolderForSliceTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRepeat  = value.repeat
        if (valueHolderForRepeat !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRepeatTmpValue  = (valueHolderForRepeat as RepeatMode)
            valueSerializer.writeInt32(valueHolderForRepeatTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForSource  = value.source
        if (valueHolderForSource !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForSourceTmpValue  = valueHolderForSource!
            if (valueHolderForSourceTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForSourceTmpValueForIdx0  = valueHolderForSourceTmpValue as string
                valueSerializer.writeString(valueHolderForSourceTmpValueForIdx0)
            } else if (valueHolderForSourceTmpValue instanceof Resource) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForSourceTmpValueForIdx1  = valueHolderForSourceTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForSourceTmpValueForIdx1)
            } else if (valueHolderForSourceTmpValue instanceof LinearGradientOptions) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForSourceTmpValueForIdx2  = valueHolderForSourceTmpValue as LinearGradientOptions
                LinearGradientOptions_serializer.write(valueSerializer, valueHolderForSourceTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForWidth  = value.width
        if (valueHolderForWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForWidthTmpValue  = valueHolderForWidth!
            if (valueHolderForWidthTmpValue instanceof Length) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForWidthTmpValueForIdx0  = valueHolderForWidthTmpValue as Length
                if (valueHolderForWidthTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForWidthTmpValueForIdx0ForIdx0  = valueHolderForWidthTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForWidthTmpValueForIdx0ForIdx0)
                } else if (valueHolderForWidthTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForWidthTmpValueForIdx0ForIdx1  = valueHolderForWidthTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForWidthTmpValueForIdx0ForIdx1)
                } else if (valueHolderForWidthTmpValueForIdx0 instanceof Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForWidthTmpValueForIdx0ForIdx2  = valueHolderForWidthTmpValueForIdx0 as Resource
                    Resource_serializer.write(valueSerializer, valueHolderForWidthTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForWidthTmpValue instanceof EdgeWidths) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForWidthTmpValueForIdx1  = valueHolderForWidthTmpValue as EdgeWidths
                EdgeWidths_serializer.write(valueSerializer, valueHolderForWidthTmpValueForIdx1)
            } else if (valueHolderForWidthTmpValue instanceof LocalizedEdgeWidths) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForWidthTmpValueForIdx2  = valueHolderForWidthTmpValue as LocalizedEdgeWidths
                LocalizedEdgeWidths_serializer.write(valueSerializer, valueHolderForWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOutset  = value.outset
        if (valueHolderForOutset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOutsetTmpValue  = valueHolderForOutset!
            if (valueHolderForOutsetTmpValue instanceof Length) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOutsetTmpValueForIdx0  = valueHolderForOutsetTmpValue as Length
                if (valueHolderForOutsetTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForOutsetTmpValueForIdx0ForIdx0  = valueHolderForOutsetTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForOutsetTmpValueForIdx0ForIdx0)
                } else if (valueHolderForOutsetTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForOutsetTmpValueForIdx0ForIdx1  = valueHolderForOutsetTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForOutsetTmpValueForIdx0ForIdx1)
                } else if (valueHolderForOutsetTmpValueForIdx0 instanceof Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForOutsetTmpValueForIdx0ForIdx2  = valueHolderForOutsetTmpValueForIdx0 as Resource
                    Resource_serializer.write(valueSerializer, valueHolderForOutsetTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForOutsetTmpValue instanceof EdgeWidths) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOutsetTmpValueForIdx1  = valueHolderForOutsetTmpValue as EdgeWidths
                EdgeWidths_serializer.write(valueSerializer, valueHolderForOutsetTmpValueForIdx1)
            } else if (valueHolderForOutsetTmpValue instanceof LocalizedEdgeWidths) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForOutsetTmpValueForIdx2  = valueHolderForOutsetTmpValue as LocalizedEdgeWidths
                LocalizedEdgeWidths_serializer.write(valueSerializer, valueHolderForOutsetTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFill  = value.fill
        if (valueHolderForFill !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFillTmpValue  = valueHolderForFill!
            valueSerializer.writeBoolean(valueHolderForFillTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): BorderImageOption {
        let valueDeserializer : DeserializerBase = buffer
        const sliceTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let sliceTmpBuf : Length | EdgeWidths | LocalizedEdgeWidths | undefined = undefined
        if ((sliceTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const sliceTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let sliceTmpBuf_ : Length | EdgeWidths | LocalizedEdgeWidths | undefined
            if (sliceTmpBuf_UnionSelector == (0).toChar()) {
                const sliceTmpBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                let sliceTmpBuf_BufU : string | number | Resource | undefined
                if (sliceTmpBuf_BufUUnionSelector == (0).toChar()) {
                    sliceTmpBuf_BufU = (valueDeserializer.readString() as string)
                } else if (sliceTmpBuf_BufUUnionSelector == (1).toChar()) {
                    sliceTmpBuf_BufU = (valueDeserializer.readNumber() as number)
                } else if (sliceTmpBuf_BufUUnionSelector == (2).toChar()) {
                    sliceTmpBuf_BufU = Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error("One of the branches for sliceTmpBuf_BufU has to be chosen through deserialisation.")
                }
                sliceTmpBuf_ = (sliceTmpBuf_BufU as string | number | Resource)
            } else if (sliceTmpBuf_UnionSelector == (1).toChar()) {
                sliceTmpBuf_ = EdgeWidths_serializer.read(valueDeserializer)
            } else if (sliceTmpBuf_UnionSelector == (2).toChar()) {
                sliceTmpBuf_ = LocalizedEdgeWidths_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for sliceTmpBuf_ has to be chosen through deserialisation.")
            }
            sliceTmpBuf = (sliceTmpBuf_ as Length | EdgeWidths | LocalizedEdgeWidths)
        }
        const sliceTmpResult : Length | EdgeWidths | LocalizedEdgeWidths | undefined = sliceTmpBuf
        const repeatTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let repeatTmpBuf : RepeatMode | undefined = undefined
        if ((repeatTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            repeatTmpBuf = RepeatMode.fromValue(valueDeserializer.readInt32())
        }
        const repeatTmpResult : RepeatMode | undefined = repeatTmpBuf
        const sourceTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let sourceTmpBuf : string | Resource | LinearGradientOptions | undefined = undefined
        if ((sourceTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const sourceTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let sourceTmpBuf_ : string | Resource | LinearGradientOptions | undefined
            if (sourceTmpBuf_UnionSelector == (0).toChar()) {
                sourceTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (sourceTmpBuf_UnionSelector == (1).toChar()) {
                sourceTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else if (sourceTmpBuf_UnionSelector == (2).toChar()) {
                sourceTmpBuf_ = LinearGradientOptions_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for sourceTmpBuf_ has to be chosen through deserialisation.")
            }
            sourceTmpBuf = (sourceTmpBuf_ as string | Resource | LinearGradientOptions)
        }
        const sourceTmpResult : string | Resource | LinearGradientOptions | undefined = sourceTmpBuf
        const widthTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let widthTmpBuf : Length | EdgeWidths | LocalizedEdgeWidths | undefined = undefined
        if ((widthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const widthTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let widthTmpBuf_ : Length | EdgeWidths | LocalizedEdgeWidths | undefined
            if (widthTmpBuf_UnionSelector == (0).toChar()) {
                const widthTmpBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                let widthTmpBuf_BufU : string | number | Resource | undefined
                if (widthTmpBuf_BufUUnionSelector == (0).toChar()) {
                    widthTmpBuf_BufU = (valueDeserializer.readString() as string)
                } else if (widthTmpBuf_BufUUnionSelector == (1).toChar()) {
                    widthTmpBuf_BufU = (valueDeserializer.readNumber() as number)
                } else if (widthTmpBuf_BufUUnionSelector == (2).toChar()) {
                    widthTmpBuf_BufU = Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error("One of the branches for widthTmpBuf_BufU has to be chosen through deserialisation.")
                }
                widthTmpBuf_ = (widthTmpBuf_BufU as string | number | Resource)
            } else if (widthTmpBuf_UnionSelector == (1).toChar()) {
                widthTmpBuf_ = EdgeWidths_serializer.read(valueDeserializer)
            } else if (widthTmpBuf_UnionSelector == (2).toChar()) {
                widthTmpBuf_ = LocalizedEdgeWidths_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for widthTmpBuf_ has to be chosen through deserialisation.")
            }
            widthTmpBuf = (widthTmpBuf_ as Length | EdgeWidths | LocalizedEdgeWidths)
        }
        const widthTmpResult : Length | EdgeWidths | LocalizedEdgeWidths | undefined = widthTmpBuf
        const outsetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let outsetTmpBuf : Length | EdgeWidths | LocalizedEdgeWidths | undefined = undefined
        if ((outsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const outsetTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let outsetTmpBuf_ : Length | EdgeWidths | LocalizedEdgeWidths | undefined
            if (outsetTmpBuf_UnionSelector == (0).toChar()) {
                const outsetTmpBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                let outsetTmpBuf_BufU : string | number | Resource | undefined
                if (outsetTmpBuf_BufUUnionSelector == (0).toChar()) {
                    outsetTmpBuf_BufU = (valueDeserializer.readString() as string)
                } else if (outsetTmpBuf_BufUUnionSelector == (1).toChar()) {
                    outsetTmpBuf_BufU = (valueDeserializer.readNumber() as number)
                } else if (outsetTmpBuf_BufUUnionSelector == (2).toChar()) {
                    outsetTmpBuf_BufU = Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error("One of the branches for outsetTmpBuf_BufU has to be chosen through deserialisation.")
                }
                outsetTmpBuf_ = (outsetTmpBuf_BufU as string | number | Resource)
            } else if (outsetTmpBuf_UnionSelector == (1).toChar()) {
                outsetTmpBuf_ = EdgeWidths_serializer.read(valueDeserializer)
            } else if (outsetTmpBuf_UnionSelector == (2).toChar()) {
                outsetTmpBuf_ = LocalizedEdgeWidths_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for outsetTmpBuf_ has to be chosen through deserialisation.")
            }
            outsetTmpBuf = (outsetTmpBuf_ as Length | EdgeWidths | LocalizedEdgeWidths)
        }
        const outsetTmpResult : Length | EdgeWidths | LocalizedEdgeWidths | undefined = outsetTmpBuf
        const fillTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fillTmpBuf : boolean | undefined = undefined
        if ((fillTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            fillTmpBuf = valueDeserializer.readBoolean()
        }
        const fillTmpResult : boolean | undefined = fillTmpBuf
        let value : BorderImageOption = ({slice: sliceTmpResult, repeat: repeatTmpResult, source: sourceTmpResult, width: widthTmpResult, outset: outsetTmpResult, fill: fillTmpResult} as BorderImageOption)
        return value
    }
}
export class ContextMenuOptions_serializer {
    public static write(buffer: SerializerBase, value: ContextMenuOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForOffset  = value.offset
        if (valueHolderForOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetTmpValue  = valueHolderForOffset!
            Position_serializer.write(valueSerializer, valueHolderForOffsetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPlacement  = value.placement
        if (valueHolderForPlacement !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPlacementTmpValue  = (valueHolderForPlacement as Placement)
            valueSerializer.writeInt32(valueHolderForPlacementTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableArrow  = value.enableArrow
        if (valueHolderForEnableArrow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableArrowTmpValue  = valueHolderForEnableArrow!
            valueSerializer.writeBoolean(valueHolderForEnableArrowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowOffset  = value.arrowOffset
        if (valueHolderForArrowOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowOffsetTmpValue  = valueHolderForArrowOffset!
            if (valueHolderForArrowOffsetTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx0  = valueHolderForArrowOffsetTmpValue as string
                valueSerializer.writeString(valueHolderForArrowOffsetTmpValueForIdx0)
            } else if (valueHolderForArrowOffsetTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx1  = valueHolderForArrowOffsetTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowOffsetTmpValueForIdx1)
            } else if (valueHolderForArrowOffsetTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx2  = valueHolderForArrowOffsetTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForArrowOffsetTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPreview  = value.preview
        if (valueHolderForPreview !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPreviewTmpValue  = valueHolderForPreview!
            if (valueHolderForPreviewTmpValue instanceof MenuPreviewMode) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForPreviewTmpValueForIdx0  = valueHolderForPreviewTmpValue as MenuPreviewMode
                valueSerializer.writeInt32(valueHolderForPreviewTmpValueForIdx0.valueOf())
            } else if (valueHolderForPreviewTmpValue instanceof CustomBuilder) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForPreviewTmpValueForIdx1  = valueHolderForPreviewTmpValue as CustomBuilder
                valueSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(valueHolderForPreviewTmpValueForIdx1))
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPreviewBorderRadius  = value.previewBorderRadius
        if (valueHolderForPreviewBorderRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPreviewBorderRadiusTmpValue  = valueHolderForPreviewBorderRadius!
            if (valueHolderForPreviewBorderRadiusTmpValue instanceof Length) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForPreviewBorderRadiusTmpValueForIdx0  = valueHolderForPreviewBorderRadiusTmpValue as Length
                if (valueHolderForPreviewBorderRadiusTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx0  = valueHolderForPreviewBorderRadiusTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx0)
                } else if (valueHolderForPreviewBorderRadiusTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx1  = valueHolderForPreviewBorderRadiusTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx1)
                } else if (valueHolderForPreviewBorderRadiusTmpValueForIdx0 instanceof Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx2  = valueHolderForPreviewBorderRadiusTmpValueForIdx0 as Resource
                    Resource_serializer.write(valueSerializer, valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForPreviewBorderRadiusTmpValue instanceof BorderRadiuses) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForPreviewBorderRadiusTmpValueForIdx1  = valueHolderForPreviewBorderRadiusTmpValue as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, valueHolderForPreviewBorderRadiusTmpValueForIdx1)
            } else if (valueHolderForPreviewBorderRadiusTmpValue instanceof LocalizedBorderRadiuses) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForPreviewBorderRadiusTmpValueForIdx2  = valueHolderForPreviewBorderRadiusTmpValue as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(valueSerializer, valueHolderForPreviewBorderRadiusTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBorderRadius  = value.borderRadius
        if (valueHolderForBorderRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBorderRadiusTmpValue  = valueHolderForBorderRadius!
            if (valueHolderForBorderRadiusTmpValue instanceof Length) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBorderRadiusTmpValueForIdx0  = valueHolderForBorderRadiusTmpValue as Length
                if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx0  = valueHolderForBorderRadiusTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForBorderRadiusTmpValueForIdx0ForIdx0)
                } else if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx1  = valueHolderForBorderRadiusTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForBorderRadiusTmpValueForIdx0ForIdx1)
                } else if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx2  = valueHolderForBorderRadiusTmpValueForIdx0 as Resource
                    Resource_serializer.write(valueSerializer, valueHolderForBorderRadiusTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForBorderRadiusTmpValue instanceof BorderRadiuses) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBorderRadiusTmpValueForIdx1  = valueHolderForBorderRadiusTmpValue as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, valueHolderForBorderRadiusTmpValueForIdx1)
            } else if (valueHolderForBorderRadiusTmpValue instanceof LocalizedBorderRadiuses) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBorderRadiusTmpValueForIdx2  = valueHolderForBorderRadiusTmpValue as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(valueSerializer, valueHolderForBorderRadiusTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnAppear  = value.onAppear
        if (valueHolderForOnAppear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnAppearTmpValue  = valueHolderForOnAppear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnAppearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnDisappear  = value.onDisappear
        if (valueHolderForOnDisappear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnDisappearTmpValue  = valueHolderForOnDisappear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnDisappearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAboutToAppear  = value.aboutToAppear
        if (valueHolderForAboutToAppear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAboutToAppearTmpValue  = valueHolderForAboutToAppear!
            valueSerializer.holdAndWriteCallback(valueHolderForAboutToAppearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAboutToDisappear  = value.aboutToDisappear
        if (valueHolderForAboutToDisappear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAboutToDisappearTmpValue  = valueHolderForAboutToDisappear!
            valueSerializer.holdAndWriteCallback(valueHolderForAboutToDisappearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForLayoutRegionMargin  = value.layoutRegionMargin
        if (valueHolderForLayoutRegionMargin !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForLayoutRegionMarginTmpValue  = valueHolderForLayoutRegionMargin!
            Padding_serializer.write(valueSerializer, valueHolderForLayoutRegionMarginTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPreviewAnimationOptions  = value.previewAnimationOptions
        if (valueHolderForPreviewAnimationOptions !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPreviewAnimationOptionsTmpValue  = valueHolderForPreviewAnimationOptions!
            ContextMenuAnimationOptions_serializer.write(valueSerializer, valueHolderForPreviewAnimationOptionsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundColor  = value.backgroundColor
        if (valueHolderForBackgroundColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundColorTmpValue  = valueHolderForBackgroundColor!
            if (valueHolderForBackgroundColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx0  = valueHolderForBackgroundColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForBackgroundColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForBackgroundColorTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx1  = valueHolderForBackgroundColorTmpValue as number
                valueSerializer.writeNumber(valueHolderForBackgroundColorTmpValueForIdx1)
            } else if (valueHolderForBackgroundColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx2  = valueHolderForBackgroundColorTmpValue as string
                valueSerializer.writeString(valueHolderForBackgroundColorTmpValueForIdx2)
            } else if (valueHolderForBackgroundColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx3  = valueHolderForBackgroundColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForBackgroundColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundBlurStyle  = value.backgroundBlurStyle
        if (valueHolderForBackgroundBlurStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundBlurStyleTmpValue  = (valueHolderForBackgroundBlurStyle as BlurStyle)
            valueSerializer.writeInt32(valueHolderForBackgroundBlurStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundBlurStyleOptions  = value.backgroundBlurStyleOptions
        if (valueHolderForBackgroundBlurStyleOptions !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundBlurStyleOptionsTmpValue  = valueHolderForBackgroundBlurStyleOptions!
            BackgroundBlurStyleOptions_serializer.write(valueSerializer, valueHolderForBackgroundBlurStyleOptionsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundEffect  = value.backgroundEffect
        if (valueHolderForBackgroundEffect !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundEffectTmpValue  = valueHolderForBackgroundEffect!
            BackgroundEffectOptions_serializer.write(valueSerializer, valueHolderForBackgroundEffectTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTransition  = value.transition
        if (valueHolderForTransition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTransitionTmpValue  = valueHolderForTransition!
            TransitionEffect_serializer.write(valueSerializer, valueHolderForTransitionTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableHoverMode  = value.enableHoverMode
        if (valueHolderForEnableHoverMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableHoverModeTmpValue  = valueHolderForEnableHoverMode!
            valueSerializer.writeBoolean(valueHolderForEnableHoverModeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOutlineColor  = value.outlineColor
        if (valueHolderForOutlineColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOutlineColorTmpValue  = valueHolderForOutlineColor!
            if (valueHolderForOutlineColorTmpValue instanceof ResourceColor) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOutlineColorTmpValueForIdx0  = valueHolderForOutlineColorTmpValue as ResourceColor
                if (valueHolderForOutlineColorTmpValueForIdx0 instanceof Color) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForOutlineColorTmpValueForIdx0ForIdx0  = valueHolderForOutlineColorTmpValueForIdx0 as Color
                    valueSerializer.writeInt32(valueHolderForOutlineColorTmpValueForIdx0ForIdx0.getOrdinal())
                } else if (valueHolderForOutlineColorTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForOutlineColorTmpValueForIdx0ForIdx1  = valueHolderForOutlineColorTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForOutlineColorTmpValueForIdx0ForIdx1)
                } else if (valueHolderForOutlineColorTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForOutlineColorTmpValueForIdx0ForIdx2  = valueHolderForOutlineColorTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForOutlineColorTmpValueForIdx0ForIdx2)
                } else if (valueHolderForOutlineColorTmpValueForIdx0 instanceof Resource) {
                    valueSerializer.writeInt8((3).toByte())
                    const valueHolderForOutlineColorTmpValueForIdx0ForIdx3  = valueHolderForOutlineColorTmpValueForIdx0 as Resource
                    Resource_serializer.write(valueSerializer, valueHolderForOutlineColorTmpValueForIdx0ForIdx3)
                }
            } else if (valueHolderForOutlineColorTmpValue instanceof EdgeColors) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOutlineColorTmpValueForIdx1  = valueHolderForOutlineColorTmpValue as EdgeColors
                EdgeColors_serializer.write(valueSerializer, valueHolderForOutlineColorTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOutlineWidth  = value.outlineWidth
        if (valueHolderForOutlineWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOutlineWidthTmpValue  = valueHolderForOutlineWidth!
            if (valueHolderForOutlineWidthTmpValue instanceof Dimension) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOutlineWidthTmpValueForIdx0  = valueHolderForOutlineWidthTmpValue as Dimension
                if (valueHolderForOutlineWidthTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForOutlineWidthTmpValueForIdx0ForIdx0  = valueHolderForOutlineWidthTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForOutlineWidthTmpValueForIdx0ForIdx0)
                } else if (valueHolderForOutlineWidthTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForOutlineWidthTmpValueForIdx0ForIdx1  = valueHolderForOutlineWidthTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForOutlineWidthTmpValueForIdx0ForIdx1)
                } else if (valueHolderForOutlineWidthTmpValueForIdx0 instanceof Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForOutlineWidthTmpValueForIdx0ForIdx2  = valueHolderForOutlineWidthTmpValueForIdx0 as Resource
                    Resource_serializer.write(valueSerializer, valueHolderForOutlineWidthTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForOutlineWidthTmpValue instanceof EdgeOutlineWidths) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOutlineWidthTmpValueForIdx1  = valueHolderForOutlineWidthTmpValue as EdgeOutlineWidths
                EdgeOutlineWidths_serializer.write(valueSerializer, valueHolderForOutlineWidthTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHapticFeedbackMode  = value.hapticFeedbackMode
        if (valueHolderForHapticFeedbackMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHapticFeedbackModeTmpValue  = (valueHolderForHapticFeedbackMode as HapticFeedbackMode)
            valueSerializer.writeInt32(valueHolderForHapticFeedbackModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): ContextMenuOptions {
        let valueDeserializer : DeserializerBase = buffer
        const offsetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offsetTmpBuf : Position | undefined = undefined
        if ((offsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            offsetTmpBuf = Position_serializer.read(valueDeserializer)
        }
        const offsetTmpResult : Position | undefined = offsetTmpBuf
        const placementTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let placementTmpBuf : Placement | undefined = undefined
        if ((placementTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            placementTmpBuf = Placement.fromValue(valueDeserializer.readInt32())
        }
        const placementTmpResult : Placement | undefined = placementTmpBuf
        const enableArrowTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableArrowTmpBuf : boolean | undefined = undefined
        if ((enableArrowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableArrowTmpBuf = valueDeserializer.readBoolean()
        }
        const enableArrowTmpResult : boolean | undefined = enableArrowTmpBuf
        const arrowOffsetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowOffsetTmpBuf : Length | undefined = undefined
        if ((arrowOffsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowOffsetTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let arrowOffsetTmpBuf_ : string | number | Resource | undefined
            if (arrowOffsetTmpBuf_UnionSelector == (0).toChar()) {
                arrowOffsetTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (arrowOffsetTmpBuf_UnionSelector == (1).toChar()) {
                arrowOffsetTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (arrowOffsetTmpBuf_UnionSelector == (2).toChar()) {
                arrowOffsetTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for arrowOffsetTmpBuf_ has to be chosen through deserialisation.")
            }
            arrowOffsetTmpBuf = (arrowOffsetTmpBuf_ as string | number | Resource)
        }
        const arrowOffsetTmpResult : Length | undefined = arrowOffsetTmpBuf
        const previewTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let previewTmpBuf : MenuPreviewMode | CustomBuilder | undefined = undefined
        if ((previewTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const previewTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let previewTmpBuf_ : MenuPreviewMode | CustomBuilder | undefined
            if (previewTmpBuf_UnionSelector == (0).toChar()) {
                previewTmpBuf_ = MenuPreviewMode.fromValue(valueDeserializer.readInt32())
            } else if (previewTmpBuf_UnionSelector == (1).toChar()) {
                const previewTmpBuf_BufUBufResource : CallbackResource = valueDeserializer.readCallbackResource()
                const previewTmpBuf_BufUBufCall : KPointer = valueDeserializer.readPointer()
                const previewTmpBuf_BufUBufCallSync : KPointer = valueDeserializer.readPointer()
                previewTmpBuf_ = ():void => {
                    const previewTmpBuf_BufUBufArgsSerializer : SerializerBase = SerializerBase.hold();
                    previewTmpBuf_BufUBufArgsSerializer.writeInt32(previewTmpBuf_BufUBufResource.resourceId);
                    previewTmpBuf_BufUBufArgsSerializer.writePointer(previewTmpBuf_BufUBufCall);
                    previewTmpBuf_BufUBufArgsSerializer.writePointer(previewTmpBuf_BufUBufCallSync);
                    InteropNativeModule._CallCallbackSync(10, 737226752, previewTmpBuf_BufUBufArgsSerializer.asBuffer(), previewTmpBuf_BufUBufArgsSerializer.length());
                    previewTmpBuf_BufUBufArgsSerializer.release();
                    return;
                }
            } else {
                throw new Error("One of the branches for previewTmpBuf_ has to be chosen through deserialisation.")
            }
            previewTmpBuf = (previewTmpBuf_ as MenuPreviewMode | CustomBuilder)
        }
        const previewTmpResult : MenuPreviewMode | CustomBuilder | undefined = previewTmpBuf
        const previewBorderRadiusTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let previewBorderRadiusTmpBuf : BorderRadiusType | undefined = undefined
        if ((previewBorderRadiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const previewBorderRadiusTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let previewBorderRadiusTmpBuf_ : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined
            if (previewBorderRadiusTmpBuf_UnionSelector == (0).toChar()) {
                const previewBorderRadiusTmpBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                let previewBorderRadiusTmpBuf_BufU : string | number | Resource | undefined
                if (previewBorderRadiusTmpBuf_BufUUnionSelector == (0).toChar()) {
                    previewBorderRadiusTmpBuf_BufU = (valueDeserializer.readString() as string)
                } else if (previewBorderRadiusTmpBuf_BufUUnionSelector == (1).toChar()) {
                    previewBorderRadiusTmpBuf_BufU = (valueDeserializer.readNumber() as number)
                } else if (previewBorderRadiusTmpBuf_BufUUnionSelector == (2).toChar()) {
                    previewBorderRadiusTmpBuf_BufU = Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error("One of the branches for previewBorderRadiusTmpBuf_BufU has to be chosen through deserialisation.")
                }
                previewBorderRadiusTmpBuf_ = (previewBorderRadiusTmpBuf_BufU as string | number | Resource)
            } else if (previewBorderRadiusTmpBuf_UnionSelector == (1).toChar()) {
                previewBorderRadiusTmpBuf_ = BorderRadiuses_serializer.read(valueDeserializer)
            } else if (previewBorderRadiusTmpBuf_UnionSelector == (2).toChar()) {
                previewBorderRadiusTmpBuf_ = LocalizedBorderRadiuses_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for previewBorderRadiusTmpBuf_ has to be chosen through deserialisation.")
            }
            previewBorderRadiusTmpBuf = (previewBorderRadiusTmpBuf_ as Length | BorderRadiuses | LocalizedBorderRadiuses)
        }
        const previewBorderRadiusTmpResult : BorderRadiusType | undefined = previewBorderRadiusTmpBuf
        const borderRadiusTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let borderRadiusTmpBuf : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined = undefined
        if ((borderRadiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const borderRadiusTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let borderRadiusTmpBuf_ : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined
            if (borderRadiusTmpBuf_UnionSelector == (0).toChar()) {
                const borderRadiusTmpBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                let borderRadiusTmpBuf_BufU : string | number | Resource | undefined
                if (borderRadiusTmpBuf_BufUUnionSelector == (0).toChar()) {
                    borderRadiusTmpBuf_BufU = (valueDeserializer.readString() as string)
                } else if (borderRadiusTmpBuf_BufUUnionSelector == (1).toChar()) {
                    borderRadiusTmpBuf_BufU = (valueDeserializer.readNumber() as number)
                } else if (borderRadiusTmpBuf_BufUUnionSelector == (2).toChar()) {
                    borderRadiusTmpBuf_BufU = Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error("One of the branches for borderRadiusTmpBuf_BufU has to be chosen through deserialisation.")
                }
                borderRadiusTmpBuf_ = (borderRadiusTmpBuf_BufU as string | number | Resource)
            } else if (borderRadiusTmpBuf_UnionSelector == (1).toChar()) {
                borderRadiusTmpBuf_ = BorderRadiuses_serializer.read(valueDeserializer)
            } else if (borderRadiusTmpBuf_UnionSelector == (2).toChar()) {
                borderRadiusTmpBuf_ = LocalizedBorderRadiuses_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for borderRadiusTmpBuf_ has to be chosen through deserialisation.")
            }
            borderRadiusTmpBuf = (borderRadiusTmpBuf_ as Length | BorderRadiuses | LocalizedBorderRadiuses)
        }
        const borderRadiusTmpResult : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined = borderRadiusTmpBuf
        const onAppearTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onAppearTmpBuf : (() => void) | undefined = undefined
        if ((onAppearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onAppearTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onAppearTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onAppearTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onAppearTmpBuf = ():void => {
                const onAppearTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onAppearTmpBuf_BufArgsSerializer.writeInt32(onAppearTmpBuf_BufResource.resourceId);
                onAppearTmpBuf_BufArgsSerializer.writePointer(onAppearTmpBuf_BufCall);
                onAppearTmpBuf_BufArgsSerializer.writePointer(onAppearTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, onAppearTmpBuf_BufArgsSerializer.asBuffer(), onAppearTmpBuf_BufArgsSerializer.length());
                onAppearTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onAppearTmpResult : (() => void) | undefined = onAppearTmpBuf
        const onDisappearTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onDisappearTmpBuf : (() => void) | undefined = undefined
        if ((onDisappearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onDisappearTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDisappearTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onDisappearTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onDisappearTmpBuf = ():void => {
                const onDisappearTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onDisappearTmpBuf_BufArgsSerializer.writeInt32(onDisappearTmpBuf_BufResource.resourceId);
                onDisappearTmpBuf_BufArgsSerializer.writePointer(onDisappearTmpBuf_BufCall);
                onDisappearTmpBuf_BufArgsSerializer.writePointer(onDisappearTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, onDisappearTmpBuf_BufArgsSerializer.asBuffer(), onDisappearTmpBuf_BufArgsSerializer.length());
                onDisappearTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onDisappearTmpResult : (() => void) | undefined = onDisappearTmpBuf
        const aboutToAppearTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let aboutToAppearTmpBuf : (() => void) | undefined = undefined
        if ((aboutToAppearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const aboutToAppearTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const aboutToAppearTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const aboutToAppearTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            aboutToAppearTmpBuf = ():void => {
                const aboutToAppearTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                aboutToAppearTmpBuf_BufArgsSerializer.writeInt32(aboutToAppearTmpBuf_BufResource.resourceId);
                aboutToAppearTmpBuf_BufArgsSerializer.writePointer(aboutToAppearTmpBuf_BufCall);
                aboutToAppearTmpBuf_BufArgsSerializer.writePointer(aboutToAppearTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, aboutToAppearTmpBuf_BufArgsSerializer.asBuffer(), aboutToAppearTmpBuf_BufArgsSerializer.length());
                aboutToAppearTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const aboutToAppearTmpResult : (() => void) | undefined = aboutToAppearTmpBuf
        const aboutToDisappearTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let aboutToDisappearTmpBuf : (() => void) | undefined = undefined
        if ((aboutToDisappearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const aboutToDisappearTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const aboutToDisappearTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const aboutToDisappearTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            aboutToDisappearTmpBuf = ():void => {
                const aboutToDisappearTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                aboutToDisappearTmpBuf_BufArgsSerializer.writeInt32(aboutToDisappearTmpBuf_BufResource.resourceId);
                aboutToDisappearTmpBuf_BufArgsSerializer.writePointer(aboutToDisappearTmpBuf_BufCall);
                aboutToDisappearTmpBuf_BufArgsSerializer.writePointer(aboutToDisappearTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, aboutToDisappearTmpBuf_BufArgsSerializer.asBuffer(), aboutToDisappearTmpBuf_BufArgsSerializer.length());
                aboutToDisappearTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const aboutToDisappearTmpResult : (() => void) | undefined = aboutToDisappearTmpBuf
        const layoutRegionMarginTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let layoutRegionMarginTmpBuf : Padding | undefined = undefined
        if ((layoutRegionMarginTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            layoutRegionMarginTmpBuf = Padding_serializer.read(valueDeserializer)
        }
        const layoutRegionMarginTmpResult : Padding | undefined = layoutRegionMarginTmpBuf
        const previewAnimationOptionsTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let previewAnimationOptionsTmpBuf : ContextMenuAnimationOptions | undefined = undefined
        if ((previewAnimationOptionsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            previewAnimationOptionsTmpBuf = ContextMenuAnimationOptions_serializer.read(valueDeserializer)
        }
        const previewAnimationOptionsTmpResult : ContextMenuAnimationOptions | undefined = previewAnimationOptionsTmpBuf
        const backgroundColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundColorTmpBuf : ResourceColor | undefined = undefined
        if ((backgroundColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const backgroundColorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let backgroundColorTmpBuf_ : Color | number | string | Resource | undefined
            if (backgroundColorTmpBuf_UnionSelector == (0).toChar()) {
                backgroundColorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (backgroundColorTmpBuf_UnionSelector == (1).toChar()) {
                backgroundColorTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (backgroundColorTmpBuf_UnionSelector == (2).toChar()) {
                backgroundColorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (backgroundColorTmpBuf_UnionSelector == (3).toChar()) {
                backgroundColorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for backgroundColorTmpBuf_ has to be chosen through deserialisation.")
            }
            backgroundColorTmpBuf = (backgroundColorTmpBuf_ as Color | number | string | Resource)
        }
        const backgroundColorTmpResult : ResourceColor | undefined = backgroundColorTmpBuf
        const backgroundBlurStyleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundBlurStyleTmpBuf : BlurStyle | undefined = undefined
        if ((backgroundBlurStyleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundBlurStyleTmpBuf = BlurStyle.fromValue(valueDeserializer.readInt32())
        }
        const backgroundBlurStyleTmpResult : BlurStyle | undefined = backgroundBlurStyleTmpBuf
        const backgroundBlurStyleOptionsTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundBlurStyleOptionsTmpBuf : BackgroundBlurStyleOptions | undefined = undefined
        if ((backgroundBlurStyleOptionsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundBlurStyleOptionsTmpBuf = BackgroundBlurStyleOptions_serializer.read(valueDeserializer)
        }
        const backgroundBlurStyleOptionsTmpResult : BackgroundBlurStyleOptions | undefined = backgroundBlurStyleOptionsTmpBuf
        const backgroundEffectTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundEffectTmpBuf : BackgroundEffectOptions | undefined = undefined
        if ((backgroundEffectTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundEffectTmpBuf = BackgroundEffectOptions_serializer.read(valueDeserializer)
        }
        const backgroundEffectTmpResult : BackgroundEffectOptions | undefined = backgroundEffectTmpBuf
        const transitionTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let transitionTmpBuf : TransitionEffect | undefined = undefined
        if ((transitionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            transitionTmpBuf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transitionTmpResult : TransitionEffect | undefined = transitionTmpBuf
        const enableHoverModeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableHoverModeTmpBuf : boolean | undefined = undefined
        if ((enableHoverModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableHoverModeTmpBuf = valueDeserializer.readBoolean()
        }
        const enableHoverModeTmpResult : boolean | undefined = enableHoverModeTmpBuf
        const outlineColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let outlineColorTmpBuf : ResourceColor | EdgeColors | undefined = undefined
        if ((outlineColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const outlineColorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let outlineColorTmpBuf_ : ResourceColor | EdgeColors | undefined
            if (outlineColorTmpBuf_UnionSelector == (0).toChar()) {
                const outlineColorTmpBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                let outlineColorTmpBuf_BufU : Color | number | string | Resource | undefined
                if (outlineColorTmpBuf_BufUUnionSelector == (0).toChar()) {
                    outlineColorTmpBuf_BufU = Color.values()[valueDeserializer.readInt32()]
                } else if (outlineColorTmpBuf_BufUUnionSelector == (1).toChar()) {
                    outlineColorTmpBuf_BufU = (valueDeserializer.readNumber() as number)
                } else if (outlineColorTmpBuf_BufUUnionSelector == (2).toChar()) {
                    outlineColorTmpBuf_BufU = (valueDeserializer.readString() as string)
                } else if (outlineColorTmpBuf_BufUUnionSelector == (3).toChar()) {
                    outlineColorTmpBuf_BufU = Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error("One of the branches for outlineColorTmpBuf_BufU has to be chosen through deserialisation.")
                }
                outlineColorTmpBuf_ = (outlineColorTmpBuf_BufU as Color | number | string | Resource)
            } else if (outlineColorTmpBuf_UnionSelector == (1).toChar()) {
                outlineColorTmpBuf_ = EdgeColors_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for outlineColorTmpBuf_ has to be chosen through deserialisation.")
            }
            outlineColorTmpBuf = (outlineColorTmpBuf_ as ResourceColor | EdgeColors)
        }
        const outlineColorTmpResult : ResourceColor | EdgeColors | undefined = outlineColorTmpBuf
        const outlineWidthTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let outlineWidthTmpBuf : Dimension | EdgeOutlineWidths | undefined = undefined
        if ((outlineWidthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const outlineWidthTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let outlineWidthTmpBuf_ : Dimension | EdgeOutlineWidths | undefined
            if (outlineWidthTmpBuf_UnionSelector == (0).toChar()) {
                const outlineWidthTmpBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                let outlineWidthTmpBuf_BufU : string | number | Resource | undefined
                if (outlineWidthTmpBuf_BufUUnionSelector == (0).toChar()) {
                    outlineWidthTmpBuf_BufU = (valueDeserializer.readString() as string)
                } else if (outlineWidthTmpBuf_BufUUnionSelector == (1).toChar()) {
                    outlineWidthTmpBuf_BufU = (valueDeserializer.readNumber() as number)
                } else if (outlineWidthTmpBuf_BufUUnionSelector == (2).toChar()) {
                    outlineWidthTmpBuf_BufU = Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error("One of the branches for outlineWidthTmpBuf_BufU has to be chosen through deserialisation.")
                }
                outlineWidthTmpBuf_ = (outlineWidthTmpBuf_BufU as string | number | Resource)
            } else if (outlineWidthTmpBuf_UnionSelector == (1).toChar()) {
                outlineWidthTmpBuf_ = EdgeOutlineWidths_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for outlineWidthTmpBuf_ has to be chosen through deserialisation.")
            }
            outlineWidthTmpBuf = (outlineWidthTmpBuf_ as Dimension | EdgeOutlineWidths)
        }
        const outlineWidthTmpResult : Dimension | EdgeOutlineWidths | undefined = outlineWidthTmpBuf
        const hapticFeedbackModeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let hapticFeedbackModeTmpBuf : HapticFeedbackMode | undefined = undefined
        if ((hapticFeedbackModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            hapticFeedbackModeTmpBuf = HapticFeedbackMode.fromValue(valueDeserializer.readInt32())
        }
        const hapticFeedbackModeTmpResult : HapticFeedbackMode | undefined = hapticFeedbackModeTmpBuf
        let value : ContextMenuOptions = ({offset: offsetTmpResult, placement: placementTmpResult, enableArrow: enableArrowTmpResult, arrowOffset: arrowOffsetTmpResult, preview: previewTmpResult, previewBorderRadius: previewBorderRadiusTmpResult, borderRadius: borderRadiusTmpResult, onAppear: onAppearTmpResult, onDisappear: onDisappearTmpResult, aboutToAppear: aboutToAppearTmpResult, aboutToDisappear: aboutToDisappearTmpResult, layoutRegionMargin: layoutRegionMarginTmpResult, previewAnimationOptions: previewAnimationOptionsTmpResult, backgroundColor: backgroundColorTmpResult, backgroundBlurStyle: backgroundBlurStyleTmpResult, backgroundBlurStyleOptions: backgroundBlurStyleOptionsTmpResult, backgroundEffect: backgroundEffectTmpResult, transition: transitionTmpResult, enableHoverMode: enableHoverModeTmpResult, outlineColor: outlineColorTmpResult, outlineWidth: outlineWidthTmpResult, hapticFeedbackMode: hapticFeedbackModeTmpResult} as ContextMenuOptions)
        return value
    }
}
export class CustomPopupOptions_serializer {
    public static write(buffer: SerializerBase, value: CustomPopupOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForBuilder  = value.builder
        valueSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(valueHolderForBuilder))
        const valueHolderForPlacement  = value.placement
        if (valueHolderForPlacement !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPlacementTmpValue  = (valueHolderForPlacement as Placement)
            valueSerializer.writeInt32(valueHolderForPlacementTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPopupColor  = value.popupColor
        if (valueHolderForPopupColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPopupColorTmpValue  = valueHolderForPopupColor!
            if (valueHolderForPopupColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForPopupColorTmpValueForIdx0  = valueHolderForPopupColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForPopupColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForPopupColorTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForPopupColorTmpValueForIdx1  = valueHolderForPopupColorTmpValue as string
                valueSerializer.writeString(valueHolderForPopupColorTmpValueForIdx1)
            } else if (valueHolderForPopupColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForPopupColorTmpValueForIdx2  = valueHolderForPopupColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForPopupColorTmpValueForIdx2)
            } else if (valueHolderForPopupColorTmpValue instanceof int64) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForPopupColorTmpValueForIdx3  = valueHolderForPopupColorTmpValue as int64
                valueSerializer.writeInt64(valueHolderForPopupColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableArrow  = value.enableArrow
        if (valueHolderForEnableArrow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableArrowTmpValue  = valueHolderForEnableArrow!
            valueSerializer.writeBoolean(valueHolderForEnableArrowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAutoCancel  = value.autoCancel
        if (valueHolderForAutoCancel !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAutoCancelTmpValue  = valueHolderForAutoCancel!
            valueSerializer.writeBoolean(valueHolderForAutoCancelTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnStateChange  = value.onStateChange
        if (valueHolderForOnStateChange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnStateChangeTmpValue  = valueHolderForOnStateChange!
            valueSerializer.holdAndWriteCallback(valueHolderForOnStateChangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowOffset  = value.arrowOffset
        if (valueHolderForArrowOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowOffsetTmpValue  = valueHolderForArrowOffset!
            if (valueHolderForArrowOffsetTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx0  = valueHolderForArrowOffsetTmpValue as string
                valueSerializer.writeString(valueHolderForArrowOffsetTmpValueForIdx0)
            } else if (valueHolderForArrowOffsetTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx1  = valueHolderForArrowOffsetTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowOffsetTmpValueForIdx1)
            } else if (valueHolderForArrowOffsetTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx2  = valueHolderForArrowOffsetTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForArrowOffsetTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShowInSubWindow  = value.showInSubWindow
        if (valueHolderForShowInSubWindow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShowInSubWindowTmpValue  = valueHolderForShowInSubWindow!
            valueSerializer.writeBoolean(valueHolderForShowInSubWindowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMask  = value.mask
        if (valueHolderForMask !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMaskTmpValue  = valueHolderForMask!
            if (valueHolderForMaskTmpValue instanceof boolean) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForMaskTmpValueForIdx0  = valueHolderForMaskTmpValue as boolean
                valueSerializer.writeBoolean(valueHolderForMaskTmpValueForIdx0)
            } else if (valueHolderForMaskTmpValue instanceof PopupMaskType) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForMaskTmpValueForIdx1  = valueHolderForMaskTmpValue as PopupMaskType
                PopupMaskType_serializer.write(valueSerializer, valueHolderForMaskTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTargetSpace  = value.targetSpace
        if (valueHolderForTargetSpace !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTargetSpaceTmpValue  = valueHolderForTargetSpace!
            if (valueHolderForTargetSpaceTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx0  = valueHolderForTargetSpaceTmpValue as string
                valueSerializer.writeString(valueHolderForTargetSpaceTmpValueForIdx0)
            } else if (valueHolderForTargetSpaceTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx1  = valueHolderForTargetSpaceTmpValue as number
                valueSerializer.writeNumber(valueHolderForTargetSpaceTmpValueForIdx1)
            } else if (valueHolderForTargetSpaceTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx2  = valueHolderForTargetSpaceTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForTargetSpaceTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOffset  = value.offset
        if (valueHolderForOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetTmpValue  = valueHolderForOffset!
            Position_serializer.write(valueSerializer, valueHolderForOffsetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForWidth  = value.width
        if (valueHolderForWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForWidthTmpValue  = valueHolderForWidth!
            if (valueHolderForWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForWidthTmpValueForIdx0  = valueHolderForWidthTmpValue as string
                valueSerializer.writeString(valueHolderForWidthTmpValueForIdx0)
            } else if (valueHolderForWidthTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForWidthTmpValueForIdx1  = valueHolderForWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForWidthTmpValueForIdx1)
            } else if (valueHolderForWidthTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForWidthTmpValueForIdx2  = valueHolderForWidthTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowPointPosition  = value.arrowPointPosition
        if (valueHolderForArrowPointPosition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowPointPositionTmpValue  = (valueHolderForArrowPointPosition as ArrowPointPosition)
            valueSerializer.writeInt32(valueHolderForArrowPointPositionTmpValue.getOrdinal())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowWidth  = value.arrowWidth
        if (valueHolderForArrowWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowWidthTmpValue  = valueHolderForArrowWidth!
            if (valueHolderForArrowWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowWidthTmpValueForIdx0  = valueHolderForArrowWidthTmpValue as string
                valueSerializer.writeString(valueHolderForArrowWidthTmpValueForIdx0)
            } else if (valueHolderForArrowWidthTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowWidthTmpValueForIdx1  = valueHolderForArrowWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowWidthTmpValueForIdx1)
            } else if (valueHolderForArrowWidthTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowWidthTmpValueForIdx2  = valueHolderForArrowWidthTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForArrowWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowHeight  = value.arrowHeight
        if (valueHolderForArrowHeight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowHeightTmpValue  = valueHolderForArrowHeight!
            if (valueHolderForArrowHeightTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowHeightTmpValueForIdx0  = valueHolderForArrowHeightTmpValue as string
                valueSerializer.writeString(valueHolderForArrowHeightTmpValueForIdx0)
            } else if (valueHolderForArrowHeightTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowHeightTmpValueForIdx1  = valueHolderForArrowHeightTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowHeightTmpValueForIdx1)
            } else if (valueHolderForArrowHeightTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowHeightTmpValueForIdx2  = valueHolderForArrowHeightTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForArrowHeightTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRadius  = value.radius
        if (valueHolderForRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRadiusTmpValue  = valueHolderForRadius!
            if (valueHolderForRadiusTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForRadiusTmpValueForIdx0  = valueHolderForRadiusTmpValue as string
                valueSerializer.writeString(valueHolderForRadiusTmpValueForIdx0)
            } else if (valueHolderForRadiusTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForRadiusTmpValueForIdx1  = valueHolderForRadiusTmpValue as number
                valueSerializer.writeNumber(valueHolderForRadiusTmpValueForIdx1)
            } else if (valueHolderForRadiusTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForRadiusTmpValueForIdx2  = valueHolderForRadiusTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForRadiusTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShadow  = value.shadow
        if (valueHolderForShadow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShadowTmpValue  = valueHolderForShadow!
            if (valueHolderForShadowTmpValue instanceof ShadowOptions) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForShadowTmpValueForIdx0  = valueHolderForShadowTmpValue as ShadowOptions
                ShadowOptions_serializer.write(valueSerializer, valueHolderForShadowTmpValueForIdx0)
            } else if (valueHolderForShadowTmpValue instanceof ShadowStyle) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForShadowTmpValueForIdx1  = valueHolderForShadowTmpValue as ShadowStyle
                valueSerializer.writeInt32(valueHolderForShadowTmpValueForIdx1.valueOf())
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundBlurStyle  = value.backgroundBlurStyle
        if (valueHolderForBackgroundBlurStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundBlurStyleTmpValue  = (valueHolderForBackgroundBlurStyle as BlurStyle)
            valueSerializer.writeInt32(valueHolderForBackgroundBlurStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFocusable  = value.focusable
        if (valueHolderForFocusable !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFocusableTmpValue  = valueHolderForFocusable!
            valueSerializer.writeBoolean(valueHolderForFocusableTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTransition  = value.transition
        if (valueHolderForTransition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTransitionTmpValue  = valueHolderForTransition!
            TransitionEffect_serializer.write(valueSerializer, valueHolderForTransitionTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillDismiss  = value.onWillDismiss
        if (valueHolderForOnWillDismiss !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillDismissTmpValue  = valueHolderForOnWillDismiss!
            if (valueHolderForOnWillDismissTmpValue instanceof boolean) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOnWillDismissTmpValueForIdx0  = valueHolderForOnWillDismissTmpValue as boolean
                valueSerializer.writeBoolean(valueHolderForOnWillDismissTmpValueForIdx0)
            } else if (valueHolderForOnWillDismissTmpValue instanceof ((value0: DismissPopupAction) => void)) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOnWillDismissTmpValueForIdx1  = valueHolderForOnWillDismissTmpValue as ((value0: DismissPopupAction) => void)
                valueSerializer.holdAndWriteCallback(valueHolderForOnWillDismissTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableHoverMode  = value.enableHoverMode
        if (valueHolderForEnableHoverMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableHoverModeTmpValue  = valueHolderForEnableHoverMode!
            valueSerializer.writeBoolean(valueHolderForEnableHoverModeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFollowTransformOfTarget  = value.followTransformOfTarget
        if (valueHolderForFollowTransformOfTarget !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFollowTransformOfTargetTmpValue  = valueHolderForFollowTransformOfTarget!
            valueSerializer.writeBoolean(valueHolderForFollowTransformOfTargetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForKeyboardAvoidMode  = value.keyboardAvoidMode
        if (valueHolderForKeyboardAvoidMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForKeyboardAvoidModeTmpValue  = (valueHolderForKeyboardAvoidMode as KeyboardAvoidMode)
            valueSerializer.writeInt32(valueHolderForKeyboardAvoidModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): CustomPopupOptions {
        let valueDeserializer : DeserializerBase = buffer
        const builderTmpBufBufResource : CallbackResource = valueDeserializer.readCallbackResource()
        const builderTmpBufBufCall : KPointer = valueDeserializer.readPointer()
        const builderTmpBufBufCallSync : KPointer = valueDeserializer.readPointer()
        const builderTmpResult : CustomBuilder = ():void => {
            const builderTmpBufBufArgsSerializer : SerializerBase = SerializerBase.hold();
            builderTmpBufBufArgsSerializer.writeInt32(builderTmpBufBufResource.resourceId);
            builderTmpBufBufArgsSerializer.writePointer(builderTmpBufBufCall);
            builderTmpBufBufArgsSerializer.writePointer(builderTmpBufBufCallSync);
            InteropNativeModule._CallCallbackSync(10, 737226752, builderTmpBufBufArgsSerializer.asBuffer(), builderTmpBufBufArgsSerializer.length());
            builderTmpBufBufArgsSerializer.release();
            return;
        }
        const placementTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let placementTmpBuf : Placement | undefined = undefined
        if ((placementTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            placementTmpBuf = Placement.fromValue(valueDeserializer.readInt32())
        }
        const placementTmpResult : Placement | undefined = placementTmpBuf
        const popupColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let popupColorTmpBuf : Color | string | Resource | int64 | undefined = undefined
        if ((popupColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const popupColorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let popupColorTmpBuf_ : Color | string | Resource | int64 | undefined
            if (popupColorTmpBuf_UnionSelector == (0).toChar()) {
                popupColorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (popupColorTmpBuf_UnionSelector == (1).toChar()) {
                popupColorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (popupColorTmpBuf_UnionSelector == (2).toChar()) {
                popupColorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else if (popupColorTmpBuf_UnionSelector == (3).toChar()) {
                popupColorTmpBuf_ = valueDeserializer.readInt64()
            } else {
                throw new Error("One of the branches for popupColorTmpBuf_ has to be chosen through deserialisation.")
            }
            popupColorTmpBuf = (popupColorTmpBuf_ as Color | string | Resource | int64)
        }
        const popupColorTmpResult : Color | string | Resource | int64 | undefined = popupColorTmpBuf
        const enableArrowTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableArrowTmpBuf : boolean | undefined = undefined
        if ((enableArrowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableArrowTmpBuf = valueDeserializer.readBoolean()
        }
        const enableArrowTmpResult : boolean | undefined = enableArrowTmpBuf
        const autoCancelTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let autoCancelTmpBuf : boolean | undefined = undefined
        if ((autoCancelTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            autoCancelTmpBuf = valueDeserializer.readBoolean()
        }
        const autoCancelTmpResult : boolean | undefined = autoCancelTmpBuf
        const onStateChangeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onStateChangeTmpBuf : PopupStateChangeCallback | undefined = undefined
        if ((onStateChangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onStateChangeTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onStateChangeTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onStateChangeTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onStateChangeTmpBuf = (event: PopupStateChangeParam):void => {
                const onStateChangeTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onStateChangeTmpBuf_BufArgsSerializer.writeInt32(onStateChangeTmpBuf_BufResource.resourceId);
                onStateChangeTmpBuf_BufArgsSerializer.writePointer(onStateChangeTmpBuf_BufCall);
                onStateChangeTmpBuf_BufArgsSerializer.writePointer(onStateChangeTmpBuf_BufCallSync);
                PopupStateChangeParam_serializer.write(onStateChangeTmpBuf_BufArgsSerializer, event);
                InteropNativeModule._CallCallbackSync(10, -1444325632, onStateChangeTmpBuf_BufArgsSerializer.asBuffer(), onStateChangeTmpBuf_BufArgsSerializer.length());
                onStateChangeTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onStateChangeTmpResult : PopupStateChangeCallback | undefined = onStateChangeTmpBuf
        const arrowOffsetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowOffsetTmpBuf : Length | undefined = undefined
        if ((arrowOffsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowOffsetTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let arrowOffsetTmpBuf_ : string | number | Resource | undefined
            if (arrowOffsetTmpBuf_UnionSelector == (0).toChar()) {
                arrowOffsetTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (arrowOffsetTmpBuf_UnionSelector == (1).toChar()) {
                arrowOffsetTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (arrowOffsetTmpBuf_UnionSelector == (2).toChar()) {
                arrowOffsetTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for arrowOffsetTmpBuf_ has to be chosen through deserialisation.")
            }
            arrowOffsetTmpBuf = (arrowOffsetTmpBuf_ as string | number | Resource)
        }
        const arrowOffsetTmpResult : Length | undefined = arrowOffsetTmpBuf
        const showInSubWindowTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let showInSubWindowTmpBuf : boolean | undefined = undefined
        if ((showInSubWindowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            showInSubWindowTmpBuf = valueDeserializer.readBoolean()
        }
        const showInSubWindowTmpResult : boolean | undefined = showInSubWindowTmpBuf
        const maskTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let maskTmpBuf : boolean | PopupMaskType | undefined = undefined
        if ((maskTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const maskTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let maskTmpBuf_ : boolean | PopupMaskType | undefined
            if (maskTmpBuf_UnionSelector == (0).toChar()) {
                maskTmpBuf_ = valueDeserializer.readBoolean()
            } else if (maskTmpBuf_UnionSelector == (1).toChar()) {
                maskTmpBuf_ = PopupMaskType_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for maskTmpBuf_ has to be chosen through deserialisation.")
            }
            maskTmpBuf = (maskTmpBuf_ as boolean | PopupMaskType)
        }
        const maskTmpResult : boolean | PopupMaskType | undefined = maskTmpBuf
        const targetSpaceTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let targetSpaceTmpBuf : Length | undefined = undefined
        if ((targetSpaceTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const targetSpaceTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let targetSpaceTmpBuf_ : string | number | Resource | undefined
            if (targetSpaceTmpBuf_UnionSelector == (0).toChar()) {
                targetSpaceTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (targetSpaceTmpBuf_UnionSelector == (1).toChar()) {
                targetSpaceTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (targetSpaceTmpBuf_UnionSelector == (2).toChar()) {
                targetSpaceTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for targetSpaceTmpBuf_ has to be chosen through deserialisation.")
            }
            targetSpaceTmpBuf = (targetSpaceTmpBuf_ as string | number | Resource)
        }
        const targetSpaceTmpResult : Length | undefined = targetSpaceTmpBuf
        const offsetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offsetTmpBuf : Position | undefined = undefined
        if ((offsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            offsetTmpBuf = Position_serializer.read(valueDeserializer)
        }
        const offsetTmpResult : Position | undefined = offsetTmpBuf
        const widthTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let widthTmpBuf : Dimension | undefined = undefined
        if ((widthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const widthTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let widthTmpBuf_ : string | number | Resource | undefined
            if (widthTmpBuf_UnionSelector == (0).toChar()) {
                widthTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (widthTmpBuf_UnionSelector == (1).toChar()) {
                widthTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (widthTmpBuf_UnionSelector == (2).toChar()) {
                widthTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for widthTmpBuf_ has to be chosen through deserialisation.")
            }
            widthTmpBuf = (widthTmpBuf_ as string | number | Resource)
        }
        const widthTmpResult : Dimension | undefined = widthTmpBuf
        const arrowPointPositionTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowPointPositionTmpBuf : ArrowPointPosition | undefined = undefined
        if ((arrowPointPositionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            arrowPointPositionTmpBuf = ArrowPointPosition.values()[valueDeserializer.readInt32()]
        }
        const arrowPointPositionTmpResult : ArrowPointPosition | undefined = arrowPointPositionTmpBuf
        const arrowWidthTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowWidthTmpBuf : Dimension | undefined = undefined
        if ((arrowWidthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowWidthTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let arrowWidthTmpBuf_ : string | number | Resource | undefined
            if (arrowWidthTmpBuf_UnionSelector == (0).toChar()) {
                arrowWidthTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (arrowWidthTmpBuf_UnionSelector == (1).toChar()) {
                arrowWidthTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (arrowWidthTmpBuf_UnionSelector == (2).toChar()) {
                arrowWidthTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for arrowWidthTmpBuf_ has to be chosen through deserialisation.")
            }
            arrowWidthTmpBuf = (arrowWidthTmpBuf_ as string | number | Resource)
        }
        const arrowWidthTmpResult : Dimension | undefined = arrowWidthTmpBuf
        const arrowHeightTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowHeightTmpBuf : Dimension | undefined = undefined
        if ((arrowHeightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowHeightTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let arrowHeightTmpBuf_ : string | number | Resource | undefined
            if (arrowHeightTmpBuf_UnionSelector == (0).toChar()) {
                arrowHeightTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (arrowHeightTmpBuf_UnionSelector == (1).toChar()) {
                arrowHeightTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (arrowHeightTmpBuf_UnionSelector == (2).toChar()) {
                arrowHeightTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for arrowHeightTmpBuf_ has to be chosen through deserialisation.")
            }
            arrowHeightTmpBuf = (arrowHeightTmpBuf_ as string | number | Resource)
        }
        const arrowHeightTmpResult : Dimension | undefined = arrowHeightTmpBuf
        const radiusTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let radiusTmpBuf : Dimension | undefined = undefined
        if ((radiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const radiusTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let radiusTmpBuf_ : string | number | Resource | undefined
            if (radiusTmpBuf_UnionSelector == (0).toChar()) {
                radiusTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (radiusTmpBuf_UnionSelector == (1).toChar()) {
                radiusTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (radiusTmpBuf_UnionSelector == (2).toChar()) {
                radiusTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for radiusTmpBuf_ has to be chosen through deserialisation.")
            }
            radiusTmpBuf = (radiusTmpBuf_ as string | number | Resource)
        }
        const radiusTmpResult : Dimension | undefined = radiusTmpBuf
        const shadowTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let shadowTmpBuf : ShadowOptions | ShadowStyle | undefined = undefined
        if ((shadowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const shadowTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let shadowTmpBuf_ : ShadowOptions | ShadowStyle | undefined
            if (shadowTmpBuf_UnionSelector == (0).toChar()) {
                shadowTmpBuf_ = ShadowOptions_serializer.read(valueDeserializer)
            } else if (shadowTmpBuf_UnionSelector == (1).toChar()) {
                shadowTmpBuf_ = ShadowStyle.fromValue(valueDeserializer.readInt32())
            } else {
                throw new Error("One of the branches for shadowTmpBuf_ has to be chosen through deserialisation.")
            }
            shadowTmpBuf = (shadowTmpBuf_ as ShadowOptions | ShadowStyle)
        }
        const shadowTmpResult : ShadowOptions | ShadowStyle | undefined = shadowTmpBuf
        const backgroundBlurStyleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundBlurStyleTmpBuf : BlurStyle | undefined = undefined
        if ((backgroundBlurStyleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundBlurStyleTmpBuf = BlurStyle.fromValue(valueDeserializer.readInt32())
        }
        const backgroundBlurStyleTmpResult : BlurStyle | undefined = backgroundBlurStyleTmpBuf
        const focusableTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let focusableTmpBuf : boolean | undefined = undefined
        if ((focusableTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            focusableTmpBuf = valueDeserializer.readBoolean()
        }
        const focusableTmpResult : boolean | undefined = focusableTmpBuf
        const transitionTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let transitionTmpBuf : TransitionEffect | undefined = undefined
        if ((transitionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            transitionTmpBuf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transitionTmpResult : TransitionEffect | undefined = transitionTmpBuf
        const onWillDismissTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillDismissTmpBuf : boolean | ((value0: DismissPopupAction) => void) | undefined = undefined
        if ((onWillDismissTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillDismissTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let onWillDismissTmpBuf_ : boolean | ((value0: DismissPopupAction) => void) | undefined
            if (onWillDismissTmpBuf_UnionSelector == (0).toChar()) {
                onWillDismissTmpBuf_ = valueDeserializer.readBoolean()
            } else if (onWillDismissTmpBuf_UnionSelector == (1).toChar()) {
                const onWillDismissTmpBuf_BufUBufResource : CallbackResource = valueDeserializer.readCallbackResource()
                const onWillDismissTmpBuf_BufUBufCall : KPointer = valueDeserializer.readPointer()
                const onWillDismissTmpBuf_BufUBufCallSync : KPointer = valueDeserializer.readPointer()
                onWillDismissTmpBuf_ = (value0: DismissPopupAction):void => {
                    const onWillDismissTmpBuf_BufUBufArgsSerializer : SerializerBase = SerializerBase.hold();
                    onWillDismissTmpBuf_BufUBufArgsSerializer.writeInt32(onWillDismissTmpBuf_BufUBufResource.resourceId);
                    onWillDismissTmpBuf_BufUBufArgsSerializer.writePointer(onWillDismissTmpBuf_BufUBufCall);
                    onWillDismissTmpBuf_BufUBufArgsSerializer.writePointer(onWillDismissTmpBuf_BufUBufCallSync);
                    DismissPopupAction_serializer.write(onWillDismissTmpBuf_BufUBufArgsSerializer, value0);
                    InteropNativeModule._CallCallbackSync(10, -2004166751, onWillDismissTmpBuf_BufUBufArgsSerializer.asBuffer(), onWillDismissTmpBuf_BufUBufArgsSerializer.length());
                    onWillDismissTmpBuf_BufUBufArgsSerializer.release();
                    return;
                }
            } else {
                throw new Error("One of the branches for onWillDismissTmpBuf_ has to be chosen through deserialisation.")
            }
            onWillDismissTmpBuf = (onWillDismissTmpBuf_ as boolean | ((value0: DismissPopupAction) => void))
        }
        const onWillDismissTmpResult : boolean | ((value0: DismissPopupAction) => void) | undefined = onWillDismissTmpBuf
        const enableHoverModeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableHoverModeTmpBuf : boolean | undefined = undefined
        if ((enableHoverModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableHoverModeTmpBuf = valueDeserializer.readBoolean()
        }
        const enableHoverModeTmpResult : boolean | undefined = enableHoverModeTmpBuf
        const followTransformOfTargetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let followTransformOfTargetTmpBuf : boolean | undefined = undefined
        if ((followTransformOfTargetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            followTransformOfTargetTmpBuf = valueDeserializer.readBoolean()
        }
        const followTransformOfTargetTmpResult : boolean | undefined = followTransformOfTargetTmpBuf
        const keyboardAvoidModeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let keyboardAvoidModeTmpBuf : KeyboardAvoidMode | undefined = undefined
        if ((keyboardAvoidModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            keyboardAvoidModeTmpBuf = KeyboardAvoidMode.fromValue(valueDeserializer.readInt32())
        }
        const keyboardAvoidModeTmpResult : KeyboardAvoidMode | undefined = keyboardAvoidModeTmpBuf
        let value : CustomPopupOptions = ({builder: builderTmpResult, placement: placementTmpResult, popupColor: popupColorTmpResult, enableArrow: enableArrowTmpResult, autoCancel: autoCancelTmpResult, onStateChange: onStateChangeTmpResult, arrowOffset: arrowOffsetTmpResult, showInSubWindow: showInSubWindowTmpResult, mask: maskTmpResult, targetSpace: targetSpaceTmpResult, offset: offsetTmpResult, width: widthTmpResult, arrowPointPosition: arrowPointPositionTmpResult, arrowWidth: arrowWidthTmpResult, arrowHeight: arrowHeightTmpResult, radius: radiusTmpResult, shadow: shadowTmpResult, backgroundBlurStyle: backgroundBlurStyleTmpResult, focusable: focusableTmpResult, transition: transitionTmpResult, onWillDismiss: onWillDismissTmpResult, enableHoverMode: enableHoverModeTmpResult, followTransformOfTarget: followTransformOfTargetTmpResult, keyboardAvoidMode: keyboardAvoidModeTmpResult} as CustomPopupOptions)
        return value
    }
}
export class EventTarget_serializer {
    public static write(buffer: SerializerBase, value: EventTarget): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForArea  = value.area
        Area_serializer.write(valueSerializer, valueHolderForArea)
        const valueHolderForId  = value.id
        if (valueHolderForId !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForIdTmpValue  = valueHolderForId!
            valueSerializer.writeString(valueHolderForIdTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): EventTarget {
        let valueDeserializer : DeserializerBase = buffer
        const areaTmpResult : Area = Area_serializer.read(valueDeserializer)
        const idTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let idTmpBuf : string | undefined = undefined
        if ((idTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            idTmpBuf = (valueDeserializer.readString() as string)
        }
        const idTmpResult : string | undefined = idTmpBuf
        let value : EventTarget = ({area: areaTmpResult, id: idTmpResult} as EventTarget)
        return value
    }
}
export class FocusAxisEvent_serializer {
    public static write(buffer: SerializerBase, value: FocusAxisEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): FocusAxisEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return FocusAxisEventInternal.fromPtr(ptr)
    }
}
export class GeometryInfo_serializer {
    public static write(buffer: SerializerBase, value: GeometryInfo): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForWidth  = value.width
        valueSerializer.writeNumber(valueHolderForWidth)
        const valueHolderForHeight  = value.height
        valueSerializer.writeNumber(valueHolderForHeight)
        const valueHolderForBorderWidth  = value.borderWidth
        EdgeWidths_serializer.write(valueSerializer, valueHolderForBorderWidth)
        const valueHolderForMargin  = value.margin
        Padding_serializer.write(valueSerializer, valueHolderForMargin)
        const valueHolderForPadding  = value.padding
        Padding_serializer.write(valueSerializer, valueHolderForPadding)
    }
    public static read(buffer: DeserializerBase): GeometryInfo {
        let valueDeserializer : DeserializerBase = buffer
        const widthTmpResult : number = (valueDeserializer.readNumber() as number)
        const heightTmpResult : number = (valueDeserializer.readNumber() as number)
        const borderWidthTmpResult : EdgeWidths = EdgeWidths_serializer.read(valueDeserializer)
        const marginTmpResult : Padding = Padding_serializer.read(valueDeserializer)
        const paddingTmpResult : Padding = Padding_serializer.read(valueDeserializer)
        let value : GeometryInfo = ({width: widthTmpResult, height: heightTmpResult, borderWidth: borderWidthTmpResult, margin: marginTmpResult, padding: paddingTmpResult} as GeometryInfo)
        return value
    }
}
export class HoverEvent_serializer {
    public static write(buffer: SerializerBase, value: HoverEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): HoverEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return HoverEventInternal.fromPtr(ptr)
    }
}
export class MenuOptions_serializer {
    public static write(buffer: SerializerBase, value: MenuOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForOffset  = value.offset
        if (valueHolderForOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetTmpValue  = valueHolderForOffset!
            Position_serializer.write(valueSerializer, valueHolderForOffsetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPlacement  = value.placement
        if (valueHolderForPlacement !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPlacementTmpValue  = (valueHolderForPlacement as Placement)
            valueSerializer.writeInt32(valueHolderForPlacementTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableArrow  = value.enableArrow
        if (valueHolderForEnableArrow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableArrowTmpValue  = valueHolderForEnableArrow!
            valueSerializer.writeBoolean(valueHolderForEnableArrowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowOffset  = value.arrowOffset
        if (valueHolderForArrowOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowOffsetTmpValue  = valueHolderForArrowOffset!
            if (valueHolderForArrowOffsetTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx0  = valueHolderForArrowOffsetTmpValue as string
                valueSerializer.writeString(valueHolderForArrowOffsetTmpValueForIdx0)
            } else if (valueHolderForArrowOffsetTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx1  = valueHolderForArrowOffsetTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowOffsetTmpValueForIdx1)
            } else if (valueHolderForArrowOffsetTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx2  = valueHolderForArrowOffsetTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForArrowOffsetTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPreview  = value.preview
        if (valueHolderForPreview !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPreviewTmpValue  = valueHolderForPreview!
            if (valueHolderForPreviewTmpValue instanceof MenuPreviewMode) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForPreviewTmpValueForIdx0  = valueHolderForPreviewTmpValue as MenuPreviewMode
                valueSerializer.writeInt32(valueHolderForPreviewTmpValueForIdx0.valueOf())
            } else if (valueHolderForPreviewTmpValue instanceof CustomBuilder) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForPreviewTmpValueForIdx1  = valueHolderForPreviewTmpValue as CustomBuilder
                valueSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(valueHolderForPreviewTmpValueForIdx1))
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPreviewBorderRadius  = value.previewBorderRadius
        if (valueHolderForPreviewBorderRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPreviewBorderRadiusTmpValue  = valueHolderForPreviewBorderRadius!
            if (valueHolderForPreviewBorderRadiusTmpValue instanceof Length) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForPreviewBorderRadiusTmpValueForIdx0  = valueHolderForPreviewBorderRadiusTmpValue as Length
                if (valueHolderForPreviewBorderRadiusTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx0  = valueHolderForPreviewBorderRadiusTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx0)
                } else if (valueHolderForPreviewBorderRadiusTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx1  = valueHolderForPreviewBorderRadiusTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx1)
                } else if (valueHolderForPreviewBorderRadiusTmpValueForIdx0 instanceof Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx2  = valueHolderForPreviewBorderRadiusTmpValueForIdx0 as Resource
                    Resource_serializer.write(valueSerializer, valueHolderForPreviewBorderRadiusTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForPreviewBorderRadiusTmpValue instanceof BorderRadiuses) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForPreviewBorderRadiusTmpValueForIdx1  = valueHolderForPreviewBorderRadiusTmpValue as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, valueHolderForPreviewBorderRadiusTmpValueForIdx1)
            } else if (valueHolderForPreviewBorderRadiusTmpValue instanceof LocalizedBorderRadiuses) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForPreviewBorderRadiusTmpValueForIdx2  = valueHolderForPreviewBorderRadiusTmpValue as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(valueSerializer, valueHolderForPreviewBorderRadiusTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBorderRadius  = value.borderRadius
        if (valueHolderForBorderRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBorderRadiusTmpValue  = valueHolderForBorderRadius!
            if (valueHolderForBorderRadiusTmpValue instanceof Length) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBorderRadiusTmpValueForIdx0  = valueHolderForBorderRadiusTmpValue as Length
                if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx0  = valueHolderForBorderRadiusTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForBorderRadiusTmpValueForIdx0ForIdx0)
                } else if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx1  = valueHolderForBorderRadiusTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForBorderRadiusTmpValueForIdx0ForIdx1)
                } else if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx2  = valueHolderForBorderRadiusTmpValueForIdx0 as Resource
                    Resource_serializer.write(valueSerializer, valueHolderForBorderRadiusTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForBorderRadiusTmpValue instanceof BorderRadiuses) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBorderRadiusTmpValueForIdx1  = valueHolderForBorderRadiusTmpValue as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, valueHolderForBorderRadiusTmpValueForIdx1)
            } else if (valueHolderForBorderRadiusTmpValue instanceof LocalizedBorderRadiuses) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBorderRadiusTmpValueForIdx2  = valueHolderForBorderRadiusTmpValue as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(valueSerializer, valueHolderForBorderRadiusTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnAppear  = value.onAppear
        if (valueHolderForOnAppear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnAppearTmpValue  = valueHolderForOnAppear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnAppearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnDisappear  = value.onDisappear
        if (valueHolderForOnDisappear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnDisappearTmpValue  = valueHolderForOnDisappear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnDisappearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAboutToAppear  = value.aboutToAppear
        if (valueHolderForAboutToAppear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAboutToAppearTmpValue  = valueHolderForAboutToAppear!
            valueSerializer.holdAndWriteCallback(valueHolderForAboutToAppearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAboutToDisappear  = value.aboutToDisappear
        if (valueHolderForAboutToDisappear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAboutToDisappearTmpValue  = valueHolderForAboutToDisappear!
            valueSerializer.holdAndWriteCallback(valueHolderForAboutToDisappearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForLayoutRegionMargin  = value.layoutRegionMargin
        if (valueHolderForLayoutRegionMargin !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForLayoutRegionMarginTmpValue  = valueHolderForLayoutRegionMargin!
            Padding_serializer.write(valueSerializer, valueHolderForLayoutRegionMarginTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPreviewAnimationOptions  = value.previewAnimationOptions
        if (valueHolderForPreviewAnimationOptions !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPreviewAnimationOptionsTmpValue  = valueHolderForPreviewAnimationOptions!
            ContextMenuAnimationOptions_serializer.write(valueSerializer, valueHolderForPreviewAnimationOptionsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundColor  = value.backgroundColor
        if (valueHolderForBackgroundColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundColorTmpValue  = valueHolderForBackgroundColor!
            if (valueHolderForBackgroundColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx0  = valueHolderForBackgroundColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForBackgroundColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForBackgroundColorTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx1  = valueHolderForBackgroundColorTmpValue as number
                valueSerializer.writeNumber(valueHolderForBackgroundColorTmpValueForIdx1)
            } else if (valueHolderForBackgroundColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx2  = valueHolderForBackgroundColorTmpValue as string
                valueSerializer.writeString(valueHolderForBackgroundColorTmpValueForIdx2)
            } else if (valueHolderForBackgroundColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx3  = valueHolderForBackgroundColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForBackgroundColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundBlurStyle  = value.backgroundBlurStyle
        if (valueHolderForBackgroundBlurStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundBlurStyleTmpValue  = (valueHolderForBackgroundBlurStyle as BlurStyle)
            valueSerializer.writeInt32(valueHolderForBackgroundBlurStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundBlurStyleOptions  = value.backgroundBlurStyleOptions
        if (valueHolderForBackgroundBlurStyleOptions !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundBlurStyleOptionsTmpValue  = valueHolderForBackgroundBlurStyleOptions!
            BackgroundBlurStyleOptions_serializer.write(valueSerializer, valueHolderForBackgroundBlurStyleOptionsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundEffect  = value.backgroundEffect
        if (valueHolderForBackgroundEffect !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundEffectTmpValue  = valueHolderForBackgroundEffect!
            BackgroundEffectOptions_serializer.write(valueSerializer, valueHolderForBackgroundEffectTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTransition  = value.transition
        if (valueHolderForTransition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTransitionTmpValue  = valueHolderForTransition!
            TransitionEffect_serializer.write(valueSerializer, valueHolderForTransitionTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableHoverMode  = value.enableHoverMode
        if (valueHolderForEnableHoverMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableHoverModeTmpValue  = valueHolderForEnableHoverMode!
            valueSerializer.writeBoolean(valueHolderForEnableHoverModeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOutlineColor  = value.outlineColor
        if (valueHolderForOutlineColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOutlineColorTmpValue  = valueHolderForOutlineColor!
            if (valueHolderForOutlineColorTmpValue instanceof ResourceColor) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOutlineColorTmpValueForIdx0  = valueHolderForOutlineColorTmpValue as ResourceColor
                if (valueHolderForOutlineColorTmpValueForIdx0 instanceof Color) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForOutlineColorTmpValueForIdx0ForIdx0  = valueHolderForOutlineColorTmpValueForIdx0 as Color
                    valueSerializer.writeInt32(valueHolderForOutlineColorTmpValueForIdx0ForIdx0.getOrdinal())
                } else if (valueHolderForOutlineColorTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForOutlineColorTmpValueForIdx0ForIdx1  = valueHolderForOutlineColorTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForOutlineColorTmpValueForIdx0ForIdx1)
                } else if (valueHolderForOutlineColorTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForOutlineColorTmpValueForIdx0ForIdx2  = valueHolderForOutlineColorTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForOutlineColorTmpValueForIdx0ForIdx2)
                } else if (valueHolderForOutlineColorTmpValueForIdx0 instanceof Resource) {
                    valueSerializer.writeInt8((3).toByte())
                    const valueHolderForOutlineColorTmpValueForIdx0ForIdx3  = valueHolderForOutlineColorTmpValueForIdx0 as Resource
                    Resource_serializer.write(valueSerializer, valueHolderForOutlineColorTmpValueForIdx0ForIdx3)
                }
            } else if (valueHolderForOutlineColorTmpValue instanceof EdgeColors) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOutlineColorTmpValueForIdx1  = valueHolderForOutlineColorTmpValue as EdgeColors
                EdgeColors_serializer.write(valueSerializer, valueHolderForOutlineColorTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOutlineWidth  = value.outlineWidth
        if (valueHolderForOutlineWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOutlineWidthTmpValue  = valueHolderForOutlineWidth!
            if (valueHolderForOutlineWidthTmpValue instanceof Dimension) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOutlineWidthTmpValueForIdx0  = valueHolderForOutlineWidthTmpValue as Dimension
                if (valueHolderForOutlineWidthTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForOutlineWidthTmpValueForIdx0ForIdx0  = valueHolderForOutlineWidthTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForOutlineWidthTmpValueForIdx0ForIdx0)
                } else if (valueHolderForOutlineWidthTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForOutlineWidthTmpValueForIdx0ForIdx1  = valueHolderForOutlineWidthTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForOutlineWidthTmpValueForIdx0ForIdx1)
                } else if (valueHolderForOutlineWidthTmpValueForIdx0 instanceof Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForOutlineWidthTmpValueForIdx0ForIdx2  = valueHolderForOutlineWidthTmpValueForIdx0 as Resource
                    Resource_serializer.write(valueSerializer, valueHolderForOutlineWidthTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForOutlineWidthTmpValue instanceof EdgeOutlineWidths) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOutlineWidthTmpValueForIdx1  = valueHolderForOutlineWidthTmpValue as EdgeOutlineWidths
                EdgeOutlineWidths_serializer.write(valueSerializer, valueHolderForOutlineWidthTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHapticFeedbackMode  = value.hapticFeedbackMode
        if (valueHolderForHapticFeedbackMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHapticFeedbackModeTmpValue  = (valueHolderForHapticFeedbackMode as HapticFeedbackMode)
            valueSerializer.writeInt32(valueHolderForHapticFeedbackModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTitle  = value.title
        if (valueHolderForTitle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTitleTmpValue  = valueHolderForTitle!
            if (valueHolderForTitleTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForTitleTmpValueForIdx0  = valueHolderForTitleTmpValue as string
                valueSerializer.writeString(valueHolderForTitleTmpValueForIdx0)
            } else if (valueHolderForTitleTmpValue instanceof Resource) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForTitleTmpValueForIdx1  = valueHolderForTitleTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForTitleTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShowInSubWindow  = value.showInSubWindow
        if (valueHolderForShowInSubWindow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShowInSubWindowTmpValue  = valueHolderForShowInSubWindow!
            valueSerializer.writeBoolean(valueHolderForShowInSubWindowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): MenuOptions {
        let valueDeserializer : DeserializerBase = buffer
        const offsetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offsetTmpBuf : Position | undefined = undefined
        if ((offsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            offsetTmpBuf = Position_serializer.read(valueDeserializer)
        }
        const offsetTmpResult : Position | undefined = offsetTmpBuf
        const placementTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let placementTmpBuf : Placement | undefined = undefined
        if ((placementTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            placementTmpBuf = Placement.fromValue(valueDeserializer.readInt32())
        }
        const placementTmpResult : Placement | undefined = placementTmpBuf
        const enableArrowTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableArrowTmpBuf : boolean | undefined = undefined
        if ((enableArrowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableArrowTmpBuf = valueDeserializer.readBoolean()
        }
        const enableArrowTmpResult : boolean | undefined = enableArrowTmpBuf
        const arrowOffsetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowOffsetTmpBuf : Length | undefined = undefined
        if ((arrowOffsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowOffsetTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let arrowOffsetTmpBuf_ : string | number | Resource | undefined
            if (arrowOffsetTmpBuf_UnionSelector == (0).toChar()) {
                arrowOffsetTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (arrowOffsetTmpBuf_UnionSelector == (1).toChar()) {
                arrowOffsetTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (arrowOffsetTmpBuf_UnionSelector == (2).toChar()) {
                arrowOffsetTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for arrowOffsetTmpBuf_ has to be chosen through deserialisation.")
            }
            arrowOffsetTmpBuf = (arrowOffsetTmpBuf_ as string | number | Resource)
        }
        const arrowOffsetTmpResult : Length | undefined = arrowOffsetTmpBuf
        const previewTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let previewTmpBuf : MenuPreviewMode | CustomBuilder | undefined = undefined
        if ((previewTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const previewTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let previewTmpBuf_ : MenuPreviewMode | CustomBuilder | undefined
            if (previewTmpBuf_UnionSelector == (0).toChar()) {
                previewTmpBuf_ = MenuPreviewMode.fromValue(valueDeserializer.readInt32())
            } else if (previewTmpBuf_UnionSelector == (1).toChar()) {
                const previewTmpBuf_BufUBufResource : CallbackResource = valueDeserializer.readCallbackResource()
                const previewTmpBuf_BufUBufCall : KPointer = valueDeserializer.readPointer()
                const previewTmpBuf_BufUBufCallSync : KPointer = valueDeserializer.readPointer()
                previewTmpBuf_ = ():void => {
                    const previewTmpBuf_BufUBufArgsSerializer : SerializerBase = SerializerBase.hold();
                    previewTmpBuf_BufUBufArgsSerializer.writeInt32(previewTmpBuf_BufUBufResource.resourceId);
                    previewTmpBuf_BufUBufArgsSerializer.writePointer(previewTmpBuf_BufUBufCall);
                    previewTmpBuf_BufUBufArgsSerializer.writePointer(previewTmpBuf_BufUBufCallSync);
                    InteropNativeModule._CallCallbackSync(10, 737226752, previewTmpBuf_BufUBufArgsSerializer.asBuffer(), previewTmpBuf_BufUBufArgsSerializer.length());
                    previewTmpBuf_BufUBufArgsSerializer.release();
                    return;
                }
            } else {
                throw new Error("One of the branches for previewTmpBuf_ has to be chosen through deserialisation.")
            }
            previewTmpBuf = (previewTmpBuf_ as MenuPreviewMode | CustomBuilder)
        }
        const previewTmpResult : MenuPreviewMode | CustomBuilder | undefined = previewTmpBuf
        const previewBorderRadiusTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let previewBorderRadiusTmpBuf : BorderRadiusType | undefined = undefined
        if ((previewBorderRadiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const previewBorderRadiusTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let previewBorderRadiusTmpBuf_ : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined
            if (previewBorderRadiusTmpBuf_UnionSelector == (0).toChar()) {
                const previewBorderRadiusTmpBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                let previewBorderRadiusTmpBuf_BufU : string | number | Resource | undefined
                if (previewBorderRadiusTmpBuf_BufUUnionSelector == (0).toChar()) {
                    previewBorderRadiusTmpBuf_BufU = (valueDeserializer.readString() as string)
                } else if (previewBorderRadiusTmpBuf_BufUUnionSelector == (1).toChar()) {
                    previewBorderRadiusTmpBuf_BufU = (valueDeserializer.readNumber() as number)
                } else if (previewBorderRadiusTmpBuf_BufUUnionSelector == (2).toChar()) {
                    previewBorderRadiusTmpBuf_BufU = Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error("One of the branches for previewBorderRadiusTmpBuf_BufU has to be chosen through deserialisation.")
                }
                previewBorderRadiusTmpBuf_ = (previewBorderRadiusTmpBuf_BufU as string | number | Resource)
            } else if (previewBorderRadiusTmpBuf_UnionSelector == (1).toChar()) {
                previewBorderRadiusTmpBuf_ = BorderRadiuses_serializer.read(valueDeserializer)
            } else if (previewBorderRadiusTmpBuf_UnionSelector == (2).toChar()) {
                previewBorderRadiusTmpBuf_ = LocalizedBorderRadiuses_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for previewBorderRadiusTmpBuf_ has to be chosen through deserialisation.")
            }
            previewBorderRadiusTmpBuf = (previewBorderRadiusTmpBuf_ as Length | BorderRadiuses | LocalizedBorderRadiuses)
        }
        const previewBorderRadiusTmpResult : BorderRadiusType | undefined = previewBorderRadiusTmpBuf
        const borderRadiusTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let borderRadiusTmpBuf : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined = undefined
        if ((borderRadiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const borderRadiusTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let borderRadiusTmpBuf_ : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined
            if (borderRadiusTmpBuf_UnionSelector == (0).toChar()) {
                const borderRadiusTmpBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                let borderRadiusTmpBuf_BufU : string | number | Resource | undefined
                if (borderRadiusTmpBuf_BufUUnionSelector == (0).toChar()) {
                    borderRadiusTmpBuf_BufU = (valueDeserializer.readString() as string)
                } else if (borderRadiusTmpBuf_BufUUnionSelector == (1).toChar()) {
                    borderRadiusTmpBuf_BufU = (valueDeserializer.readNumber() as number)
                } else if (borderRadiusTmpBuf_BufUUnionSelector == (2).toChar()) {
                    borderRadiusTmpBuf_BufU = Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error("One of the branches for borderRadiusTmpBuf_BufU has to be chosen through deserialisation.")
                }
                borderRadiusTmpBuf_ = (borderRadiusTmpBuf_BufU as string | number | Resource)
            } else if (borderRadiusTmpBuf_UnionSelector == (1).toChar()) {
                borderRadiusTmpBuf_ = BorderRadiuses_serializer.read(valueDeserializer)
            } else if (borderRadiusTmpBuf_UnionSelector == (2).toChar()) {
                borderRadiusTmpBuf_ = LocalizedBorderRadiuses_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for borderRadiusTmpBuf_ has to be chosen through deserialisation.")
            }
            borderRadiusTmpBuf = (borderRadiusTmpBuf_ as Length | BorderRadiuses | LocalizedBorderRadiuses)
        }
        const borderRadiusTmpResult : Length | BorderRadiuses | LocalizedBorderRadiuses | undefined = borderRadiusTmpBuf
        const onAppearTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onAppearTmpBuf : (() => void) | undefined = undefined
        if ((onAppearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onAppearTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onAppearTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onAppearTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onAppearTmpBuf = ():void => {
                const onAppearTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onAppearTmpBuf_BufArgsSerializer.writeInt32(onAppearTmpBuf_BufResource.resourceId);
                onAppearTmpBuf_BufArgsSerializer.writePointer(onAppearTmpBuf_BufCall);
                onAppearTmpBuf_BufArgsSerializer.writePointer(onAppearTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, onAppearTmpBuf_BufArgsSerializer.asBuffer(), onAppearTmpBuf_BufArgsSerializer.length());
                onAppearTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onAppearTmpResult : (() => void) | undefined = onAppearTmpBuf
        const onDisappearTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onDisappearTmpBuf : (() => void) | undefined = undefined
        if ((onDisappearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onDisappearTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDisappearTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onDisappearTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onDisappearTmpBuf = ():void => {
                const onDisappearTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onDisappearTmpBuf_BufArgsSerializer.writeInt32(onDisappearTmpBuf_BufResource.resourceId);
                onDisappearTmpBuf_BufArgsSerializer.writePointer(onDisappearTmpBuf_BufCall);
                onDisappearTmpBuf_BufArgsSerializer.writePointer(onDisappearTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, onDisappearTmpBuf_BufArgsSerializer.asBuffer(), onDisappearTmpBuf_BufArgsSerializer.length());
                onDisappearTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onDisappearTmpResult : (() => void) | undefined = onDisappearTmpBuf
        const aboutToAppearTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let aboutToAppearTmpBuf : (() => void) | undefined = undefined
        if ((aboutToAppearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const aboutToAppearTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const aboutToAppearTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const aboutToAppearTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            aboutToAppearTmpBuf = ():void => {
                const aboutToAppearTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                aboutToAppearTmpBuf_BufArgsSerializer.writeInt32(aboutToAppearTmpBuf_BufResource.resourceId);
                aboutToAppearTmpBuf_BufArgsSerializer.writePointer(aboutToAppearTmpBuf_BufCall);
                aboutToAppearTmpBuf_BufArgsSerializer.writePointer(aboutToAppearTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, aboutToAppearTmpBuf_BufArgsSerializer.asBuffer(), aboutToAppearTmpBuf_BufArgsSerializer.length());
                aboutToAppearTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const aboutToAppearTmpResult : (() => void) | undefined = aboutToAppearTmpBuf
        const aboutToDisappearTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let aboutToDisappearTmpBuf : (() => void) | undefined = undefined
        if ((aboutToDisappearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const aboutToDisappearTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const aboutToDisappearTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const aboutToDisappearTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            aboutToDisappearTmpBuf = ():void => {
                const aboutToDisappearTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                aboutToDisappearTmpBuf_BufArgsSerializer.writeInt32(aboutToDisappearTmpBuf_BufResource.resourceId);
                aboutToDisappearTmpBuf_BufArgsSerializer.writePointer(aboutToDisappearTmpBuf_BufCall);
                aboutToDisappearTmpBuf_BufArgsSerializer.writePointer(aboutToDisappearTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, aboutToDisappearTmpBuf_BufArgsSerializer.asBuffer(), aboutToDisappearTmpBuf_BufArgsSerializer.length());
                aboutToDisappearTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const aboutToDisappearTmpResult : (() => void) | undefined = aboutToDisappearTmpBuf
        const layoutRegionMarginTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let layoutRegionMarginTmpBuf : Padding | undefined = undefined
        if ((layoutRegionMarginTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            layoutRegionMarginTmpBuf = Padding_serializer.read(valueDeserializer)
        }
        const layoutRegionMarginTmpResult : Padding | undefined = layoutRegionMarginTmpBuf
        const previewAnimationOptionsTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let previewAnimationOptionsTmpBuf : ContextMenuAnimationOptions | undefined = undefined
        if ((previewAnimationOptionsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            previewAnimationOptionsTmpBuf = ContextMenuAnimationOptions_serializer.read(valueDeserializer)
        }
        const previewAnimationOptionsTmpResult : ContextMenuAnimationOptions | undefined = previewAnimationOptionsTmpBuf
        const backgroundColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundColorTmpBuf : ResourceColor | undefined = undefined
        if ((backgroundColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const backgroundColorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let backgroundColorTmpBuf_ : Color | number | string | Resource | undefined
            if (backgroundColorTmpBuf_UnionSelector == (0).toChar()) {
                backgroundColorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (backgroundColorTmpBuf_UnionSelector == (1).toChar()) {
                backgroundColorTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (backgroundColorTmpBuf_UnionSelector == (2).toChar()) {
                backgroundColorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (backgroundColorTmpBuf_UnionSelector == (3).toChar()) {
                backgroundColorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for backgroundColorTmpBuf_ has to be chosen through deserialisation.")
            }
            backgroundColorTmpBuf = (backgroundColorTmpBuf_ as Color | number | string | Resource)
        }
        const backgroundColorTmpResult : ResourceColor | undefined = backgroundColorTmpBuf
        const backgroundBlurStyleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundBlurStyleTmpBuf : BlurStyle | undefined = undefined
        if ((backgroundBlurStyleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundBlurStyleTmpBuf = BlurStyle.fromValue(valueDeserializer.readInt32())
        }
        const backgroundBlurStyleTmpResult : BlurStyle | undefined = backgroundBlurStyleTmpBuf
        const backgroundBlurStyleOptionsTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundBlurStyleOptionsTmpBuf : BackgroundBlurStyleOptions | undefined = undefined
        if ((backgroundBlurStyleOptionsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundBlurStyleOptionsTmpBuf = BackgroundBlurStyleOptions_serializer.read(valueDeserializer)
        }
        const backgroundBlurStyleOptionsTmpResult : BackgroundBlurStyleOptions | undefined = backgroundBlurStyleOptionsTmpBuf
        const backgroundEffectTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundEffectTmpBuf : BackgroundEffectOptions | undefined = undefined
        if ((backgroundEffectTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundEffectTmpBuf = BackgroundEffectOptions_serializer.read(valueDeserializer)
        }
        const backgroundEffectTmpResult : BackgroundEffectOptions | undefined = backgroundEffectTmpBuf
        const transitionTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let transitionTmpBuf : TransitionEffect | undefined = undefined
        if ((transitionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            transitionTmpBuf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transitionTmpResult : TransitionEffect | undefined = transitionTmpBuf
        const enableHoverModeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableHoverModeTmpBuf : boolean | undefined = undefined
        if ((enableHoverModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableHoverModeTmpBuf = valueDeserializer.readBoolean()
        }
        const enableHoverModeTmpResult : boolean | undefined = enableHoverModeTmpBuf
        const outlineColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let outlineColorTmpBuf : ResourceColor | EdgeColors | undefined = undefined
        if ((outlineColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const outlineColorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let outlineColorTmpBuf_ : ResourceColor | EdgeColors | undefined
            if (outlineColorTmpBuf_UnionSelector == (0).toChar()) {
                const outlineColorTmpBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                let outlineColorTmpBuf_BufU : Color | number | string | Resource | undefined
                if (outlineColorTmpBuf_BufUUnionSelector == (0).toChar()) {
                    outlineColorTmpBuf_BufU = Color.values()[valueDeserializer.readInt32()]
                } else if (outlineColorTmpBuf_BufUUnionSelector == (1).toChar()) {
                    outlineColorTmpBuf_BufU = (valueDeserializer.readNumber() as number)
                } else if (outlineColorTmpBuf_BufUUnionSelector == (2).toChar()) {
                    outlineColorTmpBuf_BufU = (valueDeserializer.readString() as string)
                } else if (outlineColorTmpBuf_BufUUnionSelector == (3).toChar()) {
                    outlineColorTmpBuf_BufU = Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error("One of the branches for outlineColorTmpBuf_BufU has to be chosen through deserialisation.")
                }
                outlineColorTmpBuf_ = (outlineColorTmpBuf_BufU as Color | number | string | Resource)
            } else if (outlineColorTmpBuf_UnionSelector == (1).toChar()) {
                outlineColorTmpBuf_ = EdgeColors_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for outlineColorTmpBuf_ has to be chosen through deserialisation.")
            }
            outlineColorTmpBuf = (outlineColorTmpBuf_ as ResourceColor | EdgeColors)
        }
        const outlineColorTmpResult : ResourceColor | EdgeColors | undefined = outlineColorTmpBuf
        const outlineWidthTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let outlineWidthTmpBuf : Dimension | EdgeOutlineWidths | undefined = undefined
        if ((outlineWidthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const outlineWidthTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let outlineWidthTmpBuf_ : Dimension | EdgeOutlineWidths | undefined
            if (outlineWidthTmpBuf_UnionSelector == (0).toChar()) {
                const outlineWidthTmpBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                let outlineWidthTmpBuf_BufU : string | number | Resource | undefined
                if (outlineWidthTmpBuf_BufUUnionSelector == (0).toChar()) {
                    outlineWidthTmpBuf_BufU = (valueDeserializer.readString() as string)
                } else if (outlineWidthTmpBuf_BufUUnionSelector == (1).toChar()) {
                    outlineWidthTmpBuf_BufU = (valueDeserializer.readNumber() as number)
                } else if (outlineWidthTmpBuf_BufUUnionSelector == (2).toChar()) {
                    outlineWidthTmpBuf_BufU = Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error("One of the branches for outlineWidthTmpBuf_BufU has to be chosen through deserialisation.")
                }
                outlineWidthTmpBuf_ = (outlineWidthTmpBuf_BufU as string | number | Resource)
            } else if (outlineWidthTmpBuf_UnionSelector == (1).toChar()) {
                outlineWidthTmpBuf_ = EdgeOutlineWidths_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for outlineWidthTmpBuf_ has to be chosen through deserialisation.")
            }
            outlineWidthTmpBuf = (outlineWidthTmpBuf_ as Dimension | EdgeOutlineWidths)
        }
        const outlineWidthTmpResult : Dimension | EdgeOutlineWidths | undefined = outlineWidthTmpBuf
        const hapticFeedbackModeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let hapticFeedbackModeTmpBuf : HapticFeedbackMode | undefined = undefined
        if ((hapticFeedbackModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            hapticFeedbackModeTmpBuf = HapticFeedbackMode.fromValue(valueDeserializer.readInt32())
        }
        const hapticFeedbackModeTmpResult : HapticFeedbackMode | undefined = hapticFeedbackModeTmpBuf
        const titleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let titleTmpBuf : ResourceStr | undefined = undefined
        if ((titleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const titleTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let titleTmpBuf_ : string | Resource | undefined
            if (titleTmpBuf_UnionSelector == (0).toChar()) {
                titleTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (titleTmpBuf_UnionSelector == (1).toChar()) {
                titleTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for titleTmpBuf_ has to be chosen through deserialisation.")
            }
            titleTmpBuf = (titleTmpBuf_ as string | Resource)
        }
        const titleTmpResult : ResourceStr | undefined = titleTmpBuf
        const showInSubWindowTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let showInSubWindowTmpBuf : boolean | undefined = undefined
        if ((showInSubWindowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            showInSubWindowTmpBuf = valueDeserializer.readBoolean()
        }
        const showInSubWindowTmpResult : boolean | undefined = showInSubWindowTmpBuf
        let value : MenuOptions = ({offset: offsetTmpResult, placement: placementTmpResult, enableArrow: enableArrowTmpResult, arrowOffset: arrowOffsetTmpResult, preview: previewTmpResult, previewBorderRadius: previewBorderRadiusTmpResult, borderRadius: borderRadiusTmpResult, onAppear: onAppearTmpResult, onDisappear: onDisappearTmpResult, aboutToAppear: aboutToAppearTmpResult, aboutToDisappear: aboutToDisappearTmpResult, layoutRegionMargin: layoutRegionMarginTmpResult, previewAnimationOptions: previewAnimationOptionsTmpResult, backgroundColor: backgroundColorTmpResult, backgroundBlurStyle: backgroundBlurStyleTmpResult, backgroundBlurStyleOptions: backgroundBlurStyleOptionsTmpResult, backgroundEffect: backgroundEffectTmpResult, transition: transitionTmpResult, enableHoverMode: enableHoverModeTmpResult, outlineColor: outlineColorTmpResult, outlineWidth: outlineWidthTmpResult, hapticFeedbackMode: hapticFeedbackModeTmpResult, title: titleTmpResult, showInSubWindow: showInSubWindowTmpResult} as MenuOptions)
        return value
    }
}
export class MouseEvent_serializer {
    public static write(buffer: SerializerBase, value: MouseEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): MouseEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return MouseEventInternal.fromPtr(ptr)
    }
}
export class PickerDialogButtonStyle_serializer {
    public static write(buffer: SerializerBase, value: PickerDialogButtonStyle): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForType  = value.type
        if (valueHolderForType !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTypeTmpValue  = (valueHolderForType as ButtonType)
            valueSerializer.writeInt32(valueHolderForTypeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForStyle  = value.style
        if (valueHolderForStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForStyleTmpValue  = (valueHolderForStyle as ButtonStyleMode)
            valueSerializer.writeInt32(valueHolderForStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRole  = value.role
        if (valueHolderForRole !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRoleTmpValue  = (valueHolderForRole as ButtonRole)
            valueSerializer.writeInt32(valueHolderForRoleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFontSize  = value.fontSize
        if (valueHolderForFontSize !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFontSizeTmpValue  = valueHolderForFontSize!
            if (valueHolderForFontSizeTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForFontSizeTmpValueForIdx0  = valueHolderForFontSizeTmpValue as string
                valueSerializer.writeString(valueHolderForFontSizeTmpValueForIdx0)
            } else if (valueHolderForFontSizeTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForFontSizeTmpValueForIdx1  = valueHolderForFontSizeTmpValue as number
                valueSerializer.writeNumber(valueHolderForFontSizeTmpValueForIdx1)
            } else if (valueHolderForFontSizeTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForFontSizeTmpValueForIdx2  = valueHolderForFontSizeTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForFontSizeTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFontColor  = value.fontColor
        if (valueHolderForFontColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFontColorTmpValue  = valueHolderForFontColor!
            if (valueHolderForFontColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForFontColorTmpValueForIdx0  = valueHolderForFontColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForFontColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForFontColorTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForFontColorTmpValueForIdx1  = valueHolderForFontColorTmpValue as number
                valueSerializer.writeNumber(valueHolderForFontColorTmpValueForIdx1)
            } else if (valueHolderForFontColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForFontColorTmpValueForIdx2  = valueHolderForFontColorTmpValue as string
                valueSerializer.writeString(valueHolderForFontColorTmpValueForIdx2)
            } else if (valueHolderForFontColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForFontColorTmpValueForIdx3  = valueHolderForFontColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForFontColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFontWeight  = value.fontWeight
        if (valueHolderForFontWeight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFontWeightTmpValue  = valueHolderForFontWeight!
            if (valueHolderForFontWeightTmpValue instanceof FontWeight) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForFontWeightTmpValueForIdx0  = valueHolderForFontWeightTmpValue as FontWeight
                valueSerializer.writeInt32(valueHolderForFontWeightTmpValueForIdx0.valueOf())
            } else if (valueHolderForFontWeightTmpValue instanceof int32) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForFontWeightTmpValueForIdx1  = valueHolderForFontWeightTmpValue as int32
                valueSerializer.writeInt32(valueHolderForFontWeightTmpValueForIdx1)
            } else if (valueHolderForFontWeightTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForFontWeightTmpValueForIdx2  = valueHolderForFontWeightTmpValue as string
                valueSerializer.writeString(valueHolderForFontWeightTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFontStyle  = value.fontStyle
        if (valueHolderForFontStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFontStyleTmpValue  = (valueHolderForFontStyle as FontStyle)
            valueSerializer.writeInt32(valueHolderForFontStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFontFamily  = value.fontFamily
        if (valueHolderForFontFamily !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFontFamilyTmpValue  = valueHolderForFontFamily!
            if (valueHolderForFontFamilyTmpValue instanceof Resource) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForFontFamilyTmpValueForIdx0  = valueHolderForFontFamilyTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForFontFamilyTmpValueForIdx0)
            } else if (valueHolderForFontFamilyTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForFontFamilyTmpValueForIdx1  = valueHolderForFontFamilyTmpValue as string
                valueSerializer.writeString(valueHolderForFontFamilyTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundColor  = value.backgroundColor
        if (valueHolderForBackgroundColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundColorTmpValue  = valueHolderForBackgroundColor!
            if (valueHolderForBackgroundColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx0  = valueHolderForBackgroundColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForBackgroundColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForBackgroundColorTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx1  = valueHolderForBackgroundColorTmpValue as number
                valueSerializer.writeNumber(valueHolderForBackgroundColorTmpValueForIdx1)
            } else if (valueHolderForBackgroundColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx2  = valueHolderForBackgroundColorTmpValue as string
                valueSerializer.writeString(valueHolderForBackgroundColorTmpValueForIdx2)
            } else if (valueHolderForBackgroundColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx3  = valueHolderForBackgroundColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForBackgroundColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBorderRadius  = value.borderRadius
        if (valueHolderForBorderRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBorderRadiusTmpValue  = valueHolderForBorderRadius!
            if (valueHolderForBorderRadiusTmpValue instanceof Length) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBorderRadiusTmpValueForIdx0  = valueHolderForBorderRadiusTmpValue as Length
                if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx0  = valueHolderForBorderRadiusTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForBorderRadiusTmpValueForIdx0ForIdx0)
                } else if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx1  = valueHolderForBorderRadiusTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForBorderRadiusTmpValueForIdx0ForIdx1)
                } else if (valueHolderForBorderRadiusTmpValueForIdx0 instanceof Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForBorderRadiusTmpValueForIdx0ForIdx2  = valueHolderForBorderRadiusTmpValueForIdx0 as Resource
                    Resource_serializer.write(valueSerializer, valueHolderForBorderRadiusTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForBorderRadiusTmpValue instanceof BorderRadiuses) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBorderRadiusTmpValueForIdx1  = valueHolderForBorderRadiusTmpValue as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, valueHolderForBorderRadiusTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPrimary  = value.primary
        if (valueHolderForPrimary !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPrimaryTmpValue  = valueHolderForPrimary!
            valueSerializer.writeBoolean(valueHolderForPrimaryTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PickerDialogButtonStyle {
        let valueDeserializer : DeserializerBase = buffer
        const typeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let typeTmpBuf : ButtonType | undefined = undefined
        if ((typeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            typeTmpBuf = ButtonType.fromValue(valueDeserializer.readInt32())
        }
        const typeTmpResult : ButtonType | undefined = typeTmpBuf
        const styleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let styleTmpBuf : ButtonStyleMode | undefined = undefined
        if ((styleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            styleTmpBuf = ButtonStyleMode.fromValue(valueDeserializer.readInt32())
        }
        const styleTmpResult : ButtonStyleMode | undefined = styleTmpBuf
        const roleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let roleTmpBuf : ButtonRole | undefined = undefined
        if ((roleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            roleTmpBuf = ButtonRole.fromValue(valueDeserializer.readInt32())
        }
        const roleTmpResult : ButtonRole | undefined = roleTmpBuf
        const fontSizeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fontSizeTmpBuf : Length | undefined = undefined
        if ((fontSizeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const fontSizeTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let fontSizeTmpBuf_ : string | number | Resource | undefined
            if (fontSizeTmpBuf_UnionSelector == (0).toChar()) {
                fontSizeTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (fontSizeTmpBuf_UnionSelector == (1).toChar()) {
                fontSizeTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (fontSizeTmpBuf_UnionSelector == (2).toChar()) {
                fontSizeTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for fontSizeTmpBuf_ has to be chosen through deserialisation.")
            }
            fontSizeTmpBuf = (fontSizeTmpBuf_ as string | number | Resource)
        }
        const fontSizeTmpResult : Length | undefined = fontSizeTmpBuf
        const fontColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fontColorTmpBuf : ResourceColor | undefined = undefined
        if ((fontColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const fontColorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let fontColorTmpBuf_ : Color | number | string | Resource | undefined
            if (fontColorTmpBuf_UnionSelector == (0).toChar()) {
                fontColorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (fontColorTmpBuf_UnionSelector == (1).toChar()) {
                fontColorTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (fontColorTmpBuf_UnionSelector == (2).toChar()) {
                fontColorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (fontColorTmpBuf_UnionSelector == (3).toChar()) {
                fontColorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for fontColorTmpBuf_ has to be chosen through deserialisation.")
            }
            fontColorTmpBuf = (fontColorTmpBuf_ as Color | number | string | Resource)
        }
        const fontColorTmpResult : ResourceColor | undefined = fontColorTmpBuf
        const fontWeightTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fontWeightTmpBuf : FontWeight | int32 | string | undefined = undefined
        if ((fontWeightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const fontWeightTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let fontWeightTmpBuf_ : FontWeight | int32 | string | undefined
            if (fontWeightTmpBuf_UnionSelector == (0).toChar()) {
                fontWeightTmpBuf_ = FontWeight.fromValue(valueDeserializer.readInt32())
            } else if (fontWeightTmpBuf_UnionSelector == (1).toChar()) {
                fontWeightTmpBuf_ = valueDeserializer.readInt32()
            } else if (fontWeightTmpBuf_UnionSelector == (2).toChar()) {
                fontWeightTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for fontWeightTmpBuf_ has to be chosen through deserialisation.")
            }
            fontWeightTmpBuf = (fontWeightTmpBuf_ as FontWeight | int32 | string)
        }
        const fontWeightTmpResult : FontWeight | int32 | string | undefined = fontWeightTmpBuf
        const fontStyleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fontStyleTmpBuf : FontStyle | undefined = undefined
        if ((fontStyleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            fontStyleTmpBuf = FontStyle.fromValue(valueDeserializer.readInt32())
        }
        const fontStyleTmpResult : FontStyle | undefined = fontStyleTmpBuf
        const fontFamilyTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fontFamilyTmpBuf : Resource | string | undefined = undefined
        if ((fontFamilyTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const fontFamilyTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let fontFamilyTmpBuf_ : Resource | string | undefined
            if (fontFamilyTmpBuf_UnionSelector == (0).toChar()) {
                fontFamilyTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else if (fontFamilyTmpBuf_UnionSelector == (1).toChar()) {
                fontFamilyTmpBuf_ = (valueDeserializer.readString() as string)
            } else {
                throw new Error("One of the branches for fontFamilyTmpBuf_ has to be chosen through deserialisation.")
            }
            fontFamilyTmpBuf = (fontFamilyTmpBuf_ as Resource | string)
        }
        const fontFamilyTmpResult : Resource | string | undefined = fontFamilyTmpBuf
        const backgroundColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundColorTmpBuf : ResourceColor | undefined = undefined
        if ((backgroundColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const backgroundColorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let backgroundColorTmpBuf_ : Color | number | string | Resource | undefined
            if (backgroundColorTmpBuf_UnionSelector == (0).toChar()) {
                backgroundColorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (backgroundColorTmpBuf_UnionSelector == (1).toChar()) {
                backgroundColorTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (backgroundColorTmpBuf_UnionSelector == (2).toChar()) {
                backgroundColorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (backgroundColorTmpBuf_UnionSelector == (3).toChar()) {
                backgroundColorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for backgroundColorTmpBuf_ has to be chosen through deserialisation.")
            }
            backgroundColorTmpBuf = (backgroundColorTmpBuf_ as Color | number | string | Resource)
        }
        const backgroundColorTmpResult : ResourceColor | undefined = backgroundColorTmpBuf
        const borderRadiusTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let borderRadiusTmpBuf : Length | BorderRadiuses | undefined = undefined
        if ((borderRadiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const borderRadiusTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let borderRadiusTmpBuf_ : Length | BorderRadiuses | undefined
            if (borderRadiusTmpBuf_UnionSelector == (0).toChar()) {
                const borderRadiusTmpBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                let borderRadiusTmpBuf_BufU : string | number | Resource | undefined
                if (borderRadiusTmpBuf_BufUUnionSelector == (0).toChar()) {
                    borderRadiusTmpBuf_BufU = (valueDeserializer.readString() as string)
                } else if (borderRadiusTmpBuf_BufUUnionSelector == (1).toChar()) {
                    borderRadiusTmpBuf_BufU = (valueDeserializer.readNumber() as number)
                } else if (borderRadiusTmpBuf_BufUUnionSelector == (2).toChar()) {
                    borderRadiusTmpBuf_BufU = Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error("One of the branches for borderRadiusTmpBuf_BufU has to be chosen through deserialisation.")
                }
                borderRadiusTmpBuf_ = (borderRadiusTmpBuf_BufU as string | number | Resource)
            } else if (borderRadiusTmpBuf_UnionSelector == (1).toChar()) {
                borderRadiusTmpBuf_ = BorderRadiuses_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for borderRadiusTmpBuf_ has to be chosen through deserialisation.")
            }
            borderRadiusTmpBuf = (borderRadiusTmpBuf_ as Length | BorderRadiuses)
        }
        const borderRadiusTmpResult : Length | BorderRadiuses | undefined = borderRadiusTmpBuf
        const primaryTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let primaryTmpBuf : boolean | undefined = undefined
        if ((primaryTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            primaryTmpBuf = valueDeserializer.readBoolean()
        }
        const primaryTmpResult : boolean | undefined = primaryTmpBuf
        let value : PickerDialogButtonStyle = ({type: typeTmpResult, style: styleTmpResult, role: roleTmpResult, fontSize: fontSizeTmpResult, fontColor: fontColorTmpResult, fontWeight: fontWeightTmpResult, fontStyle: fontStyleTmpResult, fontFamily: fontFamilyTmpResult, backgroundColor: backgroundColorTmpResult, borderRadius: borderRadiusTmpResult, primary: primaryTmpResult} as PickerDialogButtonStyle)
        return value
    }
}
export class PickerTextStyle_serializer {
    public static write(buffer: SerializerBase, value: PickerTextStyle): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForColor  = value.color
        if (valueHolderForColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForColorTmpValue  = valueHolderForColor!
            if (valueHolderForColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForColorTmpValueForIdx0  = valueHolderForColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForColorTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForColorTmpValueForIdx1  = valueHolderForColorTmpValue as number
                valueSerializer.writeNumber(valueHolderForColorTmpValueForIdx1)
            } else if (valueHolderForColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForColorTmpValueForIdx2  = valueHolderForColorTmpValue as string
                valueSerializer.writeString(valueHolderForColorTmpValueForIdx2)
            } else if (valueHolderForColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForColorTmpValueForIdx3  = valueHolderForColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFont  = value.font
        if (valueHolderForFont !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFontTmpValue  = valueHolderForFont!
            Font_serializer.write(valueSerializer, valueHolderForFontTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PickerTextStyle {
        let valueDeserializer : DeserializerBase = buffer
        const colorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let colorTmpBuf : ResourceColor | undefined = undefined
        if ((colorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const colorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let colorTmpBuf_ : Color | number | string | Resource | undefined
            if (colorTmpBuf_UnionSelector == (0).toChar()) {
                colorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (colorTmpBuf_UnionSelector == (1).toChar()) {
                colorTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (colorTmpBuf_UnionSelector == (2).toChar()) {
                colorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (colorTmpBuf_UnionSelector == (3).toChar()) {
                colorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for colorTmpBuf_ has to be chosen through deserialisation.")
            }
            colorTmpBuf = (colorTmpBuf_ as Color | number | string | Resource)
        }
        const colorTmpResult : ResourceColor | undefined = colorTmpBuf
        const fontTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fontTmpBuf : Font | undefined = undefined
        if ((fontTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            fontTmpBuf = Font_serializer.read(valueDeserializer)
        }
        const fontTmpResult : Font | undefined = fontTmpBuf
        let value : PickerTextStyle = ({color: colorTmpResult, font: fontTmpResult} as PickerTextStyle)
        return value
    }
}
export class PopupCommonOptions_serializer {
    public static write(buffer: SerializerBase, value: PopupCommonOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForPlacement  = value.placement
        if (valueHolderForPlacement !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPlacementTmpValue  = (valueHolderForPlacement as Placement)
            valueSerializer.writeInt32(valueHolderForPlacementTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPopupColor  = value.popupColor
        if (valueHolderForPopupColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPopupColorTmpValue  = valueHolderForPopupColor!
            if (valueHolderForPopupColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForPopupColorTmpValueForIdx0  = valueHolderForPopupColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForPopupColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForPopupColorTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForPopupColorTmpValueForIdx1  = valueHolderForPopupColorTmpValue as number
                valueSerializer.writeNumber(valueHolderForPopupColorTmpValueForIdx1)
            } else if (valueHolderForPopupColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForPopupColorTmpValueForIdx2  = valueHolderForPopupColorTmpValue as string
                valueSerializer.writeString(valueHolderForPopupColorTmpValueForIdx2)
            } else if (valueHolderForPopupColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForPopupColorTmpValueForIdx3  = valueHolderForPopupColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForPopupColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableArrow  = value.enableArrow
        if (valueHolderForEnableArrow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableArrowTmpValue  = valueHolderForEnableArrow!
            valueSerializer.writeBoolean(valueHolderForEnableArrowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAutoCancel  = value.autoCancel
        if (valueHolderForAutoCancel !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAutoCancelTmpValue  = valueHolderForAutoCancel!
            valueSerializer.writeBoolean(valueHolderForAutoCancelTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnStateChange  = value.onStateChange
        if (valueHolderForOnStateChange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnStateChangeTmpValue  = valueHolderForOnStateChange!
            valueSerializer.holdAndWriteCallback(valueHolderForOnStateChangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowOffset  = value.arrowOffset
        if (valueHolderForArrowOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowOffsetTmpValue  = valueHolderForArrowOffset!
            if (valueHolderForArrowOffsetTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx0  = valueHolderForArrowOffsetTmpValue as string
                valueSerializer.writeString(valueHolderForArrowOffsetTmpValueForIdx0)
            } else if (valueHolderForArrowOffsetTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx1  = valueHolderForArrowOffsetTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowOffsetTmpValueForIdx1)
            } else if (valueHolderForArrowOffsetTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx2  = valueHolderForArrowOffsetTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForArrowOffsetTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShowInSubWindow  = value.showInSubWindow
        if (valueHolderForShowInSubWindow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShowInSubWindowTmpValue  = valueHolderForShowInSubWindow!
            valueSerializer.writeBoolean(valueHolderForShowInSubWindowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMask  = value.mask
        if (valueHolderForMask !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMaskTmpValue  = valueHolderForMask!
            if (valueHolderForMaskTmpValue instanceof boolean) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForMaskTmpValueForIdx0  = valueHolderForMaskTmpValue as boolean
                valueSerializer.writeBoolean(valueHolderForMaskTmpValueForIdx0)
            } else if (valueHolderForMaskTmpValue instanceof PopupMaskType) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForMaskTmpValueForIdx1  = valueHolderForMaskTmpValue as PopupMaskType
                PopupMaskType_serializer.write(valueSerializer, valueHolderForMaskTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTargetSpace  = value.targetSpace
        if (valueHolderForTargetSpace !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTargetSpaceTmpValue  = valueHolderForTargetSpace!
            if (valueHolderForTargetSpaceTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx0  = valueHolderForTargetSpaceTmpValue as string
                valueSerializer.writeString(valueHolderForTargetSpaceTmpValueForIdx0)
            } else if (valueHolderForTargetSpaceTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx1  = valueHolderForTargetSpaceTmpValue as number
                valueSerializer.writeNumber(valueHolderForTargetSpaceTmpValueForIdx1)
            } else if (valueHolderForTargetSpaceTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx2  = valueHolderForTargetSpaceTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForTargetSpaceTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOffset  = value.offset
        if (valueHolderForOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetTmpValue  = valueHolderForOffset!
            Position_serializer.write(valueSerializer, valueHolderForOffsetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForWidth  = value.width
        if (valueHolderForWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForWidthTmpValue  = valueHolderForWidth!
            if (valueHolderForWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForWidthTmpValueForIdx0  = valueHolderForWidthTmpValue as string
                valueSerializer.writeString(valueHolderForWidthTmpValueForIdx0)
            } else if (valueHolderForWidthTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForWidthTmpValueForIdx1  = valueHolderForWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForWidthTmpValueForIdx1)
            } else if (valueHolderForWidthTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForWidthTmpValueForIdx2  = valueHolderForWidthTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowPointPosition  = value.arrowPointPosition
        if (valueHolderForArrowPointPosition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowPointPositionTmpValue  = (valueHolderForArrowPointPosition as ArrowPointPosition)
            valueSerializer.writeInt32(valueHolderForArrowPointPositionTmpValue.getOrdinal())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowWidth  = value.arrowWidth
        if (valueHolderForArrowWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowWidthTmpValue  = valueHolderForArrowWidth!
            if (valueHolderForArrowWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowWidthTmpValueForIdx0  = valueHolderForArrowWidthTmpValue as string
                valueSerializer.writeString(valueHolderForArrowWidthTmpValueForIdx0)
            } else if (valueHolderForArrowWidthTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowWidthTmpValueForIdx1  = valueHolderForArrowWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowWidthTmpValueForIdx1)
            } else if (valueHolderForArrowWidthTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowWidthTmpValueForIdx2  = valueHolderForArrowWidthTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForArrowWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowHeight  = value.arrowHeight
        if (valueHolderForArrowHeight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowHeightTmpValue  = valueHolderForArrowHeight!
            if (valueHolderForArrowHeightTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowHeightTmpValueForIdx0  = valueHolderForArrowHeightTmpValue as string
                valueSerializer.writeString(valueHolderForArrowHeightTmpValueForIdx0)
            } else if (valueHolderForArrowHeightTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowHeightTmpValueForIdx1  = valueHolderForArrowHeightTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowHeightTmpValueForIdx1)
            } else if (valueHolderForArrowHeightTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowHeightTmpValueForIdx2  = valueHolderForArrowHeightTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForArrowHeightTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRadius  = value.radius
        if (valueHolderForRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRadiusTmpValue  = valueHolderForRadius!
            if (valueHolderForRadiusTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForRadiusTmpValueForIdx0  = valueHolderForRadiusTmpValue as string
                valueSerializer.writeString(valueHolderForRadiusTmpValueForIdx0)
            } else if (valueHolderForRadiusTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForRadiusTmpValueForIdx1  = valueHolderForRadiusTmpValue as number
                valueSerializer.writeNumber(valueHolderForRadiusTmpValueForIdx1)
            } else if (valueHolderForRadiusTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForRadiusTmpValueForIdx2  = valueHolderForRadiusTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForRadiusTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShadow  = value.shadow
        if (valueHolderForShadow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShadowTmpValue  = valueHolderForShadow!
            if (valueHolderForShadowTmpValue instanceof ShadowOptions) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForShadowTmpValueForIdx0  = valueHolderForShadowTmpValue as ShadowOptions
                ShadowOptions_serializer.write(valueSerializer, valueHolderForShadowTmpValueForIdx0)
            } else if (valueHolderForShadowTmpValue instanceof ShadowStyle) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForShadowTmpValueForIdx1  = valueHolderForShadowTmpValue as ShadowStyle
                valueSerializer.writeInt32(valueHolderForShadowTmpValueForIdx1.valueOf())
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundBlurStyle  = value.backgroundBlurStyle
        if (valueHolderForBackgroundBlurStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundBlurStyleTmpValue  = (valueHolderForBackgroundBlurStyle as BlurStyle)
            valueSerializer.writeInt32(valueHolderForBackgroundBlurStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFocusable  = value.focusable
        if (valueHolderForFocusable !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFocusableTmpValue  = valueHolderForFocusable!
            valueSerializer.writeBoolean(valueHolderForFocusableTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTransition  = value.transition
        if (valueHolderForTransition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTransitionTmpValue  = valueHolderForTransition!
            TransitionEffect_serializer.write(valueSerializer, valueHolderForTransitionTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillDismiss  = value.onWillDismiss
        if (valueHolderForOnWillDismiss !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillDismissTmpValue  = valueHolderForOnWillDismiss!
            if (valueHolderForOnWillDismissTmpValue instanceof boolean) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOnWillDismissTmpValueForIdx0  = valueHolderForOnWillDismissTmpValue as boolean
                valueSerializer.writeBoolean(valueHolderForOnWillDismissTmpValueForIdx0)
            } else if (valueHolderForOnWillDismissTmpValue instanceof ((value0: DismissPopupAction) => void)) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOnWillDismissTmpValueForIdx1  = valueHolderForOnWillDismissTmpValue as ((value0: DismissPopupAction) => void)
                valueSerializer.holdAndWriteCallback(valueHolderForOnWillDismissTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableHoverMode  = value.enableHoverMode
        if (valueHolderForEnableHoverMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableHoverModeTmpValue  = valueHolderForEnableHoverMode!
            valueSerializer.writeBoolean(valueHolderForEnableHoverModeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFollowTransformOfTarget  = value.followTransformOfTarget
        if (valueHolderForFollowTransformOfTarget !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFollowTransformOfTargetTmpValue  = valueHolderForFollowTransformOfTarget!
            valueSerializer.writeBoolean(valueHolderForFollowTransformOfTargetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PopupCommonOptions {
        let valueDeserializer : DeserializerBase = buffer
        const placementTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let placementTmpBuf : Placement | undefined = undefined
        if ((placementTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            placementTmpBuf = Placement.fromValue(valueDeserializer.readInt32())
        }
        const placementTmpResult : Placement | undefined = placementTmpBuf
        const popupColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let popupColorTmpBuf : ResourceColor | undefined = undefined
        if ((popupColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const popupColorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let popupColorTmpBuf_ : Color | number | string | Resource | undefined
            if (popupColorTmpBuf_UnionSelector == (0).toChar()) {
                popupColorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (popupColorTmpBuf_UnionSelector == (1).toChar()) {
                popupColorTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (popupColorTmpBuf_UnionSelector == (2).toChar()) {
                popupColorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (popupColorTmpBuf_UnionSelector == (3).toChar()) {
                popupColorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for popupColorTmpBuf_ has to be chosen through deserialisation.")
            }
            popupColorTmpBuf = (popupColorTmpBuf_ as Color | number | string | Resource)
        }
        const popupColorTmpResult : ResourceColor | undefined = popupColorTmpBuf
        const enableArrowTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableArrowTmpBuf : boolean | undefined = undefined
        if ((enableArrowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableArrowTmpBuf = valueDeserializer.readBoolean()
        }
        const enableArrowTmpResult : boolean | undefined = enableArrowTmpBuf
        const autoCancelTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let autoCancelTmpBuf : boolean | undefined = undefined
        if ((autoCancelTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            autoCancelTmpBuf = valueDeserializer.readBoolean()
        }
        const autoCancelTmpResult : boolean | undefined = autoCancelTmpBuf
        const onStateChangeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onStateChangeTmpBuf : PopupStateChangeCallback | undefined = undefined
        if ((onStateChangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onStateChangeTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onStateChangeTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onStateChangeTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onStateChangeTmpBuf = (event: PopupStateChangeParam):void => {
                const onStateChangeTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onStateChangeTmpBuf_BufArgsSerializer.writeInt32(onStateChangeTmpBuf_BufResource.resourceId);
                onStateChangeTmpBuf_BufArgsSerializer.writePointer(onStateChangeTmpBuf_BufCall);
                onStateChangeTmpBuf_BufArgsSerializer.writePointer(onStateChangeTmpBuf_BufCallSync);
                PopupStateChangeParam_serializer.write(onStateChangeTmpBuf_BufArgsSerializer, event);
                InteropNativeModule._CallCallbackSync(10, -1444325632, onStateChangeTmpBuf_BufArgsSerializer.asBuffer(), onStateChangeTmpBuf_BufArgsSerializer.length());
                onStateChangeTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onStateChangeTmpResult : PopupStateChangeCallback | undefined = onStateChangeTmpBuf
        const arrowOffsetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowOffsetTmpBuf : Length | undefined = undefined
        if ((arrowOffsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowOffsetTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let arrowOffsetTmpBuf_ : string | number | Resource | undefined
            if (arrowOffsetTmpBuf_UnionSelector == (0).toChar()) {
                arrowOffsetTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (arrowOffsetTmpBuf_UnionSelector == (1).toChar()) {
                arrowOffsetTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (arrowOffsetTmpBuf_UnionSelector == (2).toChar()) {
                arrowOffsetTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for arrowOffsetTmpBuf_ has to be chosen through deserialisation.")
            }
            arrowOffsetTmpBuf = (arrowOffsetTmpBuf_ as string | number | Resource)
        }
        const arrowOffsetTmpResult : Length | undefined = arrowOffsetTmpBuf
        const showInSubWindowTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let showInSubWindowTmpBuf : boolean | undefined = undefined
        if ((showInSubWindowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            showInSubWindowTmpBuf = valueDeserializer.readBoolean()
        }
        const showInSubWindowTmpResult : boolean | undefined = showInSubWindowTmpBuf
        const maskTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let maskTmpBuf : boolean | PopupMaskType | undefined = undefined
        if ((maskTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const maskTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let maskTmpBuf_ : boolean | PopupMaskType | undefined
            if (maskTmpBuf_UnionSelector == (0).toChar()) {
                maskTmpBuf_ = valueDeserializer.readBoolean()
            } else if (maskTmpBuf_UnionSelector == (1).toChar()) {
                maskTmpBuf_ = PopupMaskType_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for maskTmpBuf_ has to be chosen through deserialisation.")
            }
            maskTmpBuf = (maskTmpBuf_ as boolean | PopupMaskType)
        }
        const maskTmpResult : boolean | PopupMaskType | undefined = maskTmpBuf
        const targetSpaceTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let targetSpaceTmpBuf : Length | undefined = undefined
        if ((targetSpaceTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const targetSpaceTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let targetSpaceTmpBuf_ : string | number | Resource | undefined
            if (targetSpaceTmpBuf_UnionSelector == (0).toChar()) {
                targetSpaceTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (targetSpaceTmpBuf_UnionSelector == (1).toChar()) {
                targetSpaceTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (targetSpaceTmpBuf_UnionSelector == (2).toChar()) {
                targetSpaceTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for targetSpaceTmpBuf_ has to be chosen through deserialisation.")
            }
            targetSpaceTmpBuf = (targetSpaceTmpBuf_ as string | number | Resource)
        }
        const targetSpaceTmpResult : Length | undefined = targetSpaceTmpBuf
        const offsetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offsetTmpBuf : Position | undefined = undefined
        if ((offsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            offsetTmpBuf = Position_serializer.read(valueDeserializer)
        }
        const offsetTmpResult : Position | undefined = offsetTmpBuf
        const widthTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let widthTmpBuf : Dimension | undefined = undefined
        if ((widthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const widthTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let widthTmpBuf_ : string | number | Resource | undefined
            if (widthTmpBuf_UnionSelector == (0).toChar()) {
                widthTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (widthTmpBuf_UnionSelector == (1).toChar()) {
                widthTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (widthTmpBuf_UnionSelector == (2).toChar()) {
                widthTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for widthTmpBuf_ has to be chosen through deserialisation.")
            }
            widthTmpBuf = (widthTmpBuf_ as string | number | Resource)
        }
        const widthTmpResult : Dimension | undefined = widthTmpBuf
        const arrowPointPositionTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowPointPositionTmpBuf : ArrowPointPosition | undefined = undefined
        if ((arrowPointPositionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            arrowPointPositionTmpBuf = ArrowPointPosition.values()[valueDeserializer.readInt32()]
        }
        const arrowPointPositionTmpResult : ArrowPointPosition | undefined = arrowPointPositionTmpBuf
        const arrowWidthTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowWidthTmpBuf : Dimension | undefined = undefined
        if ((arrowWidthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowWidthTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let arrowWidthTmpBuf_ : string | number | Resource | undefined
            if (arrowWidthTmpBuf_UnionSelector == (0).toChar()) {
                arrowWidthTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (arrowWidthTmpBuf_UnionSelector == (1).toChar()) {
                arrowWidthTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (arrowWidthTmpBuf_UnionSelector == (2).toChar()) {
                arrowWidthTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for arrowWidthTmpBuf_ has to be chosen through deserialisation.")
            }
            arrowWidthTmpBuf = (arrowWidthTmpBuf_ as string | number | Resource)
        }
        const arrowWidthTmpResult : Dimension | undefined = arrowWidthTmpBuf
        const arrowHeightTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowHeightTmpBuf : Dimension | undefined = undefined
        if ((arrowHeightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowHeightTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let arrowHeightTmpBuf_ : string | number | Resource | undefined
            if (arrowHeightTmpBuf_UnionSelector == (0).toChar()) {
                arrowHeightTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (arrowHeightTmpBuf_UnionSelector == (1).toChar()) {
                arrowHeightTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (arrowHeightTmpBuf_UnionSelector == (2).toChar()) {
                arrowHeightTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for arrowHeightTmpBuf_ has to be chosen through deserialisation.")
            }
            arrowHeightTmpBuf = (arrowHeightTmpBuf_ as string | number | Resource)
        }
        const arrowHeightTmpResult : Dimension | undefined = arrowHeightTmpBuf
        const radiusTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let radiusTmpBuf : Dimension | undefined = undefined
        if ((radiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const radiusTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let radiusTmpBuf_ : string | number | Resource | undefined
            if (radiusTmpBuf_UnionSelector == (0).toChar()) {
                radiusTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (radiusTmpBuf_UnionSelector == (1).toChar()) {
                radiusTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (radiusTmpBuf_UnionSelector == (2).toChar()) {
                radiusTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for radiusTmpBuf_ has to be chosen through deserialisation.")
            }
            radiusTmpBuf = (radiusTmpBuf_ as string | number | Resource)
        }
        const radiusTmpResult : Dimension | undefined = radiusTmpBuf
        const shadowTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let shadowTmpBuf : ShadowOptions | ShadowStyle | undefined = undefined
        if ((shadowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const shadowTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let shadowTmpBuf_ : ShadowOptions | ShadowStyle | undefined
            if (shadowTmpBuf_UnionSelector == (0).toChar()) {
                shadowTmpBuf_ = ShadowOptions_serializer.read(valueDeserializer)
            } else if (shadowTmpBuf_UnionSelector == (1).toChar()) {
                shadowTmpBuf_ = ShadowStyle.fromValue(valueDeserializer.readInt32())
            } else {
                throw new Error("One of the branches for shadowTmpBuf_ has to be chosen through deserialisation.")
            }
            shadowTmpBuf = (shadowTmpBuf_ as ShadowOptions | ShadowStyle)
        }
        const shadowTmpResult : ShadowOptions | ShadowStyle | undefined = shadowTmpBuf
        const backgroundBlurStyleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundBlurStyleTmpBuf : BlurStyle | undefined = undefined
        if ((backgroundBlurStyleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundBlurStyleTmpBuf = BlurStyle.fromValue(valueDeserializer.readInt32())
        }
        const backgroundBlurStyleTmpResult : BlurStyle | undefined = backgroundBlurStyleTmpBuf
        const focusableTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let focusableTmpBuf : boolean | undefined = undefined
        if ((focusableTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            focusableTmpBuf = valueDeserializer.readBoolean()
        }
        const focusableTmpResult : boolean | undefined = focusableTmpBuf
        const transitionTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let transitionTmpBuf : TransitionEffect | undefined = undefined
        if ((transitionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            transitionTmpBuf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transitionTmpResult : TransitionEffect | undefined = transitionTmpBuf
        const onWillDismissTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillDismissTmpBuf : boolean | ((value0: DismissPopupAction) => void) | undefined = undefined
        if ((onWillDismissTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillDismissTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let onWillDismissTmpBuf_ : boolean | ((value0: DismissPopupAction) => void) | undefined
            if (onWillDismissTmpBuf_UnionSelector == (0).toChar()) {
                onWillDismissTmpBuf_ = valueDeserializer.readBoolean()
            } else if (onWillDismissTmpBuf_UnionSelector == (1).toChar()) {
                const onWillDismissTmpBuf_BufUBufResource : CallbackResource = valueDeserializer.readCallbackResource()
                const onWillDismissTmpBuf_BufUBufCall : KPointer = valueDeserializer.readPointer()
                const onWillDismissTmpBuf_BufUBufCallSync : KPointer = valueDeserializer.readPointer()
                onWillDismissTmpBuf_ = (value0: DismissPopupAction):void => {
                    const onWillDismissTmpBuf_BufUBufArgsSerializer : SerializerBase = SerializerBase.hold();
                    onWillDismissTmpBuf_BufUBufArgsSerializer.writeInt32(onWillDismissTmpBuf_BufUBufResource.resourceId);
                    onWillDismissTmpBuf_BufUBufArgsSerializer.writePointer(onWillDismissTmpBuf_BufUBufCall);
                    onWillDismissTmpBuf_BufUBufArgsSerializer.writePointer(onWillDismissTmpBuf_BufUBufCallSync);
                    DismissPopupAction_serializer.write(onWillDismissTmpBuf_BufUBufArgsSerializer, value0);
                    InteropNativeModule._CallCallbackSync(10, -2004166751, onWillDismissTmpBuf_BufUBufArgsSerializer.asBuffer(), onWillDismissTmpBuf_BufUBufArgsSerializer.length());
                    onWillDismissTmpBuf_BufUBufArgsSerializer.release();
                    return;
                }
            } else {
                throw new Error("One of the branches for onWillDismissTmpBuf_ has to be chosen through deserialisation.")
            }
            onWillDismissTmpBuf = (onWillDismissTmpBuf_ as boolean | ((value0: DismissPopupAction) => void))
        }
        const onWillDismissTmpResult : boolean | ((value0: DismissPopupAction) => void) | undefined = onWillDismissTmpBuf
        const enableHoverModeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableHoverModeTmpBuf : boolean | undefined = undefined
        if ((enableHoverModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableHoverModeTmpBuf = valueDeserializer.readBoolean()
        }
        const enableHoverModeTmpResult : boolean | undefined = enableHoverModeTmpBuf
        const followTransformOfTargetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let followTransformOfTargetTmpBuf : boolean | undefined = undefined
        if ((followTransformOfTargetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            followTransformOfTargetTmpBuf = valueDeserializer.readBoolean()
        }
        const followTransformOfTargetTmpResult : boolean | undefined = followTransformOfTargetTmpBuf
        let value : PopupCommonOptions = ({placement: placementTmpResult, popupColor: popupColorTmpResult, enableArrow: enableArrowTmpResult, autoCancel: autoCancelTmpResult, onStateChange: onStateChangeTmpResult, arrowOffset: arrowOffsetTmpResult, showInSubWindow: showInSubWindowTmpResult, mask: maskTmpResult, targetSpace: targetSpaceTmpResult, offset: offsetTmpResult, width: widthTmpResult, arrowPointPosition: arrowPointPositionTmpResult, arrowWidth: arrowWidthTmpResult, arrowHeight: arrowHeightTmpResult, radius: radiusTmpResult, shadow: shadowTmpResult, backgroundBlurStyle: backgroundBlurStyleTmpResult, focusable: focusableTmpResult, transition: transitionTmpResult, onWillDismiss: onWillDismissTmpResult, enableHoverMode: enableHoverModeTmpResult, followTransformOfTarget: followTransformOfTargetTmpResult} as PopupCommonOptions)
        return value
    }
}
export class PopupMessageOptions_serializer {
    public static write(buffer: SerializerBase, value: PopupMessageOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForTextColor  = value.textColor
        if (valueHolderForTextColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTextColorTmpValue  = valueHolderForTextColor!
            if (valueHolderForTextColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForTextColorTmpValueForIdx0  = valueHolderForTextColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForTextColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForTextColorTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForTextColorTmpValueForIdx1  = valueHolderForTextColorTmpValue as number
                valueSerializer.writeNumber(valueHolderForTextColorTmpValueForIdx1)
            } else if (valueHolderForTextColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForTextColorTmpValueForIdx2  = valueHolderForTextColorTmpValue as string
                valueSerializer.writeString(valueHolderForTextColorTmpValueForIdx2)
            } else if (valueHolderForTextColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForTextColorTmpValueForIdx3  = valueHolderForTextColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForTextColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFont  = value.font
        if (valueHolderForFont !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFontTmpValue  = valueHolderForFont!
            Font_serializer.write(valueSerializer, valueHolderForFontTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PopupMessageOptions {
        let valueDeserializer : DeserializerBase = buffer
        const textColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let textColorTmpBuf : ResourceColor | undefined = undefined
        if ((textColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const textColorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let textColorTmpBuf_ : Color | number | string | Resource | undefined
            if (textColorTmpBuf_UnionSelector == (0).toChar()) {
                textColorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (textColorTmpBuf_UnionSelector == (1).toChar()) {
                textColorTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (textColorTmpBuf_UnionSelector == (2).toChar()) {
                textColorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (textColorTmpBuf_UnionSelector == (3).toChar()) {
                textColorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for textColorTmpBuf_ has to be chosen through deserialisation.")
            }
            textColorTmpBuf = (textColorTmpBuf_ as Color | number | string | Resource)
        }
        const textColorTmpResult : ResourceColor | undefined = textColorTmpBuf
        const fontTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let fontTmpBuf : Font | undefined = undefined
        if ((fontTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            fontTmpBuf = Font_serializer.read(valueDeserializer)
        }
        const fontTmpResult : Font | undefined = fontTmpBuf
        let value : PopupMessageOptions = ({textColor: textColorTmpResult, font: fontTmpResult} as PopupMessageOptions)
        return value
    }
}
export class SheetOptions_serializer {
    public static write(buffer: SerializerBase, value: SheetOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForBackgroundColor  = value.backgroundColor
        if (valueHolderForBackgroundColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundColorTmpValue  = valueHolderForBackgroundColor!
            if (valueHolderForBackgroundColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx0  = valueHolderForBackgroundColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForBackgroundColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForBackgroundColorTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx1  = valueHolderForBackgroundColorTmpValue as number
                valueSerializer.writeNumber(valueHolderForBackgroundColorTmpValueForIdx1)
            } else if (valueHolderForBackgroundColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx2  = valueHolderForBackgroundColorTmpValue as string
                valueSerializer.writeString(valueHolderForBackgroundColorTmpValueForIdx2)
            } else if (valueHolderForBackgroundColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForBackgroundColorTmpValueForIdx3  = valueHolderForBackgroundColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForBackgroundColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnAppear  = value.onAppear
        if (valueHolderForOnAppear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnAppearTmpValue  = valueHolderForOnAppear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnAppearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnDisappear  = value.onDisappear
        if (valueHolderForOnDisappear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnDisappearTmpValue  = valueHolderForOnDisappear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnDisappearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillAppear  = value.onWillAppear
        if (valueHolderForOnWillAppear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillAppearTmpValue  = valueHolderForOnWillAppear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnWillAppearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillDisappear  = value.onWillDisappear
        if (valueHolderForOnWillDisappear !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillDisappearTmpValue  = valueHolderForOnWillDisappear!
            valueSerializer.holdAndWriteCallback(valueHolderForOnWillDisappearTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHeight  = value.height
        if (valueHolderForHeight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHeightTmpValue  = valueHolderForHeight!
            if (valueHolderForHeightTmpValue instanceof SheetSize) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForHeightTmpValueForIdx0  = valueHolderForHeightTmpValue as SheetSize
                valueSerializer.writeInt32(valueHolderForHeightTmpValueForIdx0.valueOf())
            } else if (valueHolderForHeightTmpValue instanceof Length) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForHeightTmpValueForIdx1  = valueHolderForHeightTmpValue as Length
                if (valueHolderForHeightTmpValueForIdx1 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForHeightTmpValueForIdx1ForIdx0  = valueHolderForHeightTmpValueForIdx1 as string
                    valueSerializer.writeString(valueHolderForHeightTmpValueForIdx1ForIdx0)
                } else if (valueHolderForHeightTmpValueForIdx1 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForHeightTmpValueForIdx1ForIdx1  = valueHolderForHeightTmpValueForIdx1 as number
                    valueSerializer.writeNumber(valueHolderForHeightTmpValueForIdx1ForIdx1)
                } else if (valueHolderForHeightTmpValueForIdx1 instanceof Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForHeightTmpValueForIdx1ForIdx2  = valueHolderForHeightTmpValueForIdx1 as Resource
                    Resource_serializer.write(valueSerializer, valueHolderForHeightTmpValueForIdx1ForIdx2)
                }
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDragBar  = value.dragBar
        if (valueHolderForDragBar !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDragBarTmpValue  = valueHolderForDragBar!
            valueSerializer.writeBoolean(valueHolderForDragBarTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMaskColor  = value.maskColor
        if (valueHolderForMaskColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMaskColorTmpValue  = valueHolderForMaskColor!
            if (valueHolderForMaskColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForMaskColorTmpValueForIdx0  = valueHolderForMaskColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForMaskColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForMaskColorTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForMaskColorTmpValueForIdx1  = valueHolderForMaskColorTmpValue as number
                valueSerializer.writeNumber(valueHolderForMaskColorTmpValueForIdx1)
            } else if (valueHolderForMaskColorTmpValue instanceof string) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForMaskColorTmpValueForIdx2  = valueHolderForMaskColorTmpValue as string
                valueSerializer.writeString(valueHolderForMaskColorTmpValueForIdx2)
            } else if (valueHolderForMaskColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForMaskColorTmpValueForIdx3  = valueHolderForMaskColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForMaskColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDetents  = value.detents
        if (valueHolderForDetents !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDetentsTmpValue  = valueHolderForDetents!
            if (valueHolderForDetentsTmpValue instanceof SingleLengthDetent) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForDetentsTmpValueForIdx0  = valueHolderForDetentsTmpValue as SingleLengthDetent
                const valueHolderForDetentsTmpValueForIdx0_0  = valueHolderForDetentsTmpValueForIdx0[0]
                if (valueHolderForDetentsTmpValueForIdx0_0 instanceof SheetSize) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForDetentsTmpValueForIdx0_0ForIdx0  = valueHolderForDetentsTmpValueForIdx0_0 as SheetSize
                    valueSerializer.writeInt32(valueHolderForDetentsTmpValueForIdx0_0ForIdx0.valueOf())
                } else if (valueHolderForDetentsTmpValueForIdx0_0 instanceof Length) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForDetentsTmpValueForIdx0_0ForIdx1  = valueHolderForDetentsTmpValueForIdx0_0 as Length
                    if (valueHolderForDetentsTmpValueForIdx0_0ForIdx1 instanceof string) {
                        valueSerializer.writeInt8((0).toByte())
                        const valueHolderForDetentsTmpValueForIdx0_0ForIdx1ForIdx0  = valueHolderForDetentsTmpValueForIdx0_0ForIdx1 as string
                        valueSerializer.writeString(valueHolderForDetentsTmpValueForIdx0_0ForIdx1ForIdx0)
                    } else if (valueHolderForDetentsTmpValueForIdx0_0ForIdx1 instanceof number) {
                        valueSerializer.writeInt8((1).toByte())
                        const valueHolderForDetentsTmpValueForIdx0_0ForIdx1ForIdx1  = valueHolderForDetentsTmpValueForIdx0_0ForIdx1 as number
                        valueSerializer.writeNumber(valueHolderForDetentsTmpValueForIdx0_0ForIdx1ForIdx1)
                    } else if (valueHolderForDetentsTmpValueForIdx0_0ForIdx1 instanceof Resource) {
                        valueSerializer.writeInt8((2).toByte())
                        const valueHolderForDetentsTmpValueForIdx0_0ForIdx1ForIdx2  = valueHolderForDetentsTmpValueForIdx0_0ForIdx1 as Resource
                        Resource_serializer.write(valueSerializer, valueHolderForDetentsTmpValueForIdx0_0ForIdx1ForIdx2)
                    }
                }
            } else if (valueHolderForDetentsTmpValue instanceof DoubleLengthDetents) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForDetentsTmpValueForIdx1  = valueHolderForDetentsTmpValue as DoubleLengthDetents
                const valueHolderForDetentsTmpValueForIdx1_0  = valueHolderForDetentsTmpValueForIdx1[0]
                if (valueHolderForDetentsTmpValueForIdx1_0 instanceof SheetSize) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForDetentsTmpValueForIdx1_0ForIdx0  = valueHolderForDetentsTmpValueForIdx1_0 as SheetSize
                    valueSerializer.writeInt32(valueHolderForDetentsTmpValueForIdx1_0ForIdx0.valueOf())
                } else if (valueHolderForDetentsTmpValueForIdx1_0 instanceof Length) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForDetentsTmpValueForIdx1_0ForIdx1  = valueHolderForDetentsTmpValueForIdx1_0 as Length
                    if (valueHolderForDetentsTmpValueForIdx1_0ForIdx1 instanceof string) {
                        valueSerializer.writeInt8((0).toByte())
                        const valueHolderForDetentsTmpValueForIdx1_0ForIdx1ForIdx0  = valueHolderForDetentsTmpValueForIdx1_0ForIdx1 as string
                        valueSerializer.writeString(valueHolderForDetentsTmpValueForIdx1_0ForIdx1ForIdx0)
                    } else if (valueHolderForDetentsTmpValueForIdx1_0ForIdx1 instanceof number) {
                        valueSerializer.writeInt8((1).toByte())
                        const valueHolderForDetentsTmpValueForIdx1_0ForIdx1ForIdx1  = valueHolderForDetentsTmpValueForIdx1_0ForIdx1 as number
                        valueSerializer.writeNumber(valueHolderForDetentsTmpValueForIdx1_0ForIdx1ForIdx1)
                    } else if (valueHolderForDetentsTmpValueForIdx1_0ForIdx1 instanceof Resource) {
                        valueSerializer.writeInt8((2).toByte())
                        const valueHolderForDetentsTmpValueForIdx1_0ForIdx1ForIdx2  = valueHolderForDetentsTmpValueForIdx1_0ForIdx1 as Resource
                        Resource_serializer.write(valueSerializer, valueHolderForDetentsTmpValueForIdx1_0ForIdx1ForIdx2)
                    }
                }
                const valueHolderForDetentsTmpValueForIdx1_1  = valueHolderForDetentsTmpValueForIdx1[1]
                if (valueHolderForDetentsTmpValueForIdx1_1 !== undefined) {
                    valueSerializer.writeInt8(RuntimeType.OBJECT)
                    const valueHolderForDetentsTmpValueForIdx1_1TmpValue  = valueHolderForDetentsTmpValueForIdx1_1!
                    if (valueHolderForDetentsTmpValueForIdx1_1TmpValue instanceof SheetSize) {
                        valueSerializer.writeInt8((0).toByte())
                        const valueHolderForDetentsTmpValueForIdx1_1TmpValueForIdx0  = valueHolderForDetentsTmpValueForIdx1_1TmpValue as SheetSize
                        valueSerializer.writeInt32(valueHolderForDetentsTmpValueForIdx1_1TmpValueForIdx0.valueOf())
                    } else if (valueHolderForDetentsTmpValueForIdx1_1TmpValue instanceof Length) {
                        valueSerializer.writeInt8((1).toByte())
                        const valueHolderForDetentsTmpValueForIdx1_1TmpValueForIdx1  = valueHolderForDetentsTmpValueForIdx1_1TmpValue as Length
                        if (valueHolderForDetentsTmpValueForIdx1_1TmpValueForIdx1 instanceof string) {
                            valueSerializer.writeInt8((0).toByte())
                            const valueHolderForDetentsTmpValueForIdx1_1TmpValueForIdx1ForIdx0  = valueHolderForDetentsTmpValueForIdx1_1TmpValueForIdx1 as string
                            valueSerializer.writeString(valueHolderForDetentsTmpValueForIdx1_1TmpValueForIdx1ForIdx0)
                        } else if (valueHolderForDetentsTmpValueForIdx1_1TmpValueForIdx1 instanceof number) {
                            valueSerializer.writeInt8((1).toByte())
                            const valueHolderForDetentsTmpValueForIdx1_1TmpValueForIdx1ForIdx1  = valueHolderForDetentsTmpValueForIdx1_1TmpValueForIdx1 as number
                            valueSerializer.writeNumber(valueHolderForDetentsTmpValueForIdx1_1TmpValueForIdx1ForIdx1)
                        } else if (valueHolderForDetentsTmpValueForIdx1_1TmpValueForIdx1 instanceof Resource) {
                            valueSerializer.writeInt8((2).toByte())
                            const valueHolderForDetentsTmpValueForIdx1_1TmpValueForIdx1ForIdx2  = valueHolderForDetentsTmpValueForIdx1_1TmpValueForIdx1 as Resource
                            Resource_serializer.write(valueSerializer, valueHolderForDetentsTmpValueForIdx1_1TmpValueForIdx1ForIdx2)
                        }
                    }
                } else {
                    valueSerializer.writeInt8(RuntimeType.UNDEFINED)
                }
            } else if (valueHolderForDetentsTmpValue instanceof TripleLengthDetents) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForDetentsTmpValueForIdx2  = valueHolderForDetentsTmpValue as TripleLengthDetents
                const valueHolderForDetentsTmpValueForIdx2_0  = valueHolderForDetentsTmpValueForIdx2[0]
                if (valueHolderForDetentsTmpValueForIdx2_0 instanceof SheetSize) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForDetentsTmpValueForIdx2_0ForIdx0  = valueHolderForDetentsTmpValueForIdx2_0 as SheetSize
                    valueSerializer.writeInt32(valueHolderForDetentsTmpValueForIdx2_0ForIdx0.valueOf())
                } else if (valueHolderForDetentsTmpValueForIdx2_0 instanceof Length) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForDetentsTmpValueForIdx2_0ForIdx1  = valueHolderForDetentsTmpValueForIdx2_0 as Length
                    if (valueHolderForDetentsTmpValueForIdx2_0ForIdx1 instanceof string) {
                        valueSerializer.writeInt8((0).toByte())
                        const valueHolderForDetentsTmpValueForIdx2_0ForIdx1ForIdx0  = valueHolderForDetentsTmpValueForIdx2_0ForIdx1 as string
                        valueSerializer.writeString(valueHolderForDetentsTmpValueForIdx2_0ForIdx1ForIdx0)
                    } else if (valueHolderForDetentsTmpValueForIdx2_0ForIdx1 instanceof number) {
                        valueSerializer.writeInt8((1).toByte())
                        const valueHolderForDetentsTmpValueForIdx2_0ForIdx1ForIdx1  = valueHolderForDetentsTmpValueForIdx2_0ForIdx1 as number
                        valueSerializer.writeNumber(valueHolderForDetentsTmpValueForIdx2_0ForIdx1ForIdx1)
                    } else if (valueHolderForDetentsTmpValueForIdx2_0ForIdx1 instanceof Resource) {
                        valueSerializer.writeInt8((2).toByte())
                        const valueHolderForDetentsTmpValueForIdx2_0ForIdx1ForIdx2  = valueHolderForDetentsTmpValueForIdx2_0ForIdx1 as Resource
                        Resource_serializer.write(valueSerializer, valueHolderForDetentsTmpValueForIdx2_0ForIdx1ForIdx2)
                    }
                }
                const valueHolderForDetentsTmpValueForIdx2_1  = valueHolderForDetentsTmpValueForIdx2[1]
                if (valueHolderForDetentsTmpValueForIdx2_1 !== undefined) {
                    valueSerializer.writeInt8(RuntimeType.OBJECT)
                    const valueHolderForDetentsTmpValueForIdx2_1TmpValue  = valueHolderForDetentsTmpValueForIdx2_1!
                    if (valueHolderForDetentsTmpValueForIdx2_1TmpValue instanceof SheetSize) {
                        valueSerializer.writeInt8((0).toByte())
                        const valueHolderForDetentsTmpValueForIdx2_1TmpValueForIdx0  = valueHolderForDetentsTmpValueForIdx2_1TmpValue as SheetSize
                        valueSerializer.writeInt32(valueHolderForDetentsTmpValueForIdx2_1TmpValueForIdx0.valueOf())
                    } else if (valueHolderForDetentsTmpValueForIdx2_1TmpValue instanceof Length) {
                        valueSerializer.writeInt8((1).toByte())
                        const valueHolderForDetentsTmpValueForIdx2_1TmpValueForIdx1  = valueHolderForDetentsTmpValueForIdx2_1TmpValue as Length
                        if (valueHolderForDetentsTmpValueForIdx2_1TmpValueForIdx1 instanceof string) {
                            valueSerializer.writeInt8((0).toByte())
                            const valueHolderForDetentsTmpValueForIdx2_1TmpValueForIdx1ForIdx0  = valueHolderForDetentsTmpValueForIdx2_1TmpValueForIdx1 as string
                            valueSerializer.writeString(valueHolderForDetentsTmpValueForIdx2_1TmpValueForIdx1ForIdx0)
                        } else if (valueHolderForDetentsTmpValueForIdx2_1TmpValueForIdx1 instanceof number) {
                            valueSerializer.writeInt8((1).toByte())
                            const valueHolderForDetentsTmpValueForIdx2_1TmpValueForIdx1ForIdx1  = valueHolderForDetentsTmpValueForIdx2_1TmpValueForIdx1 as number
                            valueSerializer.writeNumber(valueHolderForDetentsTmpValueForIdx2_1TmpValueForIdx1ForIdx1)
                        } else if (valueHolderForDetentsTmpValueForIdx2_1TmpValueForIdx1 instanceof Resource) {
                            valueSerializer.writeInt8((2).toByte())
                            const valueHolderForDetentsTmpValueForIdx2_1TmpValueForIdx1ForIdx2  = valueHolderForDetentsTmpValueForIdx2_1TmpValueForIdx1 as Resource
                            Resource_serializer.write(valueSerializer, valueHolderForDetentsTmpValueForIdx2_1TmpValueForIdx1ForIdx2)
                        }
                    }
                } else {
                    valueSerializer.writeInt8(RuntimeType.UNDEFINED)
                }
                const valueHolderForDetentsTmpValueForIdx2_2  = valueHolderForDetentsTmpValueForIdx2[2]
                if (valueHolderForDetentsTmpValueForIdx2_2 !== undefined) {
                    valueSerializer.writeInt8(RuntimeType.OBJECT)
                    const valueHolderForDetentsTmpValueForIdx2_2TmpValue  = valueHolderForDetentsTmpValueForIdx2_2!
                    if (valueHolderForDetentsTmpValueForIdx2_2TmpValue instanceof SheetSize) {
                        valueSerializer.writeInt8((0).toByte())
                        const valueHolderForDetentsTmpValueForIdx2_2TmpValueForIdx0  = valueHolderForDetentsTmpValueForIdx2_2TmpValue as SheetSize
                        valueSerializer.writeInt32(valueHolderForDetentsTmpValueForIdx2_2TmpValueForIdx0.valueOf())
                    } else if (valueHolderForDetentsTmpValueForIdx2_2TmpValue instanceof Length) {
                        valueSerializer.writeInt8((1).toByte())
                        const valueHolderForDetentsTmpValueForIdx2_2TmpValueForIdx1  = valueHolderForDetentsTmpValueForIdx2_2TmpValue as Length
                        if (valueHolderForDetentsTmpValueForIdx2_2TmpValueForIdx1 instanceof string) {
                            valueSerializer.writeInt8((0).toByte())
                            const valueHolderForDetentsTmpValueForIdx2_2TmpValueForIdx1ForIdx0  = valueHolderForDetentsTmpValueForIdx2_2TmpValueForIdx1 as string
                            valueSerializer.writeString(valueHolderForDetentsTmpValueForIdx2_2TmpValueForIdx1ForIdx0)
                        } else if (valueHolderForDetentsTmpValueForIdx2_2TmpValueForIdx1 instanceof number) {
                            valueSerializer.writeInt8((1).toByte())
                            const valueHolderForDetentsTmpValueForIdx2_2TmpValueForIdx1ForIdx1  = valueHolderForDetentsTmpValueForIdx2_2TmpValueForIdx1 as number
                            valueSerializer.writeNumber(valueHolderForDetentsTmpValueForIdx2_2TmpValueForIdx1ForIdx1)
                        } else if (valueHolderForDetentsTmpValueForIdx2_2TmpValueForIdx1 instanceof Resource) {
                            valueSerializer.writeInt8((2).toByte())
                            const valueHolderForDetentsTmpValueForIdx2_2TmpValueForIdx1ForIdx2  = valueHolderForDetentsTmpValueForIdx2_2TmpValueForIdx1 as Resource
                            Resource_serializer.write(valueSerializer, valueHolderForDetentsTmpValueForIdx2_2TmpValueForIdx1ForIdx2)
                        }
                    }
                } else {
                    valueSerializer.writeInt8(RuntimeType.UNDEFINED)
                }
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBlurStyle  = value.blurStyle
        if (valueHolderForBlurStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBlurStyleTmpValue  = (valueHolderForBlurStyle as BlurStyle)
            valueSerializer.writeInt32(valueHolderForBlurStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShowClose  = value.showClose
        if (valueHolderForShowClose !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShowCloseTmpValue  = valueHolderForShowClose!
            if (valueHolderForShowCloseTmpValue instanceof boolean) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForShowCloseTmpValueForIdx0  = valueHolderForShowCloseTmpValue as boolean
                valueSerializer.writeBoolean(valueHolderForShowCloseTmpValueForIdx0)
            } else if (valueHolderForShowCloseTmpValue instanceof Resource) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForShowCloseTmpValueForIdx1  = valueHolderForShowCloseTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForShowCloseTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPreferType  = value.preferType
        if (valueHolderForPreferType !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPreferTypeTmpValue  = (valueHolderForPreferType as SheetType)
            valueSerializer.writeInt32(valueHolderForPreferTypeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTitle  = value.title
        if (valueHolderForTitle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTitleTmpValue  = valueHolderForTitle!
            if (valueHolderForTitleTmpValue instanceof SheetTitleOptions) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForTitleTmpValueForIdx0  = valueHolderForTitleTmpValue as SheetTitleOptions
                SheetTitleOptions_serializer.write(valueSerializer, valueHolderForTitleTmpValueForIdx0)
            } else if (valueHolderForTitleTmpValue instanceof CustomBuilder) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForTitleTmpValueForIdx1  = valueHolderForTitleTmpValue as CustomBuilder
                valueSerializer.holdAndWriteCallback(CallbackTransformer.transformFromCustomBuilder(valueHolderForTitleTmpValueForIdx1))
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShouldDismiss  = value.shouldDismiss
        if (valueHolderForShouldDismiss !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShouldDismissTmpValue  = valueHolderForShouldDismiss!
            valueSerializer.holdAndWriteCallback(valueHolderForShouldDismissTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillDismiss  = value.onWillDismiss
        if (valueHolderForOnWillDismiss !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillDismissTmpValue  = valueHolderForOnWillDismiss!
            valueSerializer.holdAndWriteCallback(valueHolderForOnWillDismissTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillSpringBackWhenDismiss  = value.onWillSpringBackWhenDismiss
        if (valueHolderForOnWillSpringBackWhenDismiss !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillSpringBackWhenDismissTmpValue  = valueHolderForOnWillSpringBackWhenDismiss!
            valueSerializer.holdAndWriteCallback(valueHolderForOnWillSpringBackWhenDismissTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableOutsideInteractive  = value.enableOutsideInteractive
        if (valueHolderForEnableOutsideInteractive !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableOutsideInteractiveTmpValue  = valueHolderForEnableOutsideInteractive!
            valueSerializer.writeBoolean(valueHolderForEnableOutsideInteractiveTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForWidth  = value.width
        if (valueHolderForWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForWidthTmpValue  = valueHolderForWidth!
            if (valueHolderForWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForWidthTmpValueForIdx0  = valueHolderForWidthTmpValue as string
                valueSerializer.writeString(valueHolderForWidthTmpValueForIdx0)
            } else if (valueHolderForWidthTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForWidthTmpValueForIdx1  = valueHolderForWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForWidthTmpValueForIdx1)
            } else if (valueHolderForWidthTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForWidthTmpValueForIdx2  = valueHolderForWidthTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBorderWidth  = value.borderWidth
        if (valueHolderForBorderWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBorderWidthTmpValue  = valueHolderForBorderWidth!
            if (valueHolderForBorderWidthTmpValue instanceof Dimension) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBorderWidthTmpValueForIdx0  = valueHolderForBorderWidthTmpValue as Dimension
                if (valueHolderForBorderWidthTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForBorderWidthTmpValueForIdx0ForIdx0  = valueHolderForBorderWidthTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForBorderWidthTmpValueForIdx0ForIdx0)
                } else if (valueHolderForBorderWidthTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForBorderWidthTmpValueForIdx0ForIdx1  = valueHolderForBorderWidthTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForBorderWidthTmpValueForIdx0ForIdx1)
                } else if (valueHolderForBorderWidthTmpValueForIdx0 instanceof Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForBorderWidthTmpValueForIdx0ForIdx2  = valueHolderForBorderWidthTmpValueForIdx0 as Resource
                    Resource_serializer.write(valueSerializer, valueHolderForBorderWidthTmpValueForIdx0ForIdx2)
                }
            } else if (valueHolderForBorderWidthTmpValue instanceof EdgeWidths) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBorderWidthTmpValueForIdx1  = valueHolderForBorderWidthTmpValue as EdgeWidths
                EdgeWidths_serializer.write(valueSerializer, valueHolderForBorderWidthTmpValueForIdx1)
            } else if (valueHolderForBorderWidthTmpValue instanceof LocalizedEdgeWidths) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBorderWidthTmpValueForIdx2  = valueHolderForBorderWidthTmpValue as LocalizedEdgeWidths
                LocalizedEdgeWidths_serializer.write(valueSerializer, valueHolderForBorderWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBorderColor  = value.borderColor
        if (valueHolderForBorderColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBorderColorTmpValue  = valueHolderForBorderColor!
            if (valueHolderForBorderColorTmpValue instanceof ResourceColor) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBorderColorTmpValueForIdx0  = valueHolderForBorderColorTmpValue as ResourceColor
                if (valueHolderForBorderColorTmpValueForIdx0 instanceof Color) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForBorderColorTmpValueForIdx0ForIdx0  = valueHolderForBorderColorTmpValueForIdx0 as Color
                    valueSerializer.writeInt32(valueHolderForBorderColorTmpValueForIdx0ForIdx0.getOrdinal())
                } else if (valueHolderForBorderColorTmpValueForIdx0 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForBorderColorTmpValueForIdx0ForIdx1  = valueHolderForBorderColorTmpValueForIdx0 as number
                    valueSerializer.writeNumber(valueHolderForBorderColorTmpValueForIdx0ForIdx1)
                } else if (valueHolderForBorderColorTmpValueForIdx0 instanceof string) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForBorderColorTmpValueForIdx0ForIdx2  = valueHolderForBorderColorTmpValueForIdx0 as string
                    valueSerializer.writeString(valueHolderForBorderColorTmpValueForIdx0ForIdx2)
                } else if (valueHolderForBorderColorTmpValueForIdx0 instanceof Resource) {
                    valueSerializer.writeInt8((3).toByte())
                    const valueHolderForBorderColorTmpValueForIdx0ForIdx3  = valueHolderForBorderColorTmpValueForIdx0 as Resource
                    Resource_serializer.write(valueSerializer, valueHolderForBorderColorTmpValueForIdx0ForIdx3)
                }
            } else if (valueHolderForBorderColorTmpValue instanceof EdgeColors) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBorderColorTmpValueForIdx1  = valueHolderForBorderColorTmpValue as EdgeColors
                EdgeColors_serializer.write(valueSerializer, valueHolderForBorderColorTmpValueForIdx1)
            } else if (valueHolderForBorderColorTmpValue instanceof LocalizedEdgeColors) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForBorderColorTmpValueForIdx2  = valueHolderForBorderColorTmpValue as LocalizedEdgeColors
                LocalizedEdgeColors_serializer.write(valueSerializer, valueHolderForBorderColorTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBorderStyle  = value.borderStyle
        if (valueHolderForBorderStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBorderStyleTmpValue  = valueHolderForBorderStyle!
            if (valueHolderForBorderStyleTmpValue instanceof BorderStyle) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForBorderStyleTmpValueForIdx0  = valueHolderForBorderStyleTmpValue as BorderStyle
                valueSerializer.writeInt32(valueHolderForBorderStyleTmpValueForIdx0.valueOf())
            } else if (valueHolderForBorderStyleTmpValue instanceof EdgeStyles) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForBorderStyleTmpValueForIdx1  = valueHolderForBorderStyleTmpValue as EdgeStyles
                EdgeStyles_serializer.write(valueSerializer, valueHolderForBorderStyleTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShadow  = value.shadow
        if (valueHolderForShadow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShadowTmpValue  = valueHolderForShadow!
            if (valueHolderForShadowTmpValue instanceof ShadowOptions) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForShadowTmpValueForIdx0  = valueHolderForShadowTmpValue as ShadowOptions
                ShadowOptions_serializer.write(valueSerializer, valueHolderForShadowTmpValueForIdx0)
            } else if (valueHolderForShadowTmpValue instanceof ShadowStyle) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForShadowTmpValueForIdx1  = valueHolderForShadowTmpValue as ShadowStyle
                valueSerializer.writeInt32(valueHolderForShadowTmpValueForIdx1.valueOf())
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnHeightDidChange  = value.onHeightDidChange
        if (valueHolderForOnHeightDidChange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnHeightDidChangeTmpValue  = valueHolderForOnHeightDidChange!
            valueSerializer.holdAndWriteCallback(valueHolderForOnHeightDidChangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMode  = value.mode
        if (valueHolderForMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForModeTmpValue  = (valueHolderForMode as SheetMode)
            valueSerializer.writeInt32(valueHolderForModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForScrollSizeMode  = value.scrollSizeMode
        if (valueHolderForScrollSizeMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForScrollSizeModeTmpValue  = (valueHolderForScrollSizeMode as ScrollSizeMode)
            valueSerializer.writeInt32(valueHolderForScrollSizeModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnDetentsDidChange  = value.onDetentsDidChange
        if (valueHolderForOnDetentsDidChange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnDetentsDidChangeTmpValue  = valueHolderForOnDetentsDidChange!
            valueSerializer.holdAndWriteCallback(valueHolderForOnDetentsDidChangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWidthDidChange  = value.onWidthDidChange
        if (valueHolderForOnWidthDidChange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWidthDidChangeTmpValue  = valueHolderForOnWidthDidChange!
            valueSerializer.holdAndWriteCallback(valueHolderForOnWidthDidChangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnTypeDidChange  = value.onTypeDidChange
        if (valueHolderForOnTypeDidChange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnTypeDidChangeTmpValue  = valueHolderForOnTypeDidChange!
            valueSerializer.holdAndWriteCallback(valueHolderForOnTypeDidChangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForUiContext  = value.uiContext
        if (valueHolderForUiContext !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForUiContextTmpValue  = valueHolderForUiContext!
            UIContext_serializer.write(valueSerializer, valueHolderForUiContextTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForKeyboardAvoidMode  = value.keyboardAvoidMode
        if (valueHolderForKeyboardAvoidMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForKeyboardAvoidModeTmpValue  = (valueHolderForKeyboardAvoidMode as SheetKeyboardAvoidMode)
            valueSerializer.writeInt32(valueHolderForKeyboardAvoidModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableHoverMode  = value.enableHoverMode
        if (valueHolderForEnableHoverMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableHoverModeTmpValue  = valueHolderForEnableHoverMode!
            valueSerializer.writeBoolean(valueHolderForEnableHoverModeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForHoverModeArea  = value.hoverModeArea
        if (valueHolderForHoverModeArea !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForHoverModeAreaTmpValue  = (valueHolderForHoverModeArea as HoverModeAreaType)
            valueSerializer.writeInt32(valueHolderForHoverModeAreaTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOffset  = value.offset
        if (valueHolderForOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetTmpValue  = valueHolderForOffset!
            Position_serializer.write(valueSerializer, valueHolderForOffsetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEffectEdge  = value.effectEdge
        if (valueHolderForEffectEdge !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEffectEdgeTmpValue  = valueHolderForEffectEdge!
            valueSerializer.writeInt32(valueHolderForEffectEdgeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRadius  = value.radius
        if (valueHolderForRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRadiusTmpValue  = valueHolderForRadius!
            if (valueHolderForRadiusTmpValue instanceof LengthMetrics) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForRadiusTmpValueForIdx0  = valueHolderForRadiusTmpValue as LengthMetrics
                LengthMetrics_serializer.write(valueSerializer, valueHolderForRadiusTmpValueForIdx0)
            } else if (valueHolderForRadiusTmpValue instanceof BorderRadiuses) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForRadiusTmpValueForIdx1  = valueHolderForRadiusTmpValue as BorderRadiuses
                BorderRadiuses_serializer.write(valueSerializer, valueHolderForRadiusTmpValueForIdx1)
            } else if (valueHolderForRadiusTmpValue instanceof LocalizedBorderRadiuses) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForRadiusTmpValueForIdx2  = valueHolderForRadiusTmpValue as LocalizedBorderRadiuses
                LocalizedBorderRadiuses_serializer.write(valueSerializer, valueHolderForRadiusTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForDetentSelection  = value.detentSelection
        if (valueHolderForDetentSelection !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForDetentSelectionTmpValue  = valueHolderForDetentSelection!
            if (valueHolderForDetentSelectionTmpValue instanceof SheetSize) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForDetentSelectionTmpValueForIdx0  = valueHolderForDetentSelectionTmpValue as SheetSize
                valueSerializer.writeInt32(valueHolderForDetentSelectionTmpValueForIdx0.valueOf())
            } else if (valueHolderForDetentSelectionTmpValue instanceof Length) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForDetentSelectionTmpValueForIdx1  = valueHolderForDetentSelectionTmpValue as Length
                if (valueHolderForDetentSelectionTmpValueForIdx1 instanceof string) {
                    valueSerializer.writeInt8((0).toByte())
                    const valueHolderForDetentSelectionTmpValueForIdx1ForIdx0  = valueHolderForDetentSelectionTmpValueForIdx1 as string
                    valueSerializer.writeString(valueHolderForDetentSelectionTmpValueForIdx1ForIdx0)
                } else if (valueHolderForDetentSelectionTmpValueForIdx1 instanceof number) {
                    valueSerializer.writeInt8((1).toByte())
                    const valueHolderForDetentSelectionTmpValueForIdx1ForIdx1  = valueHolderForDetentSelectionTmpValueForIdx1 as number
                    valueSerializer.writeNumber(valueHolderForDetentSelectionTmpValueForIdx1ForIdx1)
                } else if (valueHolderForDetentSelectionTmpValueForIdx1 instanceof Resource) {
                    valueSerializer.writeInt8((2).toByte())
                    const valueHolderForDetentSelectionTmpValueForIdx1ForIdx2  = valueHolderForDetentSelectionTmpValueForIdx1 as Resource
                    Resource_serializer.write(valueSerializer, valueHolderForDetentSelectionTmpValueForIdx1ForIdx2)
                }
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShowInSubWindow  = value.showInSubWindow
        if (valueHolderForShowInSubWindow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShowInSubWindowTmpValue  = valueHolderForShowInSubWindow!
            valueSerializer.writeBoolean(valueHolderForShowInSubWindowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPlacement  = value.placement
        if (valueHolderForPlacement !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPlacementTmpValue  = (valueHolderForPlacement as Placement)
            valueSerializer.writeInt32(valueHolderForPlacementTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPlacementOnTarget  = value.placementOnTarget
        if (valueHolderForPlacementOnTarget !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPlacementOnTargetTmpValue  = valueHolderForPlacementOnTarget!
            valueSerializer.writeBoolean(valueHolderForPlacementOnTargetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): SheetOptions {
        let valueDeserializer : DeserializerBase = buffer
        const backgroundColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundColorTmpBuf : ResourceColor | undefined = undefined
        if ((backgroundColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const backgroundColorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let backgroundColorTmpBuf_ : Color | number | string | Resource | undefined
            if (backgroundColorTmpBuf_UnionSelector == (0).toChar()) {
                backgroundColorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (backgroundColorTmpBuf_UnionSelector == (1).toChar()) {
                backgroundColorTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (backgroundColorTmpBuf_UnionSelector == (2).toChar()) {
                backgroundColorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (backgroundColorTmpBuf_UnionSelector == (3).toChar()) {
                backgroundColorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for backgroundColorTmpBuf_ has to be chosen through deserialisation.")
            }
            backgroundColorTmpBuf = (backgroundColorTmpBuf_ as Color | number | string | Resource)
        }
        const backgroundColorTmpResult : ResourceColor | undefined = backgroundColorTmpBuf
        const onAppearTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onAppearTmpBuf : (() => void) | undefined = undefined
        if ((onAppearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onAppearTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onAppearTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onAppearTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onAppearTmpBuf = ():void => {
                const onAppearTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onAppearTmpBuf_BufArgsSerializer.writeInt32(onAppearTmpBuf_BufResource.resourceId);
                onAppearTmpBuf_BufArgsSerializer.writePointer(onAppearTmpBuf_BufCall);
                onAppearTmpBuf_BufArgsSerializer.writePointer(onAppearTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, onAppearTmpBuf_BufArgsSerializer.asBuffer(), onAppearTmpBuf_BufArgsSerializer.length());
                onAppearTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onAppearTmpResult : (() => void) | undefined = onAppearTmpBuf
        const onDisappearTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onDisappearTmpBuf : (() => void) | undefined = undefined
        if ((onDisappearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onDisappearTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDisappearTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onDisappearTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onDisappearTmpBuf = ():void => {
                const onDisappearTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onDisappearTmpBuf_BufArgsSerializer.writeInt32(onDisappearTmpBuf_BufResource.resourceId);
                onDisappearTmpBuf_BufArgsSerializer.writePointer(onDisappearTmpBuf_BufCall);
                onDisappearTmpBuf_BufArgsSerializer.writePointer(onDisappearTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, onDisappearTmpBuf_BufArgsSerializer.asBuffer(), onDisappearTmpBuf_BufArgsSerializer.length());
                onDisappearTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onDisappearTmpResult : (() => void) | undefined = onDisappearTmpBuf
        const onWillAppearTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillAppearTmpBuf : (() => void) | undefined = undefined
        if ((onWillAppearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillAppearTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillAppearTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onWillAppearTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onWillAppearTmpBuf = ():void => {
                const onWillAppearTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onWillAppearTmpBuf_BufArgsSerializer.writeInt32(onWillAppearTmpBuf_BufResource.resourceId);
                onWillAppearTmpBuf_BufArgsSerializer.writePointer(onWillAppearTmpBuf_BufCall);
                onWillAppearTmpBuf_BufArgsSerializer.writePointer(onWillAppearTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, onWillAppearTmpBuf_BufArgsSerializer.asBuffer(), onWillAppearTmpBuf_BufArgsSerializer.length());
                onWillAppearTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onWillAppearTmpResult : (() => void) | undefined = onWillAppearTmpBuf
        const onWillDisappearTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillDisappearTmpBuf : (() => void) | undefined = undefined
        if ((onWillDisappearTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillDisappearTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillDisappearTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onWillDisappearTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onWillDisappearTmpBuf = ():void => {
                const onWillDisappearTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onWillDisappearTmpBuf_BufArgsSerializer.writeInt32(onWillDisappearTmpBuf_BufResource.resourceId);
                onWillDisappearTmpBuf_BufArgsSerializer.writePointer(onWillDisappearTmpBuf_BufCall);
                onWillDisappearTmpBuf_BufArgsSerializer.writePointer(onWillDisappearTmpBuf_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, onWillDisappearTmpBuf_BufArgsSerializer.asBuffer(), onWillDisappearTmpBuf_BufArgsSerializer.length());
                onWillDisappearTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onWillDisappearTmpResult : (() => void) | undefined = onWillDisappearTmpBuf
        const heightTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let heightTmpBuf : SheetSize | Length | undefined = undefined
        if ((heightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const heightTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let heightTmpBuf_ : SheetSize | Length | undefined
            if (heightTmpBuf_UnionSelector == (0).toChar()) {
                heightTmpBuf_ = SheetSize.fromValue(valueDeserializer.readInt32())
            } else if (heightTmpBuf_UnionSelector == (1).toChar()) {
                const heightTmpBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                let heightTmpBuf_BufU : string | number | Resource | undefined
                if (heightTmpBuf_BufUUnionSelector == (0).toChar()) {
                    heightTmpBuf_BufU = (valueDeserializer.readString() as string)
                } else if (heightTmpBuf_BufUUnionSelector == (1).toChar()) {
                    heightTmpBuf_BufU = (valueDeserializer.readNumber() as number)
                } else if (heightTmpBuf_BufUUnionSelector == (2).toChar()) {
                    heightTmpBuf_BufU = Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error("One of the branches for heightTmpBuf_BufU has to be chosen through deserialisation.")
                }
                heightTmpBuf_ = (heightTmpBuf_BufU as string | number | Resource)
            } else {
                throw new Error("One of the branches for heightTmpBuf_ has to be chosen through deserialisation.")
            }
            heightTmpBuf = (heightTmpBuf_ as SheetSize | Length)
        }
        const heightTmpResult : SheetSize | Length | undefined = heightTmpBuf
        const dragBarTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let dragBarTmpBuf : boolean | undefined = undefined
        if ((dragBarTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            dragBarTmpBuf = valueDeserializer.readBoolean()
        }
        const dragBarTmpResult : boolean | undefined = dragBarTmpBuf
        const enableFloatingDragBarTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableFloatingDragBarTmpBuf : boolean | undefined = undefined
        if ((enableFloatingDragBarTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableFloatingDragBarTmpBuf = valueDeserializer.readBoolean()
        }
        const enableFloatingDragBarTmpResult : boolean | undefined = enableFloatingDragBarTmpBuf
        const modalTransitionTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let modalTransitionTmpBuf : ModalTransition | undefined = undefined
        if ((modalTransitionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            modalTransitionTmpBuf = ModalTransition.fromValue(valueDeserializer.readInt32())
        }
        const modalTransitionTmpResult : ModalTransition | undefined = modalTransitionTmpBuf
        const maskColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let maskColorTmpBuf : ResourceColor | undefined = undefined
        if ((maskColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const maskColorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let maskColorTmpBuf_ : Color | number | string | Resource | undefined
            if (maskColorTmpBuf_UnionSelector == (0).toChar()) {
                maskColorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (maskColorTmpBuf_UnionSelector == (1).toChar()) {
                maskColorTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (maskColorTmpBuf_UnionSelector == (2).toChar()) {
                maskColorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (maskColorTmpBuf_UnionSelector == (3).toChar()) {
                maskColorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for maskColorTmpBuf_ has to be chosen through deserialisation.")
            }
            maskColorTmpBuf = (maskColorTmpBuf_ as Color | number | string | Resource)
        }
        const maskColorTmpResult : ResourceColor | undefined = maskColorTmpBuf
        const detentsTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let detentsTmpBuf : SingleLengthDetent | DoubleLengthDetents | TripleLengthDetents | undefined = undefined
        if ((detentsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const detentsTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let detentsTmpBuf_ : SingleLengthDetent | DoubleLengthDetents | TripleLengthDetents | undefined
            if (detentsTmpBuf_UnionSelector == (0).toChar()) {
                const detentsTmpBuf_BufUValue0TempBufUnionSelector : int32 = valueDeserializer.readInt8()
                let detentsTmpBuf_BufUValue0TempBuf : SheetSize | Length | undefined
                if (detentsTmpBuf_BufUValue0TempBufUnionSelector == (0).toChar()) {
                    detentsTmpBuf_BufUValue0TempBuf = SheetSize.fromValue(valueDeserializer.readInt32())
                } else if (detentsTmpBuf_BufUValue0TempBufUnionSelector == (1).toChar()) {
                    const detentsTmpBuf_BufUValue0TempBufBufUUnionSelector : int32 = valueDeserializer.readInt8()
                    let detentsTmpBuf_BufUValue0TempBufBufU : string | number | Resource | undefined
                    if (detentsTmpBuf_BufUValue0TempBufBufUUnionSelector == (0).toChar()) {
                        detentsTmpBuf_BufUValue0TempBufBufU = (valueDeserializer.readString() as string)
                    } else if (detentsTmpBuf_BufUValue0TempBufBufUUnionSelector == (1).toChar()) {
                        detentsTmpBuf_BufUValue0TempBufBufU = (valueDeserializer.readNumber() as number)
                    } else if (detentsTmpBuf_BufUValue0TempBufBufUUnionSelector == (2).toChar()) {
                        detentsTmpBuf_BufUValue0TempBufBufU = Resource_serializer.read(valueDeserializer)
                    } else {
                        throw new Error("One of the branches for detentsTmpBuf_BufUValue0TempBufBufU has to be chosen through deserialisation.")
                    }
                    detentsTmpBuf_BufUValue0TempBuf = (detentsTmpBuf_BufUValue0TempBufBufU as string | number | Resource)
                } else {
                    throw new Error("One of the branches for detentsTmpBuf_BufUValue0TempBuf has to be chosen through deserialisation.")
                }
                const detentsTmpBuf_BufUValue0 : SheetSize | Length = (detentsTmpBuf_BufUValue0TempBuf as SheetSize | Length)
                detentsTmpBuf_ = ([detentsTmpBuf_BufUValue0] as SingleLengthDetent)
            } else if (detentsTmpBuf_UnionSelector == (1).toChar()) {
                const detentsTmpBuf_BufUValue0TempBufUnionSelector : int32 = valueDeserializer.readInt8()
                let detentsTmpBuf_BufUValue0TempBuf : SheetSize | Length | undefined
                if (detentsTmpBuf_BufUValue0TempBufUnionSelector == (0).toChar()) {
                    detentsTmpBuf_BufUValue0TempBuf = SheetSize.fromValue(valueDeserializer.readInt32())
                } else if (detentsTmpBuf_BufUValue0TempBufUnionSelector == (1).toChar()) {
                    const detentsTmpBuf_BufUValue0TempBufBufUUnionSelector : int32 = valueDeserializer.readInt8()
                    let detentsTmpBuf_BufUValue0TempBufBufU : string | number | Resource | undefined
                    if (detentsTmpBuf_BufUValue0TempBufBufUUnionSelector == (0).toChar()) {
                        detentsTmpBuf_BufUValue0TempBufBufU = (valueDeserializer.readString() as string)
                    } else if (detentsTmpBuf_BufUValue0TempBufBufUUnionSelector == (1).toChar()) {
                        detentsTmpBuf_BufUValue0TempBufBufU = (valueDeserializer.readNumber() as number)
                    } else if (detentsTmpBuf_BufUValue0TempBufBufUUnionSelector == (2).toChar()) {
                        detentsTmpBuf_BufUValue0TempBufBufU = Resource_serializer.read(valueDeserializer)
                    } else {
                        throw new Error("One of the branches for detentsTmpBuf_BufUValue0TempBufBufU has to be chosen through deserialisation.")
                    }
                    detentsTmpBuf_BufUValue0TempBuf = (detentsTmpBuf_BufUValue0TempBufBufU as string | number | Resource)
                } else {
                    throw new Error("One of the branches for detentsTmpBuf_BufUValue0TempBuf has to be chosen through deserialisation.")
                }
                const detentsTmpBuf_BufUValue0 : SheetSize | Length = (detentsTmpBuf_BufUValue0TempBuf as SheetSize | Length)
                const detentsTmpBuf_BufUValue1TempBuf_runtimeType  = valueDeserializer.readInt8().toInt()
                let detentsTmpBuf_BufUValue1TempBuf : SheetSize | Length | undefined = undefined
                if ((detentsTmpBuf_BufUValue1TempBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
                    const detentsTmpBuf_BufUValue1TempBuf_UnionSelector : int32 = valueDeserializer.readInt8()
                    let detentsTmpBuf_BufUValue1TempBuf_ : SheetSize | Length | undefined
                    if (detentsTmpBuf_BufUValue1TempBuf_UnionSelector == (0).toChar()) {
                        detentsTmpBuf_BufUValue1TempBuf_ = SheetSize.fromValue(valueDeserializer.readInt32())
                    } else if (detentsTmpBuf_BufUValue1TempBuf_UnionSelector == (1).toChar()) {
                        const detentsTmpBuf_BufUValue1TempBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                        let detentsTmpBuf_BufUValue1TempBuf_BufU : string | number | Resource | undefined
                        if (detentsTmpBuf_BufUValue1TempBuf_BufUUnionSelector == (0).toChar()) {
                            detentsTmpBuf_BufUValue1TempBuf_BufU = (valueDeserializer.readString() as string)
                        } else if (detentsTmpBuf_BufUValue1TempBuf_BufUUnionSelector == (1).toChar()) {
                            detentsTmpBuf_BufUValue1TempBuf_BufU = (valueDeserializer.readNumber() as number)
                        } else if (detentsTmpBuf_BufUValue1TempBuf_BufUUnionSelector == (2).toChar()) {
                            detentsTmpBuf_BufUValue1TempBuf_BufU = Resource_serializer.read(valueDeserializer)
                        } else {
                            throw new Error("One of the branches for detentsTmpBuf_BufUValue1TempBuf_BufU has to be chosen through deserialisation.")
                        }
                        detentsTmpBuf_BufUValue1TempBuf_ = (detentsTmpBuf_BufUValue1TempBuf_BufU as string | number | Resource)
                    } else {
                        throw new Error("One of the branches for detentsTmpBuf_BufUValue1TempBuf_ has to be chosen through deserialisation.")
                    }
                    detentsTmpBuf_BufUValue1TempBuf = (detentsTmpBuf_BufUValue1TempBuf_ as SheetSize | Length)
                }
                const detentsTmpBuf_BufUValue1 : SheetSize | Length | undefined = detentsTmpBuf_BufUValue1TempBuf
                detentsTmpBuf_ = ([detentsTmpBuf_BufUValue0, detentsTmpBuf_BufUValue1] as DoubleLengthDetents)
            } else if (detentsTmpBuf_UnionSelector == (2).toChar()) {
                const detentsTmpBuf_BufUValue0TempBufUnionSelector : int32 = valueDeserializer.readInt8()
                let detentsTmpBuf_BufUValue0TempBuf : SheetSize | Length | undefined
                if (detentsTmpBuf_BufUValue0TempBufUnionSelector == (0).toChar()) {
                    detentsTmpBuf_BufUValue0TempBuf = SheetSize.fromValue(valueDeserializer.readInt32())
                } else if (detentsTmpBuf_BufUValue0TempBufUnionSelector == (1).toChar()) {
                    const detentsTmpBuf_BufUValue0TempBufBufUUnionSelector : int32 = valueDeserializer.readInt8()
                    let detentsTmpBuf_BufUValue0TempBufBufU : string | number | Resource | undefined
                    if (detentsTmpBuf_BufUValue0TempBufBufUUnionSelector == (0).toChar()) {
                        detentsTmpBuf_BufUValue0TempBufBufU = (valueDeserializer.readString() as string)
                    } else if (detentsTmpBuf_BufUValue0TempBufBufUUnionSelector == (1).toChar()) {
                        detentsTmpBuf_BufUValue0TempBufBufU = (valueDeserializer.readNumber() as number)
                    } else if (detentsTmpBuf_BufUValue0TempBufBufUUnionSelector == (2).toChar()) {
                        detentsTmpBuf_BufUValue0TempBufBufU = Resource_serializer.read(valueDeserializer)
                    } else {
                        throw new Error("One of the branches for detentsTmpBuf_BufUValue0TempBufBufU has to be chosen through deserialisation.")
                    }
                    detentsTmpBuf_BufUValue0TempBuf = (detentsTmpBuf_BufUValue0TempBufBufU as string | number | Resource)
                } else {
                    throw new Error("One of the branches for detentsTmpBuf_BufUValue0TempBuf has to be chosen through deserialisation.")
                }
                const detentsTmpBuf_BufUValue0 : SheetSize | Length = (detentsTmpBuf_BufUValue0TempBuf as SheetSize | Length)
                const detentsTmpBuf_BufUValue1TempBuf_runtimeType  = valueDeserializer.readInt8().toInt()
                let detentsTmpBuf_BufUValue1TempBuf : SheetSize | Length | undefined = undefined
                if ((detentsTmpBuf_BufUValue1TempBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
                    const detentsTmpBuf_BufUValue1TempBuf_UnionSelector : int32 = valueDeserializer.readInt8()
                    let detentsTmpBuf_BufUValue1TempBuf_ : SheetSize | Length | undefined
                    if (detentsTmpBuf_BufUValue1TempBuf_UnionSelector == (0).toChar()) {
                        detentsTmpBuf_BufUValue1TempBuf_ = SheetSize.fromValue(valueDeserializer.readInt32())
                    } else if (detentsTmpBuf_BufUValue1TempBuf_UnionSelector == (1).toChar()) {
                        const detentsTmpBuf_BufUValue1TempBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                        let detentsTmpBuf_BufUValue1TempBuf_BufU : string | number | Resource | undefined
                        if (detentsTmpBuf_BufUValue1TempBuf_BufUUnionSelector == (0).toChar()) {
                            detentsTmpBuf_BufUValue1TempBuf_BufU = (valueDeserializer.readString() as string)
                        } else if (detentsTmpBuf_BufUValue1TempBuf_BufUUnionSelector == (1).toChar()) {
                            detentsTmpBuf_BufUValue1TempBuf_BufU = (valueDeserializer.readNumber() as number)
                        } else if (detentsTmpBuf_BufUValue1TempBuf_BufUUnionSelector == (2).toChar()) {
                            detentsTmpBuf_BufUValue1TempBuf_BufU = Resource_serializer.read(valueDeserializer)
                        } else {
                            throw new Error("One of the branches for detentsTmpBuf_BufUValue1TempBuf_BufU has to be chosen through deserialisation.")
                        }
                        detentsTmpBuf_BufUValue1TempBuf_ = (detentsTmpBuf_BufUValue1TempBuf_BufU as string | number | Resource)
                    } else {
                        throw new Error("One of the branches for detentsTmpBuf_BufUValue1TempBuf_ has to be chosen through deserialisation.")
                    }
                    detentsTmpBuf_BufUValue1TempBuf = (detentsTmpBuf_BufUValue1TempBuf_ as SheetSize | Length)
                }
                const detentsTmpBuf_BufUValue1 : SheetSize | Length | undefined = detentsTmpBuf_BufUValue1TempBuf
                const detentsTmpBuf_BufUValue2TempBuf_runtimeType  = valueDeserializer.readInt8().toInt()
                let detentsTmpBuf_BufUValue2TempBuf : SheetSize | Length | undefined = undefined
                if ((detentsTmpBuf_BufUValue2TempBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
                    const detentsTmpBuf_BufUValue2TempBuf_UnionSelector : int32 = valueDeserializer.readInt8()
                    let detentsTmpBuf_BufUValue2TempBuf_ : SheetSize | Length | undefined
                    if (detentsTmpBuf_BufUValue2TempBuf_UnionSelector == (0).toChar()) {
                        detentsTmpBuf_BufUValue2TempBuf_ = SheetSize.fromValue(valueDeserializer.readInt32())
                    } else if (detentsTmpBuf_BufUValue2TempBuf_UnionSelector == (1).toChar()) {
                        const detentsTmpBuf_BufUValue2TempBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                        let detentsTmpBuf_BufUValue2TempBuf_BufU : string | number | Resource | undefined
                        if (detentsTmpBuf_BufUValue2TempBuf_BufUUnionSelector == (0).toChar()) {
                            detentsTmpBuf_BufUValue2TempBuf_BufU = (valueDeserializer.readString() as string)
                        } else if (detentsTmpBuf_BufUValue2TempBuf_BufUUnionSelector == (1).toChar()) {
                            detentsTmpBuf_BufUValue2TempBuf_BufU = (valueDeserializer.readNumber() as number)
                        } else if (detentsTmpBuf_BufUValue2TempBuf_BufUUnionSelector == (2).toChar()) {
                            detentsTmpBuf_BufUValue2TempBuf_BufU = Resource_serializer.read(valueDeserializer)
                        } else {
                            throw new Error("One of the branches for detentsTmpBuf_BufUValue2TempBuf_BufU has to be chosen through deserialisation.")
                        }
                        detentsTmpBuf_BufUValue2TempBuf_ = (detentsTmpBuf_BufUValue2TempBuf_BufU as string | number | Resource)
                    } else {
                        throw new Error("One of the branches for detentsTmpBuf_BufUValue2TempBuf_ has to be chosen through deserialisation.")
                    }
                    detentsTmpBuf_BufUValue2TempBuf = (detentsTmpBuf_BufUValue2TempBuf_ as SheetSize | Length)
                }
                const detentsTmpBuf_BufUValue2 : SheetSize | Length | undefined = detentsTmpBuf_BufUValue2TempBuf
                detentsTmpBuf_ = ([detentsTmpBuf_BufUValue0, detentsTmpBuf_BufUValue1, detentsTmpBuf_BufUValue2] as TripleLengthDetents)
            } else {
                throw new Error("One of the branches for detentsTmpBuf_ has to be chosen through deserialisation.")
            }
            detentsTmpBuf = (detentsTmpBuf_ as SingleLengthDetent | DoubleLengthDetents | TripleLengthDetents)
        }
        const detentsTmpResult : SingleLengthDetent | DoubleLengthDetents | TripleLengthDetents | undefined = detentsTmpBuf
        const blurStyleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let blurStyleTmpBuf : BlurStyle | undefined = undefined
        if ((blurStyleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            blurStyleTmpBuf = BlurStyle.fromValue(valueDeserializer.readInt32())
        }
        const blurStyleTmpResult : BlurStyle | undefined = blurStyleTmpBuf
        const showCloseTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let showCloseTmpBuf : boolean | Resource | undefined = undefined
        if ((showCloseTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const showCloseTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let showCloseTmpBuf_ : boolean | Resource | undefined
            if (showCloseTmpBuf_UnionSelector == (0).toChar()) {
                showCloseTmpBuf_ = valueDeserializer.readBoolean()
            } else if (showCloseTmpBuf_UnionSelector == (1).toChar()) {
                showCloseTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for showCloseTmpBuf_ has to be chosen through deserialisation.")
            }
            showCloseTmpBuf = (showCloseTmpBuf_ as boolean | Resource)
        }
        const showCloseTmpResult : boolean | Resource | undefined = showCloseTmpBuf
        const preferTypeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let preferTypeTmpBuf : SheetType | undefined = undefined
        if ((preferTypeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            preferTypeTmpBuf = SheetType.fromValue(valueDeserializer.readInt32())
        }
        const preferTypeTmpResult : SheetType | undefined = preferTypeTmpBuf
        const titleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let titleTmpBuf : SheetTitleOptions | CustomBuilder | undefined = undefined
        if ((titleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const titleTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let titleTmpBuf_ : SheetTitleOptions | CustomBuilder | undefined
            if (titleTmpBuf_UnionSelector == (0).toChar()) {
                titleTmpBuf_ = SheetTitleOptions_serializer.read(valueDeserializer)
            } else if (titleTmpBuf_UnionSelector == (1).toChar()) {
                const titleTmpBuf_BufUBufResource : CallbackResource = valueDeserializer.readCallbackResource()
                const titleTmpBuf_BufUBufCall : KPointer = valueDeserializer.readPointer()
                const titleTmpBuf_BufUBufCallSync : KPointer = valueDeserializer.readPointer()
                titleTmpBuf_ = ():void => {
                    const titleTmpBuf_BufUBufArgsSerializer : SerializerBase = SerializerBase.hold();
                    titleTmpBuf_BufUBufArgsSerializer.writeInt32(titleTmpBuf_BufUBufResource.resourceId);
                    titleTmpBuf_BufUBufArgsSerializer.writePointer(titleTmpBuf_BufUBufCall);
                    titleTmpBuf_BufUBufArgsSerializer.writePointer(titleTmpBuf_BufUBufCallSync);
                    InteropNativeModule._CallCallbackSync(10, 737226752, titleTmpBuf_BufUBufArgsSerializer.asBuffer(), titleTmpBuf_BufUBufArgsSerializer.length());
                    titleTmpBuf_BufUBufArgsSerializer.release();
                    return;
                }
            } else {
                throw new Error("One of the branches for titleTmpBuf_ has to be chosen through deserialisation.")
            }
            titleTmpBuf = (titleTmpBuf_ as SheetTitleOptions | CustomBuilder)
        }
        const titleTmpResult : SheetTitleOptions | CustomBuilder | undefined = titleTmpBuf
        const shouldDismissTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let shouldDismissTmpBuf : ((sheetDismiss: SheetDismiss) => void) | undefined = undefined
        if ((shouldDismissTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const shouldDismissTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const shouldDismissTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const shouldDismissTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            shouldDismissTmpBuf = (sheetDismiss: SheetDismiss):void => {
                const shouldDismissTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                shouldDismissTmpBuf_BufArgsSerializer.writeInt32(shouldDismissTmpBuf_BufResource.resourceId);
                shouldDismissTmpBuf_BufArgsSerializer.writePointer(shouldDismissTmpBuf_BufCall);
                shouldDismissTmpBuf_BufArgsSerializer.writePointer(shouldDismissTmpBuf_BufCallSync);
                SheetDismiss_serializer.write(shouldDismissTmpBuf_BufArgsSerializer, sheetDismiss);
                InteropNativeModule._CallCallbackSync(10, 22609082, shouldDismissTmpBuf_BufArgsSerializer.asBuffer(), shouldDismissTmpBuf_BufArgsSerializer.length());
                shouldDismissTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const shouldDismissTmpResult : ((sheetDismiss: SheetDismiss) => void) | undefined = shouldDismissTmpBuf
        const onWillDismissTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillDismissTmpBuf : ((value0: DismissSheetAction) => void) | undefined = undefined
        if ((onWillDismissTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillDismissTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillDismissTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onWillDismissTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onWillDismissTmpBuf = (value0: DismissSheetAction):void => {
                const onWillDismissTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onWillDismissTmpBuf_BufArgsSerializer.writeInt32(onWillDismissTmpBuf_BufResource.resourceId);
                onWillDismissTmpBuf_BufArgsSerializer.writePointer(onWillDismissTmpBuf_BufCall);
                onWillDismissTmpBuf_BufArgsSerializer.writePointer(onWillDismissTmpBuf_BufCallSync);
                DismissSheetAction_serializer.write(onWillDismissTmpBuf_BufArgsSerializer, value0);
                InteropNativeModule._CallCallbackSync(10, 889549796, onWillDismissTmpBuf_BufArgsSerializer.asBuffer(), onWillDismissTmpBuf_BufArgsSerializer.length());
                onWillDismissTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onWillDismissTmpResult : ((value0: DismissSheetAction) => void) | undefined = onWillDismissTmpBuf
        const onWillSpringBackWhenDismissTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillSpringBackWhenDismissTmpBuf : ((value0: SpringBackAction) => void) | undefined = undefined
        if ((onWillSpringBackWhenDismissTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillSpringBackWhenDismissTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWillSpringBackWhenDismissTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onWillSpringBackWhenDismissTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onWillSpringBackWhenDismissTmpBuf = (value0: SpringBackAction):void => {
                const onWillSpringBackWhenDismissTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onWillSpringBackWhenDismissTmpBuf_BufArgsSerializer.writeInt32(onWillSpringBackWhenDismissTmpBuf_BufResource.resourceId);
                onWillSpringBackWhenDismissTmpBuf_BufArgsSerializer.writePointer(onWillSpringBackWhenDismissTmpBuf_BufCall);
                onWillSpringBackWhenDismissTmpBuf_BufArgsSerializer.writePointer(onWillSpringBackWhenDismissTmpBuf_BufCallSync);
                SpringBackAction_serializer.write(onWillSpringBackWhenDismissTmpBuf_BufArgsSerializer, value0);
                InteropNativeModule._CallCallbackSync(10, 1536231691, onWillSpringBackWhenDismissTmpBuf_BufArgsSerializer.asBuffer(), onWillSpringBackWhenDismissTmpBuf_BufArgsSerializer.length());
                onWillSpringBackWhenDismissTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onWillSpringBackWhenDismissTmpResult : ((value0: SpringBackAction) => void) | undefined = onWillSpringBackWhenDismissTmpBuf
        const enableOutsideInteractiveTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableOutsideInteractiveTmpBuf : boolean | undefined = undefined
        if ((enableOutsideInteractiveTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableOutsideInteractiveTmpBuf = valueDeserializer.readBoolean()
        }
        const enableOutsideInteractiveTmpResult : boolean | undefined = enableOutsideInteractiveTmpBuf
        const widthTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let widthTmpBuf : Dimension | undefined = undefined
        if ((widthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const widthTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let widthTmpBuf_ : string | number | Resource | undefined
            if (widthTmpBuf_UnionSelector == (0).toChar()) {
                widthTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (widthTmpBuf_UnionSelector == (1).toChar()) {
                widthTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (widthTmpBuf_UnionSelector == (2).toChar()) {
                widthTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for widthTmpBuf_ has to be chosen through deserialisation.")
            }
            widthTmpBuf = (widthTmpBuf_ as string | number | Resource)
        }
        const widthTmpResult : Dimension | undefined = widthTmpBuf
        const borderWidthTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let borderWidthTmpBuf : Dimension | EdgeWidths | LocalizedEdgeWidths | undefined = undefined
        if ((borderWidthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const borderWidthTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let borderWidthTmpBuf_ : Dimension | EdgeWidths | LocalizedEdgeWidths | undefined
            if (borderWidthTmpBuf_UnionSelector == (0).toChar()) {
                const borderWidthTmpBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                let borderWidthTmpBuf_BufU : string | number | Resource | undefined
                if (borderWidthTmpBuf_BufUUnionSelector == (0).toChar()) {
                    borderWidthTmpBuf_BufU = (valueDeserializer.readString() as string)
                } else if (borderWidthTmpBuf_BufUUnionSelector == (1).toChar()) {
                    borderWidthTmpBuf_BufU = (valueDeserializer.readNumber() as number)
                } else if (borderWidthTmpBuf_BufUUnionSelector == (2).toChar()) {
                    borderWidthTmpBuf_BufU = Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error("One of the branches for borderWidthTmpBuf_BufU has to be chosen through deserialisation.")
                }
                borderWidthTmpBuf_ = (borderWidthTmpBuf_BufU as string | number | Resource)
            } else if (borderWidthTmpBuf_UnionSelector == (1).toChar()) {
                borderWidthTmpBuf_ = EdgeWidths_serializer.read(valueDeserializer)
            } else if (borderWidthTmpBuf_UnionSelector == (2).toChar()) {
                borderWidthTmpBuf_ = LocalizedEdgeWidths_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for borderWidthTmpBuf_ has to be chosen through deserialisation.")
            }
            borderWidthTmpBuf = (borderWidthTmpBuf_ as Dimension | EdgeWidths | LocalizedEdgeWidths)
        }
        const borderWidthTmpResult : Dimension | EdgeWidths | LocalizedEdgeWidths | undefined = borderWidthTmpBuf
        const borderColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let borderColorTmpBuf : ResourceColor | EdgeColors | LocalizedEdgeColors | undefined = undefined
        if ((borderColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const borderColorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let borderColorTmpBuf_ : ResourceColor | EdgeColors | LocalizedEdgeColors | undefined
            if (borderColorTmpBuf_UnionSelector == (0).toChar()) {
                const borderColorTmpBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                let borderColorTmpBuf_BufU : Color | number | string | Resource | undefined
                if (borderColorTmpBuf_BufUUnionSelector == (0).toChar()) {
                    borderColorTmpBuf_BufU = Color.values()[valueDeserializer.readInt32()]
                } else if (borderColorTmpBuf_BufUUnionSelector == (1).toChar()) {
                    borderColorTmpBuf_BufU = (valueDeserializer.readNumber() as number)
                } else if (borderColorTmpBuf_BufUUnionSelector == (2).toChar()) {
                    borderColorTmpBuf_BufU = (valueDeserializer.readString() as string)
                } else if (borderColorTmpBuf_BufUUnionSelector == (3).toChar()) {
                    borderColorTmpBuf_BufU = Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error("One of the branches for borderColorTmpBuf_BufU has to be chosen through deserialisation.")
                }
                borderColorTmpBuf_ = (borderColorTmpBuf_BufU as Color | number | string | Resource)
            } else if (borderColorTmpBuf_UnionSelector == (1).toChar()) {
                borderColorTmpBuf_ = EdgeColors_serializer.read(valueDeserializer)
            } else if (borderColorTmpBuf_UnionSelector == (2).toChar()) {
                borderColorTmpBuf_ = LocalizedEdgeColors_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for borderColorTmpBuf_ has to be chosen through deserialisation.")
            }
            borderColorTmpBuf = (borderColorTmpBuf_ as ResourceColor | EdgeColors | LocalizedEdgeColors)
        }
        const borderColorTmpResult : ResourceColor | EdgeColors | LocalizedEdgeColors | undefined = borderColorTmpBuf
        const borderStyleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let borderStyleTmpBuf : BorderStyle | EdgeStyles | undefined = undefined
        if ((borderStyleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const borderStyleTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let borderStyleTmpBuf_ : BorderStyle | EdgeStyles | undefined
            if (borderStyleTmpBuf_UnionSelector == (0).toChar()) {
                borderStyleTmpBuf_ = BorderStyle.fromValue(valueDeserializer.readInt32())
            } else if (borderStyleTmpBuf_UnionSelector == (1).toChar()) {
                borderStyleTmpBuf_ = EdgeStyles_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for borderStyleTmpBuf_ has to be chosen through deserialisation.")
            }
            borderStyleTmpBuf = (borderStyleTmpBuf_ as BorderStyle | EdgeStyles)
        }
        const borderStyleTmpResult : BorderStyle | EdgeStyles | undefined = borderStyleTmpBuf
        const shadowTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let shadowTmpBuf : ShadowOptions | ShadowStyle | undefined = undefined
        if ((shadowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const shadowTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let shadowTmpBuf_ : ShadowOptions | ShadowStyle | undefined
            if (shadowTmpBuf_UnionSelector == (0).toChar()) {
                shadowTmpBuf_ = ShadowOptions_serializer.read(valueDeserializer)
            } else if (shadowTmpBuf_UnionSelector == (1).toChar()) {
                shadowTmpBuf_ = ShadowStyle.fromValue(valueDeserializer.readInt32())
            } else {
                throw new Error("One of the branches for shadowTmpBuf_ has to be chosen through deserialisation.")
            }
            shadowTmpBuf = (shadowTmpBuf_ as ShadowOptions | ShadowStyle)
        }
        const shadowTmpResult : ShadowOptions | ShadowStyle | undefined = shadowTmpBuf
        const onHeightDidChangeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onHeightDidChangeTmpBuf : ((value0: int32) => void) | undefined = undefined
        if ((onHeightDidChangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onHeightDidChangeTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onHeightDidChangeTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onHeightDidChangeTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onHeightDidChangeTmpBuf = (value0: int32):void => {
                const onHeightDidChangeTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onHeightDidChangeTmpBuf_BufArgsSerializer.writeInt32(onHeightDidChangeTmpBuf_BufResource.resourceId);
                onHeightDidChangeTmpBuf_BufArgsSerializer.writePointer(onHeightDidChangeTmpBuf_BufCall);
                onHeightDidChangeTmpBuf_BufArgsSerializer.writePointer(onHeightDidChangeTmpBuf_BufCallSync);
                onHeightDidChangeTmpBuf_BufArgsSerializer.writeInt32(value0);
                InteropNativeModule._CallCallbackSync(10, 1148910599, onHeightDidChangeTmpBuf_BufArgsSerializer.asBuffer(), onHeightDidChangeTmpBuf_BufArgsSerializer.length());
                onHeightDidChangeTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onHeightDidChangeTmpResult : ((value0: int32) => void) | undefined = onHeightDidChangeTmpBuf
        const modeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let modeTmpBuf : SheetMode | undefined = undefined
        if ((modeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            modeTmpBuf = SheetMode.fromValue(valueDeserializer.readInt32())
        }
        const modeTmpResult : SheetMode | undefined = modeTmpBuf
        const scrollSizeModeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let scrollSizeModeTmpBuf : ScrollSizeMode | undefined = undefined
        if ((scrollSizeModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            scrollSizeModeTmpBuf = ScrollSizeMode.fromValue(valueDeserializer.readInt32())
        }
        const scrollSizeModeTmpResult : ScrollSizeMode | undefined = scrollSizeModeTmpBuf
        const onDetentsDidChangeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onDetentsDidChangeTmpBuf : ((value0: int32) => void) | undefined = undefined
        if ((onDetentsDidChangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onDetentsDidChangeTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onDetentsDidChangeTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onDetentsDidChangeTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onDetentsDidChangeTmpBuf = (value0: int32):void => {
                const onDetentsDidChangeTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onDetentsDidChangeTmpBuf_BufArgsSerializer.writeInt32(onDetentsDidChangeTmpBuf_BufResource.resourceId);
                onDetentsDidChangeTmpBuf_BufArgsSerializer.writePointer(onDetentsDidChangeTmpBuf_BufCall);
                onDetentsDidChangeTmpBuf_BufArgsSerializer.writePointer(onDetentsDidChangeTmpBuf_BufCallSync);
                onDetentsDidChangeTmpBuf_BufArgsSerializer.writeInt32(value0);
                InteropNativeModule._CallCallbackSync(10, 1148910599, onDetentsDidChangeTmpBuf_BufArgsSerializer.asBuffer(), onDetentsDidChangeTmpBuf_BufArgsSerializer.length());
                onDetentsDidChangeTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onDetentsDidChangeTmpResult : ((value0: int32) => void) | undefined = onDetentsDidChangeTmpBuf
        const onWidthDidChangeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWidthDidChangeTmpBuf : ((value0: int32) => void) | undefined = undefined
        if ((onWidthDidChangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWidthDidChangeTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onWidthDidChangeTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onWidthDidChangeTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onWidthDidChangeTmpBuf = (value0: int32):void => {
                const onWidthDidChangeTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onWidthDidChangeTmpBuf_BufArgsSerializer.writeInt32(onWidthDidChangeTmpBuf_BufResource.resourceId);
                onWidthDidChangeTmpBuf_BufArgsSerializer.writePointer(onWidthDidChangeTmpBuf_BufCall);
                onWidthDidChangeTmpBuf_BufArgsSerializer.writePointer(onWidthDidChangeTmpBuf_BufCallSync);
                onWidthDidChangeTmpBuf_BufArgsSerializer.writeInt32(value0);
                InteropNativeModule._CallCallbackSync(10, 1148910599, onWidthDidChangeTmpBuf_BufArgsSerializer.asBuffer(), onWidthDidChangeTmpBuf_BufArgsSerializer.length());
                onWidthDidChangeTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onWidthDidChangeTmpResult : ((value0: int32) => void) | undefined = onWidthDidChangeTmpBuf
        const onTypeDidChangeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onTypeDidChangeTmpBuf : ((value0: SheetType) => void) | undefined = undefined
        if ((onTypeDidChangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onTypeDidChangeTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onTypeDidChangeTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onTypeDidChangeTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onTypeDidChangeTmpBuf = (value0: SheetType):void => {
                const onTypeDidChangeTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onTypeDidChangeTmpBuf_BufArgsSerializer.writeInt32(onTypeDidChangeTmpBuf_BufResource.resourceId);
                onTypeDidChangeTmpBuf_BufArgsSerializer.writePointer(onTypeDidChangeTmpBuf_BufCall);
                onTypeDidChangeTmpBuf_BufArgsSerializer.writePointer(onTypeDidChangeTmpBuf_BufCallSync);
                onTypeDidChangeTmpBuf_BufArgsSerializer.writeInt32(value0.valueOf());
                InteropNativeModule._CallCallbackSync(10, -224451112, onTypeDidChangeTmpBuf_BufArgsSerializer.asBuffer(), onTypeDidChangeTmpBuf_BufArgsSerializer.length());
                onTypeDidChangeTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onTypeDidChangeTmpResult : ((value0: SheetType) => void) | undefined = onTypeDidChangeTmpBuf
        const uiContextTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let uiContextTmpBuf : UIContext | undefined = undefined
        if ((uiContextTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            uiContextTmpBuf = (UIContext_serializer.read(valueDeserializer) as UIContext)
        }
        const uiContextTmpResult : UIContext | undefined = uiContextTmpBuf
        const keyboardAvoidModeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let keyboardAvoidModeTmpBuf : SheetKeyboardAvoidMode | undefined = undefined
        if ((keyboardAvoidModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            keyboardAvoidModeTmpBuf = SheetKeyboardAvoidMode.fromValue(valueDeserializer.readInt32())
        }
        const keyboardAvoidModeTmpResult : SheetKeyboardAvoidMode | undefined = keyboardAvoidModeTmpBuf
        const enableHoverModeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableHoverModeTmpBuf : boolean | undefined = undefined
        if ((enableHoverModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableHoverModeTmpBuf = valueDeserializer.readBoolean()
        }
        const enableHoverModeTmpResult : boolean | undefined = enableHoverModeTmpBuf
        const hoverModeAreaTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let hoverModeAreaTmpBuf : HoverModeAreaType | undefined = undefined
        if ((hoverModeAreaTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            hoverModeAreaTmpBuf = HoverModeAreaType.fromValue(valueDeserializer.readInt32())
        }
        const hoverModeAreaTmpResult : HoverModeAreaType | undefined = hoverModeAreaTmpBuf
        const offsetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offsetTmpBuf : Position | undefined = undefined
        if ((offsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            offsetTmpBuf = Position_serializer.read(valueDeserializer)
        }
        const offsetTmpResult : Position | undefined = offsetTmpBuf
        const effectEdgeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let effectEdgeTmpBuf : int32 | undefined = undefined
        if ((effectEdgeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            effectEdgeTmpBuf = valueDeserializer.readInt32()
        }
        const effectEdgeTmpResult : int32 | undefined = effectEdgeTmpBuf
        const radiusTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let radiusTmpBuf : LengthMetrics | BorderRadiuses | LocalizedBorderRadiuses | undefined = undefined
        if ((radiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const radiusTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let radiusTmpBuf_ : LengthMetrics | BorderRadiuses | LocalizedBorderRadiuses | undefined
            if (radiusTmpBuf_UnionSelector == (0).toChar()) {
                radiusTmpBuf_ = LengthMetrics_serializer.read(valueDeserializer)
            } else if (radiusTmpBuf_UnionSelector == (1).toChar()) {
                radiusTmpBuf_ = BorderRadiuses_serializer.read(valueDeserializer)
            } else if (radiusTmpBuf_UnionSelector == (2).toChar()) {
                radiusTmpBuf_ = LocalizedBorderRadiuses_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for radiusTmpBuf_ has to be chosen through deserialisation.")
            }
            radiusTmpBuf = (radiusTmpBuf_ as LengthMetrics | BorderRadiuses | LocalizedBorderRadiuses)
        }
        const radiusTmpResult : LengthMetrics | BorderRadiuses | LocalizedBorderRadiuses | undefined = radiusTmpBuf
        const detentSelectionTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let detentSelectionTmpBuf : SheetSize | Length | undefined = undefined
        if ((detentSelectionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const detentSelectionTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let detentSelectionTmpBuf_ : SheetSize | Length | undefined
            if (detentSelectionTmpBuf_UnionSelector == (0).toChar()) {
                detentSelectionTmpBuf_ = SheetSize.fromValue(valueDeserializer.readInt32())
            } else if (detentSelectionTmpBuf_UnionSelector == (1).toChar()) {
                const detentSelectionTmpBuf_BufUUnionSelector : int32 = valueDeserializer.readInt8()
                let detentSelectionTmpBuf_BufU : string | number | Resource | undefined
                if (detentSelectionTmpBuf_BufUUnionSelector == (0).toChar()) {
                    detentSelectionTmpBuf_BufU = (valueDeserializer.readString() as string)
                } else if (detentSelectionTmpBuf_BufUUnionSelector == (1).toChar()) {
                    detentSelectionTmpBuf_BufU = (valueDeserializer.readNumber() as number)
                } else if (detentSelectionTmpBuf_BufUUnionSelector == (2).toChar()) {
                    detentSelectionTmpBuf_BufU = Resource_serializer.read(valueDeserializer)
                } else {
                    throw new Error("One of the branches for detentSelectionTmpBuf_BufU has to be chosen through deserialisation.")
                }
                detentSelectionTmpBuf_ = (detentSelectionTmpBuf_BufU as string | number | Resource)
            } else {
                throw new Error("One of the branches for detentSelectionTmpBuf_ has to be chosen through deserialisation.")
            }
            detentSelectionTmpBuf = (detentSelectionTmpBuf_ as SheetSize | Length)
        }
        const detentSelectionTmpResult : SheetSize | Length | undefined = detentSelectionTmpBuf
        const showInSubWindowTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let showInSubWindowTmpBuf : boolean | undefined = undefined
        if ((showInSubWindowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            showInSubWindowTmpBuf = valueDeserializer.readBoolean()
        }
        const showInSubWindowTmpResult : boolean | undefined = showInSubWindowTmpBuf
        const placementTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let placementTmpBuf : Placement | undefined = undefined
        if ((placementTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            placementTmpBuf = Placement.fromValue(valueDeserializer.readInt32())
        }
        const placementTmpResult : Placement | undefined = placementTmpBuf
        const placementOnTargetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let placementOnTargetTmpBuf : boolean | undefined = undefined
        if ((placementOnTargetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            placementOnTargetTmpBuf = valueDeserializer.readBoolean()
        }
        const placementOnTargetTmpResult : boolean | undefined = placementOnTargetTmpBuf
        let value : SheetOptions = ({backgroundColor: backgroundColorTmpResult, onAppear: onAppearTmpResult, onDisappear: onDisappearTmpResult, onWillAppear: onWillAppearTmpResult, onWillDisappear: onWillDisappearTmpResult, height: heightTmpResult, dragBar: dragBarTmpResult, enableFloatingDragBar: enableFloatingDragBarTmpResult, modalTransition: modalTransitionTmpResult, maskColor: maskColorTmpResult, detents: detentsTmpResult, blurStyle: blurStyleTmpResult, showClose: showCloseTmpResult, preferType: preferTypeTmpResult, title: titleTmpResult, shouldDismiss: shouldDismissTmpResult, onWillDismiss: onWillDismissTmpResult, onWillSpringBackWhenDismiss: onWillSpringBackWhenDismissTmpResult, enableOutsideInteractive: enableOutsideInteractiveTmpResult, width: widthTmpResult, borderWidth: borderWidthTmpResult, borderColor: borderColorTmpResult, borderStyle: borderStyleTmpResult, shadow: shadowTmpResult, onHeightDidChange: onHeightDidChangeTmpResult, mode: modeTmpResult, scrollSizeMode: scrollSizeModeTmpResult, onDetentsDidChange: onDetentsDidChangeTmpResult, onWidthDidChange: onWidthDidChangeTmpResult, onTypeDidChange: onTypeDidChangeTmpResult, uiContext: uiContextTmpResult, keyboardAvoidMode: keyboardAvoidModeTmpResult, enableHoverMode: enableHoverModeTmpResult, hoverModeArea: hoverModeAreaTmpResult, offset: offsetTmpResult, effectEdge: effectEdgeTmpResult, radius: radiusTmpResult, detentSelection: detentSelectionTmpResult, showInSubWindow: showInSubWindowTmpResult, placement: placementTmpResult, placementOnTarget: placementOnTargetTmpResult} as SheetOptions)
        return value
    }
}
export class TouchEvent_serializer {
    public static write(buffer: SerializerBase, value: TouchEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): TouchEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return TouchEventInternal.fromPtr(ptr)
    }
}
export class AccessibilityHoverEvent_serializer {
    public static write(buffer: SerializerBase, value: AccessibilityHoverEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): AccessibilityHoverEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return AccessibilityHoverEventInternal.fromPtr(ptr)
    }
}
export class AxisEvent_serializer {
    public static write(buffer: SerializerBase, value: AxisEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): AxisEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return AxisEventInternal.fromPtr(ptr)
    }
}
export class BaseEvent_serializer {
    public static write(buffer: SerializerBase, value: BaseEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): BaseEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return BaseEventInternal.fromPtr(ptr)
    }
}
export class ClickEvent_serializer {
    public static write(buffer: SerializerBase, value: ClickEvent): void {
        let valueSerializer : SerializerBase = buffer
        valueSerializer.writePointer(toPeerPtr(value))
    }
    public static read(buffer: DeserializerBase): ClickEvent {
        let valueDeserializer : DeserializerBase = buffer
        let ptr : KPointer = valueDeserializer.readPointer()
        return ClickEventInternal.fromPtr(ptr)
    }
}
export class PopupOptions_serializer {
    public static write(buffer: SerializerBase, value: PopupOptions): void {
        let valueSerializer : SerializerBase = buffer
        const valueHolderForMessage  = value.message
        valueSerializer.writeString(valueHolderForMessage)
        const valueHolderForPlacement  = value.placement
        if (valueHolderForPlacement !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPlacementTmpValue  = (valueHolderForPlacement as Placement)
            valueSerializer.writeInt32(valueHolderForPlacementTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPrimaryButton  = value.primaryButton
        if (valueHolderForPrimaryButton !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPrimaryButtonTmpValue  = valueHolderForPrimaryButton!
            PopupButton_serializer.write(valueSerializer, valueHolderForPrimaryButtonTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForSecondaryButton  = value.secondaryButton
        if (valueHolderForSecondaryButton !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForSecondaryButtonTmpValue  = valueHolderForSecondaryButton!
            PopupButton_serializer.write(valueSerializer, valueHolderForSecondaryButtonTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnStateChange  = value.onStateChange
        if (valueHolderForOnStateChange !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnStateChangeTmpValue  = valueHolderForOnStateChange!
            valueSerializer.holdAndWriteCallback(valueHolderForOnStateChangeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowOffset  = value.arrowOffset
        if (valueHolderForArrowOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowOffsetTmpValue  = valueHolderForArrowOffset!
            if (valueHolderForArrowOffsetTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx0  = valueHolderForArrowOffsetTmpValue as string
                valueSerializer.writeString(valueHolderForArrowOffsetTmpValueForIdx0)
            } else if (valueHolderForArrowOffsetTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx1  = valueHolderForArrowOffsetTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowOffsetTmpValueForIdx1)
            } else if (valueHolderForArrowOffsetTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowOffsetTmpValueForIdx2  = valueHolderForArrowOffsetTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForArrowOffsetTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShowInSubWindow  = value.showInSubWindow
        if (valueHolderForShowInSubWindow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShowInSubWindowTmpValue  = valueHolderForShowInSubWindow!
            valueSerializer.writeBoolean(valueHolderForShowInSubWindowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMask  = value.mask
        if (valueHolderForMask !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMaskTmpValue  = valueHolderForMask!
            if (valueHolderForMaskTmpValue instanceof boolean) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForMaskTmpValueForIdx0  = valueHolderForMaskTmpValue as boolean
                valueSerializer.writeBoolean(valueHolderForMaskTmpValueForIdx0)
            } else if (valueHolderForMaskTmpValue instanceof PopupMaskType) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForMaskTmpValueForIdx1  = valueHolderForMaskTmpValue as PopupMaskType
                PopupMaskType_serializer.write(valueSerializer, valueHolderForMaskTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForMessageOptions  = value.messageOptions
        if (valueHolderForMessageOptions !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForMessageOptionsTmpValue  = valueHolderForMessageOptions!
            PopupMessageOptions_serializer.write(valueSerializer, valueHolderForMessageOptionsTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTargetSpace  = value.targetSpace
        if (valueHolderForTargetSpace !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTargetSpaceTmpValue  = valueHolderForTargetSpace!
            if (valueHolderForTargetSpaceTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx0  = valueHolderForTargetSpaceTmpValue as string
                valueSerializer.writeString(valueHolderForTargetSpaceTmpValueForIdx0)
            } else if (valueHolderForTargetSpaceTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx1  = valueHolderForTargetSpaceTmpValue as number
                valueSerializer.writeNumber(valueHolderForTargetSpaceTmpValueForIdx1)
            } else if (valueHolderForTargetSpaceTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForTargetSpaceTmpValueForIdx2  = valueHolderForTargetSpaceTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForTargetSpaceTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableArrow  = value.enableArrow
        if (valueHolderForEnableArrow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableArrowTmpValue  = valueHolderForEnableArrow!
            valueSerializer.writeBoolean(valueHolderForEnableArrowTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOffset  = value.offset
        if (valueHolderForOffset !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOffsetTmpValue  = valueHolderForOffset!
            Position_serializer.write(valueSerializer, valueHolderForOffsetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForPopupColor  = value.popupColor
        if (valueHolderForPopupColor !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForPopupColorTmpValue  = valueHolderForPopupColor!
            if (valueHolderForPopupColorTmpValue instanceof Color) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForPopupColorTmpValueForIdx0  = valueHolderForPopupColorTmpValue as Color
                valueSerializer.writeInt32(valueHolderForPopupColorTmpValueForIdx0.getOrdinal())
            } else if (valueHolderForPopupColorTmpValue instanceof string) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForPopupColorTmpValueForIdx1  = valueHolderForPopupColorTmpValue as string
                valueSerializer.writeString(valueHolderForPopupColorTmpValueForIdx1)
            } else if (valueHolderForPopupColorTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForPopupColorTmpValueForIdx2  = valueHolderForPopupColorTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForPopupColorTmpValueForIdx2)
            } else if (valueHolderForPopupColorTmpValue instanceof int64) {
                valueSerializer.writeInt8((3).toByte())
                const valueHolderForPopupColorTmpValueForIdx3  = valueHolderForPopupColorTmpValue as int64
                valueSerializer.writeInt64(valueHolderForPopupColorTmpValueForIdx3)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForAutoCancel  = value.autoCancel
        if (valueHolderForAutoCancel !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForAutoCancelTmpValue  = valueHolderForAutoCancel!
            valueSerializer.writeBoolean(valueHolderForAutoCancelTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForWidth  = value.width
        if (valueHolderForWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForWidthTmpValue  = valueHolderForWidth!
            if (valueHolderForWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForWidthTmpValueForIdx0  = valueHolderForWidthTmpValue as string
                valueSerializer.writeString(valueHolderForWidthTmpValueForIdx0)
            } else if (valueHolderForWidthTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForWidthTmpValueForIdx1  = valueHolderForWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForWidthTmpValueForIdx1)
            } else if (valueHolderForWidthTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForWidthTmpValueForIdx2  = valueHolderForWidthTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowPointPosition  = value.arrowPointPosition
        if (valueHolderForArrowPointPosition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowPointPositionTmpValue  = (valueHolderForArrowPointPosition as ArrowPointPosition)
            valueSerializer.writeInt32(valueHolderForArrowPointPositionTmpValue.getOrdinal())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowWidth  = value.arrowWidth
        if (valueHolderForArrowWidth !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowWidthTmpValue  = valueHolderForArrowWidth!
            if (valueHolderForArrowWidthTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowWidthTmpValueForIdx0  = valueHolderForArrowWidthTmpValue as string
                valueSerializer.writeString(valueHolderForArrowWidthTmpValueForIdx0)
            } else if (valueHolderForArrowWidthTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowWidthTmpValueForIdx1  = valueHolderForArrowWidthTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowWidthTmpValueForIdx1)
            } else if (valueHolderForArrowWidthTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowWidthTmpValueForIdx2  = valueHolderForArrowWidthTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForArrowWidthTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForArrowHeight  = value.arrowHeight
        if (valueHolderForArrowHeight !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForArrowHeightTmpValue  = valueHolderForArrowHeight!
            if (valueHolderForArrowHeightTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForArrowHeightTmpValueForIdx0  = valueHolderForArrowHeightTmpValue as string
                valueSerializer.writeString(valueHolderForArrowHeightTmpValueForIdx0)
            } else if (valueHolderForArrowHeightTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForArrowHeightTmpValueForIdx1  = valueHolderForArrowHeightTmpValue as number
                valueSerializer.writeNumber(valueHolderForArrowHeightTmpValueForIdx1)
            } else if (valueHolderForArrowHeightTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForArrowHeightTmpValueForIdx2  = valueHolderForArrowHeightTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForArrowHeightTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForRadius  = value.radius
        if (valueHolderForRadius !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForRadiusTmpValue  = valueHolderForRadius!
            if (valueHolderForRadiusTmpValue instanceof string) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForRadiusTmpValueForIdx0  = valueHolderForRadiusTmpValue as string
                valueSerializer.writeString(valueHolderForRadiusTmpValueForIdx0)
            } else if (valueHolderForRadiusTmpValue instanceof number) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForRadiusTmpValueForIdx1  = valueHolderForRadiusTmpValue as number
                valueSerializer.writeNumber(valueHolderForRadiusTmpValueForIdx1)
            } else if (valueHolderForRadiusTmpValue instanceof Resource) {
                valueSerializer.writeInt8((2).toByte())
                const valueHolderForRadiusTmpValueForIdx2  = valueHolderForRadiusTmpValue as Resource
                Resource_serializer.write(valueSerializer, valueHolderForRadiusTmpValueForIdx2)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForShadow  = value.shadow
        if (valueHolderForShadow !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForShadowTmpValue  = valueHolderForShadow!
            if (valueHolderForShadowTmpValue instanceof ShadowOptions) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForShadowTmpValueForIdx0  = valueHolderForShadowTmpValue as ShadowOptions
                ShadowOptions_serializer.write(valueSerializer, valueHolderForShadowTmpValueForIdx0)
            } else if (valueHolderForShadowTmpValue instanceof ShadowStyle) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForShadowTmpValueForIdx1  = valueHolderForShadowTmpValue as ShadowStyle
                valueSerializer.writeInt32(valueHolderForShadowTmpValueForIdx1.valueOf())
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForBackgroundBlurStyle  = value.backgroundBlurStyle
        if (valueHolderForBackgroundBlurStyle !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForBackgroundBlurStyleTmpValue  = (valueHolderForBackgroundBlurStyle as BlurStyle)
            valueSerializer.writeInt32(valueHolderForBackgroundBlurStyleTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForTransition  = value.transition
        if (valueHolderForTransition !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForTransitionTmpValue  = valueHolderForTransition!
            TransitionEffect_serializer.write(valueSerializer, valueHolderForTransitionTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForOnWillDismiss  = value.onWillDismiss
        if (valueHolderForOnWillDismiss !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForOnWillDismissTmpValue  = valueHolderForOnWillDismiss!
            if (valueHolderForOnWillDismissTmpValue instanceof boolean) {
                valueSerializer.writeInt8((0).toByte())
                const valueHolderForOnWillDismissTmpValueForIdx0  = valueHolderForOnWillDismissTmpValue as boolean
                valueSerializer.writeBoolean(valueHolderForOnWillDismissTmpValueForIdx0)
            } else if (valueHolderForOnWillDismissTmpValue instanceof ((value0: DismissPopupAction) => void)) {
                valueSerializer.writeInt8((1).toByte())
                const valueHolderForOnWillDismissTmpValueForIdx1  = valueHolderForOnWillDismissTmpValue as ((value0: DismissPopupAction) => void)
                valueSerializer.holdAndWriteCallback(valueHolderForOnWillDismissTmpValueForIdx1)
            }
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForEnableHoverMode  = value.enableHoverMode
        if (valueHolderForEnableHoverMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForEnableHoverModeTmpValue  = valueHolderForEnableHoverMode!
            valueSerializer.writeBoolean(valueHolderForEnableHoverModeTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForFollowTransformOfTarget  = value.followTransformOfTarget
        if (valueHolderForFollowTransformOfTarget !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForFollowTransformOfTargetTmpValue  = valueHolderForFollowTransformOfTarget!
            valueSerializer.writeBoolean(valueHolderForFollowTransformOfTargetTmpValue)
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        const valueHolderForKeyboardAvoidMode  = value.keyboardAvoidMode
        if (valueHolderForKeyboardAvoidMode !== undefined) {
            valueSerializer.writeInt8(RuntimeType.OBJECT)
            const valueHolderForKeyboardAvoidModeTmpValue  = (valueHolderForKeyboardAvoidMode as KeyboardAvoidMode)
            valueSerializer.writeInt32(valueHolderForKeyboardAvoidModeTmpValue.valueOf())
        } else {
            valueSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
    }
    public static read(buffer: DeserializerBase): PopupOptions {
        let valueDeserializer : DeserializerBase = buffer
        const messageTmpResult : string = (valueDeserializer.readString() as string)
        const placementTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let placementTmpBuf : Placement | undefined = undefined
        if ((placementTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            placementTmpBuf = Placement.fromValue(valueDeserializer.readInt32())
        }
        const placementTmpResult : Placement | undefined = placementTmpBuf
        const primaryButtonTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let primaryButtonTmpBuf : PopupButton | undefined = undefined
        if ((primaryButtonTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            primaryButtonTmpBuf = PopupButton_serializer.read(valueDeserializer)
        }
        const primaryButtonTmpResult : PopupButton | undefined = primaryButtonTmpBuf
        const secondaryButtonTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let secondaryButtonTmpBuf : PopupButton | undefined = undefined
        if ((secondaryButtonTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            secondaryButtonTmpBuf = PopupButton_serializer.read(valueDeserializer)
        }
        const secondaryButtonTmpResult : PopupButton | undefined = secondaryButtonTmpBuf
        const onStateChangeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onStateChangeTmpBuf : PopupStateChangeCallback | undefined = undefined
        if ((onStateChangeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onStateChangeTmpBuf_BufResource : CallbackResource = valueDeserializer.readCallbackResource()
            const onStateChangeTmpBuf_BufCall : KPointer = valueDeserializer.readPointer()
            const onStateChangeTmpBuf_BufCallSync : KPointer = valueDeserializer.readPointer()
            onStateChangeTmpBuf = (event: PopupStateChangeParam):void => {
                const onStateChangeTmpBuf_BufArgsSerializer : SerializerBase = SerializerBase.hold();
                onStateChangeTmpBuf_BufArgsSerializer.writeInt32(onStateChangeTmpBuf_BufResource.resourceId);
                onStateChangeTmpBuf_BufArgsSerializer.writePointer(onStateChangeTmpBuf_BufCall);
                onStateChangeTmpBuf_BufArgsSerializer.writePointer(onStateChangeTmpBuf_BufCallSync);
                PopupStateChangeParam_serializer.write(onStateChangeTmpBuf_BufArgsSerializer, event);
                InteropNativeModule._CallCallbackSync(10, -1444325632, onStateChangeTmpBuf_BufArgsSerializer.asBuffer(), onStateChangeTmpBuf_BufArgsSerializer.length());
                onStateChangeTmpBuf_BufArgsSerializer.release();
                return;
            }
        }
        const onStateChangeTmpResult : PopupStateChangeCallback | undefined = onStateChangeTmpBuf
        const arrowOffsetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowOffsetTmpBuf : Length | undefined = undefined
        if ((arrowOffsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowOffsetTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let arrowOffsetTmpBuf_ : string | number | Resource | undefined
            if (arrowOffsetTmpBuf_UnionSelector == (0).toChar()) {
                arrowOffsetTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (arrowOffsetTmpBuf_UnionSelector == (1).toChar()) {
                arrowOffsetTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (arrowOffsetTmpBuf_UnionSelector == (2).toChar()) {
                arrowOffsetTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for arrowOffsetTmpBuf_ has to be chosen through deserialisation.")
            }
            arrowOffsetTmpBuf = (arrowOffsetTmpBuf_ as string | number | Resource)
        }
        const arrowOffsetTmpResult : Length | undefined = arrowOffsetTmpBuf
        const showInSubWindowTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let showInSubWindowTmpBuf : boolean | undefined = undefined
        if ((showInSubWindowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            showInSubWindowTmpBuf = valueDeserializer.readBoolean()
        }
        const showInSubWindowTmpResult : boolean | undefined = showInSubWindowTmpBuf
        const maskTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let maskTmpBuf : boolean | PopupMaskType | undefined = undefined
        if ((maskTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const maskTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let maskTmpBuf_ : boolean | PopupMaskType | undefined
            if (maskTmpBuf_UnionSelector == (0).toChar()) {
                maskTmpBuf_ = valueDeserializer.readBoolean()
            } else if (maskTmpBuf_UnionSelector == (1).toChar()) {
                maskTmpBuf_ = PopupMaskType_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for maskTmpBuf_ has to be chosen through deserialisation.")
            }
            maskTmpBuf = (maskTmpBuf_ as boolean | PopupMaskType)
        }
        const maskTmpResult : boolean | PopupMaskType | undefined = maskTmpBuf
        const messageOptionsTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let messageOptionsTmpBuf : PopupMessageOptions | undefined = undefined
        if ((messageOptionsTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            messageOptionsTmpBuf = PopupMessageOptions_serializer.read(valueDeserializer)
        }
        const messageOptionsTmpResult : PopupMessageOptions | undefined = messageOptionsTmpBuf
        const targetSpaceTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let targetSpaceTmpBuf : Length | undefined = undefined
        if ((targetSpaceTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const targetSpaceTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let targetSpaceTmpBuf_ : string | number | Resource | undefined
            if (targetSpaceTmpBuf_UnionSelector == (0).toChar()) {
                targetSpaceTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (targetSpaceTmpBuf_UnionSelector == (1).toChar()) {
                targetSpaceTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (targetSpaceTmpBuf_UnionSelector == (2).toChar()) {
                targetSpaceTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for targetSpaceTmpBuf_ has to be chosen through deserialisation.")
            }
            targetSpaceTmpBuf = (targetSpaceTmpBuf_ as string | number | Resource)
        }
        const targetSpaceTmpResult : Length | undefined = targetSpaceTmpBuf
        const enableArrowTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableArrowTmpBuf : boolean | undefined = undefined
        if ((enableArrowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableArrowTmpBuf = valueDeserializer.readBoolean()
        }
        const enableArrowTmpResult : boolean | undefined = enableArrowTmpBuf
        const offsetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let offsetTmpBuf : Position | undefined = undefined
        if ((offsetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            offsetTmpBuf = Position_serializer.read(valueDeserializer)
        }
        const offsetTmpResult : Position | undefined = offsetTmpBuf
        const popupColorTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let popupColorTmpBuf : Color | string | Resource | int64 | undefined = undefined
        if ((popupColorTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const popupColorTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let popupColorTmpBuf_ : Color | string | Resource | int64 | undefined
            if (popupColorTmpBuf_UnionSelector == (0).toChar()) {
                popupColorTmpBuf_ = Color.values()[valueDeserializer.readInt32()]
            } else if (popupColorTmpBuf_UnionSelector == (1).toChar()) {
                popupColorTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (popupColorTmpBuf_UnionSelector == (2).toChar()) {
                popupColorTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else if (popupColorTmpBuf_UnionSelector == (3).toChar()) {
                popupColorTmpBuf_ = valueDeserializer.readInt64()
            } else {
                throw new Error("One of the branches for popupColorTmpBuf_ has to be chosen through deserialisation.")
            }
            popupColorTmpBuf = (popupColorTmpBuf_ as Color | string | Resource | int64)
        }
        const popupColorTmpResult : Color | string | Resource | int64 | undefined = popupColorTmpBuf
        const autoCancelTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let autoCancelTmpBuf : boolean | undefined = undefined
        if ((autoCancelTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            autoCancelTmpBuf = valueDeserializer.readBoolean()
        }
        const autoCancelTmpResult : boolean | undefined = autoCancelTmpBuf
        const widthTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let widthTmpBuf : Dimension | undefined = undefined
        if ((widthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const widthTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let widthTmpBuf_ : string | number | Resource | undefined
            if (widthTmpBuf_UnionSelector == (0).toChar()) {
                widthTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (widthTmpBuf_UnionSelector == (1).toChar()) {
                widthTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (widthTmpBuf_UnionSelector == (2).toChar()) {
                widthTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for widthTmpBuf_ has to be chosen through deserialisation.")
            }
            widthTmpBuf = (widthTmpBuf_ as string | number | Resource)
        }
        const widthTmpResult : Dimension | undefined = widthTmpBuf
        const arrowPointPositionTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowPointPositionTmpBuf : ArrowPointPosition | undefined = undefined
        if ((arrowPointPositionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            arrowPointPositionTmpBuf = ArrowPointPosition.values()[valueDeserializer.readInt32()]
        }
        const arrowPointPositionTmpResult : ArrowPointPosition | undefined = arrowPointPositionTmpBuf
        const arrowWidthTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowWidthTmpBuf : Dimension | undefined = undefined
        if ((arrowWidthTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowWidthTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let arrowWidthTmpBuf_ : string | number | Resource | undefined
            if (arrowWidthTmpBuf_UnionSelector == (0).toChar()) {
                arrowWidthTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (arrowWidthTmpBuf_UnionSelector == (1).toChar()) {
                arrowWidthTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (arrowWidthTmpBuf_UnionSelector == (2).toChar()) {
                arrowWidthTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for arrowWidthTmpBuf_ has to be chosen through deserialisation.")
            }
            arrowWidthTmpBuf = (arrowWidthTmpBuf_ as string | number | Resource)
        }
        const arrowWidthTmpResult : Dimension | undefined = arrowWidthTmpBuf
        const arrowHeightTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let arrowHeightTmpBuf : Dimension | undefined = undefined
        if ((arrowHeightTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const arrowHeightTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let arrowHeightTmpBuf_ : string | number | Resource | undefined
            if (arrowHeightTmpBuf_UnionSelector == (0).toChar()) {
                arrowHeightTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (arrowHeightTmpBuf_UnionSelector == (1).toChar()) {
                arrowHeightTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (arrowHeightTmpBuf_UnionSelector == (2).toChar()) {
                arrowHeightTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for arrowHeightTmpBuf_ has to be chosen through deserialisation.")
            }
            arrowHeightTmpBuf = (arrowHeightTmpBuf_ as string | number | Resource)
        }
        const arrowHeightTmpResult : Dimension | undefined = arrowHeightTmpBuf
        const radiusTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let radiusTmpBuf : Dimension | undefined = undefined
        if ((radiusTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const radiusTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let radiusTmpBuf_ : string | number | Resource | undefined
            if (radiusTmpBuf_UnionSelector == (0).toChar()) {
                radiusTmpBuf_ = (valueDeserializer.readString() as string)
            } else if (radiusTmpBuf_UnionSelector == (1).toChar()) {
                radiusTmpBuf_ = (valueDeserializer.readNumber() as number)
            } else if (radiusTmpBuf_UnionSelector == (2).toChar()) {
                radiusTmpBuf_ = Resource_serializer.read(valueDeserializer)
            } else {
                throw new Error("One of the branches for radiusTmpBuf_ has to be chosen through deserialisation.")
            }
            radiusTmpBuf = (radiusTmpBuf_ as string | number | Resource)
        }
        const radiusTmpResult : Dimension | undefined = radiusTmpBuf
        const shadowTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let shadowTmpBuf : ShadowOptions | ShadowStyle | undefined = undefined
        if ((shadowTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const shadowTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let shadowTmpBuf_ : ShadowOptions | ShadowStyle | undefined
            if (shadowTmpBuf_UnionSelector == (0).toChar()) {
                shadowTmpBuf_ = ShadowOptions_serializer.read(valueDeserializer)
            } else if (shadowTmpBuf_UnionSelector == (1).toChar()) {
                shadowTmpBuf_ = ShadowStyle.fromValue(valueDeserializer.readInt32())
            } else {
                throw new Error("One of the branches for shadowTmpBuf_ has to be chosen through deserialisation.")
            }
            shadowTmpBuf = (shadowTmpBuf_ as ShadowOptions | ShadowStyle)
        }
        const shadowTmpResult : ShadowOptions | ShadowStyle | undefined = shadowTmpBuf
        const backgroundBlurStyleTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let backgroundBlurStyleTmpBuf : BlurStyle | undefined = undefined
        if ((backgroundBlurStyleTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            backgroundBlurStyleTmpBuf = BlurStyle.fromValue(valueDeserializer.readInt32())
        }
        const backgroundBlurStyleTmpResult : BlurStyle | undefined = backgroundBlurStyleTmpBuf
        const transitionTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let transitionTmpBuf : TransitionEffect | undefined = undefined
        if ((transitionTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            transitionTmpBuf = (TransitionEffect_serializer.read(valueDeserializer) as TransitionEffect)
        }
        const transitionTmpResult : TransitionEffect | undefined = transitionTmpBuf
        const onWillDismissTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let onWillDismissTmpBuf : boolean | ((value0: DismissPopupAction) => void) | undefined = undefined
        if ((onWillDismissTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            const onWillDismissTmpBuf_UnionSelector : int32 = valueDeserializer.readInt8()
            let onWillDismissTmpBuf_ : boolean | ((value0: DismissPopupAction) => void) | undefined
            if (onWillDismissTmpBuf_UnionSelector == (0).toChar()) {
                onWillDismissTmpBuf_ = valueDeserializer.readBoolean()
            } else if (onWillDismissTmpBuf_UnionSelector == (1).toChar()) {
                const onWillDismissTmpBuf_BufUBufResource : CallbackResource = valueDeserializer.readCallbackResource()
                const onWillDismissTmpBuf_BufUBufCall : KPointer = valueDeserializer.readPointer()
                const onWillDismissTmpBuf_BufUBufCallSync : KPointer = valueDeserializer.readPointer()
                onWillDismissTmpBuf_ = (value0: DismissPopupAction):void => {
                    const onWillDismissTmpBuf_BufUBufArgsSerializer : SerializerBase = SerializerBase.hold();
                    onWillDismissTmpBuf_BufUBufArgsSerializer.writeInt32(onWillDismissTmpBuf_BufUBufResource.resourceId);
                    onWillDismissTmpBuf_BufUBufArgsSerializer.writePointer(onWillDismissTmpBuf_BufUBufCall);
                    onWillDismissTmpBuf_BufUBufArgsSerializer.writePointer(onWillDismissTmpBuf_BufUBufCallSync);
                    DismissPopupAction_serializer.write(onWillDismissTmpBuf_BufUBufArgsSerializer, value0);
                    InteropNativeModule._CallCallbackSync(10, -2004166751, onWillDismissTmpBuf_BufUBufArgsSerializer.asBuffer(), onWillDismissTmpBuf_BufUBufArgsSerializer.length());
                    onWillDismissTmpBuf_BufUBufArgsSerializer.release();
                    return;
                }
            } else {
                throw new Error("One of the branches for onWillDismissTmpBuf_ has to be chosen through deserialisation.")
            }
            onWillDismissTmpBuf = (onWillDismissTmpBuf_ as boolean | ((value0: DismissPopupAction) => void))
        }
        const onWillDismissTmpResult : boolean | ((value0: DismissPopupAction) => void) | undefined = onWillDismissTmpBuf
        const enableHoverModeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let enableHoverModeTmpBuf : boolean | undefined = undefined
        if ((enableHoverModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            enableHoverModeTmpBuf = valueDeserializer.readBoolean()
        }
        const enableHoverModeTmpResult : boolean | undefined = enableHoverModeTmpBuf
        const followTransformOfTargetTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let followTransformOfTargetTmpBuf : boolean | undefined = undefined
        if ((followTransformOfTargetTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            followTransformOfTargetTmpBuf = valueDeserializer.readBoolean()
        }
        const followTransformOfTargetTmpResult : boolean | undefined = followTransformOfTargetTmpBuf
        const keyboardAvoidModeTmpBuf_runtimeType  = valueDeserializer.readInt8().toInt()
        let keyboardAvoidModeTmpBuf : KeyboardAvoidMode | undefined = undefined
        if ((keyboardAvoidModeTmpBuf_runtimeType) != (RuntimeType.UNDEFINED)) {
            keyboardAvoidModeTmpBuf = KeyboardAvoidMode.fromValue(valueDeserializer.readInt32())
        }
        const keyboardAvoidModeTmpResult : KeyboardAvoidMode | undefined = keyboardAvoidModeTmpBuf
        let value : PopupOptions = ({message: messageTmpResult, placement: placementTmpResult, primaryButton: primaryButtonTmpResult, secondaryButton: secondaryButtonTmpResult, onStateChange: onStateChangeTmpResult, arrowOffset: arrowOffsetTmpResult, showInSubWindow: showInSubWindowTmpResult, mask: maskTmpResult, messageOptions: messageOptionsTmpResult, targetSpace: targetSpaceTmpResult, enableArrow: enableArrowTmpResult, offset: offsetTmpResult, popupColor: popupColorTmpResult, autoCancel: autoCancelTmpResult, width: widthTmpResult, arrowPointPosition: arrowPointPositionTmpResult, arrowWidth: arrowWidthTmpResult, arrowHeight: arrowHeightTmpResult, radius: radiusTmpResult, shadow: shadowTmpResult, backgroundBlurStyle: backgroundBlurStyleTmpResult, transition: transitionTmpResult, onWillDismiss: onWillDismissTmpResult, enableHoverMode: enableHoverModeTmpResult, followTransformOfTarget: followTransformOfTargetTmpResult, keyboardAvoidMode: keyboardAvoidModeTmpResult} as PopupOptions)
        return value
    }
}
export interface AccessibilityHoverEvent extends BaseEvent {
    type: AccessibilityHoverType
    x: double
    y: double
    displayX: double
    displayY: double
    windowX: double
    windowY: double
}
export class AccessibilityHoverEventInternal extends BaseEventInternal implements MaterializedBase,AccessibilityHoverEvent {
    get type(): AccessibilityHoverType {
        return this.getType()
    }
    set type(type: AccessibilityHoverType) {
        this.setType(type)
    }
    get x(): double {
        return this.getX()
    }
    set x(x: double) {
        this.setX(x)
    }
    get y(): double {
        return this.getY()
    }
    set y(y: double) {
        this.setY(y)
    }
    get displayX(): double {
        return this.getDisplayX()
    }
    set displayX(displayX: double) {
        this.setDisplayX(displayX)
    }
    get displayY(): double {
        return this.getDisplayY()
    }
    set displayY(displayY: double) {
        this.setDisplayY(displayY)
    }
    get windowX(): double {
        return this.getWindowX()
    }
    set windowX(windowX: double) {
        this.setWindowX(windowX)
    }
    get windowY(): double {
        return this.getWindowY()
    }
    set windowY(windowY: double) {
        this.setWindowY(windowY)
    }
    constructor(peerPtr: KPointer) {
        super(peerPtr)
    }
    constructor() {
        this(AccessibilityHoverEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): AccessibilityHoverEventInternal {
        return new AccessibilityHoverEventInternal(ptr)
    }
    private getType(): AccessibilityHoverType {
        return this.getType_serialize()
    }
    private setType(type: AccessibilityHoverType): void {
        const type_casted = type as (AccessibilityHoverType)
        this.setType_serialize(type_casted)
        return
    }
    private getX(): double {
        return this.getX_serialize()
    }
    private setX(x: double): void {
        const x_casted = x as (double)
        this.setX_serialize(x_casted)
        return
    }
    private getY(): double {
        return this.getY_serialize()
    }
    private setY(y: double): void {
        const y_casted = y as (double)
        this.setY_serialize(y_casted)
        return
    }
    private getDisplayX(): double {
        return this.getDisplayX_serialize()
    }
    private setDisplayX(displayX: double): void {
        const displayX_casted = displayX as (double)
        this.setDisplayX_serialize(displayX_casted)
        return
    }
    private getDisplayY(): double {
        return this.getDisplayY_serialize()
    }
    private setDisplayY(displayY: double): void {
        const displayY_casted = displayY as (double)
        this.setDisplayY_serialize(displayY_casted)
        return
    }
    private getWindowX(): double {
        return this.getWindowX_serialize()
    }
    private setWindowX(windowX: double): void {
        const windowX_casted = windowX as (double)
        this.setWindowX_serialize(windowX_casted)
        return
    }
    private getWindowY(): double {
        return this.getWindowY_serialize()
    }
    private setWindowY(windowY: double): void {
        const windowY_casted = windowY as (double)
        this.setWindowY_serialize(windowY_casted)
        return
    }
    private getType_serialize(): AccessibilityHoverType {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getType(this.peer!.ptr)
        return AccessibilityHoverType.fromValue(retval)
    }
    private setType_serialize(type: AccessibilityHoverType): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setType(this.peer!.ptr, type.valueOf())
    }
    private getX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getX(this.peer!.ptr)
        return retval
    }
    private setX_serialize(x: double): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setX(this.peer!.ptr, x)
    }
    private getY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getY(this.peer!.ptr)
        return retval
    }
    private setY_serialize(y: double): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setY(this.peer!.ptr, y)
    }
    private getDisplayX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getDisplayX(this.peer!.ptr)
        return retval
    }
    private setDisplayX_serialize(displayX: double): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setDisplayX(this.peer!.ptr, displayX)
    }
    private getDisplayY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getDisplayY(this.peer!.ptr)
        return retval
    }
    private setDisplayY_serialize(displayY: double): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setDisplayY(this.peer!.ptr, displayY)
    }
    private getWindowX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getWindowX(this.peer!.ptr)
        return retval
    }
    private setWindowX_serialize(windowX: double): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setWindowX(this.peer!.ptr, windowX)
    }
    private getWindowY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AccessibilityHoverEvent_getWindowY(this.peer!.ptr)
        return retval
    }
    private setWindowY_serialize(windowY: double): void {
        ArkUIGeneratedNativeModule._AccessibilityHoverEvent_setWindowY(this.peer!.ptr, windowY)
    }
}
export interface AxisEvent extends BaseEvent {
    action: AxisAction
    displayX: double
    displayY: double
    windowX: double
    windowY: double
    x: double
    y: double
    scrollStep?: int32 | undefined
    propagation(): void
    getHorizontalAxisValue(): double
    getVerticalAxisValue(): double
    hasAxis(axisType: AxisType): boolean
}
export class AxisEventInternal extends BaseEventInternal implements MaterializedBase,AxisEvent {
    get action(): AxisAction {
        return this.getAction()
    }
    set action(action: AxisAction) {
        this.setAction(action)
    }
    get displayX(): double {
        return this.getDisplayX()
    }
    set displayX(displayX: double) {
        this.setDisplayX(displayX)
    }
    get displayY(): double {
        return this.getDisplayY()
    }
    set displayY(displayY: double) {
        this.setDisplayY(displayY)
    }
    get windowX(): double {
        return this.getWindowX()
    }
    set windowX(windowX: double) {
        this.setWindowX(windowX)
    }
    get windowY(): double {
        return this.getWindowY()
    }
    set windowY(windowY: double) {
        this.setWindowY(windowY)
    }
    get x(): double {
        return this.getX()
    }
    set x(x: double) {
        this.setX(x)
    }
    get y(): double {
        return this.getY()
    }
    set y(y: double) {
        this.setY(y)
    }
    get scrollStep(): int32 | undefined {
        return this.getScrollStep()
    }
    set scrollStep(scrollStep: int32 | undefined) {
        const scrollStep_NonNull  = (scrollStep as int32)
        this.setScrollStep(scrollStep_NonNull)
    }
    public propagation(): void {
        this.propagation_serialize()
        return
    }
    constructor(peerPtr: KPointer) {
        super(peerPtr)
    }
    constructor() {
        this(AxisEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._AxisEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): AxisEventInternal {
        return new AxisEventInternal(ptr)
    }
    public getHorizontalAxisValue(): double {
        return this.getHorizontalAxisValue_serialize()
    }
    public getVerticalAxisValue(): double {
        return this.getVerticalAxisValue_serialize()
    }
    public hasAxis(axisType: AxisType): boolean {
        const axisType_casted = axisType as (AxisType)
        return this.hasAxis_serialize(axisType_casted)
    }
    private getAction(): AxisAction {
        return this.getAction_serialize()
    }
    private setAction(action: AxisAction): void {
        const action_casted = action as (AxisAction)
        this.setAction_serialize(action_casted)
        return
    }
    private getDisplayX(): double {
        return this.getDisplayX_serialize()
    }
    private setDisplayX(displayX: double): void {
        const displayX_casted = displayX as (double)
        this.setDisplayX_serialize(displayX_casted)
        return
    }
    private getDisplayY(): double {
        return this.getDisplayY_serialize()
    }
    private setDisplayY(displayY: double): void {
        const displayY_casted = displayY as (double)
        this.setDisplayY_serialize(displayY_casted)
        return
    }
    private getWindowX(): double {
        return this.getWindowX_serialize()
    }
    private setWindowX(windowX: double): void {
        const windowX_casted = windowX as (double)
        this.setWindowX_serialize(windowX_casted)
        return
    }
    private getWindowY(): double {
        return this.getWindowY_serialize()
    }
    private setWindowY(windowY: double): void {
        const windowY_casted = windowY as (double)
        this.setWindowY_serialize(windowY_casted)
        return
    }
    private getX(): double {
        return this.getX_serialize()
    }
    private setX(x: double): void {
        const x_casted = x as (double)
        this.setX_serialize(x_casted)
        return
    }
    private getY(): double {
        return this.getY_serialize()
    }
    private setY(y: double): void {
        const y_casted = y as (double)
        this.setY_serialize(y_casted)
        return
    }
    private getScrollStep(): int32 | undefined {
        return this.getScrollStep_serialize()
    }
    private setScrollStep(scrollStep: int32 | undefined): void {
        const scrollStep_casted = scrollStep as (int32 | undefined)
        this.setScrollStep_serialize(scrollStep_casted)
        return
    }
    getHorizontalAxisValue_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getHorizontalAxisValue(this.peer!.ptr)
        return retval
    }
    hasAxis_serialize(axisType: AxisType): boolean {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_hasAxis(this.peer!.ptr, axisType.valueOf())
        return retval
    }
    getVerticalAxisValue_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getVerticalAxisValue(this.peer!.ptr)
        return retval
    }
    private getAction_serialize(): AxisAction {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getAction(this.peer!.ptr)
        return AxisAction.fromValue(retval)
    }
    private setAction_serialize(action: AxisAction): void {
        ArkUIGeneratedNativeModule._AxisEvent_setAction(this.peer!.ptr, action.valueOf())
    }
    private getDisplayX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getDisplayX(this.peer!.ptr)
        return retval
    }
    private setDisplayX_serialize(displayX: double): void {
        ArkUIGeneratedNativeModule._AxisEvent_setDisplayX(this.peer!.ptr, displayX)
    }
    private getDisplayY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getDisplayY(this.peer!.ptr)
        return retval
    }
    private setDisplayY_serialize(displayY: double): void {
        ArkUIGeneratedNativeModule._AxisEvent_setDisplayY(this.peer!.ptr, displayY)
    }
    private getWindowX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getWindowX(this.peer!.ptr)
        return retval
    }
    private setWindowX_serialize(windowX: double): void {
        ArkUIGeneratedNativeModule._AxisEvent_setWindowX(this.peer!.ptr, windowX)
    }
    private getWindowY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getWindowY(this.peer!.ptr)
        return retval
    }
    private setWindowY_serialize(windowY: double): void {
        ArkUIGeneratedNativeModule._AxisEvent_setWindowY(this.peer!.ptr, windowY)
    }
    private getX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getX(this.peer!.ptr)
        return retval
    }
    private setX_serialize(x: double): void {
        ArkUIGeneratedNativeModule._AxisEvent_setX(this.peer!.ptr, x)
    }
    private getY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getY(this.peer!.ptr)
        return retval
    }
    private setY_serialize(y: double): void {
        ArkUIGeneratedNativeModule._AxisEvent_setY(this.peer!.ptr, y)
    }
    private getScrollStep_serialize(): int32 | undefined {
        const retval  = ArkUIGeneratedNativeModule._AxisEvent_getScrollStep(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : int32 | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readInt32()
        }
        const returnResult : int32 | undefined = buffer
        return returnResult
    }
    private setScrollStep_serialize(scrollStep: int32 | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (scrollStep !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const scrollStepTmpValue  = scrollStep!
            thisSerializer.writeInt32(scrollStepTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._AxisEvent_setScrollStep(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    propagation_serialize(): void {
        ArkUIGeneratedNativeModule._AxisEvent_propagation(this.peer!.ptr)
    }
}
export interface ClickEvent extends BaseEvent {
    displayX: double
    displayY: double
    windowX: double
    windowY: double
    x: double
    y: double
    hand?: InteractionHand | undefined
    preventDefault(): void
}
export class ClickEventInternal extends BaseEventInternal implements MaterializedBase,ClickEvent {
    get displayX(): double {
        return this.getDisplayX()
    }
    set displayX(displayX: double) {
        this.setDisplayX(displayX)
    }
    get displayY(): double {
        return this.getDisplayY()
    }
    set displayY(displayY: double) {
        this.setDisplayY(displayY)
    }
    get windowX(): double {
        return this.getWindowX()
    }
    set windowX(windowX: double) {
        this.setWindowX(windowX)
    }
    get windowY(): double {
        return this.getWindowY()
    }
    set windowY(windowY: double) {
        this.setWindowY(windowY)
    }
    get x(): double {
        return this.getX()
    }
    set x(x: double) {
        this.setX(x)
    }
    get y(): double {
        return this.getY()
    }
    set y(y: double) {
        this.setY(y)
    }
    get hand(): InteractionHand | undefined {
        return this.getHand()
    }
    set hand(hand: InteractionHand | undefined) {
        const hand_NonNull  = (hand as InteractionHand)
        this.setHand(hand_NonNull)
    }
    public preventDefault(): void {
        this.preventDefault_serialize()
        return
    }
    constructor(peerPtr: KPointer) {
        super(peerPtr)
    }
    constructor() {
        this(ClickEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._ClickEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): ClickEventInternal {
        return new ClickEventInternal(ptr)
    }
    private getDisplayX(): double {
        return this.getDisplayX_serialize()
    }
    private setDisplayX(displayX: double): void {
        const displayX_casted = displayX as (double)
        this.setDisplayX_serialize(displayX_casted)
        return
    }
    private getDisplayY(): double {
        return this.getDisplayY_serialize()
    }
    private setDisplayY(displayY: double): void {
        const displayY_casted = displayY as (double)
        this.setDisplayY_serialize(displayY_casted)
        return
    }
    private getWindowX(): double {
        return this.getWindowX_serialize()
    }
    private setWindowX(windowX: double): void {
        const windowX_casted = windowX as (double)
        this.setWindowX_serialize(windowX_casted)
        return
    }
    private getWindowY(): double {
        return this.getWindowY_serialize()
    }
    private setWindowY(windowY: double): void {
        const windowY_casted = windowY as (double)
        this.setWindowY_serialize(windowY_casted)
        return
    }
    private getX(): double {
        return this.getX_serialize()
    }
    private setX(x: double): void {
        const x_casted = x as (double)
        this.setX_serialize(x_casted)
        return
    }
    private getY(): double {
        return this.getY_serialize()
    }
    private setY(y: double): void {
        const y_casted = y as (double)
        this.setY_serialize(y_casted)
        return
    }
    private getHand(): InteractionHand | undefined {
        return this.getHand_serialize()
    }
    private setHand(hand: InteractionHand | undefined): void {
        const hand_casted = hand as (InteractionHand | undefined)
        this.setHand_serialize(hand_casted)
        return
    }
    private getDisplayX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getDisplayX(this.peer!.ptr)
        return retval
    }
    private setDisplayX_serialize(displayX: double): void {
        ArkUIGeneratedNativeModule._ClickEvent_setDisplayX(this.peer!.ptr, displayX)
    }
    private getDisplayY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getDisplayY(this.peer!.ptr)
        return retval
    }
    private setDisplayY_serialize(displayY: double): void {
        ArkUIGeneratedNativeModule._ClickEvent_setDisplayY(this.peer!.ptr, displayY)
    }
    private getWindowX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getWindowX(this.peer!.ptr)
        return retval
    }
    private setWindowX_serialize(windowX: double): void {
        ArkUIGeneratedNativeModule._ClickEvent_setWindowX(this.peer!.ptr, windowX)
    }
    private getWindowY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getWindowY(this.peer!.ptr)
        return retval
    }
    private setWindowY_serialize(windowY: double): void {
        ArkUIGeneratedNativeModule._ClickEvent_setWindowY(this.peer!.ptr, windowY)
    }
    private getX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getX(this.peer!.ptr)
        return retval
    }
    private setX_serialize(x: double): void {
        ArkUIGeneratedNativeModule._ClickEvent_setX(this.peer!.ptr, x)
    }
    private getY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getY(this.peer!.ptr)
        return retval
    }
    private setY_serialize(y: double): void {
        ArkUIGeneratedNativeModule._ClickEvent_setY(this.peer!.ptr, y)
    }
    private getHand_serialize(): InteractionHand | undefined {
        const retval  = ArkUIGeneratedNativeModule._ClickEvent_getHand(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : InteractionHand | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = InteractionHand.fromValue(retvalDeserializer.readInt32())
        }
        const returnResult : InteractionHand | undefined = buffer
        return returnResult
    }
    private setHand_serialize(hand: InteractionHand | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (hand !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const handTmpValue  = (hand as InteractionHand)
            thisSerializer.writeInt32(handTmpValue.valueOf())
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._ClickEvent_setHand(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    preventDefault_serialize(): void {
        ArkUIGeneratedNativeModule._ClickEvent_preventDefault(this.peer!.ptr)
    }
}
export interface FocusAxisEvent extends BaseEvent {
    axisMap: Map<AxisModel, double>
    stopPropagation(): void
}
export class FocusAxisEventInternal extends BaseEventInternal implements MaterializedBase,FocusAxisEvent {
    get axisMap(): Map<AxisModel, double> {
        return this.getAxisMap()
    }
    set axisMap(axisMap: Map<AxisModel, double>) {
        this.setAxisMap(axisMap)
    }
    public stopPropagation(): void {
        this.stopPropagation_serialize()
        return
    }
    constructor(peerPtr: KPointer) {
        super(peerPtr)
    }
    constructor() {
        this(FocusAxisEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._FocusAxisEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._FocusAxisEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): FocusAxisEventInternal {
        return new FocusAxisEventInternal(ptr)
    }
    private getAxisMap(): Map<AxisModel, double> {
        return this.getAxisMap_serialize()
    }
    private setAxisMap(axisMap: Map<AxisModel, double>): void {
        const axisMap_casted = axisMap as (Map<AxisModel, double>)
        this.setAxisMap_serialize(axisMap_casted)
        return
    }
    private getAxisMap_serialize(): Map<AxisModel, double> {
        const retval  = ArkUIGeneratedNativeModule._FocusAxisEvent_getAxisMap(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const bufferSizeVar : int32 = retvalDeserializer.readInt32()
        let buffer : Map<AxisModel, double> = new Map<AxisModel, double>()
        // TODO: TS map resize
        for (let bufferIVar = 0; bufferIVar < bufferSizeVar; bufferIVar++) {
            const bufferKeyVar : AxisModel = AxisModel.fromValue(retvalDeserializer.readInt32())
            const bufferValueVar : double = retvalDeserializer.readFloat64()
            buffer.set(bufferKeyVar, bufferValueVar)
        }
        const returnResult : Map<AxisModel, double> = buffer
        return returnResult
    }
    private setAxisMap_serialize(axisMap: Map<AxisModel, double>): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.writeInt32((axisMap.size).toInt())
        for (const pair of axisMap) {
            const axisMapKeyVar = pair[0]
            const axisMapValueVar = pair[1]
            thisSerializer.writeInt32(axisMapKeyVar.valueOf())
            thisSerializer.writeFloat64(axisMapValueVar)
        }
        ArkUIGeneratedNativeModule._FocusAxisEvent_setAxisMap(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    stopPropagation_serialize(): void {
        ArkUIGeneratedNativeModule._FocusAxisEvent_stopPropagation(this.peer!.ptr)
    }
}
export interface HoverEvent extends BaseEvent {
    x?: double | undefined
    y?: double | undefined
    windowX?: double | undefined
    windowY?: double | undefined
    displayX?: double | undefined
    displayY?: double | undefined
    stopPropagation(): void
}
export class HoverEventInternal extends BaseEventInternal implements MaterializedBase,HoverEvent {
    get x(): double | undefined {
        return this.getX()
    }
    set x(x: double | undefined) {
        const x_NonNull  = (x as double)
        this.setX(x_NonNull)
    }
    get y(): double | undefined {
        return this.getY()
    }
    set y(y: double | undefined) {
        const y_NonNull  = (y as double)
        this.setY(y_NonNull)
    }
    get windowX(): double | undefined {
        return this.getWindowX()
    }
    set windowX(windowX: double | undefined) {
        const windowX_NonNull  = (windowX as double)
        this.setWindowX(windowX_NonNull)
    }
    get windowY(): double | undefined {
        return this.getWindowY()
    }
    set windowY(windowY: double | undefined) {
        const windowY_NonNull  = (windowY as double)
        this.setWindowY(windowY_NonNull)
    }
    get displayX(): double | undefined {
        return this.getDisplayX()
    }
    set displayX(displayX: double | undefined) {
        const displayX_NonNull  = (displayX as double)
        this.setDisplayX(displayX_NonNull)
    }
    get displayY(): double | undefined {
        return this.getDisplayY()
    }
    set displayY(displayY: double | undefined) {
        const displayY_NonNull  = (displayY as double)
        this.setDisplayY(displayY_NonNull)
    }
    public stopPropagation(): void {
        this.stopPropagation_serialize()
        return
    }
    constructor(peerPtr: KPointer) {
        super(peerPtr)
    }
    constructor() {
        this(HoverEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._HoverEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): HoverEventInternal {
        return new HoverEventInternal(ptr)
    }
    private getX(): double | undefined {
        return this.getX_serialize()
    }
    private setX(x: double | undefined): void {
        const x_casted = x as (double | undefined)
        this.setX_serialize(x_casted)
        return
    }
    private getY(): double | undefined {
        return this.getY_serialize()
    }
    private setY(y: double | undefined): void {
        const y_casted = y as (double | undefined)
        this.setY_serialize(y_casted)
        return
    }
    private getWindowX(): double | undefined {
        return this.getWindowX_serialize()
    }
    private setWindowX(windowX: double | undefined): void {
        const windowX_casted = windowX as (double | undefined)
        this.setWindowX_serialize(windowX_casted)
        return
    }
    private getWindowY(): double | undefined {
        return this.getWindowY_serialize()
    }
    private setWindowY(windowY: double | undefined): void {
        const windowY_casted = windowY as (double | undefined)
        this.setWindowY_serialize(windowY_casted)
        return
    }
    private getDisplayX(): double | undefined {
        return this.getDisplayX_serialize()
    }
    private setDisplayX(displayX: double | undefined): void {
        const displayX_casted = displayX as (double | undefined)
        this.setDisplayX_serialize(displayX_casted)
        return
    }
    private getDisplayY(): double | undefined {
        return this.getDisplayY_serialize()
    }
    private setDisplayY(displayY: double | undefined): void {
        const displayY_casted = displayY as (double | undefined)
        this.setDisplayY_serialize(displayY_casted)
        return
    }
    private getX_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getX(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setX_serialize(x: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (x !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const xTmpValue  = x!
            thisSerializer.writeFloat64(xTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setX(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getY_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getY(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setY_serialize(y: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (y !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const yTmpValue  = y!
            thisSerializer.writeFloat64(yTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setY(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getWindowX_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getWindowX(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setWindowX_serialize(windowX: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (windowX !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const windowXTmpValue  = windowX!
            thisSerializer.writeFloat64(windowXTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setWindowX(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getWindowY_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getWindowY(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setWindowY_serialize(windowY: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (windowY !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const windowYTmpValue  = windowY!
            thisSerializer.writeFloat64(windowYTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setWindowY(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getDisplayX_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getDisplayX(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setDisplayX_serialize(displayX: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (displayX !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const displayXTmpValue  = displayX!
            thisSerializer.writeFloat64(displayXTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setDisplayX(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getDisplayY_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._HoverEvent_getDisplayY(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setDisplayY_serialize(displayY: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (displayY !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const displayYTmpValue  = displayY!
            thisSerializer.writeFloat64(displayYTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._HoverEvent_setDisplayY(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    stopPropagation_serialize(): void {
        ArkUIGeneratedNativeModule._HoverEvent_stopPropagation(this.peer!.ptr)
    }
}
export interface MouseEvent extends BaseEvent {
    button: MouseButton
    action: MouseAction
    displayX: double
    displayY: double
    windowX: double
    windowY: double
    x: double
    y: double
    stopPropagation: (() => void)
    rawDeltaX?: double | undefined
    rawDeltaY?: double | undefined
    pressedButtons?: Array<MouseButton> | undefined
}
export class MouseEventInternal extends BaseEventInternal implements MaterializedBase,MouseEvent {
    get button(): MouseButton {
        return this.getButton()
    }
    set button(button: MouseButton) {
        this.setButton(button)
    }
    get action(): MouseAction {
        return this.getAction()
    }
    set action(action: MouseAction) {
        this.setAction(action)
    }
    get displayX(): double {
        return this.getDisplayX()
    }
    set displayX(displayX: double) {
        this.setDisplayX(displayX)
    }
    get displayY(): double {
        return this.getDisplayY()
    }
    set displayY(displayY: double) {
        this.setDisplayY(displayY)
    }
    get windowX(): double {
        return this.getWindowX()
    }
    set windowX(windowX: double) {
        this.setWindowX(windowX)
    }
    get windowY(): double {
        return this.getWindowY()
    }
    set windowY(windowY: double) {
        this.setWindowY(windowY)
    }
    get x(): double {
        return this.getX()
    }
    set x(x: double) {
        this.setX(x)
    }
    get y(): double {
        return this.getY()
    }
    set y(y: double) {
        this.setY(y)
    }
    get stopPropagation(): (() => void) {
        return this.getStopPropagation()
    }
    set stopPropagation(stopPropagation: (() => void)) {
        this.setStopPropagation(stopPropagation)
    }
    get rawDeltaX(): double | undefined {
        return this.getRawDeltaX()
    }
    set rawDeltaX(rawDeltaX: double | undefined) {
        const rawDeltaX_NonNull  = (rawDeltaX as double)
        this.setRawDeltaX(rawDeltaX_NonNull)
    }
    get rawDeltaY(): double | undefined {
        return this.getRawDeltaY()
    }
    set rawDeltaY(rawDeltaY: double | undefined) {
        const rawDeltaY_NonNull  = (rawDeltaY as double)
        this.setRawDeltaY(rawDeltaY_NonNull)
    }
    get pressedButtons(): Array<MouseButton> | undefined {
        return this.getPressedButtons()
    }
    set pressedButtons(pressedButtons: Array<MouseButton> | undefined) {
        const pressedButtons_NonNull  = (pressedButtons as Array<MouseButton>)
        this.setPressedButtons(pressedButtons_NonNull)
    }
    constructor(peerPtr: KPointer) {
        super(peerPtr)
    }
    constructor() {
        this(MouseEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._MouseEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): MouseEventInternal {
        return new MouseEventInternal(ptr)
    }
    private getButton(): MouseButton {
        return this.getButton_serialize()
    }
    private setButton(button: MouseButton): void {
        const button_casted = button as (MouseButton)
        this.setButton_serialize(button_casted)
        return
    }
    private getAction(): MouseAction {
        return this.getAction_serialize()
    }
    private setAction(action: MouseAction): void {
        const action_casted = action as (MouseAction)
        this.setAction_serialize(action_casted)
        return
    }
    private getDisplayX(): double {
        return this.getDisplayX_serialize()
    }
    private setDisplayX(displayX: double): void {
        const displayX_casted = displayX as (double)
        this.setDisplayX_serialize(displayX_casted)
        return
    }
    private getDisplayY(): double {
        return this.getDisplayY_serialize()
    }
    private setDisplayY(displayY: double): void {
        const displayY_casted = displayY as (double)
        this.setDisplayY_serialize(displayY_casted)
        return
    }
    private getWindowX(): double {
        return this.getWindowX_serialize()
    }
    private setWindowX(windowX: double): void {
        const windowX_casted = windowX as (double)
        this.setWindowX_serialize(windowX_casted)
        return
    }
    private getWindowY(): double {
        return this.getWindowY_serialize()
    }
    private setWindowY(windowY: double): void {
        const windowY_casted = windowY as (double)
        this.setWindowY_serialize(windowY_casted)
        return
    }
    private getX(): double {
        return this.getX_serialize()
    }
    private setX(x: double): void {
        const x_casted = x as (double)
        this.setX_serialize(x_casted)
        return
    }
    private getY(): double {
        return this.getY_serialize()
    }
    private setY(y: double): void {
        const y_casted = y as (double)
        this.setY_serialize(y_casted)
        return
    }
    private getStopPropagation(): (() => void) {
        return this.getStopPropagation_serialize()
    }
    private setStopPropagation(stopPropagation: (() => void)): void {
        const stopPropagation_casted = stopPropagation as ((() => void))
        this.setStopPropagation_serialize(stopPropagation_casted)
        return
    }
    private getRawDeltaX(): double | undefined {
        return this.getRawDeltaX_serialize()
    }
    private setRawDeltaX(rawDeltaX: double | undefined): void {
        const rawDeltaX_casted = rawDeltaX as (double | undefined)
        this.setRawDeltaX_serialize(rawDeltaX_casted)
        return
    }
    private getRawDeltaY(): double | undefined {
        return this.getRawDeltaY_serialize()
    }
    private setRawDeltaY(rawDeltaY: double | undefined): void {
        const rawDeltaY_casted = rawDeltaY as (double | undefined)
        this.setRawDeltaY_serialize(rawDeltaY_casted)
        return
    }
    private getPressedButtons(): Array<MouseButton> | undefined {
        return this.getPressedButtons_serialize()
    }
    private setPressedButtons(pressedButtons: Array<MouseButton> | undefined): void {
        const pressedButtons_casted = pressedButtons as (Array<MouseButton> | undefined)
        this.setPressedButtons_serialize(pressedButtons_casted)
        return
    }
    private getButton_serialize(): MouseButton {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getButton(this.peer!.ptr)
        return MouseButton.fromValue(retval)
    }
    private setButton_serialize(button: MouseButton): void {
        ArkUIGeneratedNativeModule._MouseEvent_setButton(this.peer!.ptr, button.valueOf())
    }
    private getAction_serialize(): MouseAction {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getAction(this.peer!.ptr)
        return MouseAction.fromValue(retval)
    }
    private setAction_serialize(action: MouseAction): void {
        ArkUIGeneratedNativeModule._MouseEvent_setAction(this.peer!.ptr, action.valueOf())
    }
    private getDisplayX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getDisplayX(this.peer!.ptr)
        return retval
    }
    private setDisplayX_serialize(displayX: double): void {
        ArkUIGeneratedNativeModule._MouseEvent_setDisplayX(this.peer!.ptr, displayX)
    }
    private getDisplayY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getDisplayY(this.peer!.ptr)
        return retval
    }
    private setDisplayY_serialize(displayY: double): void {
        ArkUIGeneratedNativeModule._MouseEvent_setDisplayY(this.peer!.ptr, displayY)
    }
    private getWindowX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getWindowX(this.peer!.ptr)
        return retval
    }
    private setWindowX_serialize(windowX: double): void {
        ArkUIGeneratedNativeModule._MouseEvent_setWindowX(this.peer!.ptr, windowX)
    }
    private getWindowY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getWindowY(this.peer!.ptr)
        return retval
    }
    private setWindowY_serialize(windowY: double): void {
        ArkUIGeneratedNativeModule._MouseEvent_setWindowY(this.peer!.ptr, windowY)
    }
    private getX_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getX(this.peer!.ptr)
        return retval
    }
    private setX_serialize(x: double): void {
        ArkUIGeneratedNativeModule._MouseEvent_setX(this.peer!.ptr, x)
    }
    private getY_serialize(): double {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getY(this.peer!.ptr)
        return retval
    }
    private setY_serialize(y: double): void {
        ArkUIGeneratedNativeModule._MouseEvent_setY(this.peer!.ptr, y)
    }
    private getStopPropagation_serialize(): (() => void) {
        const retval = ArkUIGeneratedNativeModule._MouseEvent_getStopPropagation(this.peer!.ptr)
        let retvalDeserializer: DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType = retvalDeserializer.readInt8().toInt()
        let buffer: (() => void) | undefined = undefined
        
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            const buffer_BufResource: CallbackResource = retvalDeserializer.readCallbackResource()
            const buffer_BufCall: KPointer = retvalDeserializer.readPointer()
            const buffer_BufCallSync: KPointer = retvalDeserializer.readPointer()
            
            buffer = (): void => {
                const buffer_BufArgsSerializer: SerializerBase = SerializerBase.hold();
                buffer_BufArgsSerializer.writeInt32(buffer_BufResource.resourceId);
                buffer_BufArgsSerializer.writePointer(buffer_BufCall);
                buffer_BufArgsSerializer.writePointer(buffer_BufCallSync);
                InteropNativeModule._CallCallbackSync(10, -1867723152, buffer_BufArgsSerializer.asBuffer(), buffer_BufArgsSerializer.length());
                buffer_BufArgsSerializer.release();
                return;
            }
        }
        
        const returnResult: (() => void) = (buffer || (() => {})) as (() => void);
        return returnResult;
    }
    private setStopPropagation_serialize(stopPropagation: (() => void)): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.holdAndWriteCallback(stopPropagation)
        ArkUIGeneratedNativeModule._MouseEvent_setStopPropagation(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getRawDeltaX_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getRawDeltaX(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setRawDeltaX_serialize(rawDeltaX: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (rawDeltaX !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const rawDeltaXTmpValue  = rawDeltaX!
            thisSerializer.writeFloat64(rawDeltaXTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._MouseEvent_setRawDeltaX(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getRawDeltaY_serialize(): double | undefined {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getRawDeltaY(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : double | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            buffer = retvalDeserializer.readFloat64()
        }
        const returnResult : double | undefined = buffer
        return returnResult
    }
    private setRawDeltaY_serialize(rawDeltaY: double | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (rawDeltaY !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const rawDeltaYTmpValue  = rawDeltaY!
            thisSerializer.writeFloat64(rawDeltaYTmpValue)
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._MouseEvent_setRawDeltaY(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getPressedButtons_serialize(): Array<MouseButton> | undefined {
        const retval  = ArkUIGeneratedNativeModule._MouseEvent_getPressedButtons(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : Array<MouseButton> | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            const buffer_Length : int32 = retvalDeserializer.readInt32()
            let buffer_ : Array<MouseButton> = new Array<MouseButton>(buffer_Length)
            for (let buffer_BufCounterI = 0; buffer_BufCounterI < buffer_Length; buffer_BufCounterI++) {
                buffer_[buffer_BufCounterI] = MouseButton.fromValue(retvalDeserializer.readInt32())
            }
            buffer = buffer_
        }
        const returnResult : Array<MouseButton> | undefined = buffer
        return returnResult
    }
    private setPressedButtons_serialize(pressedButtons: Array<MouseButton> | undefined): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        if (pressedButtons !== undefined) {
            thisSerializer.writeInt8(RuntimeType.OBJECT)
            const pressedButtonsTmpValue  = pressedButtons!
            thisSerializer.writeInt32((pressedButtonsTmpValue.length).toInt())
            for (let pressedButtonsTmpValueCounterI = 0; pressedButtonsTmpValueCounterI < pressedButtonsTmpValue.length; pressedButtonsTmpValueCounterI++) {
                const pressedButtonsTmpValueTmpElement : MouseButton = pressedButtonsTmpValue[pressedButtonsTmpValueCounterI]
                thisSerializer.writeInt32(pressedButtonsTmpValueTmpElement.valueOf())
            }
        } else {
            thisSerializer.writeInt8(RuntimeType.UNDEFINED)
        }
        ArkUIGeneratedNativeModule._MouseEvent_setPressedButtons(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
}
export interface TouchEvent extends BaseEvent {
    type: TouchType
    touches: Array<TouchObject>
    changedTouches: Array<TouchObject>
    stopPropagation(): void
    preventDefault(): void
    getHistoricalPoints(): Array<HistoricalPoint> | undefined
}
export class TouchEventInternal extends BaseEventInternal implements MaterializedBase,TouchEvent {
    get type(): TouchType {
        return this.getType()
    }
    set type(type: TouchType) {
        this.setType(type)
    }
    get touches(): Array<TouchObject> {
        return this.getTouches()
    }
    set touches(touches: Array<TouchObject>) {
        this.setTouches(touches)
    }
    get changedTouches(): Array<TouchObject> {
        return this.getChangedTouches()
    }
    set changedTouches(changedTouches: Array<TouchObject>) {
        this.setChangedTouches(changedTouches)
    }
    public stopPropagation(): void {
        this.stopPropagation_serialize()
        return
    }
    public preventDefault(): void {
        this.preventDefault_serialize()
        return
    }
    constructor(peerPtr: KPointer) {
        super(peerPtr)
    }
    constructor() {
        this(TouchEventInternal.construct())
    }
    static construct(): KPointer {
        const retval  = ArkUIGeneratedNativeModule._TouchEvent_construct()
        return retval
    }
    static getFinalizer(): KPointer {
        return ArkUIGeneratedNativeModule._TouchEvent_getFinalizer()
    }
    public static fromPtr(ptr: KPointer): TouchEventInternal {
        return new TouchEventInternal(ptr)
    }
    public getHistoricalPoints(): Array<HistoricalPoint> | undefined {
        return this.getHistoricalPoints_serialize()
    }
    private getType(): TouchType {
        return this.getType_serialize()
    }
    private setType(type: TouchType): void {
        const type_casted = type as (TouchType)
        this.setType_serialize(type_casted)
        return
    }
    private getTouches(): Array<TouchObject> {
        return this.getTouches_serialize()
    }
    private setTouches(touches: Array<TouchObject>): void {
        const touches_casted = touches as (Array<TouchObject>)
        this.setTouches_serialize(touches_casted)
        return
    }
    private getChangedTouches(): Array<TouchObject> {
        return this.getChangedTouches_serialize()
    }
    private setChangedTouches(changedTouches: Array<TouchObject>): void {
        const changedTouches_casted = changedTouches as (Array<TouchObject>)
        this.setChangedTouches_serialize(changedTouches_casted)
        return
    }
    getHistoricalPoints_serialize(): Array<HistoricalPoint> | undefined {
        const retval  = ArkUIGeneratedNativeModule._TouchEvent_getHistoricalPoints(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const buffer_runtimeType  = retvalDeserializer.readInt8().toInt()
        let buffer : Array<HistoricalPoint> | undefined = undefined
        if ((buffer_runtimeType) != (RuntimeType.UNDEFINED)) {
            const buffer_Length : int32 = retvalDeserializer.readInt32()
            let buffer_ : Array<HistoricalPoint> = new Array<HistoricalPoint>(buffer_Length)
            for (let buffer_BufCounterI = 0; buffer_BufCounterI < buffer_Length; buffer_BufCounterI++) {
                buffer_[buffer_BufCounterI] = HistoricalPoint_serializer.read(retvalDeserializer)
            }
            buffer = buffer_
        }
        const returnResult : Array<HistoricalPoint> | undefined = buffer
        return returnResult
    }
    private getType_serialize(): TouchType {
        const retval  = ArkUIGeneratedNativeModule._TouchEvent_getType(this.peer!.ptr)
        return TouchType.fromValue(retval)
    }
    private setType_serialize(type: TouchType): void {
        ArkUIGeneratedNativeModule._TouchEvent_setType(this.peer!.ptr, type.valueOf())
    }
    private getTouches_serialize(): Array<TouchObject> {
        const retval  = ArkUIGeneratedNativeModule._TouchEvent_getTouches(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const bufferLength : int32 = retvalDeserializer.readInt32()
        let buffer : Array<TouchObject> = new Array<TouchObject>(bufferLength)
        for (let bufferBufCounterI = 0; bufferBufCounterI < bufferLength; bufferBufCounterI++) {
            buffer[bufferBufCounterI] = TouchObject_serializer.read(retvalDeserializer)
        }
        const returnResult : Array<TouchObject> = buffer
        return returnResult
    }
    private setTouches_serialize(touches: Array<TouchObject>): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.writeInt32((touches.length).toInt())
        for (let touchesCounterI = 0; touchesCounterI < touches.length; touchesCounterI++) {
            const touchesTmpElement : TouchObject = touches[touchesCounterI]
            TouchObject_serializer.write(thisSerializer, touchesTmpElement)
        }
        ArkUIGeneratedNativeModule._TouchEvent_setTouches(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    private getChangedTouches_serialize(): Array<TouchObject> {
        const retval  = ArkUIGeneratedNativeModule._TouchEvent_getChangedTouches(this.peer!.ptr)
        let retvalDeserializer : DeserializerBase = new DeserializerBase(retval, retval.length)
        const bufferLength : int32 = retvalDeserializer.readInt32()
        let buffer : Array<TouchObject> = new Array<TouchObject>(bufferLength)
        for (let bufferBufCounterI = 0; bufferBufCounterI < bufferLength; bufferBufCounterI++) {
            buffer[bufferBufCounterI] = TouchObject_serializer.read(retvalDeserializer)
        }
        const returnResult : Array<TouchObject> = buffer
        return returnResult
    }
    private setChangedTouches_serialize(changedTouches: Array<TouchObject>): void {
        const thisSerializer : SerializerBase = SerializerBase.hold()
        thisSerializer.writeInt32((changedTouches.length).toInt())
        for (let changedTouchesCounterI = 0; changedTouchesCounterI < changedTouches.length; changedTouchesCounterI++) {
            const changedTouchesTmpElement : TouchObject = changedTouches[changedTouchesCounterI]
            TouchObject_serializer.write(thisSerializer, changedTouchesTmpElement)
        }
        ArkUIGeneratedNativeModule._TouchEvent_setChangedTouches(this.peer!.ptr, thisSerializer.asBuffer(), thisSerializer.length())
        thisSerializer.release()
    }
    stopPropagation_serialize(): void {
        ArkUIGeneratedNativeModule._TouchEvent_stopPropagation(this.peer!.ptr)
    }
    preventDefault_serialize(): void {
        ArkUIGeneratedNativeModule._TouchEvent_preventDefault(this.peer!.ptr)
    }
}
export namespace cursorControl {
    export function setCursor(value: pointer.PointerStyle): void {
        GlobalScope.cursorControl_setCursor(value)
    }
    export function restoreDefault(): void {
        GlobalScope.cursorControl_restoreDefault()
    }
}
export namespace focusControl {
    export function requestFocus(value: string): boolean {
        return GlobalScope.focusControl_requestFocus(value)
    }
}
