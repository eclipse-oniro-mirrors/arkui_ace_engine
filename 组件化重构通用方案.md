# ACE 组件化重构通用方案

> 基于 marquee 组件重构经验总结的通用指导方案

## 目录

- [一、重构概述](#一重构概述)
- [二、架构设计](#二架构设计)
- [三、动态模块加载](#三动态模块加载)
- [四、重构步骤](#四重构步骤)
- [五、兼容性保证](#五兼容性保证)
- [六、代码模板](#六代码模板)
- [七、验证测试](#七验证测试)
- [八、常见问题](#八常见问题)

---

## 一、重构概述

### 1.1 重构目标

**主要目标**：
- ✅ 消除重复的属性设置封装，归一到 `arkts_native_xxx_bridge` 实现
- ✅ 将跨语言参数解析逻辑统一到 Bridge 层
- ✅ 实现组件代码模块化（独立到 pattern 目录），并实现独立so，动态加载
- ✅ 保持与旧实现 100% 兼容，外部属性设置逻辑完全不变
- ✅ 统一支持声明式组件和动态属性设置两种场景

**核心概念**：

| 模式 | 说明 | 典型场景 |
|------|------|----------|
| **JSView 模式** | 声明式组件的属性设置方式 | `@Builder` 装饰器、`arkxxx.js` |
| **ArkTS 模式** | 动态属性设置的能力 | AttributeModifier、FrameNode 命令式 API |

**设计原则**：
1. **向后兼容** - 旧代码无需修改即可运行，外部行为完全不变
2. **统一入口** - JSView 和 ArkTS 走相同的底层逻辑，消除重复封装
3. **职责分离** - JavaScript/ArkTS/Bridge/Modifier 各司其职
4. **行为保持** - 两种模式各自的行为特征保持不变（如默认值处理）

### 1.2 适用范围

**适用于以下类型的组件重构**：
- ✅ 消除声明式组件和动态属性设置的重复封装
- ✅ 统一到 `arkts_native_xxx_bridge` 实现
- ✅ 组件代码从 `bridge/` 迁移到 `components_ng/pattern/xxx/`
- ✅ 实现组件独立 so，支持动态加载

**典型特征**：
```
重构前 (重复封装):
  声明式组件路径:
    bridge/declarative_frontend/jsview/js_xxx.cpp  (280 行)
    - JSCallbackInfo 参数解析
    - JsFunction 回调包装
    - MarqueeModel 单例调用

  动态属性路径:
    frameworks/interfaces/native/node/xxx_modifier.cpp
    - ArkUI 原生 API 封装
    - 独立的参数解析和类型转换

重构后 (统一实现):
  统一入口:
    bridge/declarative_frontend/engine/jsi/nativeModule/arkts_native_xxx_bridge.cpp
    - 统一的参数解析逻辑 (通过 IsJsView 区分模式)
    - Converter 类型转换
    - 支持声明式组件和动态属性两种场景

  组件实现:
    core/components_ng/pattern/xxx/bridge/xxx_dynamic_modifier.cpp (动态属性)
    core/components_ng/pattern/xxx/bridge/xxx_static_modifier.cpp (声明式组件)
    core/components_ng/pattern/xxx/marquee_model_ng.cpp (统一 Model)
```

**重构收益**：
1. **代码复用** - 消除重复的参数解析和类型转换逻辑
2. **维护性提升** - 只需维护一套实现
3. **行为一致性** - 两种场景使用相同的底层逻辑
4. **模块化** - 组件独立 so，按需加载

---

## 二、架构设计

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                         应用层 (Application)                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────────────┐        ┌──────────────────────┐│
│  │  声明式组件 (JSView 模式)     │        │  动态属性 (ArkTS 模式) ││
│  │  - @Builder 装饰器           │        │  - AttributeModifier  ││
│  │  - arkxxx.js                │        │  - FrameNode 命令式   ││
│  └──────────────────────────────┘        └──────────────────────┘│
│           │                                              │         │
│           │              getUINativeModule().xxx        │         │
│           └──────────────────┬───────────────────────────┘         │
│                              ↓                                     │
└──────────────────────────────┼─────────────────────────────────────┘
                               │
┌──────────────────────────────┼─────────────────────────────────────┐
│  前端桥接层                    ↓              (Frontend Bridge)       │
│  ┌──────────────────────────────────────────────────────────┐     │
│  │  arkts_native_xxx_bridge.cpp (统一入口)                   │     │
│  │                                                           │     │
│  │  关键判断:                                                 │     │
│  │  - IsJsView() → true:  声明式组件路径                      │     │
│  │  - IsJsView() → false: 动态属性路径                        │     │
│  │                                                           │     │
│  │  统一能力:                                                  │     │
│  │  - 参数解析: Converter::Convert()                         │     │
│  │  - 类型转换: ArkUI → C++ 类型                              │     │
│  │  - 回调包装: CallbackHelper                                │     │
│  │  - 后处理: HandleCallbackJobs (仅 JSView 模式)             │     │
│  └──────────────────────────────────────────────────────────┘     │
│                               │                                    │
│         ┌─────────────────────┴─────────────────────┐              │
│         ↓                                           ↓              │
│  ┌──────────────────────────┐        ┌──────────────────────────┐ │
│  │  xxx_static_modifier.cpp  │        │  xxx_dynamic_modifier.cpp│ │
│  │  (声明式组件属性)          │        │  (动态属性)              │ │
│  │                          │        │                          │ │
│  │  GetFrameNode(nullptr)    │        │  GetFrameNode(nativeNode)│ │
│  │    → GetMainFrameNode()   │        │    → 解析 nativeNode     │ │
│  └──────────────────────────┘        └──────────────────────────┘ │
│         │                                           │              │
│         └─────────────────────┬─────────────────────┘              │
│                               ↓                                    │
│  ┌──────────────────────────────────────────────────────────┐     │
│  │  xxx_model_ng.cpp (统一 Model)                            │     │
│  │                                                           │     │
│  │  static void SetXxx(FrameNode*, value) {                  │     │
│  │      ACE_UPDATE_NODE_PAINT_PROPERTY(..., frameNode);      │     │
│  │  }                                                        │     │
│  └──────────────────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 核心设计模式

#### 模式 1: GetFrameNode 统一路径

**目的**: 根据调用场景获取 FrameNode

```cpp
// 文件: frameworks/core/components_ng/pattern/xxx/bridge/xxx_dynamic_modifier.cpp

FrameNode* GetFrameNode(ArkUINodeHandle node)
{
    if (node) {
        // ArkTS 模式 (动态属性场景):
        //   - AttributeModifier 使用
        //   - FrameNode 命令式 API
        //   - 传入的 nativeNode 是有效的 FrameNode 指针
        return reinterpret_cast<FrameNode*>(node);
    } else {
        // JSView 模式 (声明式组件场景):
        //   - @Builder 装饰器
        //   - arkxxx.js 声明式组件
        //   - nullptr 表示从 ViewStackProcessor 获取当前节点
        return ViewStackProcessor::GetInstance()->GetMainFrameNode();
    }
}
```

**使用示例**:
```cpp
// 统一的属性设置接口，支持两种场景
void SetXxxAllowScale(ArkUINodeHandle node, ArkUI_Bool allowScale)
{
    auto* frameNode = GetFrameNode(node);  // 自动识别场景
    MarqueeModelNG::SetAllowScale(frameNode, allowScale);
}
```

**调用场景对照**:

| 调用场景 | node 参数 | GetFrameNode 返回 |
|---------|-----------|------------------|
| 声明式组件 | `nullptr` | `GetMainFrameNode()` |
| AttributeModifier | `nativeNode` | `reinterpret_cast<FrameNode*>(nativeNode)` |

#### 模式 2: isJsView 标志区分

**目的**: 识别调用场景，保持各自的行为特征

```cpp
// 文件: frameworks/bridge/declarative_frontend/engine/jsi/nativeModule/arkts_native_xxx_bridge.cpp

bool IsJsView(const Local<JSValueRef>& jsVal, panda::ecmascript::EcmaVM* vm)
{
    // 声明式组件场景: 第一个参数不是 NativePointer
    // 动态属性场景: 第一个参数是 NativePointer (指向 nativeNode)
    return !jsVal->IsNativePointer(vm);
}

void ParseStartValue(const Local<JSValueRef>& startVal,
                     panda::ecmascript::EcmaVM* vm,
                     bool isJsView,
                     std::optional<bool>& start)
{
    if (startVal->IsBoolean()) {
        start = startVal->ToBoolean(vm)->Value();
    } else if (!isJsView) {
        // 动态属性场景: 参数缺失时设置默认值
        start = false;
    }
    // 声明式组件场景: 参数缺失时不设置 (保持 nullopt)
}
```

**差异对照表**:

| 场景 | 声明式组件 (isJsView=true) | 动态属性 (isJsView=false) |
|------|---------------------------|---------------------------|
| **参数缺失** | 不设置值 (保持 nullopt) | 设置默认值 |
| **参数类型错误** | 早期返回，不设置 | 设置默认值 |
| **参数为 null** | 不设置值 (保持 nullopt) | 设置默认值 |

**设计理念**:

| 场景 | 行为特征 | 原因 |
|------|---------|------|
| 声明式组件 | 不设置默认值 | 参数缺失表示使用组件内置默认值 |
| 动态属性 | 设置默认值 | 需要明确的值，避免 optional 导致的空值 |

#### 模式 3: HandleCallbackJobs 统一后处理

**目的**: 确保声明式组件场景的事件回调行为与旧实现一致

```cpp
// 文件: frameworks/bridge/declarative_frontend/engine/jsi/nativeModule/arkts_native_xxx_bridge.cpp

ArkUINativeModuleValue MarqueeBridge::SetMarqueeOnStart(ArkUIRuntimeCallInfo* runtimeCallInfo)
{
    // ... 参数解析 ...

    bool isJsView = IsJsView(firstArg, vm);
    auto frameNode = ViewStackProcessor::GetInstance()->GetMainFrameNode();
    panda::Local<panda::FunctionRef> func = callbackArg->ToObject(vm);

    std::function<void(void)> callback = [vm, frameNode, func, isJsView]() {
        PipelineContext::SetCallBackNode(AceType::WeakClaim(frameNode));

        panda::TryCatch trycatch(vm);
        auto result = func->Call(vm, func.ToLocal(), nullptr, 0);

        // 仅声明式组件场景需要后处理
        if (isJsView) {
            // 关键: 显式调用以保持兼容
            ArkTSUtils::HandleCallbackJobs(vm, trycatch, result);
        }
        // 动态属性场景: 不需要额外的后处理
    };

    GetArkUINodeModifiers()->getMarqueeModifier()->setMarqueeOnStart(nullptr, &callback);
    return panda::JSValueRef::Undefined(vm);
}
```

**为什么只在声明式组件场景调用**:

| 场景 | 是否需要 HandleCallbackJobs | 原因 |
|------|---------------------------|------|
| 声明式组件 (isJsView=true) | ✅ 需要 | 与旧的 `JsFunction::ExecuteJS()` 行为保持一致 |
| 动态属性 (isJsView=false) | ❌ 不需要 | Panda `FunctionRef::Call` 已有内置处理 |

**HandleCallbackJobs 等价性证明**:

```cpp
// 旧实现 (仅声明式组件): js_marquee.cpp
auto onChange = [func]() {
    func->ExecuteJS();  // JsiFunction::Call
};
// JsiFunction::Call 内部:
//   1. JS_CALLBACK_DURATION()
//   2. ExecutePendingJob(vm)  ← 微任务队列
//   3. HandleUncaughtException() ← 异常处理

// 新实现: arkts_native_marquee_bridge.cpp
auto onChange = [func, isJsView]() {
    func->Call(vm, ...);  // Panda FunctionRef::Call
    if (isJsView) {
        ArkTSUtils::HandleCallbackJobs(vm, trycatch, result);
        // 内部:
        //   1. ExecutePendingJob(vm)  ← 微任务队列 (相同)
        //   2. HandleUncaughtException() ← 异常处理 (相同)
    }
};
```

#### 模式 4: 资源管理保持一致

**目的**: 支持配置变更时的资源刷新

```cpp
// 旧实现: js_marquee.cpp
void JSMarquee::SetTextColor(const JSCallbackInfo& info)
{
    // 1. 先注销旧资源
    UnRegisterResource("TextColor");

    // 2. 解析新值
    if (ParseJsColor(info[0], color, resObj)) {
        colorOpt = color;
    }

    // 3. 如果是资源对象，注册新资源
    if (SystemProperties::ConfigChangePerform() && resObj) {
        RegisterResource<Color>("TextColor", resObj, color);
    }

    // 4. 设置值
    MarqueeModel::GetInstance()->SetTextColor(colorOpt);
}

// 新实现: xxx_dynamic_modifier.cpp
void SetMarqueeFontSize(ArkUINodeHandle node, ArkUI_Float32 fontSize, ...)
{
    auto* frameNode = GetFrameNode(node);
    auto pattern = frameNode->GetPattern<MarqueePattern>();

    // 1. 注销旧资源 (如果需要)
    if (SystemProperties::ConfigChangePerform()) {
        pattern->UnRegisterResource("FontSize");
    }

    // 2. 解析新值
    if (fontSizeRawPtr) {
        resObj = Referenced::RawPtr(fontSizeRawPtr);
    }

    // 3. 设置值
    MarqueeModelNG::SetFontSize(frameNode, Dimension(fontSize, unitEnum));

    // 4. 注册新资源 (如果是资源对象)
    if (SystemProperties::ConfigChangePerform() && resObj) {
        pattern->RegisterResource<CalcDimension>("FontSize", resObj, ...);
    }
}
```

---

## 三、动态模块加载

### 3.1 动态模块架构

组件化重构的核心是将组件编译成独立的共享库（.so 文件），在运行时按需动态加载。这样可以：

1. **减少主 so 体积** - 不常用的组件可以独立成单独的 so
2. **按需加载** - 只在使用组件时才加载对应的 so
3. **独立更新** - 组件 so 可以独立更新而不影响主程序
4. **模块化开发** - 每个组件有独立的编译单元

#### 动态模块架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        应用层 (Application)                      │
│                                                                  │
│  JavaScript/ArkTS 调用:                                          │
│    getUINativeModule().marquee.create(...)                       │
└─────────────────────────────────────────────────────────────────┘
                          │
                          ↓
┌─────────────────────────────────────────────────────────────────┐
│  前端桥接层 (Frontend Bridge)                                    │
│                                                                  │
│  arkts_native_api_impl_bridge.cpp                               │
│  ┌────────────────────────────────────────────────────────┐     │
│  │ LoadNativeModule(moduleName)                          │     │
│  │   → 判断 moduleName 是否在 loadModuleName 集合中       │     │
│  │   → 调用 DynamicModuleHelper::GetDynamicModule(name)   │     │
│  └────────────────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────────┘
                          │
                          ↓
┌─────────────────────────────────────────────────────────────────┐
│  动态模块加载器 (Dynamic Module Helper)                          │
│                                                                  │
│  dynamic_module_helper.cpp                                      │
│  ┌────────────────────────────────────────────────────────┐     │
│  │ GetDynamicModule(name)                                │     │
│  │   1. 检查 moduleMap_ 缓存                              │     │
│  │   2. 根据 soMap 查找 so 名称 (如 Marquee → marquee)    │     │
│  │   3. 构造 so 名称: libarkui_marquee.z.so              │     │
│  │   4. dlopen(so) 加载共享库                             │     │
│  │   5. dlsym(handle, "OHOS_ACE_DynamicModule_Create_Marquee")│   │
│  │   6. 调用创建函数返回 DynamicModule*                    │     │
│  │   7. 存入 moduleMap_ 缓存                               │     │
│  └────────────────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────────┘
                          │
                          ↓
┌─────────────────────────────────────────────────────────────────┐
│  独立共享库 (Shared Library)                                      │
│                                                                  │
│  libarkui_marquee.z.so                                          │
│  ┌────────────────────────────────────────────────────────┐     │
│  │ 导出符号 (C 接口):                                      │     │
│  │   OHOS_ACE_DynamicModule_Create_Marquee()              │     │
│  │     → 返回 new MarqueeDynamicModule()                  │     │
│  │                                                          │     │
│  │ MarqueeDynamicModule 实现:                              │     │
│  │   - RegisterAttributes()    // 注册 JS 属性            │     │
│  │   - GetDynamicModifier()    // 获取动态属性 Modifier   │     │
│  │   - GetStaticModifier()     // 获取静态属性 Modifier   │     │
│  │   - GetCjModifier()         // 获取 CJ Modifier        │     │
│  │   - GetModel()              // 获取 Model              │     │
│  └────────────────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────────┘
                          │
                          ↓
┌─────────────────────────────────────────────────────────────────┐
│  组件实现 (Component Implementation)                              │
│                                                                  │
│  marquee_pattern.cpp/h      // 组件核心逻辑                       │
│  marquee_model_ng.cpp/h     // Model 层                          │
│  marquee_dynamic_modifier.cpp // 动态属性 Modifier               │
│  marquee_static_modifier.cpp  // 静态属性 Modifier               │
│  arkts_native_marquee_bridge.cpp // Bridge 层                    │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 关键组件

#### 3.2.1 DynamicModule 基类

**文件**: `frameworks/core/common/dynamic_module.h`

```cpp
class DynamicModule {
public:
    virtual ~DynamicModule() = default;

    // 注册属性到 JavaScript 对象
    virtual void RegisterAttributes(panda::Local<panda::ObjectRef> object,
                                    panda::ecmascript::EcmaVM* vm) = 0;

    // 获取动态属性 Modifier (用于 ArkTS)
    virtual const void* GetDynamicModifier() = 0;

    // 获取静态属性 Modifier (用于 JSView)
    virtual const void* GetStaticModifier() = 0;

    // 获取 CJ Modifier (用于 C++ 跨语言调用)
    virtual const void* GetCjModifier() = 0;

    // 获取动画 Modifier (可选)
    virtual const void* GetAniModifier() { return nullptr; }

    // 获取 Model (可选)
    virtual void* GetModel() { return nullptr; }

    // 获取自定义 Modifier (可选)
    virtual const void* GetCustomModifier(const std::string& name = "") { return nullptr; }
};
```

#### 3.2.2 DynamicModuleHelper 单例

**文件**: `frameworks/core/common/dynamic_module_helper.h/cpp`

```cpp
class DynamicModuleHelper final {
public:
    static DynamicModuleHelper& GetInstance();

    // 动态加载模块
    DynamicModule* GetDynamicModule(const std::string& name);

private:
    // 组件名 → so 名称的映射
    static const std::unordered_map<std::string, std::string> soMap = {
        {"Counter", "counter"},
        {"Checkbox", "checkbox"},
        {"Sidebar", "sidebar"},
        {"Gauge", "gauge"},
        {"Rating", "rating"},
        {"FlowItem", "waterflow"},
        {"WaterFlow", "waterflow"},
        {"ColumnSplit", "linearsplit"},
        {"RowSplit", "linearsplit"},
        {"Marquee", "marquee"},
        // ... 其他组件
    };

    // 已加载模块的缓存
    std::unordered_map<std::string, std::unique_ptr<DynamicModule>> moduleMap_;
    std::mutex moduleMapMutex_;  // 线程安全
};
```

**加载流程**:

```cpp
DynamicModule* DynamicModuleHelper::GetDynamicModule(const std::string& name)
{
    // 1. Double-Checked Locking: 检查缓存
    {
        std::lock_guard<std::mutex> lock(moduleMapMutex_);
        auto iter = moduleMap_.find(name);
        if (iter != moduleMap_.end()) {
            return iter->second.get();  // 已加载，直接返回
        }
    }

    // 2. 查找 so 名称
    auto it = soMap.find(name);
    if (it == soMap.end()) {
        LOGI("No shared library mapping found for nativeModule: %{public}s", name.c_str());
        return nullptr;
    }

    // 3. 构造 so 文件名
    auto libName = DYNAMIC_MODULE_LIB_PREFIX + it->second + DYNAMIC_MODULE_LIB_POSTFIX;
    // 例如: "libarkui_" + "marquee" + ".z.so" = "libarkui_marquee.z.so"

    // 4. 加载共享库 (dlopen)
    auto* handle = dlopen(libName.c_str(), RTLD_LAZY);
    CHECK_NULL_RETURN(handle, nullptr);

    // 5. 获取创建函数 (dlsym)
    auto* createSym = reinterpret_cast<DynamicModuleCreateFunc>(
        dlsym(handle, (DYNAMIC_MODULE_CREATE + name).c_str()));
    // 例如: "OHOS_ACE_DynamicModule_Create_" + "Marquee"

    CHECK_NULL_RETURN(createSym, nullptr);

    // 6. 调用创建函数
    DynamicModule* module = createSym();
    CHECK_NULL_RETURN(module, nullptr);

    // 7. 存入缓存
    {
        std::lock_guard<std::mutex> lock(moduleMapMutex_);
        // 再次检查，防止多线程重复加载
        auto iter = moduleMap_.find(name);
        if (iter != moduleMap_.end()) {
            delete module;  // 其他线程已加载，删除重复的
            return iter->second.get();
        }
        moduleMap_.emplace(name, std::unique_ptr<DynamicModule>(module));
        return module;
    }
}
```

#### 3.2.3 组件动态模块实现

**文件**: `frameworks/core/components_ng/pattern/marquee/bridge/marquee_dynamic_module.cpp/h`

```cpp
// marquee_dynamic_module.h
class MarqueeDynamicModule : public DynamicModule {
public:
    void RegisterAttributes(panda::Local<panda::ObjectRef> object,
                            panda::ecmascript::EcmaVM* vm) override;
    const void* GetDynamicModifier() override;
    const void* GetStaticModifier() override;
    const void* GetCjModifier() override;
    void* GetModel() override;
};

// marquee_dynamic_module.cpp

// C 接口导出函数 (dlsym 需要找这个符号)
extern "C" ACE_FORCE_EXPORT void* OHOS_ACE_DynamicModule_Create_Marquee()
{
    return new OHOS::Ace::MarqueeDynamicModule();
}

void MarqueeDynamicModule::RegisterAttributes(panda::Local<panda::ObjectRef> object, panda::ecmascript::EcmaVM* vm)
{
    NG::MarqueeBridge::RegisterMarqueeAttributes(object, vm);
}

const void* MarqueeDynamicModule::GetDynamicModifier()
{
    return NG::NodeModifier::GetMarqueeDynamicModifier();
}

const void* MarqueeDynamicModule::GetStaticModifier()
{
#ifdef INCLUDE_GENERATED_SOURCES
    return NG::GeneratedModifier::GetMarqueeStaticModifier();
#else
    return nullptr;
#endif
}

const void* MarqueeDynamicModule::GetCjModifier()
{
    return NG::NodeModifier::GetCJUIMarqueeModifier();
}

void* MarqueeDynamicModule::GetModel()
{
    static NG::MarqueeModelNG model;
    return &model;
}
```

#### 3.2.4 前端桥接层注册

**文件**: `frameworks/bridge/declarative_frontend/engine/jsi/nativeModule/arkts_native_api_impl_bridge.cpp`

```cpp
// 需要动态加载的组件名集合
static const std::unordered_set<std::string> loadModuleName = {
    {"Counter"},
    {"Gauge"},
    {"Sidebar"},
    {"Checkbox"},
    {"CheckboxGroup"},
    {"Rating"},
    {"FlowItem"},
    {"WaterFlow"},
    {"ColumnSplit"},
    {"RowSplit"},
    {"Marquee"},
};

ArkUINativeModuleValue ArkUINativeModule::LoadNativeModule(ArkUIRuntimeCallInfo* runtimeCallInfo)
{
    EcmaVM* vm = runtimeCallInfo->GetVM();
    auto moduleName = firstArg->ToString(vm)->ToString(vm);

    // 检查是否是需要动态加载的模块
    if (loadModuleName.find(moduleName) != loadModuleName.end()) {
        // 动态加载模块
        auto* module = DynamicModuleHelper::GetInstance().GetDynamicModule(moduleName);
        if (module != nullptr) {
            // 注册模块属性到 JavaScript 对象
            module->RegisterAttributes(thisObj, vm);
        }
    }

    return panda::JSValueRef::Undefined(vm);
}
```

### 3.3 动态模块的编译配置

#### 3.3.1 BUILD.gn 配置

**文件**: `frameworks/core/components_ng/pattern/marquee/BUILD.gn`

```gni
import("//foundation/arkui/ace_engine/ace_config.gni")
import("//foundation/arkui/ace_engine/frameworks/core/components_ng/components.gni")

build_component_ng("marquee_pattern_ng") {
  is_component_model = true
  include_generated_sources = true

  # Pattern 层源码 (编译到主 so)
  sources = [
    "marquee_accessibility_property.cpp",
    "marquee_layout_algorithm.cpp",
    "marquee_model_ng.cpp",
    "marquee_pattern_multi_thread.cpp",
    "marquee_pattern.cpp",
  ]

  # Bridge 层源码 (编译到独立 so)
  ark_sources = [
    "bridge/arkts_native_marquee_bridge.cpp",
    "bridge/marquee_dynamic_modifier.cpp",
    "bridge/marquee_dynamic_module.cpp",  // 动态模块实现
  ]

  if (include_generated_sources) {
    ark_sources += [
      "bridge/marquee_static_modifier.cpp",
    ]
  }

  deps = [
    "${ace_root}/interfaces/inner_api/ace:ace_forward_compatibility"
  ]
}
```

**关键点**:
1. `ark_sources` 会被编译到独立的 `libarkui_marquee.z.so` 中
2. `sources` 会被编译到主 `libace.z.so` 中
3. `marquee_dynamic_module.cpp` 必须在 `ark_sources` 中

#### 3.3.2 动态库命名规则

```
libarkui_<组件名>.z.so

示例:
  libarkui_marquee.z.so     (Marquee 组件)
  libarkui_counter.z.so     (Counter 组件)
  libarkui_checkbox.z.so    (Checkbox 组件)
  libarkui_gauge.z.so       (Gauge 组件)
```

**映射规则** (在 `soMap` 中定义):
```cpp
{"Marquee", "marquee"},      // 组件名 (大写) → so 名 (小写)
{"Counter", "counter"},
{"Checkbox", "checkbox"},
```

### 3.4 动态模块的使用流程

#### 3.4.1 运行时加载流程

```
1. JavaScript 调用
   ↓
   getUINativeModule().marquee.create({...})

2. 前端桥接层
   ↓
   LoadNativeModule("Marquee")
   → 检查 "Marquee" 是否在 loadModuleName 中

3. 动态模块加载器
   ↓
   DynamicModuleHelper::GetDynamicModule("Marquee")
   → 检查缓存: moduleMap_.find("Marquee")
   → 查找 so 名称: soMap["Marquee"] = "marquee"
   → 构造 so 文件名: "libarkui_marquee.z.so"
   → dlopen("libarkui_marquee.z.so", RTLD_LAZY)
   → dlsym(handle, "OHOS_ACE_DynamicModule_Create_Marquee")
   → 调用创建函数: new MarqueeDynamicModule()
   → 存入缓存: moduleMap_["Marquee"] = module

4. 注册属性
   ↓
   module->RegisterAttributes(thisObj, vm)
   → MarqueeBridge::RegisterMarqueeAttributes(object, vm)
   → 注册 create, setAllowScale, setFontSize 等方法

5. 调用组件方法
   ↓
   marquee.create({...})
   → 调用已注册的 native 方法
```

#### 3.4.2 线程安全保证

```cpp
DynamicModule* GetDynamicModule(const std::string& name)
{
    // 1. 第一次检查: 无锁快速路径
    {
        std::lock_guard<std::mutex> lock(moduleMapMutex_);
        auto iter = moduleMap_.find(name);
        if (iter != moduleMap_.end()) {
            return iter->second.get();
        }
    }

    // 2. 加载模块: 不持有锁 (dlopen/dlsym 可能很慢)
    auto* handle = dlopen(libName.c_str(), RTLD_LAZY);
    auto* createSym = dlsym(handle, ...);
    DynamicModule* module = createSym();

    // 3. 第二次检查: 防止多线程重复加载
    {
        std::lock_guard<std::mutex> lock(moduleMapMutex_);
        auto iter = moduleMap_.find(name);
        if (iter != moduleMap_.end()) {
            delete module;  // 其他线程已加载
            return iter->second.get();
        }
        moduleMap_.emplace(name, std::unique_ptr<DynamicModule>(module));
        return module;
    }
}
```

**设计要点**:
- ✅ Double-Checked Locking 模式
- ✅ 加载时不持有锁 (dlopen/dlsym 可能很慢)
- ✅ 线程安全的缓存访问

### 3.5 动态模块的调试

#### 3.5.1 查看已加载的模块

```bash
# 查看 dlopen 加载的共享库
cat /proc/<pid>/maps | grep arkui

# 输出示例:
# 7f1234000000-7f1234200000 r-xp 00000000 fd:00 12345 /system/lib/libarkui_marquee.z.so
# 7f1234200000-7f1234300000 rw-p 001f0000 fd:00 12345 /system/lib/libarkui_marquee.z.so
```

#### 3.5.2 查看导出符号

```bash
# 查看 so 的导出符号
readelf -ds libarkui_marquee.z.so | grep OHOS_ACE_DynamicModule_Create

# 输出示例:
# 1234: 0000000000123456     FUNC GLOBAL DEFAULT 14 OHOS_ACE_DynamicModule_Create_Marquee
```

#### 3.5.3 调试日志

```cpp
// 在 dynamic_module_helper.cpp 中已有日志
LOGI("First load %{public}s nativeModule start", name.c_str());
LOGI("No shared library mapping found for nativeModule: %{public}s", name.c_str());
```

### 3.6 动态模块检查清单

- [ ] **DynamicModule 派生类**
  - [ ] 继承 `DynamicModule` 基类
  - [ ] 实现 `RegisterAttributes()`
  - [ ] 实现 `GetDynamicModifier()`
  - [ ] 实现 `GetStaticModifier()`
  - [ ] 实现 `GetCjModifier()`
  - [ ] 实现 `GetModel()` (如需要)

- [ ] **C 接口导出函数**
  - [ ] 函数名: `OHOS_ACE_DynamicModule_Create_<ComponentName>`
  - [ ] 使用 `extern "C"` 导出
  - [ ] 使用 `ACE_FORCE_EXPORT` 宏
  - [ ] 返回 `new XXXDynamicModule()`

- [ ] **so 名称映射**
  - [ ] 在 `soMap` 中添加映射
  - [ ] 格式: `{"ComponentName", "component_name"}`

- [ ] **loadModuleName 注册**
  - [ ] 在 `arkts_native_api_impl_bridge.cpp` 中添加
  - [ ] 添加到 `loadModuleName` 集合

- [ ] **BUILD.gn 配置**
  - [ ] `xxx_dynamic_module.cpp` 在 `ark_sources` 中
  - [ ] 其他实现文件在 `sources` 中

---

## 四、重构步骤

### 4.1 准备阶段

#### 步骤 1: 分析现有实现

```bash
# 1. 查看旧实现
cat frameworks/bridge/declarative_frontend/jsview/js_xxx.cpp

# 2. 统计方法数量
grep -c "^void JSXXX::" js_xxx.cpp

# 3. 提取方法签名
grep -h "^void JSXXX::" js_xxx.cpp | sort

# 4. 查看依赖
grep "#include" js_xxx.cpp
```

#### 步骤 2: 确定组件接口

列出所有需要实现的公共方法：

| 方法类型 | 方法名 | 参数 | 返回值 | 说明 |
|---------|--------|------|--------|------|
| 创建 | Create | options | void | 创建组件实例 |
| 属性设置 | SetXxx | value | void | 设置属性值 |
| 事件回调 | SetOnXxx | callback | void | 注册事件回调 |

#### 步骤 3: 创建目录结构

```bash
# 在 frameworks/core/components_ng/pattern/ 下创建组件目录
mkdir -p frameworks/core/components_ng/pattern/xxx/bridge

# 创建必要的文件
touch frameworks/core/components_ng/pattern/xxx/BUILD.gn
touch frameworks/core/components_ng/pattern/xxx/bridge/xxx_dynamic_modifier.cpp
touch frameworks/core/components_ng/pattern/xxx/bridge/xxx_dynamic_modifier.h
touch frameworks/core/components_ng/pattern/xxx/bridge/xxx_static_modifier.cpp
touch frameworks/core/components_ng/pattern/xxx/bridge/xxx_static_modifier.h
touch frameworks/core/components_ng/pattern/xxx/bridge/xxx_dynamic_module.cpp
touch frameworks/core/components_ng/pattern/xxx/bridge/xxx_dynamic_module.h
```

### 4.2 实现阶段

#### 阶段 1: Bridge 层 (arkts_native_xxx_bridge.cpp)

**文件模板**:

```cpp
/*
 * Copyright (c) 2024-2026 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 */

#include "core/interfaces/native/node/node_modifier.h"
#include "frameworks/core/components_ng/pattern/xxx/xxx_model_ng.h"
#include "arkoala_api_generated.h"

namespace OHOS::Ace::NG {

// ===== 辅助函数 =====

bool IsJsView(const Local<JSValueRef>& jsVal, panda::ecmascript::EcmaVM* vm)
{
    return !jsVal->IsNativePointer(vm);
}

void ParseStartValue(const Local<JSValueRef>& startVal,
                     panda::ecmascript::EcmaVM* vm,
                     bool isJsView,
                     std::optional<bool>& start)
{
    if (startVal->IsBoolean()) {
        start = startVal->ToBoolean(vm)->Value();
    } else if (!isJsView) {
        start = false;  // ArkTS 默认值
    }
    // JSView: 不设置，保持 nullopt
}

// ===== Bridge 方法实现 =====

ArkUINativeModuleValue XXXBridge::SetXxxPlayerStatus(ArkUIRuntimeCallInfo* runtimeCallInfo)
{
    // 1. 获取参数
    auto* vm = runtimeCallInfo->GetVM();
    Local<JSValueRef>* args = runtimeCallInfo->GetArguments();
    int32_t argc = runtimeCallInfo->GetArgumentCount();

    // 2. 判断模式
    bool isJsView = IsJsView(args[0], vm);

    // 3. 获取 FrameNode
    ArkUINativeNodeHandle nativeNode = nullptr;
    if (!isJsView) {
        nativeNode = args[0]->GetNativePointer(vm);
    }

    // 4. 解析参数
    std::optional<bool> playerStatus;
    if (argc > 1) {
        if (args[1]->IsBoolean()) {
            playerStatus = args[1]->ToBoolean(vm)->Value();
        }
    } else if (!isJsView) {
        playerStatus = false;  // ArkTS 默认值
    }

    // 5. 调用 Modifier
    if (playerStatus.has_value()) {
        GetArkUINodeModifiers()->getXxxModifier()->setXxxPlayerStatus(nativeNode, playerStatus.value());
    }

    return panda::JSValueRef::Undefined(vm);
}

ArkUINativeModuleValue XXXBridge::SetXxxOnStart(ArkUIRuntimeCallInfo* runtimeCallInfo)
{
    auto* vm = runtimeCallInfo->GetVM();
    Local<JSValueRef>* args = runtimeCallInfo->GetArguments();

    bool isJsView = IsJsView(args[0], vm);
    auto frameNode = ViewStackProcessor::GetInstance()->GetMainFrameNode();

    if (args[1]->IsUndefined() || args[1]->IsNull()) {
        if (isJsView) {
            // JSView: undefined 表示取消回调
            GetArkUINodeModifiers()->getXxxModifier()->resetXxxOnStart(nullptr);
        }
        return panda::JSValueRef::Undefined(vm);
    }

    auto callbackFunc = args[1]->ToObject(vm);

    // 创建回调 lambda
    std::function<void(void)> callback = [vm, frameNode, callbackFunc, isJsView]() {
        PipelineContext::SetCallBackNode(AceType::WeakClaim(frameNode));

        panda::TryCatch trycatch(vm);
        auto result = callbackFunc->Call(vm, callbackFunc.ToLocal(), nullptr, 0);

        if (isJsView) {
            // 关键: 必须调用 HandleCallbackJobs
            ArkTSUtils::HandleCallbackJobs(vm, trycatch, result);
        }
    };

    GetArkUINodeModifiers()->getXxxModifier()->setXxxOnStart(nullptr, &callback);
    return panda::JSValueRef::Undefined(vm);
}

} // namespace OHOS::Ace::NG
```

**要点**:
1. ✅ 每个方法都需要判断 `isJsView`
2. ✅ JSView 模式通过 `ViewStackProcessor` 获取 FrameNode
3. ✅ ArkTS 模式通过 `nativeNode` 获取 FrameNode
4. ✅ 事件回调必须调用 `HandleCallbackJobs`

#### 阶段 2: Modifier 层 (xxx_dynamic_modifier.cpp)

**文件模板**:

```cpp
/*
 * Copyright (c) 2024-2026 Huawei Device Co., Ltd.
 */

#include "core/components_ng/base/frame_node.h"
#include "core/components_ng/pattern/xxx/xxx_model_ng.h"
#include "core/components_ng/pattern/xxx/xxx_pattern.h"
#include "core/interfaces/native/node/node_modifier.h"

namespace OHOS::Ace::NG {
namespace GeneratedModifier {
namespace XXXAttributeModifier {

// ===== 辅助函数 =====

FrameNode* GetFrameNode(ArkUINodeHandle node)
{
    if (node) {
        return reinterpret_cast<FrameNode*>(node);
    }
    return ViewStackProcessor::GetInstance()->GetMainFrameNode();
}

// ===== 属性设置方法 =====

void SetXxxPlayerStatus(ArkUINodeHandle node, ArkUI_Bool playerStatus)
{
    auto* frameNode = GetFrameNode(node);
    CHECK_NULL_VOID(frameNode);

    std::optional<bool> value = playerStatus;
    MarqueeModelNG::SetPlayerStatus(frameNode, value);
}

void ResetXxxPlayerStatus(ArkUINodeHandle node)
{
    auto* frameNode = GetFrameNode(node);
    CHECK_NULL_VOID(frameNode);

    MarqueeModelNG::ResetPlayerStatus(frameNode);
}

void SetXxxFontSize(ArkUINodeHandle node, ArkUI_Float32 fontSize, int unit, void* fontSizeRawPtr)
{
    auto* frameNode = GetFrameNode(node);
    CHECK_NULL_VOID(frameNode);

    auto pattern = frameNode->GetPattern<XXXPattern>();
    CHECK_NULL_VOID(pattern);

    // 资源管理
    RefPtr<ResourceObject> resObj;
    if (fontSizeRawPtr) {
        resObj = Referenced::RawPtr(fontSizeRawPtr);
    }

    // 参数验证和默认值
    Dimension value;
    if (fontSize >= 0 && unit >= PX && unit <= CALC && unit != PERCENT) {
        value = Dimension(fontSize, static_cast<DimensionUnit>(unit));
    } else {
        // 无效值时使用主题默认值
        auto theme = pipelineContext->GetTheme<TextTheme>();
        value = theme->GetTextStyle().GetFontSize();
    }

    // 设置值
    std::optional<Dimension> fontSizeOpt = value;
    MarqueeModelNG::SetFontSize(frameNode, fontSizeOpt);

    // 资源注册
    if (SystemProperties::ConfigChangePerform()) {
        pattern->UnRegisterResource("FontSize");
        if (resObj) {
            pattern->RegisterResource<CalcDimension>("FontSize", resObj, value);
        }
    }
}

// ===== 事件回调方法 =====

void SetXxxOnStart(ArkUINodeHandle node, const std::function<void()>* callback)
{
    auto* frameNode = GetFrameNode(node);
    CHECK_NULL_VOID(frameNode);

    if (callback) {
        MarqueeModelNG::SetOnStart(frameNode, *callback);
    }
}

void ResetXxxOnStart(ArkUINodeHandle node)
{
    auto* frameNode = GetFrameNode(node);
    CHECK_NULL_VOID(frameNode);

    MarqueeModelNG::ResetOnStart(frameNode);
}

} // namespace XXXAttributeModifier
} // namespace GeneratedModifier
} // namespace OHOS::Ace::NG
```

**要点**:
1. ✅ 使用 `GetFrameNode()` 统一路径
2. ✅ 参数验证要有默认值处理
3. ✅ 资源管理要包含 `UnRegisterResource` 和 `RegisterResource`
4. ✅ CHECK_NULL_VOID 检查空指针

#### 阶段 3: Model 层 (xxx_model_ng.cpp)

**文件模板**:

```cpp
// 文件: frameworks/core/components_ng/pattern/xxx/xxx_model_ng.h

namespace OHOS::Ace::NG {
class ACE_EXPORT XXXModelNG {
public:
    // 创建组件
    void Create();

    // 属性设置 (实例方法 - 用于 JSView)
    void SetValue(const std::optional<std::string>& value);
    void SetPlayerStatus(const std::optional<bool>& playerStatus);
    void SetScrollAmount(const std::optional<double>& scrollAmount);

    // 属性设置 (静态方法 - 用于 ArkTS)
    static void SetValue(FrameNode* frameNode, const std::optional<std::string>& value);
    static void ResetValue(FrameNode* frameNode);

    static void SetPlayerStatus(FrameNode* frameNode, const std::optional<bool>& playerStatus);
    static void ResetPlayerStatus(FrameNode* frameNode);

    // 事件回调
    static void SetOnStart(FrameNode* frameNode, std::function<void()>&& callback);
    static void ResetOnStart(FrameNode* frameNode);
};

// 文件: frameworks/core/components_ng/pattern/xxx/xxx_model_ng.cpp

void XXXModelNG::Create()
{
    auto* stack = ViewStackProcessor::GetInstance();
    auto nodeId = stack->ClaimNodeId();
    ACE_LAYOUT_SCOPED_TRACE("Create[%s][self:%d]", XXX_ETS_TAG, nodeId);

    auto frameNode = FrameNode::GetOrCreateFrameNode(
        XXX_ETS_TAG, nodeId, []() { return AceType::MakeRefPtr<XXXPattern>(); });

    stack->Push(frameNode);
}

void XXXModelNG::SetPlayerStatus(const std::optional<bool>& playerStatus)
{
    if (playerStatus.has_value()) {
        ACE_UPDATE_PAINT_PROPERTY(XXXPaintProperty, PlayerStatus, playerStatus.value());
    } else {
        ACE_RESET_PAINT_PROPERTY_WITH_FLAG(XXXPaintProperty, PlayerStatus, PROPERTY_UPDATE_RENDER);
    }
}

void XXXModelNG::SetPlayerStatus(FrameNode* frameNode, const std::optional<bool>& playerStatus)
{
    CHECK_NULL_VOID(frameNode);
    if (playerStatus.has_value()) {
        ACE_UPDATE_NODE_PAINT_PROPERTY(XXXPaintProperty, PlayerStatus, playerStatus.value(), frameNode);
    }
}

void XXXModelNG::ResetPlayerStatus(FrameNode* frameNode)
{
    CHECK_NULL_VOID(frameNode);
    ACE_RESET_NODE_PAINT_PROPERTY_WITH_FLAG(XXXPaintProperty, PlayerStatus, PROPERTY_UPDATE_RENDER, frameNode);
}

void XXXModelNG::SetOnStart(FrameNode* frameNode, std::function<void()>&& callback)
{
    CHECK_NULL_VOID(frameNode);
    auto eventHub = frameNode->GetEventHub<XXXEventHub>();
    CHECK_NULL_VOID(eventHub);
    eventHub->SetOnStart(std::move(callback));
}
```

**要点**:
1. ✅ 实例方法和静态方法分开
2. ✅ 实例方法用于 JSView (通过 ViewStackProcessor)
3. ✅ 静态方法用于 ArkTS (直接传入 FrameNode)
4. ✅ 使用 ACE_UPDATE/RESET 宏简化代码

#### 阶段 4: JavaScript 层 (arkxxx.js) - 可选

如果需要创建新的 JavaScript 接口：

```javascript
/*
 * Copyright (c) 2024-2026 Huawei Device Co., Ltd.
 */

// 文件: frameworks/bridge/declarative_frontend/ark_component/components/arkxxx.js

export class JSXXX extends JSViewAbstract {
  // 创建组件
  static create(srcValue = '', startValue = false, stepValue = 0, loopValue = -1) {
    const nativeNode = getUINativeModule().xxx.create({
      src: srcValue.toString(),
      start: startValue,
      step: stepValue,
      loop: loopValue,
      fromStart: true, // 从左向右
    });
    return nativeNode;
  }

  // 属性设置 (传入 true 表示 JSView 模式)
  static allowScale(value) {
    getUINativeModule().xxx.setAllowScale(true, value);
  }

  static fontColor(value) {
    getUINativeModule().xxx.setFontColor(true, value);
  }

  static fontSize(value) {
    getUINativeModule().xxx.setFontSize(true, value, 0); // 0 = FP unit
  }

  static fontWeight(value) {
    getUINativeModule().xxx.setFontWeight(true, value);
  }

  static fontFamily(value) {
    getUINativeModule().xxx.setFontFamily(true, value);
  }

  // 事件回调
  static onStart(value) {
    getUINativeModule().xxx.setXXXOnStart(true, value);
  }

  static onBounce(value) {
    getUINativeModule().xxx.setXXXOnBounce(true, value);
  }

  static onFinish(value) {
    getUINativeModule().xxx.setXXXOnFinish(true, value);
  }
}
```

**要点**:
1. ✅ 第一个参数固定传 `true` (表示 JSView 模式)
2. ✅ 使用 `getUINativeModule().xxx` 调用原生方法
3. ✅ 方法命名保持一致性

### 4.3 配置阶段

#### BUILD.gn 配置

```gni
# 文件: frameworks/core/components_ng/pattern/xxx/BUILD.gn

import("../../../../../bridge/declarative_frontend/engine/jsi/jsi.gni")

config("xxx_config") {
  include_dirs = [
    "//foundation/arkui/ace_engine/interfaces/inner_api/ace",
    "//foundation/arkui/ace_engine/interfaces/inner_api/framework",
    "//third_party/bounds_checking_function/include",
  ]
}

ohos_shared_library("xxx_dynamic_module") {
  sources = [
    "bridge/xxx_dynamic_modifier.cpp",
    "bridge/xxx_dynamic_module.cpp",
    "bridge/xxx_static_modifier.cpp",
  ]

  include_dirs = [
    "//foundation/arkui/ace_engine/frameworks/core/components_ng",
    "//foundation/arkui/ace_engine/interfaces/native/node",
    "//foundation/arkui/ace_engine/interfaces/native/utility",
  ]

  deps = [
    "//foundation/arkui/ace_engine/frameworks/core/components_ng/base:node",
    "//foundation/arkui/ace_engine/frameworks/core/components_ng/pattern/xxx:xxx_pattern",
  ]

  external_deps = [ "napi:ace_napi.z" ]

  public_configs = [ ":xxx_config" ]

  subsystem_name = "ace"
  part_name = "ace_engine_core"
}
```

---

## 五、兼容性保证

### 5.1 兼容性检查清单

#### 5.1.1 参数解析兼容性

| 检查项 | 旧实现 | 新实现 | 验证方法 |
|--------|--------|--------|----------|
| 参数验证 | `ParseJsXxx()` | `Converter::Convert()` | 对比解析结果 |
| 默认值处理 | 参数缺失时不设置 | JSView: 不设置<br/>ArkTS: 设置默认 | 单元测试 |
| 类型转换 | 内联转换 | Converter 模板 | 对比转换结果 |
| 错误处理 | 静默失败 | 早期返回 | 边界测试 |

**验证命令**:
```bash
# 对比参数解析逻辑
grep -A 20 "ParseJsColor" deleted_files/**/js_xxx.cpp
grep -A 20 "Convert.*Color" new_files/**/arkts_native_xxx_bridge.cpp
```

#### 5.1.2 底层调用兼容性

| 检查项 | 验证点 | 验证方法 |
|--------|--------|----------|
| FrameNode 获取 | `GetFrameNode(nullptr)` → `GetMainFrameNode()` | 单步调试 |
| 底层方法 | 调用相同的 `MarqueeModelNG` 方法 | 代码审查 |
| Property 更新 | 使用相同的 ACE_UPDATE 宏 | 对比宏展开 |

**验证方法**:
```cpp
// 在 GetFrameNode 处打断点
FrameNode* GetFrameNode(ArkUINodeHandle node) {
    if (node) {
        LOGI("ArkTS mode: node=%p", node);
        return reinterpret_cast<FrameNode*>(node);
    } else {
        auto frameNode = ViewStackProcessor::GetInstance()->GetMainFrameNode();
        LOGI("JSView mode: frameNode=%p", frameNode);
        return frameNode;
    }
}
```

#### 5.1.3 事件回调兼容性

| 检查项 | 旧实现 | 新实现 | 验证方法 |
|--------|--------|--------|----------|
| 回调包装 | `JsFunction` | `FunctionRef` | 代码审查 |
| 微任务队列 | `ExecutePendingJob` 在 `JsiFunction::Call` 内 | `HandleCallbackJobs` 显式调用 | 源码对比 |
| 异常处理 | `HandleUncaughtException` 在 `JsiFunction::Call` 内 | `HandleCallbackJobs` 显式调用 | 源码对比 |
| 回调节点 | `SetCallBackNode` | **完全一致** | 代码审查 |

**关键验证**:
```bash
# 确认 HandleCallbackJobs 包含必要的调用
grep -A 10 "bool ArkTSUtils::HandleCallbackJobs" frameworks/bridge/declarative_frontend/engine/arkts_utils.cpp

# 应该看到:
# 1. JSNApi::ExecutePendingJob(vm)
# 2. runtime->HandleUncaughtException(trycatch)
```

#### 5.1.4 资源管理兼容性

| 检查项 | 验证点 | 验证方法 |
|--------|--------|----------|
| 注销旧资源 | `UnRegisterResource` 在解析前 | 代码审查 |
| 注册新资源 | `RegisterResource` 在解析后 | 代码审查 |
| 配置变更 | `SystemProperties::ConfigChangePerform()` 检查 | 代码审查 |
| 资源刷新 | Pattern 层有对应的刷新逻辑 | 单元测试 |

**常见问题**:
```cpp
// ❌ 错误: 缺少资源管理
void SetXxxFontSize(ArkUINodeHandle node, ArkUI_Float32 fontSize, ...) {
    MarqueeModelNG::SetFontSize(frameNode, fontSizeOpt);
    // 缺少 UnRegisterResource 和 RegisterResource
}

// ✅ 正确: 完整的资源管理
void SetXxxFontSize(ArkUINodeHandle node, ArkUI_Float32 fontSize, ...) {
    auto pattern = frameNode->GetPattern<XXXPattern>();

    if (SystemProperties::ConfigChangePerform()) {
        pattern->UnRegisterResource("FontSize");
    }

    MarqueeModelNG::SetFontSize(frameNode, fontSizeOpt);

    if (SystemProperties::ConfigChangePerform() && resObj) {
        pattern->RegisterResource<CalcDimension>("FontSize", resObj, value);
    }
}
```

### 5.2 兼容性测试用例

#### 测试用例 1: 基本功能测试

```javascript
// Test_1_BasicFunctionality.ets
@Test
export function TestXXXBasicFunctionality() {
  // 创建组件
  XXX.create({
    src: "Hello World",
    start: true,
    step: 10,
    loop: 3,
  });

  // 设置属性
  XXX.allowScale(true);
  XXX.fontSize(16);
  XXX.fontColor('#FF0000');
  XXX.fontWeight('bold');
  XXX.fontFamily('sans-serif');

  // 验证: 组件正常显示
}
```

#### 测试用例 2: 参数缺失测试

```javascript
@Test
export function TestXXXMissingParameters() {
  // 测试参数缺失行为
  XXX.create(); // 所有参数使用默认值

  // 验证: 不会崩溃，使用合理的默认值
}
```

#### 测试用例 3: 事件回调测试

```javascript
@Test
export function TestXXXEventCallbacks() {
  let onStartCalled = false;
  let microtaskExecuted = false;

  XXX.onStart(() => {
    onStartCalled = true;
    console.log('onStart called');

    // 测试微任务队列
    Promise.resolve().then(() => {
      microtaskExecuted = true;
      console.log('microtask executed');
    });
  });

  // 验证:
  // 1. onStartCalled = true
  // 2. microtaskExecuted = true (微任务正确执行)
}
```

#### 测试用例 4: 异常处理测试

```javascript
@Test
export function TestXXXExceptionHandling() {
  XXX.onStart(() => {
    throw new Error('Test error');
  });

  // 验证: 异常被正确捕获，不会导致崩溃
}
```

#### 测试用例 5: 配置变更测试

```javascript
@Test
export function TestXXXConfigurationChange() {
  // 设置资源对象
  const colorResource = $r('app.color.text_color');
  XXX.fontColor(colorResource);

  // 触发配置变更 (如暗色模式切换)
  // ...

  // 验证: 颜色正确刷新
}
```

---

## 六、代码模板

### 6.1 Bridge 方法模板

#### 模板 1: 简单属性 (布尔值)

```cpp
ArkUINativeModuleValue XXXBridge::SetXxxPlayerStatus(ArkUIRuntimeCallInfo* runtimeCallInfo)
{
    auto* vm = runtimeCallInfo->GetVM();
    Local<JSValueRef>* args = runtimeCallInfo->GetArguments();

    // 判断模式
    bool isJsView = IsJsView(args[0], vm);

    // 获取 nativeNode (ArkTS 模式)
    ArkUINativeNodeHandle nativeNode = nullptr;
    if (!isJsView) {
        nativeNode = args[0]->GetNativePointer(vm);
    }

    // 解析参数
    std::optional<bool> playerStatus;
    if (argc > 1 && args[1]->IsBoolean()) {
        playerStatus = args[1]->ToBoolean(vm)->Value();
    } else if (!isJsView) {
        playerStatus = false;  // ArkTS 默认值
    }

    // 调用 Modifier
    if (playerStatus.has_value()) {
        GetArkUINodeModifiers()->getXxxModifier()->setXxxPlayerStatus(nativeNode, playerStatus.value());
    } else {
        GetArkUINodeModifiers()->getXxxModifier()->resetXxxPlayerStatus(nativeNode);
    }

    return panda::JSValueRef::Undefined(vm);
}
```

#### 模板 2: 复杂属性 (带验证)

```cpp
ArkUINativeModuleValue XXXBridge::SetXxxFontSize(ArkUIRuntimeCallInfo* runtimeCallInfo)
{
    auto* vm = runtimeCallInfo->GetVM();
    Local<JSValueRef>* args = runtimeCallInfo->GetArguments();
    int32_t argc = runtimeCallInfo->GetArgumentCount();

    bool isJsView = IsJsView(args[0], vm);
    ArkUINativeNodeHandle nativeNode = nullptr;
    if (!isJsView) {
        nativeNode = args[0]->GetNativePointer(vm);
    }

    // 解析参数
    std::optional<ArkUI_Float32> fontSize;
    ArkUI_Int32 unit = 0;  // FP unit
    void* fontSizeRawPtr = nullptr;

    if (argc > 1) {
        fontSize = Converter::OptConvert<ArkUI_Float32>(args[1]);
    }
    if (argc > 2 && args[2]->IsNumber(vm)) {
        unit = args[2]->ToInt32(vm)->Value();
    }
    if (argc > 3 && args[3]->IsNativePointer(vm)) {
        fontSizeRawPtr = args[3]->GetNativePointer(vm);
    }

    // 调用 Modifier
    if (fontSize.has_value()) {
        GetArkUINodeModifiers()->getXxxModifier()->setXxxFontSize(nativeNode, fontSize.value(), unit, fontSizeRawPtr);
    } else {
        GetArkUINodeModifiers()->getXxxModifier()->resetXxxFontSize(nativeNode);
    }

    return panda::JSValueRef::Undefined(vm);
}
```

#### 模板 3: 事件回调

```cpp
ArkUINativeModuleValue XXXBridge::SetXxxOnStart(ArkUIRuntimeCallInfo* runtimeCallInfo)
{
    auto* vm = runtimeCallInfo->GetVM();
    Local<JSValueRef>* args = runtimeCallInfo->GetArguments();

    bool isJsView = IsJsView(args[0], vm);
    auto frameNode = ViewStackProcessor::GetInstance()->GetMainFrameNode();

    // 处理 undefined/null - 表示取消回调
    if (args[1]->IsUndefined() || args[1]->IsNull()) {
        if (isJsView) {
            GetArkUINodeModifiers()->getXxxModifier()->resetXxxOnStart(nullptr);
        }
        return panda::JSValueRef::Undefined(vm);
    }

    // 获取回调函数
    auto callbackFunc = args[1]->ToObject(vm);

    // 创建 std::function
    std::function<void(void)> callback = [vm, frameNode, callbackFunc, isJsView]() {
        PipelineContext::SetCallBackNode(AceType::WeakClaim(frameNode));

        panda::TryCatch trycatch(vm);
        auto result = callbackFunc->Call(vm, callbackFunc.ToLocal(), nullptr, 0);

        // 关键: 必须调用 HandleCallbackJobs
        if (isJsView) {
            ArkTSUtils::HandleCallbackJobs(vm, trycatch, result);
        }
    };

    GetArkUINodeModifiers()->getXxxModifier()->setXxxOnStart(nullptr, &callback);
    return panda::JSValueRef::Undefined(vm);
}
```

### 6.2 Modifier 方法模板

#### 模板 1: 简单属性设置

```cpp
void SetXxxPlayerStatus(ArkUINodeHandle node, ArkUI_Bool playerStatus)
{
    auto* frameNode = GetFrameNode(node);
    CHECK_NULL_VOID(frameNode);

    std::optional<bool> value = playerStatus;
    XXXModelNG::SetPlayerStatus(frameNode, value);
}

void ResetXxxPlayerStatus(ArkUINodeHandle node)
{
    auto* frameNode = GetFrameNode(node);
    CHECK_NULL_VOID(frameNode);

    XXXModelNG::ResetPlayerStatus(frameNode);
}
```

#### 模板 2: 带资源管理的属性设置

```cpp
void SetXxxFontSize(ArkUINodeHandle node, ArkUI_Float32 fontSize, ArkUI_Int32 unit, void* fontSizeRawPtr)
{
    auto* frameNode = GetFrameNode(node);
    CHECK_NULL_VOID(frameNode);

    auto pattern = frameNode->GetPattern<XXXPattern>();
    CHECK_NULL_VOID(pattern);

    auto pipelineContext = PipelineContext::GetCurrentContext();
    CHECK_NULL_VOID(pipelineContext);

    // 资源对象
    RefPtr<ResourceObject> resObj;
    if (fontSizeRawPtr) {
        resObj = Referenced::RawPtr(fontSizeRawPtr);
    }

    // 参数验证和默认值
    Dimension value;
    auto unitEnum = static_cast<DimensionUnit>(unit);
    if (fontSize >= 0 && unitEnum >= DimensionUnit::PX && unitEnum <= DimensionUnit::CALC && unitEnum != DimensionUnit::PERCENT) {
        value = Dimension(fontSize, unitEnum);
    } else {
        // 无效值时使用主题默认值
        auto theme = pipelineContext->GetTheme<TextTheme>();
        value = theme->GetTextStyle().GetFontSize();
    }

    // 设置值
    std::optional<Dimension> fontSizeOpt = value;
    XXXModelNG::SetFontSize(frameNode, fontSizeOpt);

    // 资源管理
    if (SystemProperties::ConfigChangePerform()) {
        pattern->UnRegisterResource("FontSize");
        if (resObj) {
            pattern->RegisterResource<CalcDimension>("FontSize", resObj, CalcDimension(value));
        }
    }
}
```

### 6.3 Model 方法模板

```cpp
// 实例方法 (用于 JSView)
void XXXModelNG::SetPlayerStatus(const std::optional<bool>& playerStatus)
{
    if (playerStatus.has_value()) {
        ACE_UPDATE_PAINT_PROPERTY(XXXPaintProperty, PlayerStatus, playerStatus.value());
    } else {
        ACE_RESET_PAINT_PROPERTY_WITH_FLAG(XXXPaintProperty, PlayerStatus, PROPERTY_UPDATE_RENDER);
    }
}

// 静态方法 (用于 ArkTS)
void XXXModelNG::SetPlayerStatus(FrameNode* frameNode, const std::optional<bool>& playerStatus)
{
    CHECK_NULL_VOID(frameNode);
    if (playerStatus.has_value()) {
        ACE_UPDATE_NODE_PAINT_PROPERTY(XXXPaintProperty, PlayerStatus, playerStatus.value(), frameNode);
    }
}

void XXXModelNG::ResetPlayerStatus(FrameNode* frameNode)
{
    CHECK_NULL_VOID(frameNode);
    ACE_RESET_NODE_PAINT_PROPERTY_WITH_FLAG(XXXPaintProperty, PlayerStatus, PROPERTY_UPDATE_RENDER, frameNode);
}

// 事件回调
void XXXModelNG::SetOnStart(FrameNode* frameNode, std::function<void()>&& callback)
{
    CHECK_NULL_VOID(frameNode);
    auto eventHub = frameNode->GetEventHub<XXXEventHub>();
    CHECK_NULL_VOID(eventHub);
    eventHub->SetOnStart(std::move(callback));
}

void XXXModelNG::ResetOnStart(FrameNode* frameNode)
{
    CHECK_NULL_VOID(frameNode);
    auto eventHub = frameNode->GetEventHub<XXXEventHub>();
    CHECK_NULL_VOID(eventHub);
    eventHub->SetOnStart(nullptr);
}
```

---

## 七、验证测试

### 7.1 单元测试

```cpp
// 文件: frameworks/core/components_ng/pattern/xxx/test/xxx_modifier_test.cpp

#include "gtest/gtest.h"
#include "core/components_ng/pattern/xxx/bridge/xxx_dynamic_modifier.h"

namespace OHOS::Ace::NG {

class XXXModifierTest : public testing::Test {
public:
    static void SetUpTestCase();
    static void TearDownTestCase();
};

void XXXModifierTest::SetUpTestCase()
{
    // 初始化测试环境
}

void XXXModifierTest::TearDownTestCase()
{
    // 清理测试环境
}

// 测试 GetFrameNode
TEST_F(XXXModifierTest, GetFrameNode)
{
    // ArkTS 模式
    ArkUINodeHandle nativeNode = reinterpret_cast<ArkUINodeHandle>(0x12345678);
    auto* frameNode = GetFrameNode(nativeNode);
    ASSERT_NE(frameNode, nullptr);
    EXPECT_EQ(reinterpret_cast<ArkUINodeHandle>(frameNode), nativeNode);

    // JSView 模式
    frameNode = GetFrameNode(nullptr);
    ASSERT_NE(frameNode, nullptr);
}

// 测试属性设置
TEST_F(XXXModifierTest, SetProperty)
{
    auto frameNode = FrameNode::CreateFrameNode(XXX_ETS_TAG, 1, AceType::MakeRefPtr<XXXPattern>());
    ASSERT_NE(frameNode, nullptr);

    // 设置属性
    SetXxxPlayerStatus(reinterpret_cast<ArkUINodeHandle>(frameNode.Get()), true);

    // 验证属性
    auto paintProperty = frameNode->GetPaintProperty<XXXPaintProperty>();
    ASSERT_NE(paintProperty, nullptr);
    EXPECT_TRUE(paintProperty->GetPlayerStatus().value_or(false));
}

} // namespace OHOS::Ace::NG
```

### 7.2 集成测试

```javascript
// 文件: test/xxx_integration_test.ets

import { XXX } from '@kit.ArkUI';

@test
export function XXXIntegrationTest() {
  // 测试 1: 创建组件
  XXX.create({
    src: "Test",
    start: true,
  });

  // 测试 2: 设置属性
  XXX.allowScale(true);
  XXX.fontSize(16);
  XXX.fontColor('#FF0000');

  // 测试 3: 事件回调
  let eventFired = false;
  XXX.onStart(() => {
    eventFired = true;
  });

  // 验证
  assert.isTrue(eventFired, "onStart should be called");
}
```

### 7.3 性能测试

```javascript
// 文件: test/xxx_performance_test.ets

@test
export function XXXPerformanceTest() {
  const startTime = performance.now();

  // 创建 1000 个组件
  for (let i = 0; i < 1000; i++) {
    XXX.create({ src: `Item ${i}` });
    XXX.fontSize(16);
  }

  const endTime = performance.now();
  const duration = endTime - startTime;

  // 验证性能
  assert.isTrue(duration < 1000, `Should complete in < 1s, actual: ${duration}ms`);
}
```

---

## 八、常见问题

### 8.1 编译问题

#### 问题 1: undefined reference to `GetFrameNode`

**原因**: 忘记在头文件中声明辅助函数

**解决**:
```cpp
// xxx_dynamic_modifier.h
namespace GeneratedModifier {
namespace XXXAttributeModifier {

FrameNode* GetFrameNode(ArkUINodeHandle node);  // ← 添加声明

} // namespace XXXAttributeModifier
} // namespace GeneratedModifier
```

#### 问题 2: 链接错误 - multiple definition

**原因**: 在 .h 文件中定义了函数，导致多个编译单元重复定义

**解决**: 将函数定义移到 .cpp 文件

```cpp
// ❌ 错误: xxx_dynamic_modifier.h
FrameNode* GetFrameNode(ArkUINodeHandle node) {
    // ...
}

// ✅ 正确: xxx_dynamic_modifier.h (只声明)
FrameNode* GetFrameNode(ArkUINodeHandle node);

// xxx_dynamic_modifier.cpp (定义)
FrameNode* GetFrameNode(ArkUINodeHandle node) {
    // ...
}
```

### 8.2 运行时问题

#### 问题 3: 事件回调不执行

**原因**: 忘记调用 `HandleCallbackJobs`

**解决**:
```cpp
// ❌ 错误
auto callback = [vm, func]() {
    func->Call(vm, ...);
    // 缺少 HandleCallbackJobs
};

// ✅ 正确
auto callback = [vm, func, isJsView]() {
    panda::TryCatch trycatch(vm);
    auto result = func->Call(vm, ...);

    if (isJsView) {
        ArkTSUtils::HandleCallbackJobs(vm, trycatch, result);  // ← 必须调用
    }
};
```

#### 问题 4: 配置变更时属性不刷新

**原因**: 缺少资源管理逻辑

**解决**:
```cpp
void SetXxxFontSize(ArkUINodeHandle node, ArkUI_Float32 fontSize, ...)
{
    auto pattern = frameNode->GetPattern<XXXPattern>();

    // 添加资源管理
    if (SystemProperties::ConfigChangePerform()) {
        pattern->UnRegisterResource("FontSize");  // ← 必须调用
    }

    XXXModelNG::SetFontSize(frameNode, fontSizeOpt);

    if (SystemProperties::ConfigChangePerform() && resObj) {
        pattern->RegisterResource<CalcDimension>("FontSize", resObj, value);  // ← 必须调用
    }
}
```

### 8.3 兼容性问题

#### 问题 5: 参数缺失时行为不一致

**原因**: JSView 模式不应该设置默认值

**解决**:
```cpp
// ❌ 错误: 两种模式行为一致
if (argc < 2 || !args[1]->IsBoolean()) {
    playerStatus = false;  // 错误: JSView 不应该设置默认值
}

// ✅ 正确: 区分两种模式
if (argc > 1 && args[1]->IsBoolean()) {
    playerStatus = args[1]->ToBoolean(vm)->Value();
} else if (!isJsView) {
    playerStatus = false;  // 只在 ArkTS 模式设置默认值
}
```

#### 问题 6: 微任务不执行

**原因**: JSView 模式必须调用 `HandleCallbackJobs`

**验证**:
```bash
# 搜索所有事件回调方法
grep -rn "SetOn\|SetOnBounce\|SetOnFinish\|SetOnComplete" frameworks/bridge/declarative_frontend/engine/jsi/nativeModule/

# 确认每个方法都调用了 HandleCallbackJobs
```

---

## 九、检查清单

### 9.1 代码实现检查清单

- [ ] **Bridge 层**
  - [ ] 每个 `SetXxx` 方法都判断 `isJsView`
  - [ ] JSView 模式通过 `ViewStackProcessor` 获取 FrameNode
  - [ ] ArkTS 模式通过 `nativeNode` 获取 FrameNode
  - [ ] 事件回调调用 `HandleCallbackJobs`
  - [ ] undefined/null 参数正确处理 (Reset)

- [ ] **Modifier 层**
  - [ ] 使用 `GetFrameNode()` 统一路径
  - [ ] 所有空指针检查使用 `CHECK_NULL_VOID`
  - [ ] 带资源的属性包含完整资源管理逻辑
  - [ ] 参数验证有默认值处理

- [ ] **Model 层**
  - [ ] 实例方法和静态方法分开
  - [ ] 使用 ACE_UPDATE/RESET 宏
  - [ ] Reset 方法正确重置属性

- [ ] **JavaScript 层**
  - [ ] 第一个参数传 `true` (JSView 模式)
  - [ ] 方法命名与原生层一致

### 9.2 兼容性验证检查清单

- [ ] **参数解析**
  - [ ] 对比 `ParseJsXxx` 和 `Converter::Convert` 结果
  - [ ] 验证参数缺失行为
  - [ ] 验证参数类型错误处理
  - [ ] 验证 null/undefined 处理

- [ ] **底层调用**
  - [ ] 验证 `GetFrameNode(nullptr)` 返回 `GetMainFrameNode()`
  - [ ] 验证两种模式调用相同的 `MarqueeModelNG` 方法
  - [ ] 验证 Property 更新使用相同的宏

- [ ] **事件回调**
  - [ ] 验证 `HandleCallbackJobs` 被调用
  - [ ] 验证微任务队列执行 (`ExecutePendingJob`)
  - [ ] 验证异常处理 (`HandleUncaughtException`)
  - [ ] 验证回调节点设置 (`SetCallBackNode`)

- [ ] **资源管理**
  - [ ] 验证 `UnRegisterResource` 在解析前调用
  - [ ] 验证 `RegisterResource` 在解析后调用
  - [ ] 验证配置变更时资源正确刷新

### 9.3 测试验证检查清单

- [ ] **单元测试**
  - [ ] 测试所有 `SetXxx` 方法
  - [ ] 测试所有 `ResetXxx` 方法
  - [ ] 测试 `GetFrameNode` 两种模式
  - [ ] 测试边界条件和错误处理

- [ ] **集成测试**
  - [ ] 测试基本创建和属性设置
  - [ ] 测试事件回调触发
  - [ ] 测试参数缺失场景
  - [ ] 测试异常处理

- [ ] **性能测试**
  - [ ] 测试批量创建性能
  - [ ] 测试频繁更新性能
  - [ ] 对比新旧实现性能

---

## 附录

### A. 参考文档

- [如何新增一个组件.md](./如何新增一个组件.md)
- [CLAUDE.md](./CLAUDE.md) - 项目架构和开发指南
- [MEMORY_DESIGN.md](./interfaces/inner_api/ace_kit/include/ui/base/MEMORY_DESIGN.md) - 内存管理设计
- [README_COMPATIBILITY_ANALYZER.md](./tools/README_COMPATIBILITY_ANALYZER.md) - 兼容性分析工具使用说明

### B. 关键代码位置

| 组件 | 文件 | 说明 |
|------|------|------|
| ViewStackProcessor | `frameworks/core/components_ng/base/view_stack_processor.h` | JSView 模式的 FrameNode 管理 |
| FrameNode | `frameworks/core/components_ng/base/frame_node.h` | 组件节点基类 |
| HandleCallbackJobs | `frameworks/bridge/declarative_frontend/engine/arkts_utils.cpp` | 事件回调后处理 |
| Converter | `frameworks/core/interfaces/native/utility/converter.h` | 类型转换工具 |
| ResourceObject | `frameworks/core/common/resource/resource_object.h` | 资源对象 |

### C. 常用宏定义

```cpp
// Property 更新宏
ACE_UPDATE_LAYOUT_PROPERTY(PropertyType, PropertyName, value)
ACE_RESET_LAYOUT_PROPERTY_WITH_FLAG(PropertyType, PropertyName, flag)

ACE_UPDATE_PAINT_PROPERTY(PropertyType, PropertyName, value)
ACE_RESET_PAINT_PROPERTY_WITH_FLAG(PropertyType, PropertyName, flag)

ACE_UPDATE_NODE_LAYOUT_PROPERTY(PropertyType, PropertyName, value, node)
ACE_RESET_NODE_LAYOUT_PROPERTY_WITH_FLAG(PropertyType, PropertyName, flag, node)

ACE_UPDATE_NODE_PAINT_PROPERTY(PropertyType, PropertyName, value, node)
ACE_RESET_NODE_PAINT_PROPERTY_WITH_FLAG(PropertyType, PropertyName, flag, node)

// 空指针检查
CHECK_NULL_VOID(ptr)
CHECK_NULL_RETURN(ptr, defaultValue)

// 日志宏
LOGI("Format string %s", value)
LOGE("Error: %s", error)
```

---

*本文档基于 marquee 组件重构经验总结，持续更新中*
